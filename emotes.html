<!doctype html>
<html lang="en">
 <head>
  <meta charset="utf-8" />
  <script>
   'use strict';
   /* RealityRipple's Home-Made Emote Wall
    * ====================================
    *
    * v0.7 BETA
    *
    *  <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *
    *
    * Help
    * ----
    *
    *  Please contact RealityRipple for assistance, bug reports, or questions.
    *
    *   <https://realityripple.com>
    *   <https://twitch.tv/realityripple>
    *   <https://discord.gg/fcxJ9tq3XS>
    *
    *
    * Configuration Information
    * -------------------------
    *
    * channel     The name of the channel to join. Also used to choose an IRC nickname.
    *             If FALSE, the interactive login process will be enabled.
    *
    * login       Settings related to the login process.
    *
    *             NOTE: OAuth tokens expire automatically (usually after 60 days). Please make sure to update
    *                   these values on a regular basis, if not using the interactive login process.
    *
    *  client     The Client ID value is used to track which third-party project is accessing your account.
    *             This emote wall does not require a constant ID, and will work with whatever tool you use to
    *             get an OAuth ID (see below).
    *
    *  oauth      The OAuth ID value is used in lieu of a password to access the Twitch API.
    *             Please generate an OAuth ID and matching Client ID:
    *             - Visit https://realityripple.com/Tools/Twitch/EmoteWall/
    *             - Click the "Authenticate on Twitch" button under "Do-it-Yourself" and log in
    *             - Fill out the captcha prompt, if necessary
    *             - Copy the Client ID value and paste it into "client:"
    *             - Copy the OAuth ID value and paste it into "oauth:"
    *             If you ever stop using this emote wall, please log into Twitch and visit
    *             https://www.twitch.tv/settings/connections . Under "Other Connections", click the "Disconnect" button
    *             next to "RealityRipple's Home-Made Emote Wall". If you want to use a different Twitch OAuth generator
    *             (or do it yourself), feel free.
    *             If FALSE, the interactive login process will be enabled.
    *
    * streamlabs  Settings related to Streamlabs tips.
    *
    *  token      The Socket Token is used in lieu of a password to access the Streamlabs API.
    *             Please generate a Socket Token:
    *             - Visit https://realityripple.com/Tools/Twitch/EmoteWall/
    *             - Click the "Streamlabs Tip Support" button and log in
    *             - Copy the Token value and paste it into "token:"
    *             If you ever stop using this emote wall, please log into Streamlabs and visit
    *             https://streamlabs.com/dashboard#/settings/api-settings . Under "Connected Apps", click the
    *             "Revoke Access" button next to "RealityRipple's Home-Made Emote Wall". If you want to use a different
    *             Streamlabs OAuth generator (or do it yourself), feel free.
    *
    *  curMul     This value is the currency multiplier. The ranges of Streamlabs tip entries (see below) will
    *             match against this multiplier. For example, if you use USD and want to set ranges by penny amount,
    *             then set this value to 100. If you want to use dollar amounts, set the value to 1.
    *             Note: Any decimal amount will be rounded down after multiplying, so $3.95 will be handled as "395"
    *                   pennies when multiplied by 100, or "3" dollars when multiplied by 1.
    *
    *  dispMul    This value is the currency multiplier when the currency is being displayed. For kappagen events such
    *             as Text, the Streamlabs tip amount will be multiplied by this number before being displayed.
    *             For example, if you use USD and want to display the value as cents, then set this value to 100. If
    *             you want to show dollar amounts, set this value to 1.
    *
    *  dispDec    This value is the decimal count when the currency is being displayed. After being multiplied by the
    *             dispMul value above, the Streamlabs tip amount will be rounded to this many decimal places.
    *             For example, an amount of $3.95 rounded to "0" decimal places will be "3", to "1" would be "3.9", and
    *             to "2" would be "3.95".
    *
    *  dispPre    This value should be added before any currency amount as a prefix, such as a dollar sign '$'.
    *
    *  dispSuf    This value should be added after any currency amount as a suffix, such as the word " dollars". Usually
    *             only the prefix or the suffix should be used, not both at the same time.
    *
    * streamelements  Settings related to StreamElements tips.
    *
    *  refresh    A refresh token to get a new StreamElements OAuth ID when the current one expires.
    *             The OAuth ID value is used in lieu of a password to access the StreamElements API.
    *             Please generate an OAuth ID:
    *             - Visit https://realityripple.com/Tools/Twitch/EmoteWall/
    *             - Click the "StreamElements Tip Support" button and log in
    *             - Copy the OAuth ID value and paste it into "refresh:"
    *             If you ever stop using this emote wall, please log into StreamElements and visit
    *             https://streamelements.com/dashboard/account/security. Click the "Reset my Personal Access Token"
    *             button. If you want to use a different StreamElements OAuth generator (or do it yourself), feel free.
    *             Please only use refresh or token, not both. Token does not expire, but is also less secure. OAuth is
    *             recommended, if possible.
    *
    *  token      The JWT Token is used in lieu of a password to access the StreamElements API.
    *             Please grab your JWT Token from the StreamElements Dashboard:
    *             - Visit https://streamelements.com/dashboard/account/channels
    *             - Click the "Show secrets" button
    *             - Copy the JWT Token value and paste it into "token:"
    *             Please only use refresh or token, not both. Token does not expire, but is also less secure. OAuth is
    *             recommended, if possible.
    *
    *  curMul     This value is the currency multiplier. The ranges of StreamElements tip entries (see below) will
    *             match against this multiplier. For example, if you use USD and want to set ranges by penny amount,
    *             then set this value to 100. If you want to use dollar amounts, set the value to 1.
    *             Note: Any decimal amount will be rounded down after multiplying, so $3.95 will be handled as "395"
    *                   pennies when multiplied by 100, or "3" dollars when multiplied by 1.
    *
    *  dispMul    This value is the currency multiplier when the currency is being displayed. For kappagen events such
    *             as Text, the StreamElements tip amount will be multiplied by this number before being displayed.
    *             For example, if you use USD and want to display the value as cents, then set this value to 100. If
    *             you want to show dollar amounts, set this value to 1.
    *
    *  dispDec    This value is the decimal count when the currency is being displayed. After being multiplied by the
    *             dispMul value above, the StreamElements tip amount will be rounded to this many decimal places.
    *             For example, an amount of $3.95 rounded to "0" decimal places will be "3", to "1" would be "3.9", and
    *             to "2" would be "3.95".
    *
    *  dispPre    This value should be added before any currency amount as a prefix, such as a dollar sign '$'.
    *
    *  dispSuf    This value should be added after any currency amount as a suffix, such as the word " dollars". Usually
    *             only the prefix or the suffix should be used, not both at the same time.
    *
    * display     Settings related to the animation of the emote wall.
    *
    *  styles     An array of animation styles which individual emotes randomly perform. You may turn on and off
    *             elements in this array by "commenting out" a style, by putting two slashes before the name:
    *              // 'Still',        < disabled
    *                 'StraightLine', < allowed
    *
    *  access     A bitwise flag representing which users' messages show up on the emote wall. Account types are
    *             represented by the following values:
    *
    *              0x800 = broadcaster
    *              0x400 = moderator badge
    *              0x200 = founder badge
    *              0x100 = vip badge
    *              0x080 = artist badge
    *              0x040 = tier 3 subscriber badge
    *              0x020 = tier 2 subscriber badge
    *              0x010 = tier 1 subscriber badge
    *              0x004 = cheer badge
    *              0x002 = follower
    *              0x001 = stranger
    *
    *             Just put a vertical pipe " | " in between each of the values representing levels of access:
    *
    *              ACCESS                                 MEANING 
    *             0x800 | 0x400                           broadcaster and moderator only
    *             0x800 | 0x400 | 0x100 | 0x040 | 0x020   broadcasters, mods, VIPs, and tier 2 and 3 subscribers
    *             0x800 | 0x010 | 0x002                   boradcaster, tier 1 subscribers, and followers
    *
    *             If you know how bitwise flags work, you can also use them
    *             in more complicated ways:
    *               ACCESS           MEANING
    *             0xFF7             all users from the broadcaster to strangers
    *             0xFF7 ^ 0x003     all users except followers and strangers
    *             0x070             all subscribers
    *
    *  duplicates  A boolean or integer to toggle duplicate emotes per message.
    *             If TRUE, every emote posted in chat will be shown.
    *             If FALSE, only one of each emote per message will be shown.
    *             If greater than 1, sets the maximum number of identical emotes shown from any message.
    *
    *  useEmoji   Toggles display of emojis on the emote wall, and lets you choose an emoji font style.
    *             If TRUE, emojis will be shown using the "twemoji" font.
    *             If FALSE, emojis will not be shown on the emote wall.
    *             If 'twemoji', emojis will be shown using the "twemoji" font.
    *             If 'openmoji', emojis will be shown using the "openmoji" font.
    *             If 'noto', emojis will be shown using the "noto" font.
    *             If 'blob', emojis will be shown using the "blobmoji" font.
    *
    *  extended   Settings related to third-party emotes.
    *
    *   useFFZ    Toggles display of FrankerFaceZ emotes.
    *
    *   useBTTV   Toggles display of BetterTTV emotes.
    *
    *   use7TV    Toggles display of 7TV emotes.
    *
    *   useZWE    Toggles display of Zero-Width (overlapping) emotes. If disabled, this will hide ZWEs entirely.
    *             Note: ZWE display requires more objects on-screen, which can be process-intensive, and precise
    *                   timing is required for accurate overlay.
    *                   CHAOS MAY ENSUE.
    *
    *  kappa      Settings related to emote-splosions and the !kappagen command.
    *
    *   count     The number of emotes to display per kappagen. This value should be less than the "emote max" value
    *             seen below (best would be 1/4th or less), if "emote max" is used, or it will be truncated to match.
    *
    *   styles    Similar to the array of styles for normal emotes, but this one lists emote-splosion types.
    *             Please do not try to add normal styles to the kappa list or vice versa. This is an associative array
    *             which can have custom settings for certain styles (namely The Cube and Text - see below).
    *
    *    [ALL]    Settings related to multiple kappagens. These settings will be the default for all instances of their
    *             respective kappagens. Each setting below may or may not apply to a specific kappagen style.
    *
    *     count   The number of emotes to display for this specific kappagen. This value should be less than the
    *             "emote max" value seen below (best would be 1/4th or less), if "emote max" is used, or it will be
    *             truncated to match. If unset, this will default to the global kappa count preference listed above.
    *             Note: If this preference is in an event below (not in this general kappa context), then an additional
    *                   value is possible: -1, which will refer to the AMOUNT value present in the event. This can be
    *                   the number of raiders, bits cheered, dollars tipped, subs gifted, or months subscribed.
    *
    *     command Settings related to triggering a specific kappagen style by chat command.
    *
    *      access A bitwise flag representing which users can trigger this kappagen with a command.
    *
    *      aliases  An array of style-specific kappa command aliases which can be used to force-trigger this kappagen.
    *
    *     redeem  An array of style-specific channel point reward names which can be used to force-trigger this kappagen.
    *
    *    Conga    Settings related to Conga kappagen. These settings will be the default for all instances of
    *             Conga kappagen.
    *
    *     avoidMiddle  If TRUE, conga lines will only show up on the top or bottom three rows to avoid the middle off
    *                 the screen.
    *             If FALSE, conga lines will show up on any row of the screen.
    *
    *    TheCube  Settings related to The Cube kappagen. These settings will be the default for all instances of
    *             TheCube kappagen.
    *
    *     size    A decimal value representing the height of The Cube kappagen, relative to the smallest
    *             screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "8 / 10" (80%).
    *
    *     center  If TRUE, The Cube will show up in the exact center of the screen.
    *             If FALSE, The Cube will show up in a random location.
    *
    *     rotations  The maximum number of rotations a kappa cube might spin while on screen. This effectively controls
    *               the maximum possible speed at which cubes will rotate.
    *
    *    Text     Settings related to Text kappagen. These settings will be the default for all instances of Text
    *             kappagen.
    *
    *     message  An array of alphanumeric strings (letters, numbers, and spaces), one of which will randomly be used.
    *
    *     time    The number of seconds the Text kappagen should show the final result for.
    *             This value should be adjusted depending on the average message length, for readability.
    *
    *   access    Similar to the access flag for normal emotes, but controls which users can use the !kappagen command.
    *
    *   aliases   An array of kappagen command aliases which can be used to force-trigger kappagens.
    *
    *   cooldown  The number of seconds between force-triggered kappagens using an above alias. Any commands sent before
    *             the cooldown will be treated like normal text, which may include showing any emotes in the message as
    *             normal emotes rather than in a kappagen.
    *
    *   conga     Settings related to Conga kappagen.
    *
    *    contagious  If TRUE, while one Conga kappagen is visible, all additional kappagens will also be Conga.
    *               If FALSE, Conga kappagns will behave like any other kappagen.
    *
    *    time     The number of seconds the Conga kappagen should show up on the screen for.
    *             This value lets you increase or decrease the chances of keeping a "contagious" Conga line going.
    *
    *    avoidMiddle  If TRUE, conga lines will only show up on the top or bottom three rows to avoid the middle off
    *                the screen globally.
    *             If FALSE, the setting will default to any more specific avoidMiddle Conga settings.
    *
    * emote       Settings related to individual emote display.
    *
    *  time       The number of seconds an emote should show up on the screen for.
    *
    *  max        The maximum nuber of emotes to show on the screen at one time. Set this value to 0 for
    *             infinite emotes. This value should be greater than any "kappa count" values seen above or below
    *             (best would be 4x or more), as it will limit any single kappagen events to this maximum.
    *
    *  queue      The maximum number of emotes to save in queue. Set this value to 0 for an infinite queue.
    *             This value will be ignored if the previous value (cfg.emote.max) is infinite (0).
    *
    *  size       Settings related to the size of emotes.
    *
    *   ratio     Emotes show up in multiple sizes due to the kappagen feature. There are a total of four sizes
    *             that an emote can be:
    *              - The Cube kappagen's faces are squares equal to 80% of the smaller screen dimension
    *                (usually height on PC).
    *              - Pyramid kappagen emotes have a height equal to 1/19th of the screen's width.
    *              - Fireworks, Spiral, and Confetti kappagen emotes have a height equal to the small ratio (see below).
    *              - All standard emotes and kappagens not listed above will use the normal ratio (see below).
    *                Most normal emotes will limit by height, except The Cube, which fits in the center of every side.
    *
    *    normal   A decimal value representing the height of each emote, relative to the smallest screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "1 / n" where n is greater than 10.
    *
    *    small    A decimal value representing the height of small emotes, relative to the smallest screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "1 / n" where n is greater than 20.
    *
    *   min       The minimum height of an emote, in pixels.
    *
    *   max       The maximum height of an emote, in pixels.
    *
    *   variation  An integer variable that determines how often occasional random large or small emotes show up.
    *             If FALSE, no variations will occur.
    *
    *  cube      Settings related to The Cube emote.
    *
    *   rotations  The maximum number of rotations a cube might spin while on screen. This effectively controls the
    *             maximum possible speed at which cubes will rotate.
    *
    *  in         Settings related to the showing of an emote.
    *             Note: Some kappagen styles do not use these. See the notes next to each kappagen style name.
    *
    *   fade      A boolean to toggle the "fade in" style.
    *
    *   zoom      A boolean to toggle the "zoom in" style.
    *
    *  out        Settings related to the hiding of an emote.
    *             Note: Some kappagen styles do not use these. See the notes next to each kappagen style name.
    *
    *   fade      A boolean to toggle the "fade out" style.
    *
    *   zoom      A boolean to toggle the "zoom out" style.
    *
    * event       Settings related to channel events which trigger emote-splosions (kappagen).
    *
    *  raid       Settings related to kappagens when being raided.
    *
    *   raiders   A streamer raids the channel with viewers. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all raids.
    *              If FALSE, no kappagen will occur on raids.
    *              If Integer, the value is the minimum raiders required for a raid to trigger a kappagen.
    *               If 0, no kappagen will occur on raid.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *                Keep in mind that kappagen arrays are also associative, and may have independent settings for
    *                kappas such as TheCube and Text. This applies to all such arrays listed below as well.
    *
    *   originEmotes  A boolean to toggle the use of the raiding streamer's channel emotes for raid kappagens.
    *                If TRUE, raid kappagens will use channel emotes from the raider's channel (not including third-party).
    *               If FALSE, raid kappagens will use your channel's emotes (including third-party).
    *
    *  follow     A user follows the channel.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  sub        Settings related to kappagens on a subscribe event.
    *             Note: Sub event booleans can also be arrays of kappa styles. This will override the default list
    *                   of kappa styles for the particular event in question.
    *
    *   useMsg    If TRUE, any emotes in resub messages will be used for the kappagen.
    *             If FALSE, any emotes in resub messages will show up like normal emotes.
    *
    *   t1        Settings related to kappagens on a tier 1 subscribe event.
    *
    *    first    A user subscribes at Tier 1 for the first time.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    resub    A user resubscribes at Tier 1. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Tier 1 resubs.
    *              If FALSE, no kappagen will occur on T1 resubs.
    *              If Integer, the value is the minimum months required for a Tier 1 resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    upgrade  Settings related to "converted" subscriptions.
    *
    *     gift     A user upgrades a gift sub to Tier 1.
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     prime    A user upgrades a Prime sub to Tier 1.
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    gift     Settings related to tier 1 gifts.
    *
    *     first   A user gifts another user their first Tier 1 subscription.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     resub   A user gifts another user a Tier 1 resubscription. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Tier 1 gift resubs.
    *              If FALSE, no kappagen will occur on T1 gift resubs.
    *              If Integer, the value is the minimum months required for a Tier 1 gift resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     bomb    A user gifts multiple Tier 1 subscriptions. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on any random gift.
    *              If FALSE, no kappagen will occur on giftbombs.
    *              If Integer, the value is the minimum gifts required for a gift bomb to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur on any random gift.
    *               If greater than 1, the number of gifted users in a Tier 1 giftbomb must be greater than or equal to
    *               this number to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   t2        Identical to t1, but for Tier 2 subscriptions.
    *
    *   t3        Identical to t1, but for Tier 3 subscriptions.
    *
    *   prime     Settings related to kappagens on an Amazon Prime subscribe event.
    *
    *    first    A user subscribes with Prime for the first time.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    resub    A user resubscribes with Prime. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Prime resubs.
    *              If FALSE, no kappagen will occur on Prime resubs.
    *              If Integer, the value is the minimum months required for a Prime resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  cheer      Settings related to kappagens on a cheer event.
    *
    *   useMsg    If TRUE, any emotes in cheer messages will also be included in the kappagen.
    *             If FALSE, any emotes in cheer messages will show up like normal emotes.
    *
    *   bits       Minimum number of bits for a kappagen. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all cheers.
    *              If FALSE, no kappagen will occur on cheers.
    *              If Integer, the value is the minimum bits required for a cheer to trigger a kappagen.
    *               If 0, no kappagen will occur on cheer.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-499' or '2500-4999', or an open-maximum range such as '7500+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  badge      Settings related to users earning bits badges.
    *             This section is more "fluid" than other sections.
    *             Each entry is a number representing a bits badge and a kappa boolean value.
    *             For example:
    *   '1'        If TRUE, a kappagen will occur when a user gets their 1 bit badge.
    *              If FALSE, no kappagen will occur for 1 bit badges.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *             If a user earns a bits badge for a number not listed in the array, the system will find the number
    *             which is closest to the badge, favoring the lower number in case of a tie.
    *             For example:
    *   '100': false
    *   '5000': true
    *              If a user earns their 1000 bits badge, no kappagen will occur because 1000 is closer to 100
    *              than 5000.
    *              If a user earns their 10000 bits badge, a kappagen will occur because 5000 is the closest
    *              listed number.
    *             Note: The numbers must be strings (in 'single quotes') to function properly.
    *
    *  tip        Settings related to third-party tip systems.
    *
    *   useProfileImage  If TRUE, tips will use the tipper's profile image instead of emotes.
    *                   If FALSE, tips will use your standard kappagen emotes.
    *
    *   streamlabs  Settings related to Streamlabs payment events.
    *
    *    donation  Minimum tip amount through Streamlabs for a kappagen. This value can be a boolean, integer,
    *              or array:
    *              If TRUE, a kappagen will occur on all Streamlabs tips.
    *              If FALSE, no kappagen will occur on tips.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on tips through Streamlabs.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamlabs.curMul setting (see above)
    *              based on your default currency in Streamlabs.
    *
    *    pledge    Minimum pledge amount through Streamlabs for a kappagen. This value can be a boolean, integer,
    *              or array:
    *              If TRUE, a kappagen will occur on all Streamlabs pledges.
    *              If FALSE, no kappagen will occur on pledges.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on pledges through Streamlabs.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamlabs.curMul setting (see above)
    *              based on your default currency in Streamlabs.
    *
    *   streamelements  Minimum tip amount through StreamElements for a kappagen. This value can be a boolean,
    *                  integer, or array:
    *              If TRUE, a kappagen will occur on all StreamElements tips.
    *              If FALSE, no kappagen will occur on tips.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on tips through StreamElements.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamelements.curMul setting (see above)
    *              based on your default currency in StreamElements.
    *
    */

   var cfg = {
    channel: 'CHANNEL_NAME',
    login: {
     client: '4umzcpmjkg6ar78b81s7302jlj33t8',
     oauth: 'OAUTH_ID' //Requires chat:read; channel:read:redemptions
    },
    streamlabs: {
     token: 'SOCKET_TOKEN', //Requires socket.token
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    streamelements: {
     oauth_refresh: 'OAUTH_REFRESH', //Requires tips:read
     token: 'JWT_TOKEN',
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    display: {
     styles: [
    //'Still',        // No movement
      'StraightLine', // Gentle movement in a random straight line
      'Rise',         // Slowly rise to top while wobbling back and forth
      'Bounce',       // Fall from the top at an angle and bounce along the bottom (Windows Solitaire style)
      'Speed',        // Zoom across the screen
      'Drop',         // Get stuck at the top and tumble down (no fade/zoom in, only out)
      'Crazy',        // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
      'Confetti',     // Fall like confetti                   (no zoom, no fade in, only fade out)
      'Throw',        // Toss at the middle and tumble down   (no fade/zoom in, only out)
      'TheCube'       // Rotate a 3D cube of an emote         (no zoom, only fade)
     ],
     access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x004 | 0x002 | 0x001,
     duplicates: true,
     useEmoji: true,
     extended: {
      useFFZ: true,
      useBTTV: true,
      use7TV: true,
      useZWE: true
     },
     kappa: {
      count: 150,
      styles: {
       'Rise': {},        // Slowly rise to top while wobbling back and forth
       'Speed': {},       // Zoom across the screen
       'Crazy': {},       // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
       'Burst': {},       // Expand from a center point
       'Fireworks': {},   // Burst out from a single emote (no fade/zoom; small emotes)
       'Spiral': {},      // Burst out from a single emote in a spiral (no fade/zoom; small emotes)
       'Pyramid': {},     // Build a pyramid        (no fade/zoom; specific-size emotes)
       'SmallPyramid': {},// Build a small pyramid  (no fade/zoom; small emotes)
       'Fountain': {},    // Spout from a fountain  (no fade/zoom)
       'Stampede': {},    // Stampede of emotes     (no fade/zoom)
       'Confetti': {},    // Fall like confetti     (no zoom, no fade in, only fade out; small emotes)
       'Conga': {},       // Start a conga line     (no fade/zoom)
       'TheCube': {       // Rotate a 3D cube of an emote (no zoom, only fade)
        size: 8/10,
        center: true,
        rotations: 5
       },
       'Text': {          // Show a message         (no fade/zoom; specific-size emotes)
        message: ['HYPE!'],
        time: 3
       }
      },
      access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x004 | 0x002,
      aliases: [      // !kappagen command aliases (must be lower-case)
       '!kappagen',
       '-kappagen'
      ],
      cooldown: 0,
      conga: {
       contagious: false,
       time: 5,
       avoidMiddle: false
      }
     }
    },
    emote: {
     time: 5,
     max: 0,
     queue: 0,
     size: {
      ratio: {
       normal: 1/12,
       small: 1/24
      },
      min: 16,
      max: 112,
      variation: false
     },
     cube: {
      rotations: 5
     },
     in: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     },
     out: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     }
    },
    event: {
     raid: {
      raiders: 2,
      originEmotes: false
     },
     follow: true,
     sub: {
      useMsg: true,
      t1: {
       first: false,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: false,
        resub: false,
        bomb: 5
       }
      },
      t2: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      t3: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      prime: {
       first: true,
       resub: true
      }
     },
     cheer: {
      useMsg: true,
      bits: 50
     },
     badge: {
      '1': false,
      '100': true
     },
     tip: {
      useProfileImage: false,
      streamlabs: {
       donation: false,
       pledge: false
      },
      streamelements: false
     }
    }
   };

   /* Additional Notes and Caveats
    * ============================
    *
    * Update Procedure
    * ----------------
    * 
    *  To update this emote wall, simply use the Wizard to import and download it.
    *   1) Visit the official page <https://realityripple.com/Tools/Twitch/EmoteWall/>.
    *   2) Under "Config Wizard", click "Authorize on Twitch".
    *   3) Import this HTML file by clicking Import.
    *   4) Make any changes you need to make on each page.
    *   5) At the end of your configuration, hit "Download".
    *  You will receive a new version of this HTML file with your previous settings.
    *
    *
    * Emojis
    * ------
    *
    *  Twitch filters out the ZWJ (Zero-Width Joiner) character which is used for merging many emojis.
    *  This system makes use of basic character detection to correctly parse many standard ZWJ-style emojis even without
    *  the ZWJ character, however more complicated sets such as the "family units" are not possible to correctly handle.
    *  The alternative character 0xE0002 used by some third-party Twitch chat projects will be correctly parsed as a
    *  ZWJ according to the rules laid out in the RFC:
    *   <https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f>
    *
    *
    * Emote Dimensions
    * ----------------
    *
    *  Emotes that are not square will be shrunk to fit while maintaining the original aspect ratio.
    *
    *
    * Following
    * ---------
    *
    *  Detecting followers on the current Twitch API is limited and relies on server-to-server events.
    *  The current system uses a kludge and may have issues in rare situations. The current system regularly grabs the
    *  most recent 100 followers and tries to find the previous request's latest follower, counting how many followers
    *  exist in the list before the last known follower. If the latest follower is removed from the list, or if more
    *  than 100 followers join between one check and another, the system will ignore the event and assign a new latest
    *  follower. Real support for follow events requires an API change:
    *   <https://twitch.uservoice.com/forums/310213/suggestions/41794465>
    *   <https://twitch.uservoice.com/forums/310213/suggestions/40423873>
    *
    *
    * Cheers
    * ------
    *
    *  The cheer style will be used for kappagens. If a user cheers 1000 bits in a single 1000 bit emote, then the
    *  kappagen will be made of the 1000-bit cheers. However, if the user cheers 1000 bits using multiple smaller cheer
    *  emotes, those emotes will be used for the kappagen instead.
    *
    *
    * Kappagen
    * --------
    *
    *  Each emote-splosion uses the number of emotes defined in the kappa count preference mentioned above, except
    *  Pyramid, which uses a constant number based on the pyramidDist array (below). If the trigger includes specific
    *  emotes (via kappagen, cheer, or resub message), the ratio of one emote to another will be maintained.
    *  If a user with kappa access posts "!kappagen PunchTrees PunchTrees SSSsss" then two thirds of the emotes in
    *  the emote-splosion will be "PunchTrees", and one third will be "SSSsss".
    *
    *
    * OBS
    * ---
    *
    *  This emote wall may do better if the browser source has a frame rate limit of 30 or 60.
    *  If you use your GPU while streaming, you may wish to disable Browser Source Hardware Acceleration.
    *  It may also work better using a smaller screen resolution (such as 720p on a 1080p screen) and then stretching
    *  the browser source to fit to the screen using the OBS Transform feature.
    *
    *
    * Inefficiencies
    * --------------
    *
    *  This emote wall uses normal <img> objects rather than a HTML Canvas. While this lowers efficiency, it also adds
    *  better GIF file support and allows easier user manipulation.
    *
    *  At present, the "zoom in" and "zoom out" feature uses a resource-heavy design. I had hoped the new CSS directive
    *  "scale: " would have helped, however it's useless without a "scale-origin" directive to accompany it.
    *
    *  The Bounce animation uses specific position-based drawing rather than actually being animated.
    *
    *  The Cube animation uses eight objects on screen for every image, making it a particularly resource-heavy drawing.
    * 
    *  If your computer has trouble with this emote wall, please try disabling these options.
    *
    */

   /* potentially alterable arrays */

   // distribution of emojis for Pyramid and SmallPyramid kappagen
   const pyramidDist = [1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1];

   // distribution of emojis for letters in message kappagens
   const alnumDist = {
    'A': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'a': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'B': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    'b': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'C': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0]
    ],
    'c': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'D': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'd': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'E': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'e': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'F': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'f': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    'G': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 1, 0, 0]
    ],
    'g': [
     [1, 0, 0, 1, 1, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'H': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'h': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0]
    ],
    'I': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'i': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'J': [
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'j': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0]
    ],
    'K': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'k': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'L': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'l': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'M': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'm': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'N': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'n': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'O': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'o': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'P': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    'p': [
     [1, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 1, 0, 0, 0, 0]
    ],
    'Q': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [1, 1, 0, 1, 1, 1, 1, 0, 0]
    ],
    'q': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'R': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 1, 0, 0]
    ],
    'r': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'S': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    's': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    'T': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    't': [
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0]
    ],
    'U': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'u': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'V': [
     [0, 0, 0, 0, 1, 1, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 1, 1, 0]
    ],
    'v': [
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0]
    ],
    'W': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'w': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 0, 0, 0]
    ],
    'X': [
     [0, 1, 1, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 0, 1, 1, 0]
    ],
    'x': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'Y': [
     [0, 0, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    'y': [
     [1, 0, 0, 1, 1, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'Z': [
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0]
    ],
    'z': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '1': [
     [0, 1, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '2': [
     [0, 1, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '3': [
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '4': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0]
    ],
    '5': [
     [0, 0, 1, 0, 0, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 0, 1, 0]
    ],
    '6': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0]
    ],
    '7': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    '8': [
     [0, 0, 1, 1, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '9': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 1, 1, 0, 0]
    ],
    '0': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    ':': [
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    '.': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    ',': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '\'': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 1]
    ],
    '-': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '_': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '+': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '=': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0]
    ],
    '!': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    '@': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 1, 1, 0, 0]
    ],
    '#': [
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    '$': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [1, 1, 1, 1, 1, 1, 1, 1, 1],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    '\u00a2': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '\u20ac': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    '\u00a3': [
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '\u00a5': [
     [0, 0, 0, 0, 1, 0, 1, 1, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 1, 0]
    ],
    '%': [
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0]
    ],
    '?': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ]
   };

   // treat these BTTV emotes as zero-width (overlapping) emotes
   const bttvZWE = [
    'SoSnowy',  'IceCold',   'SantaHat', 'TopHat',
    'ReinDeer', 'CandyCane', 'cvMask',   'cvHazmat'
   ];

   // list of default images to use if your channel has no emotes
   const bareList = [
    {url: 'https://cdn.frankerfacez.com/emoticon/675080/4'}
   ];
   //////////////////////////////////////////////////////////////////////////////
   // don't mess with things below this line without knowing what you're doing //
   //////////////////////////////////////////////////////////////////////////////
  </script>
  <title>Emote Wall</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
   :root
   {
    --height: 0px;
    --width: 0px;
    --emote-height: 0px;
    --emote-height-s: 0px;
    --emote-height-l: 0px;
   }
   body
   {
    margin: 0;
    overflow: hidden;
   }
   img
   {
    object-fit: contain;
    object-position: 50% 50%;
   }
   img.emote
   {
    position: fixed;
    height: 100%;
    border: 0;
    margin: 0;
    padding: 0;
    offset-rotate: 0deg;
   }

   div.scene
   {
    position: fixed;
    border: 0;
    margin: 0;
    padding: 0;
   }
   div.scene div.cube
   {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
   }
   div.scene div.cube .cubeFace
   {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.2);
   }

   div.scene img.dancer
   {
    text-align: center;
    position: relative;
    animation: dance 4s linear infinite;
   }

   @keyframes dance
   {
    0%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    6%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    13%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    19%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    25%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    31%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    38%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    44%
    {
     transform: translate(20%, 10%) rotate(-30deg);
    }
    50%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    56%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    63%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    69%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    75%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    81%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    88%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    94%
    {
     transform: translate(80%, 10%) rotate(30deg);
    }
    100%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
   }

   @keyframes wiggleL
   {
    33%
    {
     transform: translateX(-50%);
    }
    66%
    {
     transform: translateX(50%);
    }
   }
   @keyframes wiggleR
   {
    33%
    {
     transform: translateX(50%);
    }
    66%
    {
     transform: translateX(-50%);
    }
   }

   @keyframes speedL
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(-1 * var(--width) * 4), 0);
    }
   }
   @keyframes speedR
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(var(--width) * 4), 0);
    }
   }

   @keyframes dropL
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(350deg);
    }
   }
   @keyframes dropR
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(-35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(-350deg);
    }
   }

   @keyframes confettiA
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0.5, 0, -4500deg);
    }
   }

   @keyframes confettiB
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0, 0, -4500deg);
    }
   }

   @keyframes confettiC
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, -0.5, 0, -4500deg);
    }
   }

   @keyframes offsetPath
   {
    0%
    {
     offset-distance: 0%;
    }
    100%
    {
     offset-distance: 100%;
    }
   }

   @keyframes fadeIn
   {
    0%
    {
     opacity: 0;
    }
    100% /* 8% */
    {
     opacity: 1;
    }
   }

   @keyframes fadeOut
   {
    0% /* 95% */
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes noFadeOut
   {
    99%
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes zoomIn
   {
    0%
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.1)) / 2);
     max-height: calc(var(--emote-height) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 1.2)) / 2);
     max-height: calc(var(--emote-height) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.8)) / 2);
     max-height: calc(var(--emote-height) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.95)) / 2);
     max-height: calc(var(--emote-height) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
   }

   @keyframes zoomOut
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    100%
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.1)) / 2);
     max-height: calc(var(--emote-height) * 0.1);
    }
   }

   @keyframes zoomInS
   {
    0%
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.1)) / 2);
     max-height: calc(var(--emote-height-s) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 1.2)) / 2);
     max-height: calc(var(--emote-height-s) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.8)) / 2);
     max-height: calc(var(--emote-height-s) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.95)) / 2);
     max-height: calc(var(--emote-height-s) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
   }

   @keyframes zoomOutS
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    100%
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.1)) / 2);
     max-height: calc(var(--emote-height-s) * 0.1);
    }
   }

   @keyframes zoomInL
   {
    0%
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.1)) / 2);
     max-height: calc(var(--emote-height-l) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 1.2)) / 2);
     max-height: calc(var(--emote-height-l) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.8)) / 2);
     max-height: calc(var(--emote-height-l) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.95)) / 2);
     max-height: calc(var(--emote-height-l) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
   }

   @keyframes zoomOutL
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    100%
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.1)) / 2);
     max-height: calc(var(--emote-height-l) * 0.1);
    }
   }

   button
   {
    background-color: #7D5BBE;
    transition: background 0.12s ease-in, color 0.12s ease-in;
    white-space: nowrap;
    cursor: pointer;
    color: #FFFFFF;
    border-radius: 4px;
    border: none;
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
   }
   button:focus, button:hover
   {
    background-color: #772CE8;
   }
   button:focus
   {
    outline: none;
   }
   button:active
   {
    background-color: #5C16C5;
   }
  </style>
  <script>
   'use strict';
   if (typeof cfg === 'undefined')
    throw new Error('Corrupted Configuration detected.');
   document.title = cfg.channel + ' Emote Wall';
   /* global variables */
   let cList = [];     // list of channel-specific emotes, used for kappagens
   const wWS = 5;      // websocket retry backoff base (ms = base ^ (1.0 + (0.2 per retry, max 1.0)))

   const display = function()
   {
    let _eActive = 0;    // active emote count (effective, not actual)
    let _iTitanic = 0;
    const _tStart = 48;  // time to wait for transition trigger (ms)
    const _tAnim = {     // animation timing constants
     fade: {
      in: 8,            // percentage of animation spent on fading in (8% of 5 seconds)
      out: 8            // percentage of animation spent on fading out
     },
     zoom: {
      in: 17,           // percentage of animation spent on zooming in (17% of 5 seconds)
      out: 8            // percentage of animation spent on zooming out
     }
    };

    const emote = function()
    {
     let _toShow = [];    // emote queue

     let _tEmote = false; // timer for emote queue

     const list = function()
     {
      function Still(url, zwe, sW, sH, sS, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const h = shared.rnd(sW - sS);
       const v = shared.rnd(sH - sS);
       let s = 'top: ' + v + 'px;';
       s += ' left: ' + h + 'px;';
       s += ' height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
       addEmoteToDoc(tInit, url, s, false, {space: false});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        addEmoteToDoc(tInit, zwe[i].url, s, false, {space: false});
       }
      }

      function StraightLine(url, zwe, sW, sH, sS, x = false, y = false, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sSm = Math.ceil(sS / 2);
       let h = x;
       if (h === false)
        h = shared.rnd(sW) - sSm;
       let v = y;
       if (v === false)
        v = shared.rnd(sH) - sSm;
       let r = sW;
       if (sH < r)
        r = sH;
       r = r * (shared.rnd() + 1);
       const cRadius = Math.PI * 2;
       let th = shared.rnd() * cRadius;
       let hD = Math.floor(h + r * Math.cos(th));
       let vD = Math.floor(v + r * Math.sin(th));
       if (!x && !y)
       {
        const sR = sW - sS - sSm;
        const sB = sH - sS - sSm;
        while ((h < sSm && hD < sSm) || (v < sSm && vD < sSm) || (h > sR && hD > sR) || (v > sB && vD > sB))
        {
         th = shared.rnd() * cRadius;
         hD = Math.floor(h + r * Math.cos(th));
         vD = Math.floor(v + r * Math.sin(th));
        }
       }
       let s = 'height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       s += ' transition: transform ' + cfg.emote.time + 's linear;';
       s += ' transform: translate(' + h + 'px, ' + v + 'px);';
       s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
       addEmoteToDoc(tInit, url, s, false, {}, {x: hD, y: vD});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        addEmoteToDoc(tInit, zwe[i].url, s, false, {}, {x: hD, y: vD});
       }
      }

      function Rise(url, zwe, sW, sH, sS, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sSm = Math.ceil(sS / 2);
       const h = shared.rnd(sW) - sSm;
       const v = Math.floor(shared.rnd(0.3) * sH) + Math.floor(0.8 * sH);
       let s = 'left: ' + h + 'px;';
       s += ' height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       if (cfg.emote.out.fade || cfg.emote.out.zoom)
        s += ' offset-path: path("M 0 ' + v + ' L 0 ' + Math.floor(v * 0.05) + '") ;';
       else
        s += ' offset-path: path("M 0 ' + v + ' L 0 -' + sS + '") ;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       if (shared.rnd(2) === 0)
        aNames.push('wiggleL');
       else
        aNames.push('wiggleR');
       const d = shared.rnd(600);
       aDelays.push(d + 'ms');
       const w = shared.rnd(3) + 2;
       aDurs.push(w + 's');
       aTimings.push('ease-in-out');
       aFills.push('both');
       aIters.push('infinite');
       aNames.push('offsetPath');
       aDelays.push('0s');
       aDurs.push(cfg.emote.time + 's');
       aTimings.push('linear');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
       addEmoteToDoc(tInit, url, s, false, {space: false});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        addEmoteToDoc(tInit, zwe[i].url, s, false, {space: false});
       }
      }

      const Bounce = function()
      {
       const _ms = 20;

       function task(url, zwe, sW, sH, sS, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         sS = Math.ceil(sS / 2);
        else if (variationSize === 2)
         sS = sS * 2;
        const sSm = Math.ceil(sS / 2);
        const sWm = Math.ceil(sW / 2);
        const h = Math.floor(shared.rnd(sW) - sSm);
        const v = Math.floor(shared.rnd(0.2) * sH);
        let velH = shared.rnd(6) + 3;
        const velV = shared.rnd(3) + 4;
        if (h + sSm > sWm)
         velH = -1 * velH;
        let s = 'height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        let bX = h;
        let bY = v;
        let velY = velV;
        let iArr = [];
        iArr.push(addEmoteToDoc(tInit, url, s, true));
        for (let i = 0, l = zwe.length; i < l; i++)
        {
         iArr.push(addEmoteToDoc(tInit, zwe[i].url, s, true));
        }
        window.setTimeout(_tLoop, _ms, tInit, iArr, bX, bY, velH, velY, sH, sS);
       }

       function _tLoop(tInit, iArr, bX, bY, velH, velY, sH, sS)
       {
        if (_iTitanic > tInit)
         return;
        if (iArr[0].parentElement === null)
         return;
        bX += velH;
        bY += velY;
        velY += 1;
        const sB = sH - sS;
        if (bY >= sB)
        {
         bY = sB;
         velY *= -0.7;
         velY = Math.floor(velY);
        }
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].style.transform = 'translate(' + bX + 'px, ' + bY + 'px)';
        }
        window.setTimeout(_tLoop, _ms, tInit, iArr, bX, bY, velH, velY, sH, sS);
       }

       return task;
      }();

      function Speed(url, zwe, sW, sH, sS, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sSm = Math.ceil(sS / 2);
       const sWm = Math.ceil(sW / 2);
       const h = shared.rnd(sW) - sSm;
       const v = Math.floor(shared.rnd(0.4) * sH) + Math.floor(0.3 * sH);
       let s = 'top: ' + v + 'px;';
       s += ' left: ' + h + 'px;';
       s += ' height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       if (h + sSm > sWm)
       {
        s += ' transform-origin: center right;';
        aNames.push('speedL');
       }
       else
       {
        s += ' transform-origin: center left;';
        aNames.push('speedR');
       }
       aDelays.push('0.5s');
       aDurs.push(cfg.emote.time + 's');
       aTimings.push('ease-in');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
       addEmoteToDoc(tInit, url, s);
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        addEmoteToDoc(tInit, zwe[i].url, s);
       }
      }

      function Drop(url, zwe, sW, sH, sS, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sSm = Math.ceil(sS / 2);
       const h = shared.rnd(sW) - sSm;
       let s = 'left: ' + h + 'px;';
       s += ' height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       if (shared.rnd(2) === 0)
       {
        s += ' transform-origin: top left;';
        aNames.push('dropL');
       }
       else
       {
        s += ' transform-origin: top right;';
        aNames.push('dropR');
       }
       aDelays.push('0s');
       aDurs.push(cfg.emote.time + 's');
       aTimings.push('ease-in');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
       addEmoteToDoc(tInit, url, s, false, {space: false});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        addEmoteToDoc(tInit, zwe[i].url, s, false, {space: false});
       }
      }

      const Crazy = function()
      {
       /* LAYOUT SHIFTS
        * =============
        * squashes via scale
        * offset-path requires support for offset-anchor/offset-position
        * due to transform-origin changes during squash
        */
       const _squashT = 100;

       function task(url, zwe, sW, sH, sS, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         sS = Math.ceil(sS / 2);
        else if (variationSize === 2)
         sS = sS * 2;
        const sR = sW - sS;
        const sB = sH - sS;
        const h = shared.rnd(sR - 5) + 10;
        const v = shared.rnd(sB - 5) + 10;
        let s = 'top: ' + v + 'px;';
        s += ' left: ' + h + 'px;';
        s += ' height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        let dests = [];
        let traj = {x: 0, y: 0};
        traj.x = shared.rnd() * 11 - 5;
        traj.y = shared.rnd() * 11 - 5;
        let pos = {x: h, y: v, t: 0};
        let lastT = 0;
        let bCt = 0;
        const eTime = cfg.emote.time * 1000;
        const sqTime = _squashT * 2;
        while(bCt * sqTime + pos.t < eTime)
        {
         pos.x += traj.x;
         pos.y += traj.y;
         pos.t += 5;
         let wall = false;
         if (pos.x < 0)
         {
          pos.x = 0;
          traj.x *= -1;
          wall = 1;
         }
         else if (pos.x > sR)
         {
          pos.x = sR;
          traj.x *= -1;
          wall = 3;
         }
         if (pos.y < 0)
         {
          pos.y = 0;
          traj.y *= -1;
          wall = 2;
         }
         else if (pos.y > sB)
         {
          pos.y = sB;
          traj.y *= -1;
          wall = 4;
         }
         if (wall !== false)
         {
          bCt++;
          dests.push({x: Math.floor(pos.x), y: Math.floor(pos.y), t: pos.t - lastT, w: wall});
          lastT = pos.t;
         }
        }
        dests.push({x: pos.x, y: pos.y, t: pos.t - lastT, w: 0});
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
        let iArr = [];
        iArr.push(addEmoteToDoc(tInit, url, s, true, {space: false}));
        for (let i = 0, l = zwe.length; i < l; i++)
        {
         iArr.push(addEmoteToDoc(tInit, zwe[i].url, s, true, {space: false}));
        }
        let d = 0;
        const lA = iArr.length;
        const lD = dests.length;
        window.setTimeout(_tLoop, _tStart, tInit, lA, iArr, lD, dests, d);
       }

       function _tLoop(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        if (d >= lD)
         return;
        for (let i = 0; i < lA; i++)
        {
         iArr[i].style.transformOrigin = 'center center';
         iArr[i].style.transform = 'scale(1, 1)';
         iArr[i].style.top = dests[d].y + 'px';
         iArr[i].style.left = dests[d].x + 'px';
         iArr[i].style.transition = 'all ' + dests[d].t + 'ms linear';
        }
        d++;
        window.setTimeout(_tSquash, dests[d - 1].t, tInit, lA, iArr, lD, dests, d);
       }

       function _tSquash(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0; i < lA; i++)
        {
         iArr[i].style.transition = 'transform ' + _squashT + 'ms linear';
         switch(dests[d - 1].w)
         {
          case 1:
           //left
           iArr[i].style.transformOrigin = 'left center';
           iArr[i].style.transform = 'scale(0.7, 2)';
           break;
          case 2:
           //top
           iArr[i].style.transformOrigin = 'center top';
           iArr[i].style.transform = 'scale(2, 0.7)';
           break;
          case 3:
           //right
           iArr[i].style.transformOrigin = 'right center';
           iArr[i].style.transform = 'scale(0.7, 2)';
           break;
          case 4:
           //bottom
           iArr[i].style.transformOrigin = 'center bottom';
           iArr[i].style.transform = 'scale(2, 0.7)';
           break;
         }
        }
        window.setTimeout(_tUnsquash, _squashT, tInit, lA, iArr, lD, dests, d);
       }

       function _tUnsquash(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0; i < lA; i++)
        {
         iArr[i].style.transition = 'transform ' + _squashT + 'ms linear';
         iArr[i].style.transform = 'scale(1, 1)';
        }
        window.setTimeout(_tLoop, _squashT, tInit, lA, iArr, lD, dests, d);
       }

       return task;
      }();

      function Confetti(url, zwe, sW, sH, sS, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sSm = Math.ceil(sS / 2);
       const h = shared.rnd(sW) - sSm;
       let s = 'left: ' + h + 'px;';
       s += ' height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       s += ' transform-origin: center center;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       switch (shared.rnd(3))
       {
        case 0:
         aNames.push('confettiA');
         break;
        case 1:
         aNames.push('confettiB');
         break;
        case 2:
         aNames.push('confettiC');
         break;
       }
       aDelays.push('0s');
       aDurs.push(cfg.emote.time + 's');
       aTimings.push('linear');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, false, variationSize);
       addEmoteToDoc(tInit, url, s, false, {space: false});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        addEmoteToDoc(tInit, zwe[i].url, s, false, {space: false});
       }
      }

      const Throw = function()
      {
       function task(url, zwe, sW, sH, sS, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         sS = Math.ceil(sS / 2);
        else if (variationSize === 2)
         sS = sS * 2;
        const sR = sW - sS;
        const sB = sH - sS;
        const h = shared.rnd(2) === 0 ? sS * -1 : sW;
        const v = shared.rnd(sH + sS) - sS;
        const hD = Math.floor(shared.rnd() * (sR * 0.4) + sR * 0.3);
        const vD = Math.floor(shared.rnd() * (sB * 0.4) + sB * 0.3);
        const dH = shared.rnd() * sS;
        const tMS = cfg.emote.time * 1000;
        const t1 = tMS * 0.14;
        const t2 = tMS * 0.2;
        const t3 = tMS * 0.8;
        let s = 'height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: transform ' + t1 + 'ms cubic-bezier(0.32, 0, 0.67, 0);';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        let s2 = 'height: ' + sS + 'px;';
        s2 += ' width: ' + sS + 'px;';
        s2 += ' transition: transform ' + t3 + 'ms cubic-bezier(0.5, 0, 0.75, 0);';
        let r = '360';
        if (h > 0)
         r = '-360';
        s2 += ' transform: translate(' + hD + 'px, ' + (sH - dH) + 'px) rotate(' + r + 'deg);';
        let aNames = [];
        let aDelays = [];
        let aDurs = [];
        let aTimings = [];
        let aFills = [];
        let aIters = [];
        if (cfg.emote.out.fade)
        {
         const fOut = _tAnim.fade.out / 100;
         const t3F = t3 * fOut;
         aNames.push('fadeOut');
         aDelays.push(Math.floor(t3 - t3F) + 'ms');
         aDurs.push(Math.floor(t3F) + 'ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        else
        {
         aNames.push('noFadeOut');
         aDelays.push(t3 - 50 + 'ms');
         aDurs.push('50ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        if (cfg.emote.out.zoom)
        {
         const zOut = _tAnim.zoom.out / 100;
         const t3Z = t3 * zOut;
         if (variationSize === 0)
          aNames.push('zoomOutS');
         else if (variationSize === 2)
          aNames.push('zoomOutL');
         else
          aNames.push('zoomOut');
         aDelays.push(Math.floor(t3 - t3Z) + 'ms');
         aDurs.push(Math.floor(t3Z) + 'ms');
         aTimings.push('linear');
         aFills.push('forwards');
         aIters.push('1');
        }
        s2 += _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
        let iArr = [];
        iArr.push(addEmoteToDoc(tInit, url, s, true, {space: false}));
        for (let i = 0, l = zwe.length; i < l; i++)
        {
         iArr.push(addEmoteToDoc(tInit, zwe[i].url, s, true, {space: false}));
        }
        window.setTimeout(_tMove, _tStart, tInit, iArr, hD, vD);
        window.setTimeout(_tDrop, t2, tInit, iArr, s2);
       }

       function _tMove(tInit, iArr, hD, vD)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
        }
       }

       function _tDrop(tInit, iArr, s2)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].setAttribute('style', s2);
        }
       }

       return task;
      }();

      const TheCube = function()
      {
       function task(url, zwe, sW, sH, sS, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let scene = document.createElement('div');
        scene.setAttribute('class', 'scene');
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         sS = Math.ceil(sS / 2);
        else if (variationSize === 2)
         sS = sS * 2;
        const sSm = Math.ceil(sS / 2);
        const nSm = sSm * -1;
        scene.setAttribute('width', sS);
        scene.setAttribute('height', sS);
        let cube = document.createElement('div');
        cube.setAttribute('class', 'cube');
        cube.setAttribute('style', 'transform: translateZ(' + nSm + 'px);  transition: transform linear ' + cfg.emote.time + 's;');
        let f = 'height: ' + sS + 'px;';
        f += ' width: ' + sS + 'px;';
        const lZ = zwe.length;
        if (lZ === 0)
        {
         let cubeF = document.createElement('img');
         cubeF.setAttribute('src', url);
         cubeF.setAttribute('alt', '');
         cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
         cubeF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px);');
         cube.appendChild(cubeF);
         let cubeB = document.createElement('img');
         cubeB.setAttribute('src', url);
         cubeB.setAttribute('alt', '');
         cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
         cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeB);
         let cubeR = document.createElement('img');
         cubeR.setAttribute('src', url);
         cubeR.setAttribute('alt', '');
         cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
         cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeR);
         let cubeL = document.createElement('img');
         cubeL.setAttribute('src', url);
         cubeL.setAttribute('alt', '');
         cubeL.setAttribute('class', 'cubeFace cubeFaceLeft');
         cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeL);
         let cubeT = document.createElement('img');
         cubeT.setAttribute('src', url);
         cubeT.setAttribute('alt', '');
         cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
         cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeT);
         let cubeU = document.createElement('img');
         cubeU.setAttribute('src', url);
         cubeU.setAttribute('alt', '');
         cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
         cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeU);
        }
        else
        {
         let cubeF = document.createElement('div');
         cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
         cubeF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px);');
         let pctF = document.createElement('img');
         pctF.setAttribute('src', url);
         pctF.setAttribute('alt', '');
         pctF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeF.appendChild(pctF);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeF.appendChild(pctZ);
         }
         cube.appendChild(cubeF);
         let cubeB = document.createElement('div');
         cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
         cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + sSm + 'px);');
         let pctB = document.createElement('img');
         pctB.setAttribute('src', url);
         pctB.setAttribute('alt', '');
         pctB.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeB.appendChild(pctB);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeB.appendChild(pctZ);
         }
         cube.appendChild(cubeB);
         let cubeR = document.createElement('div');
         cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
         cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + sSm + 'px);');
         let pctR = document.createElement('img');
         pctR.setAttribute('src', url);
         pctR.setAttribute('alt', '');
         pctR.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeR.appendChild(pctR);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeR.appendChild(pctZ);
         }
         cube.appendChild(cubeR);
         let cubeL = document.createElement('div');
         cubeL.setAttribute('class', 'cubeFace cubeFaceLight');
         cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + sSm + 'px);');
         let pctL = document.createElement('img');
         pctL.setAttribute('src', url);
         pctL.setAttribute('alt', '');
         pctL.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeL.appendChild(pctL);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeL.appendChild(pctZ);
         }
         cube.appendChild(cubeL);
         let cubeT = document.createElement('div');
         cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
         cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + sSm + 'px);');
         let pctT = document.createElement('img');
         pctT.setAttribute('src', url);
         pctT.setAttribute('alt', '');
         pctT.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeT.appendChild(pctT);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeT.appendChild(pctZ);
         }
         cube.appendChild(cubeT);
         let cubeU = document.createElement('div');
         cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
         cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + sSm + 'px);');
         let pctU = document.createElement('img');
         pctU.setAttribute('src', url);
         pctU.setAttribute('alt', '');
         pctU.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeU.appendChild(pctU);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeU.appendChild(pctZ);
         }
         cube.appendChild(cubeU);
        }
        scene.appendChild(cube);
        const h = shared.rnd(sW) - sSm;
        const v = shared.rnd(sH) - sSm;
        let r = sW;
        if (sH < r)
         r = sH;
        r = r * (shared.rnd() + 1);
        const cRadius = Math.PI * 2;
        let th = shared.rnd() * cRadius;
        let hD = Math.floor(h + r * Math.cos(th));
        let vD = Math.floor(v + r * Math.sin(th));
        const sR = sW - sS - sSm;
        const sB = sH - sS - sSm;
        while ((h < sSm && hD < sSm) || (v < sSm && vD < sSm) || (h > sR && hD > sR) || (v > sB && vD > sB))
        {
         th = shared.rnd() * cRadius;
         hD = Math.floor(h + r * Math.cos(th));
         vD = Math.floor(v + r * Math.sin(th));
        }
        let s = 'width: ' + sS + 'px;';
        s += ' height: ' + sS + 'px;';
        s += ' perspective: ' + sS * 3  + 'px;';
        s += ' transition: all ' + cfg.emote.time + 's linear;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false, variationSize);
        scene.setAttribute('style', s);
        _eActive++;
        document.body.appendChild(scene);
        _gc.hook(scene);
        window.setTimeout(_tMove, _tStart, tInit, cube, scene, hD, vD, sS);
       }

       function _tMove(tInit, cube, scene, hD, vD, sS)
       {
        if (_iTitanic > tInit)
         return;
        const nSm = Math.ceil(sS / 2) * -1;
        let rX = 0;
        let rY = 0;
        while (Math.abs(rX) + Math.abs(rY) < 45)
        {
         rX = (360 - shared.rnd() * 720) * cfg.emote.cube.rotations;
         rY = (360 - shared.rnd() * 720) * cfg.emote.cube.rotations;
        }
        cube.style.transform = 'translateZ(' + nSm + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
        scene.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
       }

       return task;
      }();

      function Fountain(url, zwe, sW, sH, sS, fX, fY, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       const aT = Math.floor(cfg.emote.time * 1000 / 2);
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sR = sW - sS;
       const sB = sH - sS;
       let h = fX;
       if (h === false)
        h = Math.floor(shared.rnd() * (sR * 0.33) + sR * 0.33);
       let hD;
       if (shared.rnd(2) === 0)
        hD = h - shared.rnd(sR * 0.2);
       else
        hD = h + shared.rnd(sR * 0.2);
       let s = 'height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       s += ' transition: transform ' + aT + 'ms cubic-bezier(0, 0, 0.58, 1);';
       s += ' transform: translateX(' + h + 'px);';
       s += ' offset-path: path("M 0 ' + sH + ' L 0 ' + Math.floor(fY / 100 * sH + shared.rnd(sB / 2)) + ' L 0 ' + (sH + sS) + '");';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       aNames.push('offsetPath');
       aDelays.push('0s');
       aDurs.push(aT + 'ms');
       aTimings.push('cubic-bezier(0, 0.9, 1, 0.15)');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
       addEmoteToDoc(tInit, url, s, false, {time: aT}, {x: hD});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        addEmoteToDoc(tInit, zwe[i].url, s, false, {time: aT}, {x: hD});
       }
      }

      return {
       Still: Still,
       StraightLine: StraightLine,
       Rise: Rise,
       Bounce: Bounce,
       Speed: Speed,
       Drop: Drop,
       Crazy: Crazy,
       Confetti: Confetti,
       Throw: Throw,
       TheCube: TheCube,
       Fountain: Fountain
      };
     }();

     function addEmoteToDoc(tInit, uri, s, r = false, oGC = {}, oT = false)
     {
      if (_iTitanic > tInit)
       return;
      let img = document.createElement('img');
      img.setAttribute('class', 'emote');
      img.setAttribute('src', uri);
      img.setAttribute('alt', '');
      img.setAttribute('style', s);
      _eActive++;
      document.body.appendChild(img);
      let space = true;
      let decActive = true;
      let t = false;
      if (oGC !== false)
      {
       if (oGC.hasOwnProperty('space'))
        space = oGC.space;
       if (oGC.hasOwnProperty('decrement'))
        decActive = oGC.decrement;
       if (oGC.hasOwnProperty('time'))
        t = oGC.time;
       _gc.hook(img, space, decActive, t);
      }
      if (oT !== false)
      {
       let sTF = null;
       if (oT.hasOwnProperty('x') && oT.hasOwnProperty('y'))
        sTF = 'translate(' + oT.x + 'px, ' + oT.y + 'px)';
       else if (oT.hasOwnProperty('x'))
        sTF = 'translateX(' + oT.x + 'px)';
       else if (oT.hasOwnProperty('y'))
        sTF = 'translateX(' + oT.y + 'px)';
       if (sTF !== null)
        window.setTimeout(_tMoveOnDock, _tStart, tInit, img, sTF);
      }
      if (r)
       return img;
     }

     function _tMoveOnDock(tInit, img, sTF)
     {
      if (_iTitanic > tInit)
       return;
      img.style.transform = sTF;
     }

     function _queueEmote(url, zwe)
     {
      const sW = window.innerWidth;
      const sH = window.innerHeight;
      let sS = cfg.emote.size.max;
      if (sW < sH)
       sS = Math.floor(sW * cfg.emote.size.ratio.normal);
      else
       sS = Math.floor(sH * cfg.emote.size.ratio.normal);
      if (sS > cfg.emote.size.max)
       sS = cfg.emote.size.max;
      if (sS < cfg.emote.size.min)
       sS = cfg.emote.size.min;
      const ehs = Math.ceil(sS / 2);
      const ehl = sS * 2;
      document.documentElement.style.setProperty('--height', sH + 'px');
      document.documentElement.style.setProperty('--width', sW + 'px');
      document.documentElement.style.setProperty('--emote-height', sS + 'px');
      document.documentElement.style.setProperty('--emote-height-s', ehs + 'px');
      document.documentElement.style.setProperty('--emote-height-l', ehl + 'px');
      let style = cfg.display.styles[shared.rnd(cfg.display.styles.length)];
      if (style === undefined)
       return;
      list[style](url, zwe, sW, sH, sS);
     }

     function showEmotes()
     {
      if (_tEmote !== false)
      {
       window.clearTimeout(_tEmote);
       _tEmote = false;
      }
      if (cfg.emote.max > 0 && _eActive >= cfg.emote.max)
      {
       _tEmote = window.setTimeout(showEmotes, 500);
       return;
      }
      let e = null;
      while ((e = _toShow.shift()) !== undefined)
      {
       _queueEmote(e.url, e.zwe ?? []);
       if (cfg.emote.max > 0 && _eActive > cfg.emote.max)
       {
        if (cfg.emote.queue > 0 && _toShow.length > cfg.emote.queue)
         _toShow.splice(0, _toShow.length - cfg.emote.queue);
        _tEmote = window.setTimeout(showEmotes, 500);
        return;
       }
      }
     }

     function addToShowList(p)
     {
      _toShow = _toShow.concat(p);
     }

     return {
      showEmotes: showEmotes,
      addToShowList: addToShowList,
      addEmoteToDoc: addEmoteToDoc,
      list: list
     };
    }();

    const kappa = function()
    {
     let _toKappa = [];   // kappagen queue
     let _conga = [];     // CONGA TIME!
     const _dKappa = 500;

     let _tKappa = false; // timer for kappagen queue

     const _list = function()
     {
      const Fireworks = function()
      {
       const _smallBurst = 0.5;
       const _largeBurst = 1.5;

       function task(kList, sW, sH, sS, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const sSm = Math.ceil(sS / 2);
        const sWm = Math.ceil(sW / 2);
        const sendUp = 2;
        const oX = sWm - sSm;
        const oY = sH;
        let cX = oX;
        switch(shared.rnd(3))
        {
         case 0:
          cX = Math.floor(cX * _smallBurst);
          break;
         case 2:
          cX = Math.floor(cX * _largeBurst);
          break;
        }
        const cY = oY * 0.33;
        let s = 'height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: transform ' + sendUp + 's linear;';
        s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
        const oK = kList[shared.rnd(kList.length)];
        let iArr = [];
        iArr.push(display.emote.addEmoteToDoc(tInit, oK.url, s, true, false, {x: cX, y: cY}));
        if (oK.hasOwnProperty('zwe'))
        {
         for (let i = 0, l = oK.zwe.length; i < l; i++)
         {
          _eActive++;
          iArr.push(display.emote.addEmoteToDoc(tInit, oK.zwe[i].url, s, true, false, {x: cX, y: cY}));
         }
        }
        window.setTimeout(_explode, sendUp * 1000, tInit, kList, iArr, cX, cY, sS, sW, sH, iKC);
       }

       async function _explode(tInit, kList, iArr, cX, cY, sS, sW, sH, iKC)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         document.body.removeChild(iArr[i]);
         _eActive--;
        }
        let r = sW;
        if (sH < r)
         r = sH;
        r *= 0.66;
        const inner = Math.floor(iKC / 8);
        const outer = inner;
        const core = iKC - (inner + outer);
        let t = 0;
        const lK = kList.length;
        for (let v = 0; v < inner; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         const sA = shared.rnd();
         _sparkler(tInit, sK.url, cX, cY, sS, r * _smallBurst, t, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, sS, r * _smallBurst, t, sA);
          }
         }
         if (v % Math.floor(outer / 3) === 0)
          await _sleep(1);
        }
        t += 0.5;
        for (let v = 0; v < core; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         const sA = shared.rnd();
         _sparkler(tInit, sK.url, cX, cY, sS, r, t, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, sS, r, t, sA);
          }
         }
         t += 0.005;
         if (v % Math.floor(outer / 9) === 0)
          await _sleep(1);
        }
        t += 0.25;
        for (let v = 0; v < outer; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         const sA = shared.rnd();
         _sparkler(tInit, sK.url, cX, cY, sS, r * _largeBurst, t, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, sS, r * _largeBurst, t, sA);
          }
         }
         if (v % Math.floor(outer / 3) === 0)
          await _sleep(1);
        }
       }

       function _sparkler(tInit, url, cX, cY, sS, r, d, a)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        img.setAttribute('src', url);
        img.setAttribute('alt', '');
        const cRadius = Math.PI * 2;
        const th = a * cRadius;
        const hD = Math.floor(cX + r * Math.cos(th));
        const vD = Math.floor(cY + r * Math.sin(th));
        let s = 'height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: transform ' + cfg.emote.time + 's ease-out;';
        s += ' transform: translate(' + cX + 'px, ' + cY + 'px);';
        s += ' opacity: 0;';
        const dMS = d * 1000;
        const tMS = cfg.emote.time * 1000;
        const tFI = _tAnim.fade.in / 100;
        const tFO = _tAnim.fade.out / 100;
        let aNames = [];
        let aDelays = [];
        let aDurs = [];
        let aTimings = [];
        let aFills = [];
        let aIters = [];
        aNames.push('fadeIn');
        aDelays.push(dMS + 'ms');
        aDurs.push(Math.floor(tMS * tFI) + 'ms');
        aTimings.push('linear');
        aFills.push('forwards');
        aIters.push('1');
        aNames.push('fadeOut');
        aDelays.push(dMS + Math.floor(tMS - tMS * tFO) + 'ms');
        aDurs.push(Math.floor(tMS * tFO) + 'ms');
        aTimings.push('ease-out');
        aFills.push('forwards');
        aIters.push('1');
        s += _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
        img.setAttribute('style', s);
        document.body.appendChild(img);
        _gc.hook(img, true, true, dMS + tMS);
        window.setTimeout(_tMove, dMS + _tStart, tInit, img, hD, vD);
       }

       function _tMove(tInit, img, hD, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.opacity = 1;
        img.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
       }

       return task;
      }();

      const Spiral = function()
      {
       function task(kList, sW, sH, sS, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const oX = shared.rnd(sW - sS);
        const oY = shared.rnd(sH - sS);
        let r = sW;
        if (sH < r)
         r = sH;
        window.setTimeout(_init, _tStart, tInit, kList, oX, oY, sS, r, iKC);
       }

       async function _init(tInit, kList, oX, oY, sS, r, iKC)
       {
        if (_iTitanic > tInit)
         return;
        let l = iKC / 25 + 2;
        l = l + (shared.rnd() * 4 - 2);
        if (l < 0.1)
         l = 0.1;
        const cRadius = Math.PI * 2;
        const c = Math.PI * l / iKC;
        let th = shared.rnd() * cRadius;
        const o = shared.rnd(2) === 0;
        for (let i = 0; i < iKC; i++)
        {
         if (_iTitanic > tInit)
          return;
         if (o)
         {
          th-= c;
          if (th <= 0)
           th+= cRadius;
         }
         else
         {
          th+= c;
          if (th >= cRadius)
           th+= cRadius;
         }
         const oK = kList[shared.rnd(kList.length)];
         _sparkler(tInit, oK.url, oX, oY, sS, r, th);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, m = oK.zwe.length; j < m; j++)
          {
           _eActive++;
           _sparkler(tInit, oK.zwe[j].url, oX, oY, sS, r, th);
          }
         }
         await _sleep(10);
        }
       }

       function _sparkler(tInit, url, oX, oY, sS, r, th)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        img.setAttribute('src', url);
        img.setAttribute('alt', '');
        const hD = Math.floor(oX + r * Math.cos(th));
        const vD = Math.floor(oY + r * Math.sin(th));
        let s = 'height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: transform ' + cfg.emote.time + 's ease-out;';
        s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
        s += _styleEmote([], [], [], [], [], [], true, false, true, false);
        img.setAttribute('style', s);
        document.body.appendChild(img);
        _gc.hook(img, true, true);
        window.setTimeout(_tMove, _tStart, tInit, img, hD, vD);
       }

       function _tMove(tInit, img, hD, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
       }

       return task;
      }();

      const Pyramid = function()
      {
       function task(kList, sW, sH)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const sS = sW / 19;
        let drawn = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        let ct = 0;
        const lP = pyramidDist.length;
        for (let i = 0; i < lP; i++)
         ct += pyramidDist[i];
        const eMS = cfg.emote.time * 1000;
        let eT = eMS * 0.8;
        let tPerB = Math.floor(eT / ct);
        if (tPerB < 50)
         tPerB = 50;
        eT = tPerB * ct;
        const dT = eMS * 0.2;
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lP);
         while(drawn[x] >= pyramidDist[x]);
         const oK = kList[shared.rnd(kList.length)];
         _block(tInit, oK.url, x, t, sS, sH, drawn[x] + 1, tPerB, eT + dT);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _eActive++;
           _block(tInit, oK.zwe[j].url, x, t, sS, sH, drawn[x] + 1, tPerB, eT + dT);
          }
         }
         drawn[x]++;
         t += tPerB;
        }
       }

       function _block(tInit, url, x, t, sS, sH, dX, tPerB, aT)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        img.setAttribute('src', url);
        img.setAttribute('alt', '');
        const h = sS * x;
        const v = -1 * sS;
        const vD = sH - sS * dX;
        let s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: all ' + tPerB + 'ms ease-in;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tDrop, Math.floor(t / 10 + aT), tInit, img, h, sH);
        window.setTimeout(_tMove, t, tInit, img, h, vD);
       }

       function _tMove(tInit, img, h, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
       }

       function _tDrop(tInit, img, h, sH)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
        img.style.transitionTime = '500ms';
        _gc.hook(img, false, true, 500);
       }

       return task;
      }();

      const SmallPyramid = function()
      {
       function task(kList, sW, sH)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let sS = sW / 19;
        if (sS > Math.floor(sW * cfg.emote.size.ratio.small))
         sS = Math.floor(sW * cfg.emote.size.ratio.small);
        if (sS > Math.floor(sH * cfg.emote.size.ratio.small))
         sS = Math.floor(sH * cfg.emote.size.ratio.small);
        let drawn = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        let ct = 0;
        const lP = pyramidDist.length;
        for (let i = 0; i < lP; i++)
         ct += pyramidDist[i];
        const eMS = cfg.emote.time * 1000;
        let eT = eMS * 0.8;
        let tPerB = Math.floor(eT / ct);
        if (tPerB < 75)
         tPerB = 75;
        eT = tPerB * ct;
        const dT = eMS * 0.2;
        const oX = shared.rnd(sW - sS * lP);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lP);
         while(drawn[x] >= pyramidDist[x]);
         const oK = kList[shared.rnd(kList.length)];
         _block(tInit,  oK.url, oX, x, t, sS, sH, drawn[x] + 1, tPerB, eT + dT);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _eActive++;
           _block(tInit, oK.zwe[j].url, oX, x, t, sS, sH, drawn[x] + 1, tPerB, eT + dT);
          }
         }
         drawn[x]++;
         t += tPerB;
        }
       }

       function _block(tInit, url, oX, x, t, sS, sH, dX, tPerB, aT)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        img.setAttribute('src', url);
        img.setAttribute('alt', '');
        const h = oX + sS * x;
        const v = -1 * sS;
        const vD = sH - sS * dX;
        let s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: all ' + tPerB + 'ms ease-in;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tDrop, Math.floor(t / 10 + aT), tInit, img, h, sH);
        window.setTimeout(_tMove, t, tInit, img, h, vD);
       }

       function _tMove(tInit, img, h, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
       }

       function _tDrop(tInit, img, h, sH)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
        img.style.transitionTime = '500ms';
        _gc.hook(img, false, true, 500);
       }

       return task;
      }();

      const Stampede = function()
      {
       const _speed = 2000;

       async function task(kList, sW, sH, sS, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const bandHeight = sS * 3;
        const d = shared.rnd(2) === 0;
        const bandTop = shared.rnd(sH - sS * 2.5);
        const b1 = shared.rnd(4) + 1;
        const b2 = shared.rnd(8 - b1) + b1;
        const b4 = shared.rnd(4);
        const hasB4 = b4 > 0;
        await _stampede(tInit, kList, b1, _speed * 0.8, bandTop, bandHeight, d, sW, sS);
        if (_iTitanic > tInit)
         return;
        await _stampede(tInit, kList, b2, _speed * 0.4, bandTop, bandHeight, d, sW, sS);
        if (_iTitanic > tInit)
         return;
        await _stampede(tInit, kList, iKC, hasB4, bandTop, bandHeight, d, sW, sS);
        if (_iTitanic > tInit)
         return;
        if (hasB4)
         await _stampede(tInit, kList, b4, false, bandTop, bandHeight, d, sW, sS);
       }

       async function _stampede(tInit, kList, ct, pause, bandTop, bandHeight, d, sW, sS)
       {
        if (_iTitanic > tInit)
         return;
        let imgs = [];
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         const oK = kList[shared.rnd(kList.length)];
         const y = bandTop + shared.rnd(bandHeight);
         imgs.push(_run(tInit, oK.url, y, d, sW, sS));
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _run(tInit, oK.zwe[j].url, y, d, sW, sS);
          }
         }
         await _sleep(shared.rnd(90) + 10);
        }
        if (pause === false)
         return;
        if (pause !== true)
        {
         await _sleep(pause);
         return;
        }
        do
        {
         if (_iTitanic > tInit)
          return;
         await _sleep(100);
         for (let i = imgs.length - 1; i >= 0; i--)
         {
          if (imgs[i] === null || imgs[i].hasAttribute('deleted'))
           imgs.splice(i, 1);
         }
        } while (imgs.length > 0);
       }

       function _run(tInit, url, v, d, sW, sS)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        img.setAttribute('src', url);
        img.setAttribute('alt', '');
        const h = -2 * sS;
        let s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: all ' + _speed + 'ms linear;';
        if (d)
         s += ' transform: translate(' + sW + 'px, ' + v + 'px);';
        else
         s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tMark, _speed, tInit, img);
        window.setTimeout(_tMove, _tStart, tInit, img, d, h, sW + sS, v);
        return img;
       }

       function _tMove(tInit, img, d, h1, h2, v)
       {
        if (_iTitanic > tInit)
         return;
        let h = h2;
        if (d)
         h = h1;
        img.style.transform = 'translate(' + h + 'px, ' + v + 'px)';
       }

       function _tMark(tInit, img)
       {
        if (_iTitanic > tInit)
         return;
        document.body.removeChild(img);
        img.setAttribute('deleted', true);
       }

       return task;
      }();

      const Conga = function()
      {
       const _longWait = cfg.emote.time * 2;

       async function task(kList, sW, sH, sS, nM)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let v = 0;
        let unique = false;
        const bS = Math.ceil(sS * (5/3));
        const seg = Math.floor(bS / 2);
        const sht = Math.floor(sH / seg);
        let lns = sht;
        if (nM)
         lns = 6;
        while (_conga.length >= lns)
        {
         if (_iTitanic > tInit)
          return;
         await _sleep(250);
        }
        while (!unique)
        {
         v = shared.rnd(sht) * seg;
         if (nM)
         {
          v = shared.rnd(6);
          if (v > 2)
           v = sht - 1 - (v - 3);
          v *= seg;
         }
         let found = false;
         for (let i = 0, l = _conga.length; i < l; i++)
         {
          if (_conga[i].row === v)
          {
           found = true;
           break;
          }
         }
         if (!found)
          unique = true;
        }
        _conga.push({row: v, done: false});
        let urls = [];
        let zurls = [];
        const ct = Math.floor(sW / bS);
        for (let i = 0; i < ct; i++)
        {
         const oK = kList[shared.rnd(kList.length)];
         urls.push(oK.url);
         let oZ = [];
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           oZ.push(oK.zwe[j].url);
          }
         }
         zurls.push(oZ);
        }
        const d = v / seg % 2 === 0;
        const xtra = Math.floor((sW - ct * bS) / 2);
        let imgs = [];
        let zimgs = [];
        for (let i = 0; i < ct; i++)
        {
         imgs.push(_dance(tInit, urls[i], i, sW, v, sS, bS, ct, d, xtra));
         let oZ = [];
         for (let j = 0, l = zurls[i].length; j < l; j++)
         {
          oZ.push(_dance(tInit, zurls[i][j], i, sW, v, sS, bS, ct, d, xtra));
         }
         zimgs.push(oZ);
        }
        await _sleep(_longWait * 1000);
        let full = false;
        if (_conga.length === sht)
         full = true;
        await _sleep(cfg.display.kappa.conga.time * 1000);
        if (cfg.display.kappa.conga.contagious)
        {
         let ex = false;
         let lC = _conga.length;
         if (lC > 1)
          ex = true;
         for (let i = 0; i < lC; i++)
         {
          if (_conga[i].row !== v)
           continue;
          _conga[i].done = true;
          break;
         }
         let done = false;
         while (!done)
         {
          if (_iTitanic > tInit)
           return;
          lC = _conga.length;
          if (!ex && lC > 1)
           ex = true;
          let notDone = false;
          for (let i = 0; i < lC; i++)
          {
           if (_conga[i].done === false)
           {
            notDone = true;
            break;
           }
          }
          if (notDone === false)
           done = true;
          await _sleep(100);
         }
        }
        for (let i = 0, l = imgs.length; i < l; i++)
        {
         _endDance(tInit, imgs[i], i, sW, v, sS, bS, ct, d, xtra);
         for (let j = 0, m = zimgs[i].length; j < m; j++)
         {
          _endDance(tInit, zimgs[i][j], i, sW, v, sS, bS, ct, d, xtra);
         }
        }
        await _sleep(_longWait * 1000);
        for (let i = 0, l = _conga.length; i < l; i++)
        {
         if (_conga[i].row !== v)
          continue;
         _conga.splice(i, 1);
         break;
        }
       }

       function _dance(tInit, url, col, sW, v, sS, bS, ct, d, xtra)
       {
        if (_iTitanic > tInit)
         return;
        let box = document.createElement('div');
        box.setAttribute('class', 'scene');
        let img = document.createElement('img');
        img.setAttribute('class', 'dancer');
        img.setAttribute('src', url);
        img.setAttribute('alt', '');
        let s = 'width: ' + sS + 'px;';
        s += ' height: ' + sS + 'px;';
        img.setAttribute('style', s);
        let sE = bS * col + xtra;
        let sB = sE - sW;
        if (d)
        {
         sE = bS * (ct - 1 - col) + xtra;
         sB = sE + sW;
        }
        s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' width: ' + bS + 'px;';
        s += ' height: ' + bS + 'px;';
        s += ' z-index: ' + v + ';';
        s += ' transition: all ' + _longWait + 's linear;';
        s += ' transform: translate(' + sB + 'px, ' + v + 'px);';
        box.setAttribute('style', s);
        _eActive++;
        box.appendChild(img);
        document.body.appendChild(box);
        window.setTimeout(_tMove, _tStart, tInit, box, sE, v);
        return box;
       }

       function _endDance(tInit, box, col, sW, v, sS, bS, ct, d, xtra)
       {
        if (_iTitanic > tInit)
         return;
        let sB = bS * col + xtra;
        let sE = sB + sW;
        if (d)
        {
         sB = bS * (ct - 1 - col) + xtra;
         sE = sB - sW;
        }
        let s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' width: ' + bS + 'px;';
        s += ' height: ' + bS + 'px;';
        s += ' z-index: ' + v + ';';
        s += ' transition: all ' + _longWait + 's ease-in;';
        s += ' transform: translate(' + sB + 'px, ' + v + 'px);';
        box.setAttribute('style', s);
        _gc.hook(box, true, true, _longWait * 1000 * 1.25);
        window.setTimeout(_tMove, _tStart, tInit, box, sE, v);
       }

       function _tMove(tInit, box, sE, v)
       {
        if (_iTitanic > tInit)
         return;
        box.style.transform = 'translate(' + sE + 'px, ' + v + 'px)';
       }

       return task;
      }();

      const TheCube = function()
      {
       function task(url, zwe, sW, sH, sS, bC, iR)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const sSm = Math.ceil(sS / 2);
        const nSm = sSm * -1;
        const sWm = Math.ceil(sW / 2);
        const sHm = Math.ceil(sH / 2);
        let scene = document.createElement('div');
        scene.setAttribute('class', 'scene');
        scene.setAttribute('width', sS);
        scene.setAttribute('height', sS);
        let cube = document.createElement('div');
        cube.setAttribute('class', 'cube');
        cube.setAttribute('style', 'transform: translateZ(' + nSm + 'px);  transition: transform linear ' + cfg.emote.time + 's;');
        let f = 'height: ' + sS + 'px;';
        f += ' width: ' + sS + 'px;';
        const lZ = zwe.length;
        if (lZ === 0)
        {
         let cubeF = document.createElement('img');
         cubeF.setAttribute('src', url);
         cubeF.setAttribute('alt', '');
         cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
         cubeF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px);');
         cube.appendChild(cubeF);
         let cubeB = document.createElement('img');
         cubeB.setAttribute('src', url);
         cubeB.setAttribute('alt', '');
         cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
         cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeB);
         let cubeR = document.createElement('img');
         cubeR.setAttribute('src', url);
         cubeR.setAttribute('alt', '');
         cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
         cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeR);
         let cubeL = document.createElement('img');
         cubeL.setAttribute('src', url);
         cubeL.setAttribute('alt', '');
         cubeL.setAttribute('class', 'cubeFace cubeFaceLeft');
         cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeL);
         let cubeT = document.createElement('img');
         cubeT.setAttribute('src', url);
         cubeT.setAttribute('alt', '');
         cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
         cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeT);
         let cubeU = document.createElement('img');
         cubeU.setAttribute('src', url);
         cubeU.setAttribute('alt', '');
         cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
         cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeU);
        }
        else
        {
         let cubeF = document.createElement('div');
         cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
         cubeF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px);');
         let pctF = document.createElement('img');
         pctF.setAttribute('src', url);
         pctF.setAttribute('alt', '');
         pctF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeF.appendChild(pctF);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeF.appendChild(pctZ);
         }
         cube.appendChild(cubeF);
         let cubeB = document.createElement('div');
         cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
         cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + sSm + 'px);');
         let pctB = document.createElement('img');
         pctB.setAttribute('src', url);
         pctB.setAttribute('alt', '');
         pctB.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeB.appendChild(pctB);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeB.appendChild(pctZ);
         }
         cube.appendChild(cubeB);
         let cubeR = document.createElement('div');
         cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
         cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + sSm + 'px);');
         let pctR = document.createElement('img');
         pctR.setAttribute('src', url);
         pctR.setAttribute('alt', '');
         pctR.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeR.appendChild(pctR);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeR.appendChild(pctZ);
         }
         cube.appendChild(cubeR);
         let cubeL = document.createElement('div');
         cubeL.setAttribute('class', 'cubeFace cubeFaceLight');
         cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + sSm + 'px);');
         let pctL = document.createElement('img');
         pctL.setAttribute('src', url);
         pctL.setAttribute('alt', '');
         pctL.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeL.appendChild(pctL);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeL.appendChild(pctZ);
         }
         cube.appendChild(cubeL);
         let cubeT = document.createElement('div');
         cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
         cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + sSm + 'px);');
         let pctT = document.createElement('img');
         pctT.setAttribute('src', url);
         pctT.setAttribute('alt', '');
         pctT.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeT.appendChild(pctT);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeT.appendChild(pctZ);
         }
         cube.appendChild(cubeT);
         let cubeU = document.createElement('div');
         cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
         cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + sSm + 'px);');
         let pctU = document.createElement('img');
         pctU.setAttribute('src', url);
         pctU.setAttribute('alt', '');
         pctU.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeU.appendChild(pctU);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          pctZ.setAttribute('src', zwe[i].url);
          pctZ.setAttribute('alt', '');
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeU.appendChild(pctZ);
         }
         cube.appendChild(cubeU);
        }
        scene.appendChild(cube);
        let h = shared.rnd(sW - sS);
        let v = shared.rnd(sH - sS);
        if (bC)
        {
         h = Math.floor(sWm - sSm);
         v = Math.floor(sHm - sSm);
        }
        let s = 'width: ' + sS + 'px;';
        s += ' height: ' + sS + 'px;';
        s += ' perspective: ' + sS * 3 + 'px;';
        s += ' transition: all ' + cfg.emote.time + 's linear;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false);
        scene.setAttribute('style', s);
        _eActive++;
        document.body.appendChild(scene);
        _gc.hook(scene, false);
        window.setTimeout(_tMove, _tStart, tInit, cube, iR, sS);
       }

       function _tMove(tInit, cube, iR, sS)
       {
        if (_iTitanic > tInit)
         return;
        const nSm = Math.ceil(sS / 2) * -1;
        let rX = 0;
        let rY = 0;
        while (Math.abs(rX) + Math.abs(rY) < 45)
        {
         rX = (360 - shared.rnd() * 720) * iR;
         rY = (360 - shared.rnd() * 720) * iR;
        }
        cube.style.transform = 'translateZ(' + nSm + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
       }

       return task;
      }();

      const Text = function()
      {
       function task(kList, sW, sH, sMsg, iTime)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const msgDist = _buildMsgArr(sMsg);
        let ct = 0;
        let ctT = 0;
        let drawn = [];
        const lM = msgDist.length;
        for (let x = 0; x < lM; x++)
        {
         const lX = msgDist[x].length;
         for (let y = 0; y < lX; y++)
         {
          if (msgDist[x][y] !== 0)
           ctT += 1;
         }
         ct += lX;
         drawn.push(0);
        }
        let sS = Math.floor(sW / (lM + 2));
        if (sS > Math.floor(sW * cfg.emote.size.ratio.small))
         sS = Math.floor(sW * cfg.emote.size.ratio.small);
        if (sS > Math.floor(sH * cfg.emote.size.ratio.small))
         sS = Math.floor(sH * cfg.emote.size.ratio.small);
        let eT = cfg.emote.time * 1000;
        let tPerB = Math.floor(eT / ctT);
        if (tPerB < 24)
         tPerB = 24;
        eT = tPerB * ctT;
        const lF = msgDist[0].length;
        const lFS = sS * lF;
        const vH = shared.rnd(sH - lFS) + lFS;
        const oX = shared.rnd(sW - sS * lM);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lM);
         while(drawn[x] >= msgDist[x].length);
         if (msgDist[x][drawn[x]] !== 0)
         {
          const oK = kList[shared.rnd(kList.length)];
          _block(tInit, oK.url, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, sS);
          if (oK.hasOwnProperty('zwe'))
          {
           for (let j = 0, l = oK.zwe.length; j < l; j++)
           {
            _eActive++;
            _block(tInit, oK.zwe[j].url, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, sS);
           }
          }
          t += tPerB;
         }
         drawn[x]++;
        }
       }

       function _buildMsgArr(s)
       {
        let o = [];
        let spc = [];
        for (let y = 0, l = alnumDist['A'][0].length; y < l; y++)
        {
         spc.push(0);
        }
        for (let i = 0, l = s.length; i < l; i++)
        {
         if (i > 0)
          o.push(spc);
         if (s[i] === ' ')
         {
          o.push(spc);
          o.push(spc);
          continue;
         }
         const v = s[i];
         if (!alnumDist.hasOwnProperty(v))
          continue;
         const c = alnumDist[v];
         for (let x = 0, m = c.length; x < m; x++)
         {
          o.push(c[x]);
         }
        }
        return o;
       }

       function _block(tInit, url, vH, oX, dX, tPerB, eT, iTime, x, t, sH, sS)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        img.setAttribute('src', url);
        img.setAttribute('alt', '');
        const h = oX + sS * x;
        const v = -1 * sS;
        const vD = vH - sS * dX;
        let s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: all ' + tPerB + 'ms ease-in;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        const tMS = iTime * 1000;
        window.setTimeout(_tDrop, Math.floor(eT + tMS + t / 10), tInit, img, h, sH);
        window.setTimeout(_tMove, t, tInit, img, h, vD);
       }

       function _tMove(tInit, img, h, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
       }
       
       function _tDrop(tInit, img, h, sH)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
        img.style.transitionTime = '500ms';
        _gc.hook(img, false, true, 500);
       }

       return task;
      }();

      return {
       Fireworks: Fireworks,
       Spiral: Spiral,
       Pyramid: Pyramid,
       SmallPyramid: SmallPyramid,
       Stampede: Stampede,
       Conga: Conga,
       TheCube: TheCube,
       Text: Text
      };
     }();

     function _canShowKappa(k)
     {
      if (cfg.emote.max < 1)
       return true;
      if (_eActive < 1)
       return true;
      let tC = cfg.display.kappa.count;
      if (k !== false)
       tC = _getKappaCountEstimate(k);
      let cM = cfg.emote.max;
      if (tC > cM)
       cM = tC;
      return _eActive + tC < cM;
     }

     function _showKappas()
     {
      if (_tKappa !== false)
      {
       window.clearTimeout(_tKappa);
       _tKappa = false;
      }
      if (_toKappa.length < 1)
       return;
      let nK = _getNextKappa(_toKappa[0]);
      if (nK === false)
       return;
      if (!_canShowKappa(nK))
      {
       _tKappa = window.setTimeout(_showKappas, _dKappa);
       return;
      }
      let e = null;
      while ((e = _toKappa.shift()) !== undefined)
      {
       nK = false;
       let a = {};
       a[e.style] = e.prefs;
       showKappa(e.list, a, e.params);
       if (_toKappa.length < 1)
        return;
       nK = _getNextKappa(_toKappa[0]);
       if (nK === false)
        return;
       if (!_canShowKappa(nK))
       {
        if (cfg.emote.queue > 0 && _toKappa.length > cfg.emote.queue)
         _toKappa.splice(0, _toKappa.length - cfg.emote.queue);
        _tKappa = window.setTimeout(_showKappas, _dKappa);
        return;
       }
      }
     }

     function _getNextKappa(k)
     {
      let a = [];
      a[k.style] = k.prefs;
      return _getNextKappaEx(a, k.params);
     }

     function _getNextKappaEx(kS = false, kP = false)
     {
      if (typeof kS !== 'object')
      {
       if (cfg.display.kappa.styles.length < 1)
        return false;
       kS = cfg.display.kappa.styles;
      }
      let s, p;
      const keys = Object.keys(kS);
      if (cfg.display.kappa.conga.contagious && _conga.length > 0)
      {
       s = 'Conga';
       p = {};
       if (keys.includes(s))
        p = kS[s];
      }
      else
      {
       s = keys[shared.rnd(keys.length)];
       p = kS[s];
      }
      if (s === undefined)
       return false;
      let iKC = cfg.display.kappa.count;
      if (cfg.display.kappa.styles.hasOwnProperty(s) && cfg.display.kappa.styles[s].hasOwnProperty('count') && cfg.display.kappa.styles[s].count > 0)
       iKC = cfg.display.kappa.styles[s].count;
      if (p === undefined)
       p = {};
      if (p.hasOwnProperty('count'))
      {
       let tKC = p.count;
       if (tKC === -1 && kP !== false && kP.hasOwnProperty('%AMOUNT%') && Math.ceil(kP['%AMOUNT%']) > 0)
        tKC = Math.ceil(kP['%AMOUNT%']);
       if (tKC > 0)
        iKC = tKC;
      }
      if (cfg.emote.max > 0 && iKC > cfg.emote.max)
       iKC = cfg.emote.max;
      return {style: s, prefs: p, count: iKC};
     }

     function _getKappaCountEstimate(k)
     {
      switch (k.style)
      {
       case 'Pyramid':
       case 'SmallPyramid':
        let c = 0;
        for (let i = 0, l = pyramidDist.length; i < l; i++)
         c += pyramidDist[i];
        return c;
       case 'Fireworks':
        const inner = Math.floor(k.count / 8);
        const outer = inner;
        const core = k.count - (inner + outer);
        return 1 + inner + core + outer;
       case 'Conga':
        const sW = window.innerWidth;
        const sH = window.innerHeight;
        let sS = cfg.emote.size.max;
        if (sW < sH)
         sS = Math.floor(sW * cfg.emote.size.ratio.normal);
        else
         sS = Math.floor(sH * cfg.emote.size.ratio.normal);
        if (sS > cfg.emote.size.max)
         sS = cfg.emote.size.max;
        if (sS < cfg.emote.size.min)
         sS = cfg.emote.size.min;
        const bS = Math.ceil(sS * (5/3));
        return Math.floor(sW / bS);
      }
      return k.count;
     }

     async function showKappa(kList, kStyles = false, kParams = false)
     {
      const kStyle = _getNextKappaEx(kStyles, kParams);
      if (kStyle === false)
       return;
      if (kStyle.style === undefined)
       return;
      if (!Array.isArray(kList) || kList.length < 1)
       kList = cList;
      if (!Array.isArray(kList) || kList.length < 1)
       kList = bareList;
      const sW = window.innerWidth;
      const sH = window.innerHeight;
      let sS = cfg.emote.size.max;
      let sSm = Math.floor(sS / 2);
      if (sW < sH)
      {
       sS = Math.floor(sW * cfg.emote.size.ratio.normal);
       sSm = Math.floor(sW * cfg.emote.size.ratio.small);
      }
      else
      {
       sS = Math.floor(sH * cfg.emote.size.ratio.normal);
       sSm = Math.floor(sH * cfg.emote.size.ratio.small);
      }
      if (sS > cfg.emote.size.max)
       sS = cfg.emote.size.max;
      if (sS < cfg.emote.size.min)
       sS = cfg.emote.size.min;
      if (sSm > cfg.emote.size.max)
       sSm = cfg.emote.size.max;
      if (sSm < cfg.emote.size.min)
       sSm = cfg.emote.size.min;
      const sR = sW - sS;
      const sB = sH - sS;
      const ehs = Math.ceil(sS / 2);
      const ehl = sS * 2;
      const fR = sR * 0.33;
      document.documentElement.style.setProperty('--height', sH + 'px');
      document.documentElement.style.setProperty('--width', sW + 'px');
      document.documentElement.style.setProperty('--emote-height', sS + 'px');
      document.documentElement.style.setProperty('--emote-height-s', ehs + 'px');
      document.documentElement.style.setProperty('--emote-height-l', ehl + 'px');
      const waitFor = _getKappaCountEstimate(kStyle);
      if (!_canShowKappa(kStyle))
      {
       _toKappa.push({list: kList, style: kStyle.style, prefs: kStyle.prefs, params: kParams});
       if (_tKappa !== false)
       {
        window.clearTimeout(_tKappa);
        _tKappa = false;
       }
       _tKappa = window.setTimeout(_showKappas, _dKappa);
       return;
      }
      _eActive += waitFor;
      const lK = kList.length;
      const tInit = new Date().getTime();
      switch(kStyle.style)
      {
       case 'Stampede':
        await _list.Stampede(kList, sW, sH, sS, kStyle.count);
        _eActive -= kStyle.count;
        break;
       case 'Fireworks':
        _list.Fireworks(kList, sW, sH, sSm, kStyle.count);
        break;
       case 'Spiral':
        _list.Spiral(kList, sW, sH, sSm, kStyle.count);
        break;
       case 'Pyramid':
        _list.Pyramid(kList, sW, sH);
        break;
       case 'SmallPyramid':
        _list.SmallPyramid(kList, sW, sH);
        break;
       case 'Conga':
        _eActive -= waitFor;
        let avoidMiddle = false;
        if (cfg.display.kappa.conga.hasOwnProperty('avoidMiddle') && cfg.display.kappa.conga.avoidMiddle === true)
         avoidMiddle = true;
        if (kStyle.prefs.hasOwnProperty('avoidMiddle') && kStyle.prefs.avoidMiddle === true)
         avoidMiddle = true;
        _list.Conga(kList, sW, sH, sS, avoidMiddle);
        break;
       case 'Text':
        _eActive -= waitFor;
        let sTM = 'HYPE!';
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('message'))
         sTM = cfg.display.kappa.styles[kStyle.style].message[shared.rnd(cfg.display.kappa.styles[kStyle.style].message.length)];
        if (kStyle.prefs.hasOwnProperty('message'))
         sTM = kStyle.prefs.message[shared.rnd(kStyle.prefs.message.length)];
        let sTT = cfg.emote.time;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('time'))
         sTT = cfg.display.kappa.styles[kStyle.style].time;
        if (kStyle.prefs.hasOwnProperty('time'))
         sTT = kStyle.prefs.time;
        if (kParams !== false)
        {
         const pK = Object.keys(kParams);
         for (let i = 0, l = pK.length; i < l; i++)
         {
          sTM = sTM.replaceAll(pK[i], kParams[pK[i]]);
         }
        }
        _list.Text(kList, sW, sH, sTM, sTT);
        break;
       case 'TheCube':
        _eActive -= waitFor;
        let cS = sW;
        if (sW > sH)
         cS = sH;
        const rC = shared.rnd(lK);
        let sCS = 8 / 10;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('size'))
         sCS = cfg.display.kappa.styles[kStyle.style].size;
        if (kStyle.prefs.hasOwnProperty('size'))
         sCS = kStyle.prefs.size;
        let sCC = true;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('center'))
         sCC = cfg.display.kappa.styles[kStyle.style].center;
        if (kStyle.prefs.hasOwnProperty('center'))
         sCC = kStyle.prefs.center;
        let sCR = 5;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('rotations'))
         sCR = cfg.display.kappa.styles[kStyle.style].rotations;
        if (kStyle.prefs.hasOwnProperty('rotations'))
         sCR = kStyle.prefs.rotations;
        _list.TheCube(kList[rC].url, kList[rC].zwe ?? [], sW, sH, Math.floor(cS * sCS), sCC, sCR);
        break;
       case 'Burst':
        const fB = sB * 0.33;
        const oH = Math.floor(shared.rnd() * fR + fR);
        const oV = Math.floor(shared.rnd() * fB + fB);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rB = shared.rnd(lK);
         _eActive--;
         display.emote.list.StraightLine(kList[rB].url, kList[rB].zwe ?? [], sW, sH, sS, oH, oV, false, tInit);
         await _sleep(50);
        }
        break;
       case 'Fountain':
        const fX = Math.floor(shared.rnd() * fR + fR);
        const fY = shared.rnd(25) + 15;
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rF = shared.rnd(lK);
         _eActive--;
         display.emote.list.Fountain(kList[rF].url, kList[rF].zwe ?? [], sW, sH, sS, fX, fY, false, tInit);
         await _sleep(50);
        }
        break;
       case 'Confetti':
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rN = shared.rnd(lK);
         _eActive--;
         display.emote.list.Confetti(kList[rN].url, kList[rN].zwe ?? [], sW, sH, sSm, false, tInit);
         await _sleep(25);
        }
        break;
       default:
        if (typeof display.emote.list[kStyle.style] === 'undefined')
         return false;
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const r = shared.rnd(lK);
         _eActive--;
         if (kStyle.style === 'StraightLine')
          display.emote.list.StraightLine(kList[r].url, kList[r].zwe ?? [], sW, sH, sS, false, false, false, tInit);
         else
          display.emote.list[kStyle.style](kList[r].url, kList[r].zwe ?? [], sW, sH, sS, false, tInit);
         await _sleep(100);
        }
      }
     }

     function hideKappa()
     {
      if (_tKappa !== false)
      {
       window.clearTimeout(_tKappa);
       _tKappa = false;
      }
      _toKappa.length = 0;
      _conga.length = 0;
     }

     return {
      show: showKappa,
      hide: hideKappa
     };
    }();

    const _gc = function()
    {
     let _toGC = {};      // list of image elements to garbage collect

     let _tGC = false;    // timer for garbage collection

     function _doGC()
     {
      if (_tGC === false)
       return;
      window.clearTimeout(_tGC);
      _tGC = false;
      let done = true;
      const tNow = new Date().getTime();
      for (const idx in _toGC)
      {
       if (!_toGC.hasOwnProperty(idx))
        continue;
       done = false;
       const i = _toGC[idx].img;
       const t = _toGC[idx].end;
       const d = _toGC[idx].dec;
       if (_toGC[idx].space)
       {
        const r = i.getBoundingClientRect();
        if (t > tNow && r.bottom > 0 && r.right > 0 && r.top < window.innerHeight && r.left < window.innerWidth)
         continue;
       }
       else
       {
        if (t > tNow)
         continue;
       }
       delete _toGC[idx];
       if (i.parentNode !== null)
        document.body.removeChild(i);
       if (d)
        _eActive--;
      }
      if (!done)
       _tGC = window.setTimeout(_doGC, 500);
     }

     function gcEmote(img, space = true, decActive = true, t = false)
     {
      if (t === false)
       t = cfg.emote.time * 1000;
      let x = 0;
      do
      {
       x++;
      } while(_toGC.hasOwnProperty(x));
      _toGC[x] = {img: img, space: space, dec: decActive, end: new Date().getTime() + t};
      if (_tGC === false)
       _tGC = window.setTimeout(_doGC, 500);
     }

     return {
      hook: gcEmote
     };
    }();

    function _sleep(ms)
    {
     return new Promise(function(resolve){setTimeout(resolve, ms);});
    }

    function _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters)
    {
     let s = '';
     if (aNames.length > 0)
     {
      s += ' animation-name: ' + aNames.join() + ';';
      s += ' animation-delay: ' + aDelays.join() + ';';
      s += ' animation-duration: ' + aDurs.join() + ';';
      s += ' animation-timing-function: ' + aTimings.join() + ';';
      s += ' animation-fill-mode: ' + aFills.join() + ';';
      s += ' animation-iteration-count: ' + aIters.join() + ';';
     }
     return s;
    }

    function _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, fadeIn = true, zoomIn = true, fadeOut = true, zoomOut = true, variationSize = 1)
    {
     const tMS = cfg.emote.time * 1000;
     const tFI = _tAnim.fade.in / 100;
     const tFO = _tAnim.fade.out / 100;
     const tZI = _tAnim.zoom.in / 100;
     const tZO = _tAnim.zoom.out / 100;
     if (fadeIn)
     {
      aNames.push('fadeIn');
      aDelays.push('0s');
      aDurs.push(Math.floor(tMS * tFI) + 'ms');
      aTimings.push('ease-in');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (zoomIn)
     {
      if (variationSize === 0)
       aNames.push('zoomInS');
      else if (variationSize === 2)
       aNames.push('zoomInL');
      else
       aNames.push('zoomIn');
      aDelays.push('0s');
      aDurs.push(Math.floor(tMS * tZI) + 'ms');
      aTimings.push('linear');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (fadeOut)
     {
      aNames.push('fadeOut');
      aDelays.push(Math.floor(tMS - tMS * tFO) + 'ms');
      aDurs.push(Math.floor(tMS * tFO) + 'ms');
      aTimings.push('ease-out');
      aFills.push('forwards');
      aIters.push('1');
     }
     else
     {
      aNames.push('noFadeOut');
      aDelays.push(tMS - 50 + 'ms');
      aDurs.push('50ms');
      aTimings.push('ease-out');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (zoomOut)
     {
      if (variationSize === 0)
       aNames.push('zoomOutS');
      else if (variationSize === 2)
       aNames.push('zoomOutL');
      else
       aNames.push('zoomOut');
      aDelays.push(Math.floor(tMS - tMS * tZO) + 'ms');
      aDurs.push(Math.floor(tMS * tZO) + 'ms');
      aTimings.push('linear');
      aFills.push('forwards');
      aIters.push('1');
     }
     return _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
    }

    function eraseAll()
    {
     _iTitanic = new Date().getTime();
     display.kappa.hide();
     let cubes = document.getElementsByClassName('scene');
     while (cubes.length)
      cubes[0].parentElement.removeChild(cubes[0]);
     let imgs = document.getElementsByTagName('img');
     while (imgs.length)
      imgs[0].parentElement.removeChild(imgs[0]);
    }

    return {
     emote: emote,
     kappa: kappa,
     eraseAll: eraseAll
    };
   }();

   const twitch = function()
   {
    let _rList = {};     // list of triggered channel point redeems to match to PubSub events

    const net = function()
    {
     const follower = function()
     {
      let _uLF = false;    // user id of the most recent follower
      const _rFC = 2500;   // follower count interval (ms)

      async function getFollowerChange(chID)
      {
       const url = 'https://api.twitch.tv/helix/users/follows?to_id=' + chID + '&first=100';
       const h = {
        'Authorization': 'Bearer ' + cfg.login.oauth,
        'Client-Id': cfg.login.client
       };
       const r = await shared.httpRequest(url, h);
       if (r === false)
        return false;
       const j = JSON.parse(r);
       if (!j.hasOwnProperty('total') || j.total < 1)
        return false;
       if (!j.hasOwnProperty('data') || !Array.isArray(j.data) || j.data.length < 1)
        return false;
       const findU = _uLF;
       _uLF = j.data[0].from_id;
       if (findU === false)
        return false;
       let s = [];
       for (let i = 0, l = j.data.length; i < l; i++)
       {
        if (j.data[i].from_id === findU)
         return s;
        twitch.net.fList[j.data[i].from_id] = {value: true, t: new Date().getTime()};
        s.push(j.data[i].from_name);
       }
       return [];
      }

      async function detectFollowers(chID)
      {
       if (follower.timer === false)
        return;
       window.clearTimeout(follower.timer);
       follower.timer = false;
       const fRet = await getFollowerChange(chID);
       if (document.visibilityState !== 'hidden' && fRet !== false && fRet.length > 0)
       {
        for (let i = 0, l = fRet.length; i < l; i++)
         display.kappa.show(false, cfg.event.follow, {'%USER%': fRet[i]});
       }
       follower.timer = window.setTimeout(detectFollowers, _rFC, chID);
      }

      return {
       list: {},          // cache of users in chat and their follow status
       timer: false,      // timer for follower kludge
       detect: detectFollowers
      };
     }();

     async function loadCheer_channel(chID)
     {
      thirdparty.emotes.cheer = {};
      const url = 'https://api.twitch.tv/helix/bits/cheermotes?broadcaster_id=' + chID;
       const h = {
        'Authorization': 'Bearer ' + cfg.login.oauth,
        'Client-Id': cfg.login.client
       };
      const r = await shared.httpRequest(url, h);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('data'))
       return false;
      for (let c = 0, l = j.data.length; c < l; c++)
      {
       const set = j.data[c];
       if (!set.hasOwnProperty('prefix'))
        continue;
       if (!set.hasOwnProperty('tiers'))
        continue;
       const prefix = set.prefix;
       let tierList = [];
       for (let i = set.tiers.length - 1; i >= 0; i--)
       {
        if (!set.tiers[i].hasOwnProperty('min_bits'))
         continue;
        if (!set.tiers[i].hasOwnProperty('images'))
         continue;
        const amt = set.tiers[i].min_bits;
        let img = null;
        if (set.tiers[i].images.hasOwnProperty('dark'))
        {
         if (set.tiers[i].images.dark.hasOwnProperty('animated'))
         {
          if (set.tiers[i].images.dark.animated.hasOwnProperty('4'))
           img = set.tiers[i].images.dark.animated['4'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('3'))
           img = set.tiers[i].images.dark.animated['3'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('2'))
           img = set.tiers[i].images.dark.animated['2'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('1.5'))
           img = set.tiers[i].images.dark.animated['1.5'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('1'))
           img = set.tiers[i].images.dark.animated['1'];
         }
         else if (set.tiers[i].images.dark.hasOwnProperty('static'))
         {
          if (set.tiers[i].images.dark.static.hasOwnProperty('4'))
           img = set.tiers[i].images.dark.static['4'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('3'))
           img = set.tiers[i].images.dark.static['3'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('2'))
           img = set.tiers[i].images.dark.static['2'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('1.5'))
           img = set.tiers[i].images.dark.static['1.5'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('1'))
           img = set.tiers[i].images.dark.static['1'];
         }
        }
        else if (set.tiers[i].images.hasOwnProperty('light'))
        {
         if (set.tiers[i].images.light.hasOwnProperty('animated'))
         {
          if (set.tiers[i].images.light.animated.hasOwnProperty('4'))
           img = set.tiers[i].images.light.animated['4'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('3'))
           img = set.tiers[i].images.light.animated['3'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('2'))
           img = set.tiers[i].images.light.animated['2'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('1.5'))
           img = set.tiers[i].images.light.animated['1.5'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('1'))
           img = set.tiers[i].images.light.animated['1'];
         }
         else if (set.tiers[i].images.light.hasOwnProperty('static'))
         {
          if (set.tiers[i].images.light.static.hasOwnProperty('4'))
           img = set.tiers[i].images.light.static['4'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('3'))
           img = set.tiers[i].images.light.static['3'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('2'))
           img = set.tiers[i].images.light.static['2'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('1.5'))
           img = set.tiers[i].images.light.static['1.5'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('1'))
           img = set.tiers[i].images.light.static['1'];
         }
        }
        if (img === null)
         continue;
        tierList.push({min: amt, img: img});
       }
       thirdparty.emotes.cheer[prefix] = tierList;
      }
      return true;
     }

     const pubSub = function()
     {
      let _wsRetry = null;
      let _ws = null;
      let _tPing = null;

      function task()
      {
       _ws = new WebSocket('wss://pubsub-edge.twitch.tv:443');
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       _ws.onopen = null;
       _tPing = window.setInterval(_wsPing, 4 * 60 * 1000);
       let req = {};
       req.type = 'LISTEN';
       req.nonce = 'init';
       req.data = {};
       req.data.topics = [];
       req.data.topics.push('channel-points-channel-v1.' + twitch.net.channelID);
       req.data.auth_token = cfg.login.oauth;
       _ws.send(JSON.stringify(req));
      }

      function _wsClose()
      {
       if (_tPing !== null)
       {
        window.clearInterval(_tPing);
        _tPing = null;
       }
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(task, wsWait);
      }

      async function _wsMessage(ev)
      {
       if (twitch.net.dead)
       {
        _ws.close();
        return;
       }
       _wsRetry = 0;
       const r = JSON.parse(ev.data);
       if (!r.hasOwnProperty('type'))
        return;
       switch (r.type)
       {
        case 'RESPONSE':
         if (r.hasOwnProperty('error') && r.error !== '')
         {
          _ws.close();
          if (r.error === 'ERR_BADAUTH')
          {
           twitch.net.dead = true;
           shared.blargIAmDead(6);
           return;
          }
          alert('Error Connecting to Twitch PubSub: ' + r.error);
          return;
         }
         break;
        case 'MESSAGE':
         if (document.visibilityState === 'hidden')
          return;
         if (!r.hasOwnProperty('data'))
          return;
         if (!r.data.hasOwnProperty('topic'))
          return;
         if (r.data.topic !== 'channel-points-channel-v1.' + twitch.net.channelID)
          return;
         if (!r.data.hasOwnProperty('message'))
          return;
         const d = JSON.parse(r.data.message);
         if (!d.hasOwnProperty('type'))
          return;
         if (d.type !== 'reward-redeemed')
          return;
         if (!d.hasOwnProperty('data'))
          return;
         if (!d.data.hasOwnProperty('redemption'))
          return;
         if (!d.data.redemption.hasOwnProperty('reward'))
          return;
         if (!d.data.redemption.reward.hasOwnProperty('title'))
          return;
         const n = d.data.redemption.reward.title;
         if (!d.data.redemption.hasOwnProperty('user_input'))
         {
          await twitch.parse.event.redeem(n, false);
          return;
         }
         const lnID = d.data.redemption.reward.id;
         if (!_rList.hasOwnProperty(lnID))
         {
          _rList[lnID] = {name: n, cmds: []};
          return;
         }
         if (_rList[lnID].name === false)
          _rList[lnID].name = n;
         while (_rList[lnID].cmds.length > 0)
         {
          await twitch.parse.event.redeem(n, _rList[lnID].cmds.shift());
         }
         break;
       }
      }

      function _wsPing()
      {
       _ws.send('{"type": "PING"}');
      }

      return task;
     }();

     const irc = function()
     {
      let _wsRetry = 0;
      let _firstRS = true;
      let _ws = null;
      let _tTimeout = false;   // timer for irc connection timeout

      function task()
      {
       _firstRS = true;
       _ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       _ws.onopen = null;
       _tTimeout = setTimeout(_wsTimeout, 5000);
       _ws.send('CAP REQ :twitch.tv/commands twitch.tv/tags');
       _ws.send('PASS oauth:' + cfg.login.oauth);
       _ws.send('NICK ' + cfg.channel);
       _ws.send('JOIN #' + cfg.channel);
      }

      function _wsClose()
      {
       if (_tTimeout !== false)
       {
        clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(task, wsWait);
      }

      async function _wsMessage(ev)
      {
       if (twitch.net.dead)
       {
        _ws.close();
        return;
       }
       _wsRetry = 0;
       const data = ev.data.split('\r\n');
       for (let i = 0, l = data.length; i < l; i++)
       {
        if (data[i].length === 0)
         continue;
        let cmd = twitch.parse.message(data[i]);
        if (cmd === false)
        {
         console.log('Unparsed IRC Command: ', data[i]);
         continue;
        }
        switch(cmd.command)
        {
         case 'PING':
          _ws.send('PONG ' + cmd.params[0]);
          break;
         case 'PRIVMSG':
          if (document.visibilityState === 'hidden')
           return;
          if (cmd.params.length > 1)
          {
           // https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f
           cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d'); //zwj alternate
          }
          if (!await twitch.parse.event.cheer(cmd))
           twitch.parse.line(cmd);
          break;
         case 'NOTICE':
          if (cmd.params.length > 1 && cmd.params[1] === 'Login authentication failed')
          {
           twitch.net.dead = true;
           shared.blargIAmDead(1);
          }
          break;
         case 'ROOMSTATE':
          if (!cmd.hasOwnProperty('tags'))
           continue;
          if (!cmd.tags.hasOwnProperty('room-id'))
           continue;
          twitch.net.channelID = cmd.tags['room-id'];
          if (_firstRS)
          {
           if (_tTimeout !== false)
           {
            clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           _firstRS = false;
           await loadEmote_channel(twitch.net.channelID);
           await loadCheer_channel(twitch.net.channelID);
           if (cfg.display.extended.useFFZ)
            thirdparty.ffz.channel(twitch.net.channelID);
           if (cfg.display.extended.useBTTV)
           {
            thirdparty.bttv.channel(twitch.net.channelID);
            thirdparty.bttv.socket(twitch.net.channelID);
           }
           if (cfg.display.extended.use7TV)
           {
            thirdparty['7tv'].channel(twitch.net.channelID);
            thirdparty['7tv'].socket(twitch.net.channelID);
           }
           if (cfg.display.extended.useFFZ | cfg.display.extended.use7TV)
            thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval, twitch.net.channelID);
           if (cfg.display.extended.useBTTV)
            thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, thirdparty.interval, twitch.net.channelID);
           if (cfg.event.follow !== false)
            follower.timer = window.setTimeout(follower.detect, 16, twitch.net.channelID);
           pubSub();
          }
          break;
         case 'USERNOTICE':
          if (document.visibilityState === 'hidden')
           return;
          if (!cmd.hasOwnProperty('tags'))
           continue;
          if (!cmd.tags.hasOwnProperty('msg-id'))
           continue;
          if (cmd.params.length > 1)
          {
           // https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f
           cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d'); //zwj alternate
          }
          switch (cmd.tags['msg-id'])
          {
           case 'raid':
            twitch.parse.event.raid(cmd);
            break;
           case 'sub':
           case 'resub':
           case 'subgift':
           case 'submysterygift':
           case 'giftpaidupgrade':
           case 'primepaidupgrade':
            twitch.parse.event.sub(cmd);
            break;
           case 'bitsbadgetier':
            twitch.parse.event.badge(cmd);
            break;
           default:
            if (cmd.params.length > 1)
             twitch.parse.line(cmd);
          }
          break;
        }
       }
      }

      function _wsTimeout()
      {
       if (twitch.net.dead === true)
        return;
       twitch.net.dead = true;
       if (_tTimeout !== false)
       {
        clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       _ws.close();
       shared.blargIAmDead(5);
      }

      return task;
     }();

     async function loadEmote_channel(chID)
     {
      cList = [];
      const r = await _findEmote_channel(chID);
      if (r === false)
       return false;
      cList = r;
      return true;
     }

     async function getUserInfo(u)
     {
      const url = 'https://api.twitch.tv/helix/users?login=' + u;
      const h = {
       'Authorization': 'Bearer ' + cfg.login.oauth,
       'Client-Id': cfg.login.client
      };
      const r = await shared.httpRequest(url, h);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('data'))
       return false;
      if (j.data.length !== 1)
       return false;
      return j.data[0];
     }

     return {
      channelID: 0,
      fList: follower.list,
      dead: false,       // hard disconnect (usually caused by an error)
      irc: irc,
      userInfo: getUserInfo
     };
    }();

    const parse = function()
    {
     let _kLast = 0;      // last kappagen command event (for cooldown)

     function parseUser(cmd, latinOnly = false)
     {
      let data = cmd.prefix;
      let ret = {};
      if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('display-name'))
       ret['display-name'] = cmd.tags['display-name'];
      const gReg = new RegExp(twitch.parse.uReg, 'g');
      if (data.includes('!'))
      {
       ret.nick = data.slice(0, data.indexOf('!'));
       data = data.slice(data.indexOf('!') + 1);
       if (!ret.hasOwnProperty('display-name') || (latinOnly && ret['display-name'] !== ret['display-name'].replaceAll(gReg, '')))
        ret['display-name'] = ret.nick;
      }
      if (data.includes('@'))
      {
       ret.host = data.slice(0, data.indexOf('@'));
       data = data.slice(data.indexOf('@') + 1);
       if (!ret.hasOwnProperty('display-name') || (latinOnly && ret['display-name'] !== ret['display-name'].replaceAll(gReg, '')))
        ret['display-name'] = ret.host;
      }
      ret.user = data;
      return ret;
     }

     function parseMsg(line)
     {
      let cmd = {};
      if (line.slice(0, 1) === '@')
      {
       line = line.slice(1);
       if (!line.includes(' '))
        return false;
       cmd.tags = {};
       const t = line.slice(0, line.indexOf(' '));
       line = line.slice(line.indexOf(' ') + 1);
       const a = t.split(';');
       for (let i = 0, l = a.length; i < l; i++)
       {
        const k = a[i].slice(0, a[i].indexOf('='));
        let v = a[i].slice(a[i].indexOf('=') + 1);
        v = v.replace(/\\s/g, ' ');
        cmd.tags[k] = v;
       }
      }
      if (line.slice(0, 1) === ':')
      {
       line = line.slice(1);
       if (!line.includes(' '))
        return false;
       cmd.prefix = line.slice(0, line.indexOf(' '));
       line = line.slice(line.indexOf(' ') + 1);
      }
      if (!line.includes(' '))
      {
       cmd.command = line;
       return cmd;
      }
      cmd.command = line.slice(0, line.indexOf(' '));
      line = line.slice(line.indexOf(' ') + 1);
      cmd.params = [];
      if (!line.includes(' '))
      {
       cmd.params.push(line);
       return cmd;
      }
      while (line.includes(' '))
      {
       if (line.slice(0, 1) === ':')
       {
        cmd.params.push(line.slice(1));
        return cmd;
       }
       cmd.params.push(line.slice(0, line.indexOf(' ')));
       line = line.slice(line.indexOf(' ') + 1);
      }
      if (line.slice(0, 1) === ':')
       line = line.slice(1);
      cmd.params.push(line);
      return cmd;
     }

     const content = function()
     {
      const emoji = function()
      {
       let _uList = {};     // checkURL Cache

       async function task(cmd, set, dup = null)
       {
        if (cmd.params.length < 2)
         return [];
        const msg = cmd.params[1];
        const emSeg = /((?:[\p{EPres}\p{ExtPict}]\ufe0f?\u200d?)+)+/gu;
        let emList = [];
        let match = '';
        while ((match = emSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        const kcSeg = /((?:[0-9#\*]\ufe0f\u20e3)+)+/gu; //keycap
        match = '';
        while ((match = kcSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        if (emList.length === 0)
         return [];
        if (dup === null)
         dup = cfg.display.duplicates;
        if (set === true)
         set = 'twemoji';
        let ret = [];
        const uri = 'https://cdn.frankerfacez.com/static/emoji/images/' + set + '/';
        let addList = {};
        function showEmoji(c, p)
        {
         if (c.slice(-5) === '-fe0f' && !c.match(/-200d-264[0|2]-/) && !c.match(/-200d-26a7/) && !c.match(/-200d-2620/))
          c = c.slice(0, -5);
         if (!addList.hasOwnProperty(c))
          addList[c] = 0;
         else
         {
          if (dup === false)
           return false;
          if (dup !== true && addList[c] >= dup)
           return false;
         }
         addList[c]++;
         ret.push({svc: 'e', url: uri + c + '.png', str: c, pos: p});
         return true;
        }
        for (let i = 0, l = emList.length; i < l; i++)
        {
         let cpList = [];
         for (const c of emList[i][0])
         {
          const p = c.codePointAt(0).toString(16).padStart(4, '0');
          if (cpList.length === 0)
          {
           cpList.push(p);
           continue;
          }
          const lL = cpList.length - 1;
          if (p === 'fe0f') //emoji variation
           cpList[lL] += '-' + p;
          else if (p === '200d') //zwj
           cpList[lL] += '-' + p;
          else if (p === '20e3') //keycap
           cpList[lL] += '-' + p;
          else if (p.match(/1f3f[b-f]/)) //skin tone
           cpList[lL] += '-' + p;
          else if (p.match(/1f9b[0-3]/)) //hair
          {
           if (cpList[lL].slice(-5) === '-200d')
            cpList[lL] += '-' + p;
           else
            cpList[lL] += '-200d-' + p;
          }
          else if (p.match(/264[0|2]/) || p.match(/26a7/)) //gender
          {
           if (cpList[lL].slice(-5) === '-200d')
            cpList[lL] += '-' + p;
           else
            cpList[lL] += '-200d-' + p;
          }
          else if (p.match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].length < 11) //country code (2 chars max)
           cpList[lL] += '-' + p;
          else if (p === '1f308' && cpList[lL] === '1f3f3-fe0f') //rainbow flag
           cpList[lL] += '-200d-' + p;
          else if (p === '2620' && cpList[lL] === '1f3f4') //pirate flag
           cpList[lL] += '-200d-' + p;
          else if (cpList[lL].slice(-5) === '-200d') //post-zwj
           cpList[lL] += '-' + p;
          else
           cpList.push(p);
         }
         let found = false;
         const lP = cpList.length;
         if (lP === 1)
         {
          let s = cpList[0];
          let tU;
          if (s.slice(-5) === '-fe0f')
          {
           if (s.match(/-200d-264[0|2]-/) || s.match(/-200d-26a7/) || s.match(/-200d-2620/))
            tU = uri + s + '.png';
           else
            tU = uri + s.slice(0, -5) + '.png';
          }
          else
           tU = uri + s + '.png';
          found = await _checkURL(tU);
          if (found)
          {
           showEmoji(s, emList[i].index);
           continue;
          }
          while (s.includes('-'))
          {
           s = s.slice(0, s.lastIndexOf('-'));
           if (s.slice(-5) === '-fe0f')
            tU = uri + s.slice(0, -5) + '.png';
           else
            tU = uri + s + '.png';
           found = await _checkURL(tU);
           if (found)
           {
            showEmoji(s, emList[i].index);
            break;
           }
          }
          continue;
         }
         let p = emList[i].index;
         for (let j = 0; j < lP; j++)
         {
          p += cpList[j].replaceAll(/[^\-]/g, '').length + 1;
          found = await _checkURL(uri + cpList[j] + '.png');
          if (found)
           showEmoji(cpList[j], p);
         }
        }
        return ret;
       }

       function _checkURL(url)
       {
        const p = new Promise(
         function(resolve)
         {
          if (_uList.hasOwnProperty(url))
          {
           resolve(_uList[url]);
           return;
          }
          const x = new XMLHttpRequest();
          x.open('HEAD', url);
          x.onreadystatechange = function()
          {
           if (x.readyState < 2)
            return;
           x.onreadystatechange = null;
           const r = x.status === 200;
           _uList[url] = r;
           resolve(r);
          };
          x.send();
         }
        );
        return p;
       }

       return task;
      }();

      function parseT(cmd, dup = null)
      {
       if (!cmd.hasOwnProperty('tags'))
        return [];
       if (!cmd.tags.hasOwnProperty('emotes'))
        return [];
       if (cmd.tags.emotes === '')
        return [];
       if (cmd.params.length < 2)
        return [];
       const f = 'default';
       const t = 'dark';
       const x = '3.0';
       const m = cmd.params[1];
       const e = cmd.tags.emotes.split('/');
       if (dup === null)
        dup = cfg.display.duplicates;
       let ret = [];
       for (let i = 0, n = e.length; i < n; i++)
       {
        const eID = e[i].slice(0, e[i].indexOf(':'));
        const u = 'https://static-cdn.jtvnw.net/emoticons/v2/' + eID + '/' + f + '/' + t + '/' + x;
        const eVals = e[i].slice(e[i].indexOf(':') + 1).split(',');
        const eStart = parseInt(eVals[0].split('-')[0], 10);
        const eEnd = parseInt(eVals[0].split('-')[1], 10);
        const sName = m.slice(eStart, eEnd + 1);
        let l = eVals.length;
        if (dup === false)
         l = 1;
        else if (dup !== true && l > dup)
         l = dup;
        for (let c = 0; c < l; c++)
        {
         const p = parseInt(eVals[c].split('-')[0], 10);
         ret.push({svc: 't', url: u, str: sName, pos: p});
        }
       }
       return ret;
      }

      const _3rdparty = function()
      {
       function parseFFZ(cmd, dup = null)
       {
        if (!thirdparty.emotes.hasOwnProperty('ffz'))
         return [];
        if (cmd.params.length < 2)
         return [];
        const m = cmd.params[1].split(' ');
        if (dup === null)
         dup = cfg.display.duplicates;
        let ret = [];
        let addList = {};
        for (let i = 0, l = m.length; i < l; i++)
        {
         if (!thirdparty.emotes.ffz.hasOwnProperty(m[i]))
          continue;
         if (thirdparty.emotes.ffz[m[i]].users !== null)
         {
          const u = parseUser(cmd);
          if (!thirdparty.emotes.ffz[m[i]].users.includes(u.host))
           continue;
         }
         if (!addList.hasOwnProperty(m[i]))
          addList[m[i]] = 0;
         else
         {
          if (dup === false)
           continue;
          if (dup !== true && addList[m[i]] >= dup)
           continue;
         }
         addList[m[i]]++;
         let p = 0;
         for (let j = 0; j < i; j++)
         {
          p+= m[j].length + 1;
         }
         ret.push({svc: 'f', url: thirdparty.emotes.ffz[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.ffz[m[i]].scope});
        }
        return ret;
       }

       const bttv = function()
       {
        function parseBTTV(cmd, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('bttv'))
          return [];
         if (cmd.params.length < 2)
          return [];
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes.bttv.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          ret.push({svc: 'b', url: thirdparty.emotes.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.bttv[m[i]].scope});
         }
         return ret;
        }

        function parseBTTVZWE(l, cmd, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!thirdparty.emotes.hasOwnProperty('zwe'))
          return;
         if (!thirdparty.emotes.zwe.hasOwnProperty('bttv'))
          return;
         if (cmd.params.length < 2)
          return;
         l.sort(_posSort);
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!thirdparty.emotes.zwe.bttv.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope});
          }
          else
          {
           let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(thirdparty.emotes.zwe.bttv);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('7tv'))
           {
            z = Object.keys(thirdparty.emotes.zwe['7tv']);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== 'b')
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        function parseBTTVU(cmd, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('bttvU'))
          return [];
         if (cmd.params.length < 2)
          return [];
         const u = parseUser(cmd);
         if (!thirdparty.emotes.bttvU.hasOwnProperty(u.host))
          return [];
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes.bttvU[u.host].hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          ret.push({svc: 'b', url: thirdparty.emotes.bttvU[u.host][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.bttvU[u.host][m[i]].scope});
         }
         return ret;
        }

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: parseBTTV,
         zwe: parseBTTVZWE,
         user: parseBTTVU
        };
       }();

       const _7tv = function()
       {
        function parse7TV(cmd, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('7tv'))
          return [];
         if (cmd.params.length < 2)
          return [];
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes['7tv'].hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          ret.push({svc: '7', url: thirdparty.emotes['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes['7tv'][m[i]].scope});
         }
         return ret;
        }

        function parse7TVZWE(l, cmd, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!thirdparty.emotes.hasOwnProperty('zwe'))
          return;
         if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
          return;
         if (cmd.params.length < 2)
          return;
         l.sort(_posSort);
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!thirdparty.emotes.zwe['7tv'].hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope});
          }
          else
          {
           let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(thirdparty.emotes.zwe['7tv']);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttv'))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttv);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== '7')
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: parse7TV,
         zwe: parse7TVZWE
        };
       }();

       return {
        ffz: parseFFZ,
        bttv: bttv,
        '7tv': _7tv
       };
      }();

      return {
       emoji: emoji,
       twitch: parseT,
       '3rdparty': _3rdparty
      };
     }();

     async function parseLine(cmd)
     {
      let lv = -1;
      const kNow = new Date().getTime();
      if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('custom-reward-id'))
      {
       const lnID = cmd.tags['custom-reward-id'];
       if (!_rList.hasOwnProperty(lnID))
       {
        _rList[lnID] = {name: false, cmds: [cmd]};
        return;
       }
       _rList[lnID].cmds.push(cmd);
       if (_rList[lnID].name === false)
        return;
       while (_rList[lnID].cmds.length > 0)
       {
        await event.redeem(_rList[lnID].name, _rList[lnID].cmds.shift());
       }
       return;
      }
      if (cmd.params.length > 1 && (cfg.display.kappa.cooldown === 0 || kNow - _kLast > cfg.display.kappa.cooldown * 1000))
      {
       const m = cmd.params[1].toLowerCase();
       for (const k in cfg.display.kappa.styles)
       {
        if (!cfg.display.kappa.styles.hasOwnProperty(k))
         continue;
        if (!cfg.display.kappa.styles[k].hasOwnProperty('command'))
         continue;
        if (!cfg.display.kappa.styles[k].command.hasOwnProperty('aliases'))
         continue;
        let kAccess = cfg.display.kappa.access;
        if (cfg.display.kappa.styles[k].command.hasOwnProperty('access'))
         kAccess = cfg.display.kappa.styles[k].command.access;
        let kC = {};
        kC[k] = cfg.display.kappa.styles[k];
        if (cfg.display.kappa.styles[k].command.aliases.includes(m))
        {
         if (lv === -1)
          lv = await _level.get(cmd);
         if ((lv & kAccess) !== 0)
         {
          _kLast = kNow;
          display.kappa.show(false, kC);
          return;
         }
        }
        let foundKCmd = false;
        for (let i = 0, l = cfg.display.kappa.styles[k].command.aliases.length; i < l; i++)
        {
         if (m.slice(0, cfg.display.kappa.styles[k].command.aliases[i].length + 1) === cfg.display.kappa.styles[k].command.aliases[i] + ' ')
         {
          foundKCmd = true;
          break;
         }
        }
        if (foundKCmd)
        {
         if (lv === -1)
          lv = await _level.get(cmd);
         if ((lv & kAccess) !== 0)
         {
          let a = [];
          a = a.concat(twitch.parse.content.twitch(cmd, true));
          if (cfg.display.useEmoji)
           a = a.concat(await twitch.parse.content.emoji(cmd, cfg.display.useEmoji, true));
          if (cfg.display.extended.useFFZ)
           a = a.concat(twitch.parse.content['3rdparty'].ffz(cmd, true));
          if (cfg.display.extended.useBTTV)
          {
           a = a.concat(twitch.parse.content['3rdparty'].bttv.general(cmd, true));
           a = a.concat(twitch.parse.content['3rdparty'].bttv.user(cmd, true));
          }
          if (cfg.display.extended.use7TV)
           a = a.concat(twitch.parse.content['3rdparty']['7tv'].general(cmd, true));
          if (cfg.display.extended.useBTTV)
           twitch.parse.content['3rdparty'].bttv.zwe(a, cmd, 1, true);
          if (cfg.display.extended.use7TV)
           twitch.parse.content['3rdparty']['7tv'].zwe(a, cmd, 1, true);
          if (cfg.display.extended.useBTTV)
           twitch.parse.content['3rdparty'].bttv.zwe(a, cmd, 2, true);
          if (cfg.display.extended.use7TV)
           twitch.parse.content['3rdparty']['7tv'].zwe(a, cmd, 2, true);
          a = _handleDuplicates(a);
          _kLast = kNow;
          display.kappa.show(a, kC);
          return;
         }
        }
       }
       if (cfg.display.kappa.aliases.includes(m))
       {
        if (lv === -1)
         lv = await _level.get(cmd);
        if ((lv & cfg.display.kappa.access) !== 0)
        {
         _kLast = kNow;
         display.kappa.show(false);
         return;
        }
       }
       let foundCmd = false;
       for (let i = 0, l = cfg.display.kappa.aliases.length; i < l; i++)
       {
        if (m.slice(0, cfg.display.kappa.aliases[i].length + 1) === cfg.display.kappa.aliases[i] + ' ')
        {
         foundCmd = true;
         break;
        }
       }
       if (foundCmd)
       {
        if (lv === -1)
         lv = await _level.get(cmd);
        if ((lv & cfg.display.kappa.access) !== 0)
        {
         let a = [];
         a = a.concat(twitch.parse.content.twitch(cmd, true));
         if (cfg.display.useEmoji)
          a = a.concat(await twitch.parse.content.emoji(cmd, cfg.display.useEmoji, true));
         if (cfg.display.extended.useFFZ)
          a = a.concat(twitch.parse.content['3rdparty'].ffz(cmd, true));
         if (cfg.display.extended.useBTTV)
         {
          a = a.concat(twitch.parse.content['3rdparty'].bttv.general(cmd, true));
          a = a.concat(twitch.parse.content['3rdparty'].bttv.user(cmd, true));
         }
         if (cfg.display.extended.use7TV)
          a = a.concat(twitch.parse.content['3rdparty']['7tv'].general(cmd, true));
         if (cfg.display.extended.useBTTV)
          twitch.parse.content['3rdparty'].bttv.zwe(a, cmd, 1, true);
         if (cfg.display.extended.use7TV)
          twitch.parse.content['3rdparty']['7tv'].zwe(a, cmd, 1, true);
         if (cfg.display.extended.useBTTV)
          twitch.parse.content['3rdparty'].bttv.zwe(a, cmd, 2, true);
         if (cfg.display.extended.use7TV)
          twitch.parse.content['3rdparty']['7tv'].zwe(a, cmd, 2, true);
         a = _handleDuplicates(a);
         _kLast = kNow;
         display.kappa.show(a);
         return;
        }
       }
      }
      let p = [];
      p = p.concat(twitch.parse.content.twitch(cmd));
      if (cfg.display.useEmoji)
       p = p.concat(await twitch.parse.content.emoji(cmd, cfg.display.useEmoji));
      if (cfg.display.extended.useFFZ)
       p = p.concat(twitch.parse.content['3rdparty'].ffz(cmd));
      if (cfg.display.extended.useBTTV)
      {
       p = p.concat(twitch.parse.content['3rdparty'].bttv.general(cmd));
       p = p.concat(twitch.parse.content['3rdparty'].bttv.user(cmd));
      }
      if (cfg.display.extended.use7TV)
       p = p.concat(twitch.parse.content['3rdparty']['7tv'].general(cmd));
      if (cfg.display.extended.useBTTV)
       twitch.parse.content['3rdparty'].bttv.zwe(p, cmd, 1);
      if (cfg.display.extended.use7TV)
       twitch.parse.content['3rdparty']['7tv'].zwe(p, cmd, 1);
      if (cfg.display.extended.useBTTV)
       twitch.parse.content['3rdparty'].bttv.zwe(p, cmd, 2);
      if (cfg.display.extended.use7TV)
       twitch.parse.content['3rdparty']['7tv'].zwe(p, cmd, 2);
      p = _handleDuplicates(p);
      if (p.length === 0)
       return;
      if (lv === -1)
       lv = await _level.get(cmd);
      if ((lv & cfg.display.access) === 0)
       return;
      display.emote.addToShowList(p);
      display.emote.showEmotes();
     }

     const event = function()
     {
      let bList = [];     // list of giftbomb event origin ids (to prevent kappas for each gift in a bomb)

      async function parseCheer(cmd)
      {
       if (!thirdparty.emotes.hasOwnProperty('cheer'))
        return false;
       if (!cmd.hasOwnProperty('tags'))
        return false;
       if (!cmd.tags.hasOwnProperty('bits'))
        return false;
       if (cmd.tags.bits < 1)
        return false;
       let p = [];
       const msg = cmd.params[1].split(' ');
       for (let m = 0, l = msg.length; m < l; m++)
       {
        for (const prefix in thirdparty.emotes.cheer)
        {
         if (!thirdparty.emotes.cheer.hasOwnProperty(prefix))
          continue;
         const firstChars = prefix.length;
         if (msg[m].slice(0, firstChars).toLowerCase() !== prefix.toLowerCase())
          continue;
         const amt = msg[m].slice(firstChars);
         if (isNaN(amt))
          continue;
         for (let i = 0, n = thirdparty.emotes.cheer[prefix].length; i < n; i++)
         {
          if (parseInt(amt, 10) < thirdparty.emotes.cheer[prefix][i].min)
           continue;
          const sName = prefix + thirdparty.emotes.cheer[prefix][i].min;
          p.push({svc: 'c', url: thirdparty.emotes.cheer[prefix][i].img, str: sName});
          break;
         }
        }
       }
       if (cfg.event.cheer.useMsg)
       {
        p = p.concat(twitch.parse.content.twitch(cmd));
        if (cfg.display.useEmoji)
         p = p.concat(await twitch.parse.content.emoji(cmd, cfg.display.useEmoji));
        if (cfg.display.extended.useFFZ)
         p = p.concat(twitch.parse.content['3rdparty'].ffz(cmd));
        if (cfg.display.extended.useBTTV)
        {
         p = p.concat(twitch.parse.content['3rdparty'].bttv.general(cmd));
         p = p.concat(twitch.parse.content['3rdparty'].bttv.user(cmd));
        }
        if (cfg.display.extended.use7TV)
         p = p.concat(twitch.parse.content['3rdparty']['7tv'].general(cmd));
        if (cfg.display.extended.useBTTV)
         twitch.parse.content['3rdparty'].bttv.zwe(p, cmd, 1);
        if (cfg.display.extended.use7TV)
         twitch.parse.content['3rdparty']['7tv'].zwe(p, cmd, 1);
        if (cfg.display.extended.useBTTV)
         twitch.parse.content['3rdparty'].bttv.zwe(p, cmd, 2);
        if (cfg.display.extended.use7TV)
         twitch.parse.content['3rdparty']['7tv'].zwe(p, cmd, 2);
       }
       else
        await parseLine(cmd);
       p = _handleDuplicates(p);
       if (p.length === 0)
        return false;
       const r = shared.findInMaybeRange(cfg.event.cheer.bits, cmd.tags.bits);
       if (r === false)
       {
        display.emote.addToShowList(p);
        display.emote.showEmotes();
        return true;
       }
       const u = parseUser(cmd, true);
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       display.kappa.show(p, r, {'%USER%': dn, '%AMOUNT%': cmd.tags.bits});
       return true;
      }

      async function parseRaid(cmd)
      {
       if (!cmd.tags.hasOwnProperty('msg-param-viewerCount'))
        return;
       const c = cmd.tags['msg-param-viewerCount'];
       const r = shared.findInMaybeRange(cfg.event.raid.raiders, c);
       if (r === false)
        return;
       const u = parseUser(cmd, true);
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       if (!cfg.event.raid.originEmotes)
       {
        display.kappa.show(false, r, {'%USER%': dn, '%AMOUNT%': c});
        return;
       }
       const d = cmd.tags['user-id'];
       const e = await _findEmote_channel(d);
       display.kappa.show(e, r, {'%USER%': dn, '%AMOUNT%': c});
      }

      function _parseSubPlan(c)
      {
       if (!c.tags.hasOwnProperty('msg-param-sub-plan'))
        return false;
       const p = c.tags['msg-param-sub-plan'];
       switch (p)
       {
        case '1000': return 't1';
        case '2000': return 't2';
        case '3000': return 't3';
        case 'Prime': return 'prime';
       }
       return false;
      }

      async function parseSub(cmd)
      {
       if (!cmd.tags.hasOwnProperty('msg-id'))
        return;
       const subPlan = _parseSubPlan(cmd);
       if (subPlan === false)
        return;
       let mpoi = false;
       if (cmd.tags.hasOwnProperty('msg-param-origin-id'))
        mpoi = cmd.tags['msg-param-origin-id'];
       if (mpoi !== false && bList.includes(mpoi))
        return;
       let a = [];
       if (cmd.params.length > 1)
       {
        if (cfg.event.sub.useMsg)
        {
         a = a.concat(twitch.parse.content.twitch(cmd, true));
         if (cfg.display.useEmoji)
          a = a.concat(await twitch.parse.content.emoji(cmd, cfg.display.useEmoji, true));
         if (cfg.display.extended.useFFZ)
          a = a.concat(twitch.parse.content['3rdparty'].ffz(cmd, true));
         if (cfg.display.extended.useBTTV)
         {
          a = a.concat(twitch.parse.content['3rdparty'].bttv.general(cmd, true));
          a = a.concat(twitch.parse.content['3rdparty'].bttv.user(cmd, true));
         }
         if (cfg.display.extended.use7TV)
          a = a.concat(twitch.parse.content['3rdparty']['7tv'].general(cmd, true));
         if (cfg.display.extended.useBTTV)
          twitch.parse.content['3rdparty'].bttv.zwe(a, cmd, 1, true);
         if (cfg.display.extended.use7TV)
          twitch.parse.content['3rdparty']['7tv'].zwe(a, cmd, 1, true);
         if (cfg.display.extended.useBTTV)
          twitch.parse.content['3rdparty'].bttv.zwe(a, cmd, 2, true);
         if (cfg.display.extended.use7TV)
          twitch.parse.content['3rdparty']['7tv'].zwe(a, cmd, 2, true);
        }
        else
         await parseLine(cmd);
       }
       let mpm = 1;
       if (cmd.tags.hasOwnProperty('msg-param-months'))
        mpm = parseInt(cmd.tags['msg-param-months'], 10);
       let mpcm = 1;
       if (cmd.tags.hasOwnProperty('msg-param-cumulative-months'))
        mpcm = parseInt(cmd.tags['msg-param-cumulative-months'], 10);
       let mpmgc = 1;
       if (cmd.tags.hasOwnProperty('msg-param-mass-gift-count'))
        mpmgc = parseInt(cmd.tags['msg-param-mass-gift-count'], 10);
       const u = parseUser(cmd, true);
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       let mprdn = 'Anonymous';
       if (cmd.tags.hasOwnProperty('msg-param-recipient-display-name'))
        mprdn = cmd.tags['msg-param-recipient-display-name'];
       switch (cmd.tags['msg-id'])
       {
        case 'sub':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('first'))
          return;
         if (cfg.event.sub[subPlan].first === false)
          return;
         display.kappa.show(a, cfg.event.sub[subPlan].first, {'%USER%': dn});
         break;
        case 'resub':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('resub'))
          return;
         const rs = shared.findInMaybeRange(cfg.event.sub[subPlan].resub, mpcm);
         if (rs === false)
          return;
         display.kappa.show(a, rs, {'%USER%': dn, '%AMOUNT%': mpcm});
         break;
        case 'primepaidupgrade':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('upgrade'))
          return;
         if (!cfg.event.sub[subPlan].upgrade.hasOwnProperty('prime'))
          return;
         display.kappa.show(a, cfg.event.sub[subPlan].upgrade.prime, {'%USER%': dn});
         break;
        case 'giftpaidupgrade':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('upgrade'))
          return;
         if (!cfg.event.sub[subPlan].upgrade.hasOwnProperty('gift'))
          return;
         display.kappa.show(a, cfg.event.sub[subPlan].upgrade.gift, {'%USER%': dn});
         break;
        case 'subgift':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('gift'))
          return;
         if (mpm === 1)
         {
          if (!cfg.event.sub[subPlan].gift.hasOwnProperty('first'))
           return;
          if (cfg.event.sub[subPlan].gift.first === false)
           return;
          display.kappa.show(a, cfg.event.sub[subPlan].gift.first, {'%SENDER%': dn, '%USER%': mprdn});
          return;
         }
         if (!cfg.event.sub[subPlan].gift.hasOwnProperty('resub'))
          return;
         const gpr = shared.findInMaybeRange(cfg.event.sub[subPlan].gift.resub, mpm);
         if (gpr === false)
          return;
         display.kappa.show(a, gpr, {'%SENDER%': dn, '%USER%': mprdn, '%AMOUNT%': mpm});
         break;
        case 'submysterygift':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('gift'))
          return;
         if (!cfg.event.sub[subPlan].gift.hasOwnProperty('bomb'))
          return;
         if (cfg.event.sub[subPlan].gift.bomb === false)
          return;
         if (mpoi !== false)
          bList.push(mpoi);
         const gpb = shared.findInMaybeRange(cfg.event.sub[subPlan].gift.bomb, mpmgc);
         if (gpb === false)
          return;
         display.kappa.show(a, gpb, {'%SENDER%': dn, '%AMOUNT%': mpmgc});
         break;
       }
      }

      function parseBadge(cmd)
      {
       if (!cmd.tags.hasOwnProperty('msg-param-threshold'))
        return;
       const c = cmd.tags['msg-param-threshold'];
       const u = parseUser(cmd, true);
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       if (cfg.event.badge.hasOwnProperty(c) && cfg.event.badge[c] !== false)
       {
        display.kappa.show(false, cfg.event.badge[c], {'%USER%': dn, '%AMOUNT%': c});
        return;
       }
       let closest = null;
       for (const b in cfg.event.badge)
       {
        if (!cfg.event.badge.hasOwnProperty(b))
         continue;
        if (closest === null)
        {
         closest = b;
         continue;
        }
        if (Math.abs(parseInt(closest, 10) - parseInt(c, 10)) > Math.abs(parseInt(b, 10) - parseInt(c, 10)))
         closest = b;
       }
       if (closest === null)
        return;
       if (cfg.event.badge[closest] === false)
        return;
       display.kappa.show(false, cfg.event.badge[closest], {'%USER%': dn, '%AMOUNT%': c});
      }

      async function parseRedeem(title, cmd)
      {
       const kNow = new Date().getTime();
       for (const k in cfg.display.kappa.styles)
       {
        if (!cfg.display.kappa.styles.hasOwnProperty(k))
         continue;
        if (!cfg.display.kappa.styles[k].hasOwnProperty('redeem'))
         continue;
        if (!cfg.display.kappa.styles[k].redeem.includes(title))
         continue;
        let kC = {};
        kC[k] = cfg.display.kappa.styles[k];
        if (cmd === false)
        {
         _kLast = kNow;
         display.kappa.show(false, kC);
         return;
        }
        let a = [];
        a = a.concat(twitch.parse.content.twitch(cmd, true));
        if (cfg.display.useEmoji)
         a = a.concat(await twitch.parse.content.emoji(cmd, cfg.display.useEmoji, true));
        if (cfg.display.extended.useFFZ)
         a = a.concat(twitch.parse.content['3rdparty'].ffz(cmd, true));
        if (cfg.display.extended.useBTTV)
        {
         a = a.concat(twitch.parse.content['3rdparty'].bttv.general(cmd, true));
         a = a.concat(twitch.parse.content['3rdparty'].bttv.user(cmd, true));
        }
        if (cfg.display.extended.use7TV)
         a = a.concat(twitch.parse.content['3rdparty']['7tv'].general(cmd, true));
        if (cfg.display.extended.useBTTV)
         twitch.parse.content['3rdparty'].bttv.zwe(a, cmd, 1, true);
        if (cfg.display.extended.use7TV)
         twitch.parse.content['3rdparty']['7tv'].zwe(a, cmd, 1, true);
        if (cfg.display.extended.useBTTV)
         twitch.parse.content['3rdparty'].bttv.zwe(a, cmd, 2, true);
        if (cfg.display.extended.use7TV)
         twitch.parse.content['3rdparty']['7tv'].zwe(a, cmd, 2, true);
        a = _handleDuplicates(a);
        _kLast = kNow;
        display.kappa.show(a, kC);
        return;
       }
      }

      return {
       cheer: parseCheer,
       raid: parseRaid,
       sub: parseSub,
       badge: parseBadge,
       redeem: parseRedeem
      };
     }();

     const _level = function()
     {
      const _rFH = 3600000;  // follower state cache time (ms)

      function _jSplit(s, sep, limit)
      {
       let arr = [];
       let v = '';
       for (let i = 0, l = s.length; i < l; i++)
       {
        if (arr.length < limit - 1)
        {
         if (s[i] === sep)
         {
          arr.push(v);
          v = '';
          continue;
         }
        }
        v += s[i];
       }
       if (v.length > 0)
        arr.push(v);
       return arr;
      }

      async function _checkFollower(cmd)
      {
       const uID = cmd.tags['user-id'];
       if (twitch.net.fList.hasOwnProperty(uID))
       {
        const tDif = new Date().getTime() - twitch.net.fList[uID].t;
        if (tDif < _rFH)
         return twitch.net.fList[uID].value;
       }
       const url = 'https://api.twitch.tv/helix/users/follows?from_id=' + uID + '&to_id=' + cmd.tags['room-id'];
       const h = {
        'Authorization': 'Bearer ' + cfg.login.oauth,
        'Client-Id': cfg.login.client
       };
       const r = await shared.httpRequest(url, h);
       if (r === false)
        return false;
       const j = JSON.parse(r);
       if (j.hasOwnProperty('total') && j.total > 0)
       {
        twitch.net.fList[uID] = {value: true, t: new Date().getTime()};
        return true;
       }
       twitch.net.fList[uID] = {value: false, t: new Date().getTime()};
       return false;
      }

      async function parseLevel(cmd)
      {
       let r = 0x001;
       if (cmd.tags.hasOwnProperty('mod') && cmd.tags.mod === '1')
        r |= 0x400;
       if (cmd.tags.hasOwnProperty('vip') && cmd.tags.vip === '1')
        r |= 0x100;
       if (cmd.tags.hasOwnProperty('badges'))
       {
        const badges = cmd.tags.badges.split(',');
        for (let i = 0, l = badges.length; i < l; i++)
        {
         const bData = _jSplit(badges[i], '/', 2);
         switch (bData[0])
         {
          case 'broadcaster':
           r |= 0x800;
           break;
          case 'moderator':
           r |= 0x400;
           break;
          case 'vip':
           r |= 0x100;
           break;
          case 'artist-badge':
           r |= 0x080;
           break;
          case 'founder':
           r |= 0x200;
           break;
          case 'bits':
           r |= 0x004;
           break;
          case 'subscriber':
           const badge = parseInt(bData[1], 10);
           if (badge < 2000)
            r |= 0x010;
           else if (badge < 3000)
            r |= 0x020;
           else
            r |= 0x040;
           break;
         }
        }
       }
       /* api-heavy, only check if follower access is allowed and there's a chance it matters */
       let needF = false;
       if ((cfg.display.access & 0x002) === 0x002 && (cfg.display.access & 0x001) !== 0x001)
        needF = true;
       else if ((cfg.display.kappa.access & 0x002) === 0x002 && (cfg.display.kappa.access & 0x001) !== 0x001)
        needF = true;
       else
       {
        for (const k in cfg.display.kappa.styles)
        {
         if (!cfg.display.kappa.styles.hasOwnProperty(k))
          continue;
         if (!cfg.display.kappa.styles[k].hasOwnProperty('command'))
          continue;
         if (!cfg.display.kappa.styles[k].command.hasOwnProperty('access'))
          continue;
         if ((cfg.display.kappa.styles[k].command.access & 0x002) === 0x002 && (cfg.display.kappa.styles[k].command.access & 0x001) !== 0x001)
         {
          needF = true;
          break;
         }
        }
       }
       if (needF)
       {
        const f = await _checkFollower(cmd);
        if (f)
         r |= 0x002;
       }
       return r;
      }

      return {
       get: parseLevel
      };
     }();

     function _handleDuplicates(a)
     {
      const lA = a.length;
      if (lA < 1)
       return a;
      let r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'u')
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 't' || a[i].svc === 'c' || a[i].svc === 'e')
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'c' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        let f = false;
        for (let j = 0, l = r.length; j < l; j++)
        {
         if (r[j].str === a[i].str)
         {
          f = true;
          if (r[j].svc === a[i].svc)
           r.push(a[i]);
          break;
         }
        }
        if (!f)
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope !== 'c' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        let f = false;
        for (let j = 0, l = r.length; j < l; j++)
        {
         if (r[j].str === a[i].str)
         {
          f = true;
          if (r[j].svc === a[i].svc)
           r.push(a[i]);
          break;
         }
        }
        if (!f)
         r.push(a[i]);
       }
      }
      return r;
     }

     return {
      user: parseUser,
      message: parseMsg,
      content: content,
      line: parseLine,
      event: event,
      uReg: /[^A-Za-z0-9_]/
     };
    }();

    async function _findEmote_channel(chID)
    {
     const url = 'https://api.twitch.tv/helix/chat/emotes?broadcaster_id=' + chID;
     const h = {
      'Authorization': 'Bearer ' + cfg.login.oauth,
      'Client-Id': cfg.login.client
     };
     const r = await shared.httpRequest(url, h, true);
     if (r === false)
      return false;
     const j = JSON.parse(r);
     if (!j.hasOwnProperty('data'))
      return false;
     if (!Array.isArray(j.data))
      return false;
     let ret = [];
     const f = 'default';
     const t = 'dark';
     const x = '3.0';
     for (let i = 0, l = j.data.length; i < l; i++)
     {
      if (!j.data[i].hasOwnProperty('id'))
       continue;
      ret.push({url: 'https://static-cdn.jtvnw.net/emoticons/v2/' + j.data[i].id + '/' + f + '/' + t + '/' + x});
     }
     return ret;
    }

    return {
     net: net,
     parse: parse
    };
   }();

   const streamlabs = function()
   {
    async function _showStreamlabsDonations(dRet)
    {
     for (let i = 0, l = dRet.length; i < l; i++)
     {
      const n = dRet[i].name;
      const a = dRet[i].amt;
      const v = Math.floor(a * cfg.streamlabs.curMul);
      const r = shared.findInMaybeRange(cfg.event.tip.streamlabs.donation, v);
      if (r === false)
       continue;
      let p = false;
      if (cfg.event.tip.useProfileImage && n !== false)
      {
       let u = false;
       if (!twitch.parse.uReg.test(n))
        u = await twitch.net.userInfo(n);
       if (u !== false)
       {
        if (u.hasOwnProperty('profile_image_url'))
         p = [
          {url: u.profile_image_url}
         ];
       }
      }
      let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
      if (cfg.streamlabs.dispDec > 0)
       s = s.toFixed(cfg.streamlabs.dispDec);
      else
       s = Math.floor(s);
      if (cfg.streamlabs.dispPre !== false)
       s = cfg.streamlabs.dispPre + s;
      if (cfg.streamlabs.dispSuf !== false)
       s += cfg.streamlabs.dispSuf;
      display.kappa.show(p, r, {'%USER%': n, '%AMOUNT%': s});
     }
    }

    async function _showStreamlabsPledges(pRet)
    {
     for (let i = 0, l = pRet.length; i < l; i++)
     {
      const n = pRet[i].name;
      const a = pRet[i].amt;
      const v = Math.floor(a * cfg.streamlabs.curMul);
      const r = shared.findInMaybeRange(cfg.event.tip.streamlabs.pledge, v);
      if (r === false)
       continue;
      let p = false;
      if (cfg.event.tip.useProfileImage && n !== false)
      {
       let u = false;
       if (!twitch.parse.uReg.test(n))
        u = await twitch.net.userInfo(n);
       if (u !== false)
       {
        if (u.hasOwnProperty('profile_image_url'))
         p = [
          {url: u.profile_image_url}
         ];
       }
      }
      let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
      if (cfg.streamlabs.dispDec > 0)
       s = s.toFixed(cfg.streamlabs.dispDec);
      else
       s = Math.floor(s);
      if (cfg.streamlabs.dispPre !== false)
       s = cfg.streamlabs.dispPre + s;
      if (cfg.streamlabs.dispSuf !== false)
       s += cfg.streamlabs.dispSuf;
      display.kappa.show(p, r, {'%USER%': n, '%AMOUNT%': s});
     }
    }

    const streamlabsWS = function()
    {
     let _wsRetry = 0;
     let _tPing = false;
     let _ws = null;

     function task()
     {
      _wsRetry = 0;
      _tPing = 0;
      _ws = new WebSocket('wss://sockets.streamlabs.com/socket.io/?token=' + cfg.streamlabs.token + '&transport=websocket');
      _ws.onclose = _wsClose;
      _ws.onmessage = _wsMessage;
     }

     function _wsClose()
     {
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      _ws.onmessage = null;
      _ws.onclose = null;
      if (twitch.net.dead)
       return;
      const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
      if (_wsRetry < 2)
       _wsRetry += 0.2;
      window.setTimeout(task, wsWait);
     }

     async function _wsMessage(ev)
     {
      if (twitch.net.dead)
      {
       _ws.close();
       return;
      }
      _wsRetry = 0;
      const d = ev.data;
      if (d.length < 1)
       return;
      switch (d.slice(0, 1))
      {
       case '0':
        let t = 20000;
        if (d.length > 1)
        {
         const c = JSON.parse(d.slice(1));
         if (c.hasOwnProperty('pingInterval'))
          t = c.pingInterval;
        }
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, t);
        break;
       case '4':
        if (document.visibilityState === 'hidden')
         return;
        if (d.slice(1, 2) !== '2')
         return;
        if (d.length < 2)
         return;
        const o = JSON.parse(d.slice(2));
        if (o.length < 2)
         return;
        if (o[0] !== 'event')
         return;
        if (!o[1].hasOwnProperty('message'))
         return;
        let rD = [];
        let rP = [];
        for (let i = 0, l = o[1].message.length; i < l; i++)
        {
         if (!o[1].message[i].hasOwnProperty('amount'))
          continue;
         if (!o[1].message[i].hasOwnProperty('type'))
          continue;
         if (o[1].message[i].type === 'donation')
         {
          let n = false;
          if (o[1].message[i].hasOwnProperty('name'))
           n = o[1].message[i].name;
          rD.push({amt: o[1].message[i].amount, name: n});
         }
         if (o[1].message[i].type === 'pledge')
         {
          let n = false;
          if (o[1].message[i].hasOwnProperty('name'))
           n = o[1].message[i].name;
          rP.push({amt: o[1].message[i].amount, name: n});
         }
        }
        if (rD.length > 0)
         await _showStreamlabsDonations(rD);
        if (rP.length > 0)
         await _showStreamlabsPledges(rP);
        break;
      }
     }

     function _wsPing()
     {
      _ws.send('2');
     }

     return task;
    }();

    return {
     socket: streamlabsWS
    };
   }();

   const streamelements = function()
   {
    async function _showStreamElementsTip(dAmt, dName)
    {
     const v = Math.floor(dAmt * cfg.streamelements.curMul);
     if (v < 1)
      return;
     const r = shared.findInMaybeRange(cfg.event.tip.streamelements, v);
     if (r === false)
      return;
     let p = false;
     if (cfg.event.tip.useProfileImage && dName !== false)
     {
      let u = false;
      if (!twitch.parse.uReg.test(dName))
       u = await twitch.net.userInfo(dName);
      if (u !== false)
      {
       if (u.hasOwnProperty('profile_image_url'))
        p = [
         {url: u.profile_image_url}
        ];
      }
     }
     let s = Number.parseFloat(dAmt * cfg.streamelements.dispMul);
     if (cfg.streamelements.dispDec > 0)
      s = s.toFixed(cfg.streamelements.dispDec);
     else
      s = Math.floor(s);
     if (cfg.streamelements.dispPre !== false)
      s = cfg.streamelements.dispPre + s;
     if (cfg.streamelements.dispSuf !== false)
      s += cfg.streamelements.dispSuf;
     display.kappa.show(p, r, {'%USER%': dName, '%AMOUNT%': s});
    }

    const streamelementsWS = function()
    {
     let _wsRetry = 0;
     let _tPing = 0;
     let _ws = null;

     function task()
     {
      _wsRetry = 0;
      _tPing = 0;
      _ws = new WebSocket('wss://realtime.streamelements.com/socket.io/?transport=websocket');
      _ws.onclose = _wsClose;
      _ws.onmessage = _wsMessage;
     }

     function _wsClose()
     {
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      _ws.onmessage = null;
      _ws.onclose = null;
      if (twitch.net.dead)
       return;
      const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
      if (_wsRetry < 2)
       _wsRetry += 0.2;
      window.setTimeout(task, wsWait);
     }

     async function _wsMessage(ev)
     {
      if (twitch.net.dead)
      {
       _ws.close();
       return;
      }
      _wsRetry = 0;
      const d = ev.data;
      if (d.length < 1)
       return;
      switch (d.slice(0, 1))
      {
       case '0':
        let t = 20000;
        if (d.length > 1)
        {
         const c = JSON.parse(d.slice(1));
         if (c.hasOwnProperty('pingInterval'))
          t = c.pingInterval;
        }
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, t);
        break;
       case '4':
        if (d.slice(1, 2) === '0')
        {
         let a = '';
         if (cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== 'OAUTH_ID')
          a = '["authenticate",{"method":"oauth2","token":"' + cfg.streamelements.oauth + '"}]';
         else if (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== 'JWT_TOKEN')
          a = '["authenticate",{"method":"jwt","token":"' + cfg.streamelements.token + '"}]';
         _ws.send('42' + a);
         return;
        }
        if (document.visibilityState === 'hidden')
         return;
        if (d.slice(1, 2) !== '2')
         return;
        if (d.length < 2)
         return;
        const o = JSON.parse(d.slice(2));
        if (o.length < 2)
         return;
        if (o[0] !== 'event:update')
         return;
        if (!o[1].hasOwnProperty('name'))
         return;
        if (o[1].name !== 'tip-latest')
         return;
        if (!o[1].hasOwnProperty('data'))
         return;
        if (!o[1].data.hasOwnProperty('amount'))
         return;
        let n = false;
        if (o[1].data.hasOwnProperty('name'))
         n = o[1].data.name;
        await _showStreamElementsTip(o[1].data.amount, n);
        break;
      }
     }

     function _wsPing()
     {
      _ws.send('2');
     }

     return task;
    }();

    async function _getOAuthToken(t)
    {
     const url = 'https://realityripple.com/Tools/Twitch/EmoteWall/oauth2se.php?refresh=' + t;
     const r = await shared.httpRequest(url, {}, false, false);
     if (r === false)
      return false;
     const j = JSON.parse(r);
     if (!j.hasOwnProperty('access_token'))
      return false;
     if (!j.hasOwnProperty('refresh_token'))
      return false;
     if (!j.hasOwnProperty('expires_in'))
      return false;
     return j;
    }

    async function updateOAuth()
    {
     const lsOAuth = window.localStorage.getItem('streamelements.tips:read.oauth');
     const lsRefresh = window.localStorage.getItem('streamelements.tips:read.refresh');
     const lsExpires = window.localStorage.getItem('streamelements.tips:read.expires');
     const lsRefreshed = window.localStorage.getItem('streamelements.tips:read.refreshed');
     if (lsOAuth !== null)
      cfg.streamelements.oauth = lsOAuth;
     if (lsRefresh !== null)
      cfg.streamelements.oauth_refresh = lsRefresh;
     if (lsExpires !== null)
      cfg.streamelements.oauth_expires = lsExpires;
     if (lsRefreshed !== null)
      cfg.streamelements.oauth_refreshed = lsRefreshed;
     if (cfg.streamelements.hasOwnProperty('oauth_expires') && cfg.streamelements.oauth_expires > 0)
     {
      const expTime = cfg.streamelements.oauth_expires - Math.floor(new Date().getTime() / 1000);
      if (expTime < 0)
      {
       window.localStorage.removeItem('streamelements.tips:read.oauth');
       window.localStorage.removeItem('streamelements.tips:read.refresh');
       window.localStorage.removeItem('streamelements.tips:read.expires');
       window.localStorage.removeItem('streamelements.tips:read.refreshed');
       shared.blargIAmDead(7);
       return;
      }
     }
     if (cfg.streamelements.hasOwnProperty('oauth_refreshed') && cfg.streamelements.oauth_refreshed > 0)
     {
      const tokAge = Math.floor(new Date().getTime() / 1000) - cfg.streamelements.oauth_refreshed;
      if (tokAge < 24 * 60 * 60)
       return;
     }
     const ret = await _getOAuthToken(cfg.streamelements.oauth_refresh);
     if (ret === false)
      return;
     cfg.streamelements.oauth = ret.access_token;
     cfg.streamelements.oauth_refresh = ret.refresh_token;
     cfg.streamelements.oauth_expires = Math.floor(new Date().getTime() / 1000) + ret.expires_in;
     cfg.streamelements.oauth_refreshed = Math.floor(new Date().getTime() / 1000);
     window.localStorage.setItem('streamelements.tips:read.oauth', cfg.streamelements.oauth);
     window.localStorage.setItem('streamelements.tips:read.refresh', cfg.streamelements.oauth_refresh);
     window.localStorage.setItem('streamelements.tips:read.expires', cfg.streamelements.oauth_expires);
     window.localStorage.setItem('streamelements.tips:read.refreshed', cfg.streamelements.oauth_refreshed);
    }

    return {
     socket: streamelementsWS,
     updateOAuth: updateOAuth
    };
   }();

   const thirdparty = function()
   {
    function _addEmote(list, scope, code, id, url, users = null, zwe = false)
    {
     list[code] = {scope: scope, url: url, id: id, users: users};
     if (scope === 'c' && !zwe)
      cList.push({url: url});
    }

    function _removeEmote(list, scope, code)
    {
     if (!list.hasOwnProperty(code))
      return;
     if (list[code].scope !== scope)
      return;
     if (scope === 'c')
     {
      for (let c = cList.length - 1; c >= 0; c--)
      {
       if (cList[c].url !== list[code].url)
        continue;
       cList.splice(c, 1);
       break;
      }
     }
     delete list[code];
    }

    function _removeEmoteByID(list, scope, id)
    {
     for (let i = Object.keys(list).length - 1; i >= 0; i--)
     {
      const k = Object.keys(list)[i];
      if (list[k].scope !== scope)
       continue;
      if (list[k].id !== id)
       continue;
      _removeEmote(list, scope, k);
      break;
     }
    }

    function _removeEmoteByScope(list, scope)
    {
     for (let i = Object.keys(list).length - 1; i >= 0; i--)
     {
      const k = Object.keys(list)[i];
      if (list[k].scope !== scope)
       continue;
      _removeEmote(list, scope, k);
     }
    }

    const ffz = function()
    {
     function _readFFZ_URL(entry)
     {
      if (!entry.hasOwnProperty('urls'))
       return false;
      if (entry.urls.hasOwnProperty('4'))
      {
       let u4 = entry.urls[4];
       if (u4.slice(0, 2) === '//')
        u4 = 'https:' + u4;
       return u4;
      }
      if (entry.urls.hasOwnProperty('2'))
      {
       let u2 = entry.urls[2];
       if (u2.slice(0, 2) === '//')
        u2 = 'https:' + u2;
       let u24 = u2;
       if (u24.slice(-2) === '/2')
        u24 = u24.slice(0, -1) + '4';
       return u24;
      }
      if (entry.urls.hasOwnProperty('1'))
      {
       let u1 = entry.urls[1];
       if (u1.slice(0, 2) === '//')
        u1 = 'https:' + u1;
       let u14 = u1;
       if (u14.slice(-2) === '/1')
        u14 = u14.slice(0, -1) + '4';
       return u14;
      }
      return false;
     }

     async function loadFFZ_global()
     {
      thirdparty.emotes.ffz = {};
      const url = 'https://api.frankerfacez.com/v1/set/global';
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('sets'))
       return false;
      let usedSets = [];
      if (j.hasOwnProperty('default_sets'))
      {
       for (let i = 0, l = j.default_sets.length; i < l; i++)
        usedSets.push(j.default_sets[i]);
      }
      for (const set in j.sets)
      {
       if (!j.sets.hasOwnProperty(set))
        continue;
       if (!usedSets.includes(j.sets[set].id))
        continue;
       if (!j.sets[set].hasOwnProperty('emoticons'))
        continue;
       for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
       {
        if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
         continue;
        const u = _readFFZ_URL(j.sets[set].emoticons[i]);
        if (u === false)
         continue;
        _addEmote(thirdparty.emotes.ffz, 'g', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u);
       }
      }
      //user-specific, from here on everything returns true
      if (!j.hasOwnProperty('users'))
       return true;
      for (const setID in j.users)
      {
       if (!j.users.hasOwnProperty(setID))
        continue;
       const aList = j.users[setID];
       if (!Array.isArray(aList))
        continue;
       for (const set in j.sets)
       {
        if (!j.sets.hasOwnProperty(set))
         continue;
        if (setID !== set)
         continue;
        if (!j.sets[set].hasOwnProperty('emoticons'))
         continue;
        for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
        {
         if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
          continue;
         const u = _readFFZ_URL(j.sets[set].emoticons[i]);
         if (u === false)
          continue;
         _addEmote(thirdparty.emotes.ffz, 'g', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, aList);
        }
       }
      }
      return true;
     }

     async function loadFFZ_channel(chID)
     {
      thirdparty.emotes.ffz = {};
      const url = 'https://api.frankerfacez.com/v1/room/id/' + chID;
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('sets'))
       return false;
      _removeEmoteByScope(thirdparty.emotes.ffz, 'c');
      for (const set in j.sets)
      {
       if (!j.sets[set].hasOwnProperty('emoticons'))
        continue;
       for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
       {
        if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
         continue;
        const u = _readFFZ_URL(j.sets[set].emoticons[i]);
        if (u === false)
         continue;
        _addEmote(thirdparty.emotes.ffz, 'c', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u);
       }
      }
      return true;
     }

     return {
      global: loadFFZ_global,
      channel: loadFFZ_channel
     };
    }();

    const bttv = function()
    {
     const _rBE = 600000;   // bttv post-event emote recheck (ms)

     function reloadBTTV(chID)
     {
      if (thirdparty.bttv.timer === false)
       return;
      window.clearTimeout(thirdparty.bttv.timer);
      thirdparty.bttv.timer = false;
      if (cfg.display.extended.useBTTV)
       loadBTTV_channel(twitch.net.channelID);
      thirdparty.bttv.timer = window.setTimeout(reloadBTTV, thirdparty.interval, chID);
     }

     async function loadBTTV_global()
     {
      thirdparty.emotes.bttv = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      thirdparty.emotes.zwe.bttv = {};
      const url = 'https://api.betterttv.net/3/cached/emotes/global';
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!Array.isArray(j))
       return false;
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('code'))
        continue;
       if (!j[i].hasOwnProperty('id'))
        continue;
       if (bttvZWE.includes(j[i].code))
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe.bttv, 'g', j[i].code, j[i].id, 'https://cdn.betterttv.net/emote/' + j[i].id + '/3x', null, true);
        continue;
       }
       _addEmote(thirdparty.emotes.bttv, 'g', j[i].code, j[i].id, 'https://cdn.betterttv.net/emote/' + j[i].id + '/3x');
      }
      return true;
     }

     async function loadBTTV_channel(chID)
     {
      const url = 'https://api.betterttv.net/3/cached/users/twitch/' + chID;
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      _removeEmoteByScope(thirdparty.emotes.bttv, 'c');
      const j = JSON.parse(r);
      if (j.hasOwnProperty('channelEmotes'))
      {
       for (let i = 0, l = j.channelEmotes.length; i < l; i++)
       {
        if (!j.channelEmotes[i].hasOwnProperty('code'))
         continue;
        if (!j.channelEmotes[i].hasOwnProperty('id'))
         continue;
        _addEmote(thirdparty.emotes.bttv, 'c', j.channelEmotes[i].code, j.channelEmotes[i].id, 'https://cdn.betterttv.net/emote/' + j.channelEmotes[i].id + '/3x');
       }
      }
      if (j.hasOwnProperty('sharedEmotes'))
      {
       for (let i = 0, l = j.sharedEmotes.length; i < l; i++)
       {
        if (!j.sharedEmotes[i].hasOwnProperty('code'))
         continue;
        if (!j.sharedEmotes[i].hasOwnProperty('id'))
         continue;
        _addEmote(thirdparty.emotes.bttv, 'c', j.sharedEmotes[i].code, j.sharedEmotes[i].id, 'https://cdn.betterttv.net/emote/' + j.sharedEmotes[i].id + '/3x');
       }
      }
      return true;
     }

     const loadBTTV_ws_channel = function()
     {
      let _wsRetry = 0;
      let _ch = 0;
      let _ws = null;

      function task(chID)
      {
       _wsRetry = 0;
       _ch = chID;
       _ws = new WebSocket('wss://sockets.betterttv.net/ws');
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       _ws.onopen = null;
       _ws.send('{"name":"join_channel","data":{"name":"twitch:' + _ch + '"}}');
       _ws.send('{"name":"broadcast_me","data":{"name":"' + cfg.channel + '","channel":"twitch:' + _ch + '"}}');
      }

      function _wsClose()
      {
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(task, wsWait, _ch);
      }

      function _wsMessage(ev)
      {
       if (twitch.net.dead)
       {
        _ws.close();
        return;
       }
       _wsRetry = 0;
       const d = JSON.parse(ev.data);
       if (!d.hasOwnProperty('name'))
        return;
       if (!d.hasOwnProperty('data'))
        return;
       switch (d.name)
       {
        case 'lookup_user':
         if (!d.data.hasOwnProperty('name'))
          return;
         if (!d.data.hasOwnProperty('emotes') || !Array.isArray(d.data.emotes) || d.data.emotes.length < 1)
          return;
         if (!thirdparty.emotes.hasOwnProperty('bttvU'))
          thirdparty.emotes.bttvU = {};
         thirdparty.emotes.bttvU[d.data.name] = {};
         for (let i = 0, l = d.data.emotes.length; i < l; i++)
         {
          if (!d.data.emotes[i].hasOwnProperty('code'))
           continue;
          if (!d.data.emotes[i].hasOwnProperty('id'))
           continue;
          _addEmote(thirdparty.emotes.bttvU[d.data.name], 'u', d.data.emotes[i].code, d.data.emotes[i].id, 'https://cdn.betterttv.net/emote/' + d.data.emotes[i].id + '/3x');
         }
         break;
        case 'emote_create':
         if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + _ch)
          return;
         if (!d.data.hasOwnProperty('emote'))
          return;
         if (!d.data.emote.hasOwnProperty('id'))
          return;
         if (!d.data.emote.hasOwnProperty('code'))
          return;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _addEmote(thirdparty.emotes.bttv, 'c', d.data.emote.code, d.data.emote.id, 'https://cdn.betterttv.net/emote/' + d.data.emote.id + '/3x');
         thirdparty.bttv.timer = window.setTimeout(reloadBTTV, _rBE, _ch);
         break;
        case 'emote_delete':
         if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + _ch)
          return;
         if (!d.data.hasOwnProperty('emoteId'))
          return;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _removeEmoteByID(thirdparty.emotes.bttv, 'c', d.data.emoteId);
         thirdparty.bttv.timer = window.setTimeout(reloadBTTV, _rBE, _ch);
         break;
        case 'emote_update':
         if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + _ch)
          return;
         if (!d.data.hasOwnProperty('emote'))
          return;
         if (!d.data.emote.hasOwnProperty('id'))
          return;
         if (!d.data.emote.hasOwnProperty('code'))
          return;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _removeEmoteByID(thirdparty.emotes.bttv, 'c', d.data.emote.id);
         _addEmote(thirdparty.emotes.bttv, 'c', d.data.emote.code, d.data.emote.id, 'https://cdn.betterttv.net/emote/' + d.data.emote.id + '/3x');
         thirdparty.bttv.timer = window.setTimeout(reloadBTTV, _rBE, _ch);
         break;
       }
      }

      return task;
     }();

     return {
      timer: false,      // timer for BTTV third-party channel emote kludge
      global: loadBTTV_global,
      channel: loadBTTV_channel,
      socket: loadBTTV_ws_channel,
      reload: reloadBTTV
     };
    }();

    const _7tv = function()
    {
     async function load7TV_global()
     {
      thirdparty.emotes['7tv'] = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
       thirdparty.emotes.zwe['7tv'] = {};
      const url = 'https://api.7tv.app/v2/emotes/global';
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!Array.isArray(j))
       return false;
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('name'))
        continue;
       if (!j[i].hasOwnProperty('urls'))
        continue;
       let t4 = null;
       for (let u = 0, m = j[i].urls.length; u < m; u++)
       {
        const tN = j[i].urls[u][0];
        const uN = j[i].urls[u][1];
        if (tN === '4')
        {
         t4 = uN;
         break;
        }
        if (t4 !== null)
         continue;
        if (uN.includes('/' + tN + 'x'))
         t4 = uN.replaceAll('/' + tN + 'x', '/4x');
       }
       if (j[i].hasOwnProperty('visibility') && (j[i].visibility & 0x80) === 0x80) //Zero-Width
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe['7tv'], 'g', j[i].name, j[i].id, t4, null, true);
        continue;
       }
       _addEmote(thirdparty.emotes['7tv'], 'g', j[i].name, j[i].id, t4);
      }
      return true;
     }

     async function load7TV_channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
       thirdparty.emotes.zwe['7tv'] = {};
      const url = 'https://api.7tv.app/v2/users/' + chID + '/emotes';
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      if (cfg.display.extended.useZWE)
       _removeEmoteByScope(thirdparty.emotes.zwe['7tv'], 'c');
      _removeEmoteByScope(thirdparty.emotes['7tv'], 'c');
      const j = JSON.parse(r);
      if (!Array.isArray(j))
       return false;
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('name'))
        continue;
       if (!j[i].hasOwnProperty('urls'))
        continue;
       let t4 = null;
       for (let u = 0, m = j[i].urls.length; u < m; u++)
       {
        const tN = j[i].urls[u][0];
        const uN = j[i].urls[u][1];
        if (tN === '4')
        {
         t4 = uN;
         break;
        }
        if (t4 !== null)
         continue;
        if (uN.includes('/' + tN + 'x'))
         t4 = uN.replaceAll('/' + tN + 'x', '/4x');
       }
       if (j[i].hasOwnProperty('visibility') && (j[i].visibility & 0x80) === 0x80) //Zero-Width
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe['7tv'], 'c', j[i].name, j[i].id, t4, null, true);
        continue;
       }
       _addEmote(thirdparty.emotes['7tv'], 'c', j[i].name, j[i].id, t4);
      }
      return true;
     }

     async function _load7TV_channelID(chID)
     {
      const url = 'https://api.7tv.app/v2/users/' + chID;
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('id'))
       return false;
      return j.id;
     }

     const load7TV_ws_channel = function()
     {
      let _wsRetry = 0;
      let _ch = 0;
      let _accID = false;
      let _ws = null;

      async function task(chID)
      {
       _wsRetry = 0;
       _ch = chID;
       _accID = await _load7TV_channelID(_ch);
       if (_accID === false)
        return;
       _ws = new WebSocket('wss://events.7tv.io/v3');
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsClose()
      {
       _ws.onmessage = null;
       _ws.onclose = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(task, wsWait, _ch);
      }

      function _wsMessage(ev)
      {
       if (twitch.net.dead)
       {
        _ws.close();
        return;
       }
       _wsRetry = 0;
       const d = JSON.parse(ev.data);
       switch(d.op)
       {
        case 0:
         if (thirdparty.timer !== false)
          window.clearTimeout(thirdparty.timer);
         thirdparty.timer = window.setTimeout(reload3rdParty, 500, _ch);
         break;
        case 1:
         _ws.send(JSON.stringify({"op": 35, "d": {"type":"user.*", "condition": {"object_id": _accID}}}));
         _ws.send(JSON.stringify({"op": 35, "d": {"type":"emote.*", "condition": {"object_id": _accID}}}));
         _ws.send(JSON.stringify({"op": 35, "d": {"type":"emote_set.*", "condition": {"object_id": _accID}}}));
         break;
        case 2:
         break;
       }
      }

      return task;
     }();

     return {
      global: load7TV_global,
      channel: load7TV_channel,
      socket: load7TV_ws_channel
     };
    }();

    function reload3rdParty(chID)
    {
     if (thirdparty.timer === false)
      return;
     window.clearTimeout(thirdparty.timer);
     thirdparty.timer = false;
     if (cfg.display.extended.useFFZ)
      thirdparty.ffz.channel(twitch.net.channelID);
     if (cfg.display.extended.use7TV)
      thirdparty['7tv'].channel(twitch.net.channelID);
     thirdparty.timer = window.setTimeout(reload3rdParty, thirdparty.interval, chID);
    }

    return {
     emotes: {},      // pre-listed emotes, sub-grouped into: cheer, ffz, 7tv, bttv, and bttvU (user-specific BTTV)
     timer: false,    // timer for third-party channel emote kludge
     interval: 60000, // third-party channel emote recheck interval (ms)
     ffz: ffz,
     bttv: bttv,
     '7tv': _7tv,
     reload: reload3rdParty
    };
   }();

   const shared = function()
   {
    function rnd(m)
    {
     let r = new Uint32Array(1);
     window.crypto.getRandomValues(r);
     const f = r[0] / 4294967295;
     if (m === undefined)
      return f;
     if (m < 1)
      return f * m;
     return Math.floor(f * m);
    }

    function _httpRequest_RSC(x)
    {
     if (x.readyState < 2)
      return null;
     if (x.status !== 200)
     {
      x.onreadystatechange = null;
      return false;
     }
     if (x.readyState !== 4)
      return null;
     if (x.responseText === '')
      return null;
     x.onreadystatechange = null;
     if (x.responseText === null)
      return false;
     return x.responseText;
    }

    function httpRequest(url, hdrs = {}, blargOnError = false, nocache = true)
    {
     const p = new Promise(
      function(resolve)
      {
       const x = new XMLHttpRequest();
       if (nocache)
       {
        if (url.includes('?'))
         url+= '&';
        else
         url+= '?';
        url+= 'nocache=' + rnd(0xFFFFFFFF);
       }
       x.open('GET', url);
       for (const hK in hdrs)
       {
        if (!hdrs.hasOwnProperty(hK))
         continue;
        x.setRequestHeader(hK, hdrs[hK]);
       }
       x.onreadystatechange = function()
       {
        const r = _httpRequest_RSC(x);
        if (r === null)
         return;
        if (r === false && blargOnError && x.status === 401)
         shared.blargIAmDead(3);
        resolve(r);
       };
       x.send();
      }
     );
     return p;
    }

    function findInMaybeRange(r, v)
    {
     const t = typeof r;
     switch (t)
     {
      case 'undefined':
       return false;
      case 'boolean':
       return r === true;
      case 'number':
       if (r > 0 && v >= r)
        return true;
       return false;
      case 'object':
       if (r === null)
        return false;
       for (const k in r)
       {
        if (!r.hasOwnProperty(k))
         continue;
        let lower = 0;
        let upper = 0;
        if (k.slice(-1) === '+')
        {
         lower = parseInt(k.slice(0, -1), 10);
         upper = Number.MAX_SAFE_INTEGER;
        }
        else if (k.indexOf('-') !== -1)
        {
         lower = parseInt(k.slice(0, k.indexOf('-')), 10);
         upper = parseInt(k.slice(k.indexOf('-') + 1), 10);
        }
        else
        {
         lower = parseInt(k, 10);
         upper = parseInt(k, 10);
        }
        if (v >= lower && v <= upper)
         return r[k];
       }
     }
     return false;
    }

    function blargIAmDead(e)
    {
     let showButton = false;
     switch (e)
     {
      case 1:
       if (login.inUse)
       {
        document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Connect to Twitch<br><br>Please Log In Again</div>';
        showButton = true;
        login.showOut(true);
       }
       else
        document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Connect to Twitch<br><br>Please Update Your OAuth Token</div>';
       break;
      case 2:
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Corrupted Configuration<br><br>Please Check Your Browser\'s Error Console</div>';
       break;
      case 3:
       if (login.inUse)
       {
        document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Emotes<br><br>Please Log In Again</div>';
        showButton = true;
        login.showIn();
       }
       else
        document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Emotes<br><br>Please Check Your Client ID and OAuth Token</div>';
       break;
      case 4:
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Warning:<br><br>Your Credentials Will Expire Soon<br><br>Please Update Your OAuth Token</div>';
       if (login.inUse)
       {
        login.showOut(true);
        window.setTimeout(function(){document.body.innerHTML = ''; login.showOut(true);}, 15000);
        return;
       }
       break;
      case 5:
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>The Connection to the IRC Channel was Incomplete<br><br>Please Check your Channel</div>';
       break;
      case 6:
       if (login.inUse)
       {
        document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Point Redeems<br><br>Please Log In Again</div>';
        showButton = true;
        login.showIn();
       }
       else
        document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Point Redeems<br><br>Please Check Your Client ID and OAuth Token</div>';
       break;
      case 7:
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Warning:<br><br>Your StreamElements OAuth Token is Expired<br><br>Please Update your StreamElements OAuth Token</div>';
       break;
     }
     window.setTimeout(function(){document.body.innerHTML = ''; if (showButton) login.showIn();}, 15000);
    }

    return {
     rnd: rnd,
     httpRequest: httpRequest,
     findInMaybeRange: findInMaybeRange,
     blargIAmDead: blargIAmDead
    };
   }();

   const login = function()
   {
    let _tL = false;     // timer for logout button display
    const _visTime = 5000;

    function shouldUseLogin()
    {
     login.inUse = false;
     if (cfg.hasOwnProperty('channel') && cfg.channel !== false && cfg.channel !== 'CHANNEL_NAME' && cfg.hasOwnProperty('login') && cfg.login.hasOwnProperty('oauth') && cfg.login.oauth !== false && cfg.login.oauth !== 'OAUTH_ID')
      return false;
     login.inUse = true;
     if (window.localStorage.getItem('rrew.channel') !== null)
     {
      window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.channel', window.localStorage.getItem('rrew.channel'));
      window.localStorage.removeItem('rrew.channel');
     }
     if (window.localStorage.getItem('rrew.client') !== null)
     {
      window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.client', window.localStorage.getItem('rrew.client'));
      window.localStorage.removeItem('rrew.client');
     }
     if (window.localStorage.getItem('rrew.oauth') !== null)
     {
      window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.oauth', window.localStorage.getItem('rrew.oauth'));
      window.localStorage.removeItem('rrew.oauth');
     }
     if (window.localStorage.getItem('rrew.expires') !== null)
     {
      window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.expires', window.localStorage.getItem('rrew.expires'));
      window.localStorage.removeItem('rrew.expires');
     }
     let lsChannel = window.localStorage.getItem('twitch.chat:read+channel:read:redemptions.channel');
     let lsClient  = window.localStorage.getItem('twitch.chat:read+channel:read:redemptions.client');
     let lsOAuth   = window.localStorage.getItem('twitch.chat:read+channel:read:redemptions.oauth');
     let lsExpires = window.localStorage.getItem('twitch.chat:read+channel:read:redemptions.expires');
     if (lsChannel === null || lsOAuth === null)
     {
      const h = _getHashParams();
      if (!h.hasOwnProperty('channel') || !h.hasOwnProperty('client') || !h.hasOwnProperty('oauth') || !h.hasOwnProperty('expires'))
      {
       showLoginButton();
       return true;
      }
      lsChannel = h.channel;
      lsClient = h.client;
      lsOAuth = h.oauth;
      lsExpires = h.expires;
      window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.channel', lsChannel);
      window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.oauth', lsOAuth);
      window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.client', lsClient);
      window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.expires', lsExpires);
     }
     cfg.channel = lsChannel;
     cfg.login.oauth = lsOAuth;
     cfg.login.client = lsClient;
     cfg.login.expires = lsExpires;
     document.title = cfg.channel + ' Emote Wall';
     showLogoutButton();
     return false;
    }

    function _getHashParams()
    {
     const d = function(s) {
      const a = /\+/g;
      return decodeURIComponent(s.replace(a, " "));
     };
     let hashParams = {};
     const r = /([^&;=]+)=?([^&;]*)/g;
     const q = window.location.hash.substring(1);
     let e;
     while ((e = r.exec(q)) !== null)
     {
      hashParams[d(e[1])] = d(e[2]);
     }
     return hashParams;
    }

    function doLogin()
    {
     window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.channel');
     window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.oauth');
     window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.client');
     window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.expires');
     const o = encodeURIComponent(btoa(window.location));
     const c = encodeURIComponent('4umzcpmjkg6ar78b81s7302jlj33t8');
     const r = encodeURIComponent('https://realityripple.com/Tools/Twitch/EmoteWall/wizard.php');
     const s = encodeURIComponent('chat:read channel:read:redemptions');
     let u = 'https://id.twitch.tv/oauth2/authorize?client_id=' + c + '&redirect_uri=' + r + '&response_type=token&scope=' + s + '&state=redirto_' + o + '&force_verify=true';
     if (u.length > 1500)
      u = 'https://realityripple.com/Tools/Twitch/tempRedir.php?c=' + c + '&r=' + r + '&s=' + s + '&u=' + encodeURIComponent(window.location);
     window.location = u;
    }

    function showLoginButton()
    {
     document.title = 'Log In to Access Emote Wall';
     if (document.getElementById('cmdLogout'))
      document.body.removeChild(document.getElementById('cmdLogout'));
     window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.channel');
     window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.oauth');
     window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.client');
     window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.expires');
     let cmdLogin = document.createElement('button');
     cmdLogin.setAttribute('id', 'cmdLogin');
     cmdLogin.setAttribute('type', 'button');
     cmdLogin.setAttribute('onclick', 'login.begin();');
     let sStyle = 'z-index: 1000;';
     sStyle += ' position: absolute;';
     sStyle += ' top: 45%;';
     sStyle += ' left: calc(50% - 6.5em);';
     sStyle += ' width: 13em;';
     sStyle += ' font-size: 3vw;';
     sStyle += ' padding: 0.5em;';
     cmdLogin.setAttribute('style', sStyle);
     cmdLogin.innerHTML = 'Authenticate Emote Wall';
     document.body.appendChild(cmdLogin);
    }

    function showLogoutButton(v = false)
    {
     if (document.getElementById('cmdLogout'))
      document.body.removeChild(document.getElementById('cmdLogout'));
     let cmdLogout = document.createElement('button');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     cmdLogout.setAttribute('id', 'cmdLogout');
     cmdLogout.setAttribute('type', 'button');
     let sStyle = 'z-index: 1000;';
     sStyle += ' transition: opacity 0.5s;';
     sStyle += ' position: absolute;';
     sStyle += ' top: 1em;';
     sStyle += ' right: 1em;';
     sStyle += ' width: 5em;';
     sStyle += ' font-size: 1vw;';
     sStyle += ' padding: 0.5em;';
     document.addEventListener('mouseover', _fadeInLogout);
     if (v)
     {
      cmdLogout.setAttribute('onclick', 'login.begin();');
      cmdLogout.innerHTML = 'Re-Auth';
      sStyle += ' opacity: 1;';
      _tL = window.setTimeout(_fadeOutLogout, _visTime);
     }
     else
     {
      cmdLogout.setAttribute('onclick', 'showLoginButton();');
      cmdLogout.innerHTML = 'Log Out';
      sStyle += ' opacity: 0;';
     }
     cmdLogout.setAttribute('style', sStyle);
     document.body.appendChild(cmdLogout);
    }

    function _fadeInLogout()
    {
     if (document.getElementById('cmdLogout'))
      document.getElementById('cmdLogout').style.opacity = '1';
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogout, _visTime);
    }

    function _fadeOutLogout()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById('cmdLogout'))
      document.getElementById('cmdLogout').style.opacity = '0';
    }

    return {
     inUse: false,      // interactive login in use
     use: shouldUseLogin,
     begin: doLogin,
     showIn: showLoginButton,
     showOut: showLogoutButton
    };
   }();

   async function startup()
   {
    if (typeof cfg === 'undefined')
    {
     shared.blargIAmDead(2);
     return;
    }
    if (login.use() === true)
     return;
    if (cfg.login.hasOwnProperty('expires') && cfg.login.expires > 0)
    {
     const expTime = cfg.login.expires - new Date().getTime();
     if (expTime > 0)
     {
      const expDays = Math.floor(expTime / 1000 / 60 / 60 / 24);
      if (expDays < 7)
      {
       shared.blargIAmDead(4);
      }
     }
    }
    if (cfg.hasOwnProperty('streamlabs') && cfg.streamlabs.hasOwnProperty('token') && cfg.streamlabs.token !== false && cfg.streamlabs.token !== 'SOCKET_TOKEN')
     streamlabs.socket();
    if (cfg.hasOwnProperty('streamelements'))
    {
     if (cfg.streamelements.hasOwnProperty('oauth_refresh') && cfg.streamelements.oauth_refresh !== false && cfg.streamelements.oauth_refresh !== 'OAUTH_REFRESH')
      await streamelements.updateOAuth();
     if ((cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== 'OAUTH_ID') || (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== 'JWT_TOKEN'))
      streamelements.socket();
    }
    if (cfg.display.extended.useFFZ)
     await thirdparty.ffz.global();
    if (cfg.display.extended.useBTTV)
     await thirdparty.bttv.global();
    if (cfg.display.extended.use7TV)
     await thirdparty['7tv'].global();
    twitch.net.irc();
   }

   window.addEventListener('load', startup);
  </script>
 </head>
</html>