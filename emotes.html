<!doctype html>
<html lang="en">
 <head>
  <meta charset="utf-8" />
  <title>Loading Emote Wall...</title>
  <script>
   'use strict';
   /* RealityRipple's Home-Made Emote Wall
    * ====================================
    *
    * v0.8 BETA
    *
    *  <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *
    *
    * Help
    * ----
    *
    *  Please contact RealityRipple for assistance, bug reports, or questions.
    *
    *   <https://realityripple.com>
    *   <https://twitch.tv/realityripple>
    *   <https://discord.gg/fcxJ9tq3XS>
    *
    *
    * Configuration Information
    * -------------------------
    *
    *  For documentation on the configuration, please see
    *
    *   <https://github.com/RealityRipple/EmoteWall/blob/master/CONFIG.md>
    *
    *
    * Additional Notes and Caveats
    * ============================
    *
    * Update Procedure
    * ----------------
    *
    *  To update this emote wall, simply use the Wizard to import and download it.
    *   1) Visit the official page <https://realityripple.com/Tools/Twitch/EmoteWall/>.
    *   2) Click "Download Emote Wall" and choose "Use the Wizard".
    *   3) Import your previous HTML file by clicking "Import from File".
    *   4) Make any changes you need to make on each page.
    *   5) At the end of your configuration, hit "Download".
    *  You will receive a new version of this HTML file with your previous settings.
    *
    *
    * Emojis
    * ------
    *
    *  Twitch filters out the ZWJ (Zero-Width Joiner) character which is used for merging many emojis.
    *  This system makes use of basic character detection to correctly parse many standard ZWJ-style emojis even without
    *  the ZWJ character, however more complicated sets such as the "family units" are not possible to correctly handle.
    *  The alternative character 0xE0002 used by some third-party Twitch chat projects will be correctly parsed as a
    *  ZWJ according to the rules laid out in the RFC:
    *   <https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f>
    *
    *
    * Emote Dimensions
    * ----------------
    *
    *  Emotes that are not square will be shrunk to fit while maintaining the original aspect ratio.
    *
    *
    * Cheers
    * ------
    *
    *  The cheer style will be used for kappagens. If a user cheers 1000 bits in a single 1000 bit emote, then the
    *  kappagen will be made of the 1000-bit cheers. However, if the user cheers 1000 bits using multiple smaller cheer
    *  emotes, those emotes will be used for the kappagen instead.
    *
    *
    * Kappagen
    * --------
    *
    *  Each emote-splosion uses the number of emotes defined in the kappa count preference mentioned above, except
    *  Pyramid, which uses a constant number based on the pyramidDist array (below). If the trigger includes specific
    *  emotes (via kappagen, cheer, or resub message), the ratio of one emote to another will be maintained.
    *  If a user with kappa access posts "!kappagen PunchTrees PunchTrees SSSsss" then two thirds of the emotes in
    *  the emote-splosion will be "PunchTrees", and one third will be "SSSsss".
    *
    *
    * OBS
    * ---
    *
    *  This emote wall may do better if the browser source has a frame rate limit of 30 or 60.
    *  If you use your GPU while streaming, you may wish to disable Browser Source Hardware Acceleration.
    *  It may also work better using a smaller screen resolution (such as 720p on a 1080p screen) and then stretching
    *  the browser source to fit to the screen using the OBS Transform feature.
    *
    *
    * Inefficiencies
    * --------------
    *
    *  This emote wall uses normal <img> objects rather than a HTML Canvas. While this lowers efficiency, it also adds
    *  better GIF file support and allows easier user manipulation.
    *
    *  At present, the "zoom in" and "zoom out" feature uses a resource-heavy design. I had hoped the new CSS directive
    *  "scale: " would have helped, however it's useless without a "scale-origin" directive to accompany it.
    *
    *  The Bounce animation uses specific position-based drawing rather than actually being animated.
    *
    *  The Cube animation uses eight objects on screen for every image, making it a particularly resource-heavy drawing.
    *
    *  If your computer has trouble with this emote wall, please try disabling these options.
    *
    */

   /* jshint esversion: 11, bitwise: false, eqeqeq: true, loopfunc: true, forin: true, freeze: true, futurehostile: true, leanswitch: true, noarg: true, nocomma: true, nonbsp: true, nonew: true, noreturnawait: true, quotmark: single, shadow: outer, singleGroups: false, strict: global, trailingcomma: false, undef: true, unused: true, varstmt: true */

   var cfg = {
    twitch: {
     channel: 'CHANNEL_NAME',
     client: '4umzcpmjkg6ar78b81s7302jlj33t8',
     oauth_refresh: 'OAUTH_REFRESH',
     scope: [
      'chat:read',                 // required
    //'moderator:read:followers',  // optional. only required if you use follow events or access
    //'channel:read:redemptions',  // optional. only required if you use channel point redeem commands
    //'channel:read:hype_train',   // optional. only required if you use hype train events
    //'channel:read:goals',        // optional. only required if you use goal events
    //'channel:read:polls',        // optional. only required if you use poll events
    //'channel:read:predictions',  // optional. only required if you use prediction events
    //'channel:read:charity',      // optional. only required if you use Twitch charity events
    //'moderator:read:shoutouts'   // optional. only required if you use shoutout events
     ],
     share: false
    },
    youtube: {
     client: '71876675824-aepsnb3onligbj62r1i2qakfjh9sr8kg.apps.googleusercontent.com',
     oauth_refresh: 'OAUTH_REFRESH',
     connect_to: {
      title: false,
      list: [
       'liveStarting',
       'live',
       'testStarting',
       'testing'
      ],
      max: 1,
      sort: {
       'actualStartTime': 'desc',
       'publishedAt': 'desc'
      },
      recheck: false
     },
     share: false,
     feedback: false /* help improve support for monetized YouTube events, such as memberships, superchat, and gifts */
    },
    kick: {
     channel: 'CHANNEL_NAME'
    },
    streamlabs: {
     token: 'SOCKET_TOKEN', //Requires socket.token
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    streamelements: {
     oauth_refresh: 'OAUTH_REFRESH', //Requires tips:read
     token: 'JWT_TOKEN',
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    display: {
     styles: [
    //'Still',        // No movement
      'StraightLine', // Gentle movement in a random straight line
      'Rise',         // Slowly rise to top while wobbling back and forth
      'Bounce',       // Fall from the top at an angle and bounce along the bottom (Windows Solitaire style)
      'Speed',        // Zoom across the screen
      'Drop',         // Get stuck at the top and tumble down (no fade/zoom in, only out)
      'Crazy',        // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
      'Confetti',     // Fall like confetti                   (no zoom, no fade in, only fade out)
      'Throw',        // Toss at the middle and tumble down   (no fade/zoom in, only out)
      'TheCube'       // Rotate a 3D cube of an emote         (no zoom, only fade)
     ],
     access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x008 | 0x004 | 0x002 | 0x001,
     duplicates: true,
     useEmoji: true,
     extended: {
      useFFZ: true,
      useBTTV: true,
      use7TV: true,
      useZWE: true,
      fillZWE: false
     },
     hue: false,
     kappa: {
      count: 150,
      styles: {
       'Rise': {},        // Slowly rise to top while wobbling back and forth
       'Speed': {},       // Zoom across the screen
       'Crazy': {},       // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
       'Burst': {},       // Expand from a center point
       'Fireworks': {},   // Burst out from a single emote (no fade/zoom; small emotes)
       'Spiral': {},      // Burst out from a single emote in a spiral (no fade/zoom; small emotes)
       'Pyramid': {},     // Build a pyramid        (no fade/zoom; specific-size emotes)
       'SmallPyramid': {},// Build a small pyramid  (no fade/zoom; small emotes)
       'Fountain': {},    // Spout from a fountain  (no fade/zoom)
       'Stampede': {},    // Stampede of emotes     (no fade/zoom)
       'Confetti': {},    // Fall like confetti     (no zoom, no fade in, only fade out; small emotes)
       'Conga': {},       // Start a conga line     (no fade/zoom)
       'TheCube': {       // Rotate a 3D cube of an emote (no zoom, only fade)
        size: 8/10,
        center: true,
        rotations: 5
       },
       'Text': {          // Show a message         (no fade/zoom; specific-size emotes)
        message: ['HYPE!'],
        time: 3
       }
      },
      access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x008 | 0x004 | 0x002,
      aliases: [      // !kappagen command aliases (must be lower-case)
       '!kappagen',
       '-kappagen'
      ],
      cooldown: 0,
      conga: {
       contagious: false,
       time: 5,
       avoidMiddle: false
      }
     },
     statuses: true
    },
    emote: {
     time: 5,
     max: 0,
     queue: 0,
     size: {
      ratio: {
       normal: 1/12,
       small: 1/24
      },
      min: 16,
      max: 256,
      variation: false
     },
     cube: {
      rotations: 5
     },
     in: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     },
     out: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     }
    },
    event: {
     twitch: {
      clear: true,
      raid: {
       raiders: 2,
       originEmotes: true,
       originExtendedEmotes: false
      },
      follow: true,
      shoutout: {
       create: {
        styles: false,
        targetEmotes: true,
        targetExtendedEmotes: false
       },
       receive: {
        styles: false,
        originEmotes: true,
        originExtendedEmotes: false
       }
      },
      tag: {
       styles: true,
       access: -1,
       targetEmotes: true,
       targetExtendedEmotes: false
      },
      sub: {
       useMsg: true,
       t1: {
        first: true,
        resub: true,
        upgrade: {
         gift: false,
         prime: false
        },
        gift: {
         first: true,
         resub: true,
         bomb: 1
        }
       },
       t2: {
        first: true,
        resub: true,
        upgrade: {
         gift: false,
         prime: false
        },
        gift: {
         first: true,
         resub: true,
         bomb: 1
        }
       },
       t3: {
        first: true,
        resub: true,
        upgrade: {
         gift: false,
         prime: false
        },
        gift: {
         first: true,
         resub: true,
         bomb: 1
        }
       },
       prime: {
        first: true,
        resub: true
       }
      },
      cheer: {
       useMsg: true,
       bits: 50
      },
      hypechat: {
       useMsg: true,
       level: 1
      },
      badge: {
       '1': false,
       '100': true
      },
      hypetrain: {
       begin: false,
       success: false
      },
      poll: {
       begin: false,
       end: false
      },
      prediction: {
       begin: false,
       resolved: false
      },
      goal: {
       begin: false,
       achieved: false
      },
      charity: false,
      timeout: false,
      ban: false
     },
     youtube: {
      sub: true,
      member: {
       useMsg: true,
       first: true,
       milestone: true,
       giftbomb: 5
      },
      superchat: true,
      supersticker: true
     },
     kick: {
      clear: true,
      raid: {
       raiders: 2,
       originEmotes: true,
       originExtendedEmotes: false
      },
      follow: true,
      sub: {
       first: true,
       resub: true,
       gift: true,
       giftbomb: 1
      },
      poll: {
       begin: false,
       end: false
      },
      timeout: false,
      ban: false
     },
     tip: {
      useProfileImage: false,
      streamlabs: {
       donation: false,
       pledge: false
      },
      streamelements: false
     }
    },
    commands: [],
    ignore: {
     users: false,
     emotes: false
    }
   };

   /* fractions (or decimal percentages) of the emote time configuration value */

   const timing = {
    display: {
     'Still': {
      time: 1
     },
     'StraightLine': {
      time: 1
     },
     'Rise': {
      origin: {      /* percentages of the screen height */
       min: 0.8,
       max: 1.1
      },
      time: 1,
      wiggle: {      /* percentages of the above time percentage */
       delay: {
        min: 0,
        max: 3/25
       },
       min: 2/5,
       max: 1
      }
     },
     'Bounce': {
      origin: {      /* percentages of the screen height */
       min: 0,
       max: 0.2
      },
      time: 1,
      velocity: {    /* pixels per 300th of display time */
       h: {
        min: 3,
        max: 9
       },
       v: {
        min: 4,
        max: 7
       },
       loss: 0.3     /* velocity percentage lost per bounce */
      },
      gravity: 1     /* pixels added to vertical velocity per increment */
     },
     'Speed': {
      origin: {      /* percentages of the screen height */
       min: 0.3,
       max: 0.7
      },
      time: 1,
      delay: 0.1
     },
     'Drop': {
      time: 1
     },
     'Crazy': {
      time: 1,
      distance: 7000,  /* max pixels to travel */
      squash: {
       width: 2,     /* squashed wide dimension */
       height: 0.7,  /* squashed tall dimension */
       time: 1/50
      }
     },
     'Confetti': {
      time: 1
     },
     'Throw': {
      time: 1,
      twist: 7/50,
      toss: 1/5,
      drop: 4/5,
      dest: {
       h: {          /* percentages of the screen width */
        min: 0.3,
        max: 0.7
       },
       v: {          /* percentages of the screen height */
        min: 0.3,
        max: 0.7
       }
      }
     },
     'TheCube': {
      time: 1
     },
     'Fountain': {
      time: 1/2,
     }
    },
    kappa: {
     'Rise': {
      time: 2
     },
     'Speed': {
      time: 2
     },
     'Crazy': {
      time: 2
     },
     'Burst': {
      time: 1.5,
      top: {         /* top and bottom margin of the origin point */
       min: 1/4,
       max: 3/4
      },             /* left and right margin of the origin point */
      left: {
       min: 1/4,
       max: 3/4
      }
     },
     'Fireworks': {
      time: 1,
      origin: {      /* origin point(s) of the firework's rocket */
       x: [1/2],
       y: [1]
      },
      dest: {        /* destination point(s) of the firework's rocket */
       x: [1/4, 1/2, 3/4],
       y: [1/3]
      },
      speed: {
       rocket: 2/5,  /* speed of rocket */
       burst: 1/50   /* speed of initial burst */
      },
      quantity: {    /* number of emotes per burst */
       small: 1/8,
       medium: 3/4,
       large: 1/8
      },
      radius: {      /* firework burst radii */
       base: 2/3,    /* screen's smaller dimension */
       small: 1/3,
       medium: 2/3,
       large: 1
      },
      spread: 12,    /* how much more frequently to pause during medium burst */
      delays: {      /* pause between bursts */
       small: 2/25,
       large: 1/10
      }
     },
     'Spiral': {
      time: 1,
      bulk: 8,       /* max number of emotes to send in bulk (>1 can end up looking chunked) */
      vectors: {     /* number of emote vectors per circle */
       min: 40,
       max: 60
      }
     },
     'Pyramid': {
      time: 1,
      show: {
       total: 0.8,   /* percentage of time to spend showing the pyramid */
       min: 75       /* minimum animation speed per block (in ms) */
      },
      pause: 0.2,
      hide: 0.01
     },
     'SmallPyramid': {
      time: 1,
      show: {
       total: 0.8,   /* percentage of time to spend showing the pyramid */
       min: 100      /* minimum animation speed per block (in ms) */
      },
      pause: 0.2,
      hide: 0.01
     },
     'Fountain': {
      time: 1.5,
      top: {         /* peak of the fountain, as a percent of the screen height */
       min: 3/20,
       max: 2/5
      },             /* left and right margin of the origin point */
      left: {
       min: 1/3,
       max: 2/3
      }
     },
     'Stampede': {
      time: 1,
      speed: 2/5,     /* travel time across the screen for each emote */
      maxdensity: 6,  /* maximum emotes to show at once */
      top: {
       min: 0.5,      /* top of stampede relative to top of screen, in emote heights */
       max: 0.5       /* bottom of stampede relative to bottom of screen, in emote heights */
      },
      height: 3,      /* height of stampede in emote heights */
      bunch: {
       '1': {
        min: 1,
        max: 5
       },
       '2': 8,        /* this number minus the value of 1 */
       '4': {
        min: 0,
        max: 3
       }
      },
      pause: {
       '1': 4/5,
       '2': 2/5
      },
      smallSleep: {
       min: 90,
       max: 100
      }
     },
     'Confetti': {
      time: 1
     },
     'Conga': {
      time: {
       show: 2,
       hide: 2
      },
      size: 5/3,      /* height of animation space for row in emote heights */
      height: 5/6,    /* height of each row of dancers in emote heights (padding) */
      avoidMiddle: 6  /* rows to use when avoiding the middle (half top, half bottom; please use even numbers) */
     },
     'TheCube': {
      time: 1
     },
     'Text': {
      time: 1,
      show: {
       total: 0.8,   /* percentage of time to spend showing the pyramid */
       min: 75       /* minimum animation speed per block (in ms) */
      },
      hide: 0.01
     }
    }
   };

   /* potentially alterable arrays */

   // list of default images to use if your channel has no emotes
   const bareList = [
    {url: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAHv0lEQVRIx52Xa6xdRRXHf2vN7L3Puff29ra37yfQaCPGkPIwoCLVhEQEDaCngaAGo8FErZCI1gTweD6QKIiBEkyKhoBSwXtDwEaKhkQKJmKLgIRCebbIoy19nnse9+zHPPzQNBSwIbjm02Stmd9kzays/wjHsQgiEO+84YoVRcyWTHUPLo7en7Hn9d033Lzx73tiRESIfEjT4zkmGw0F6HTanyh7B7dU/emNVsJVs+bOu/eW5mWja9Y0tNlsagT5MED5AF9srv3CaNUfXOyD+eycRfO/MWfuAtPrTl+79qcbrj8a2Gw2FbYorA6tViv8v0AAaTabptVquesuP/2MkdkLtg7NXhBdOXi12L39osolnVQXtdfdsan7DhyFJscDHw8oExMNXbNm0h+dX3vpqptr1v/A1lI/OjZmYrRtlZpIUj8coj5RVINHyqr/t3W3/PVFgEajYSYmJ4Pw7nt+H7DZbOrR023YsCEx+5+6rMx738q7Bz4diq6kSUY2YzyabEQEQQVwJSE6Bnk5IPjNkNz4/Zvu2/re/d4HPOpsNpvp4uzgV9T7q+qZ/WReDBj0exByYvCEqkAkRqInEWJEYlSDijEKDArnPOY2V0+vW3fjpu6xUHkvbP013z7RSnF3lphPeVeSD6ZDWQwioTTiSkIxQDRijCAmJbGGrJYRAkznVQw+hBiCSW2Kk/RpOzr7krU//+NLR/eXd14ZzMkOzDKDzqM18R+f6rS9K3MJZaExBvAFKhCrkqRex0gkhIhNE9IsJQbPdKdHnjti8DFGfH1k1Gpt1i4dqp975S8feLXZbKoAxGZTpdUK6398ye+GEv/1TrdbRV8mrsiJVUHwnsREgnfEqkSzYWr1FOcqVBQ1hhADMrScUJ9HXnm06BP6b7skdq1kM5+gPvOczuhkIRONhlkzOelvW3f5l6Kb2pRPt31wTkNVSAweO3M5YXgJQRLU9Um6O/G93ST1YQieGCMiEbPkcwxGV1J5jw+RsshJ80PY/U+7WjhsQ33mD6++7aFfydFaG+88uw0/WDXdPeQlOCOSYJaeTTW0hLRWx3tP5Rwz6inujX/C1AvYJCV4j5m9gmL8TLpFiarBZgndTg8rih56JWbt5zCm3Lv0rHNWKRAXFS+vTjSsKnpTIVbO4D31E84mH17KvLkZr778DK+99gpWhW4/p5x1CmZ0OWmWktWGiPVllN5TGxqiDCV/uHMD9917B/94/BGKoXniagshxIWHdz5/lgK4qrzQ+AJX5pEqx44s5LCO85cH72Fy8m42P/Qn7r9/I/9+5kmSJGVs3nx05knYbBg1lsGgwBrlwP79PLjpPt54fSeHD+3n8cce5l9PPYEdWxSNSaj6vfMVILr8hKoYQAhI8ITaHJ58eht552127XoTH47Uz7ZtjzHVbVNVJWXMqFwgEul326hJeev1nex88XlUFR8CWVbjhR3b6RVObGKJMZ6hExPNNPq4ILoSE5wokW63x7639+Ax1LIUawVjDVVZ0p1qUwwGFNN9Ovvfoju1j+rQfyA4EqOIRIL3BOfwztHvdfFugOIBRrX/XHtIcKORgEhEgkPKNmoMg8LRy3NAjgwxZFl2pBH295J3DpBP96kO7KDzxvOsWLGS8bExfDiSEmst8+YvoB7auGIKCRQ6zNi0TbSfWINai1dDVh5gzoyMaFJUDd57ut0OH/3IShYvWkwYdHDt7ZAIqGNoCDrPbSarpjjv/Is56cQTmTtvPguXLef0lQuYUe6KagRR7QjA7T+6cJN17Qum2p1QDXLjfUFX5/DkoWH27DtACBXLlp7E6tXnYQn0Xvoz9HagmqAGEEsxqJguhBlLzySPNQ4c3EtNpliYTmHwYWR4ljozdLsA/HbdV9da311/uH3QV4PChBjwxTSuvoCpZCn1WUsZHx+nnNpLvnsr6vZiswwJDrUGxEBUnHPk/QKT1KgN10mtx1cOIY1JUkeTkfME4NfNi+ZxqLMjuulZea8fXai0Kkq8c2AMPiZ4PInkpImgWR2xigaPGIMYS3AeNQbBEqNDjYVoCJXzNZsap7WttfCxs3Wi0TDfbd2/z1X+plqSCqJBRTFqscagGkniNMOppz5Ux6Y1VARrDUYVjWCNYo2gRlAFq4qiiA+RKsYYFbG11nduv72SCPKzZlN4bUs6XgsPJ7H8TK/XcYhYV5SgEQFEFbGgakBBU4uEAD5gspToPRgDGHAeURt8XvnMDiXTpvaLq3/z6E8ajYbRoxKgddejeWHs14pod9VrIxaxTkwSBIOogSgQDTFAqCAWgRjAOwiVJ4RIqAKUPgQnXoLRWjqcDKjfs+zc713TbKKTRyTHuxvw9d/8/MnDkv9ecae6qqIoyigaQqyCSGJEjYD3ICAWYhmipvZIGkLURFNRW6fw+mYgual/wpb1rZbEeKTbx/dIDLTVIjQvOG1odIxLQ2Stip5iTcSVBa7yaGII3kMI2FSJHowx2EQpKsGRbMekGwc6887WXZv3His5jyOijkABmo1zRkbq8YsR/+UY3Mm+KBcgMiwabXAxGkMeQjwUot1rUvNsCMkDI3NPfezKW28tAI722g+UiRFkstHQY4OvuOK0ZFl/zpxAOWqMZD4vRGxou2rJwdbkZO/Y9RONhmlMTIb/9RX4Ly/EQPT2tQstAAAAAElFTkSuQmCC'}
   ];

   // distribution of emotes for Pyramid and SmallPyramid kappagen
   const pyramidDist = [1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1];

   // treat these BTTV emotes as zero-width (overlapping) emotes
   const bttvZWE = [
    '567b5b520e984428652809b6', //SoSnowy
    '5849c9a4f52be01a7ee5f79d', //IceCold
    '58487cc6f52be01a7ee5f205', //SantaHat
    '5849c9c8f52be01a7ee5f79e', //TopHat
    '567b5dc00e984428652809bd', //ReinDeer
    '567b5c080e984428652809ba', //CandyCane
    '5e76d399d6581c3724c0f0b8', //cvMask
    '5e76d338d6581c3724c0f0b2'  //cvHazmat
   ];

   // distribution of emotes for letters in message kappagens
   const alnumDist = {
    'A': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'a': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'B': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    'b': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'C': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0]
    ],
    'c': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'D': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'd': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'E': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'e': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'F': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'f': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    'G': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 1, 0, 0]
    ],
    'g': [
     [1, 0, 0, 1, 1, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'H': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'h': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0]
    ],
    'I': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'i': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'J': [
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'j': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0]
    ],
    'K': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'k': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'L': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'l': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'M': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'm': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'N': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'n': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'O': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'o': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'P': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    'p': [
     [1, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 1, 0, 0, 0, 0]
    ],
    'Q': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [1, 1, 0, 1, 1, 1, 1, 0, 0]
    ],
    'q': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'R': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 1, 0, 0]
    ],
    'r': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'S': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    's': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    'T': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    't': [
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0]
    ],
    'U': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'u': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'V': [
     [0, 0, 0, 0, 1, 1, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 1, 1, 0]
    ],
    'v': [
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0]
    ],
    'W': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'w': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 0, 0, 0]
    ],
    'X': [
     [0, 1, 1, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 0, 1, 1, 0]
    ],
    'x': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'Y': [
     [0, 0, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    'y': [
     [1, 0, 0, 1, 1, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'Z': [
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0]
    ],
    'z': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '1': [
     [0, 1, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '2': [
     [0, 1, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '3': [
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '4': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0]
    ],
    '5': [
     [0, 0, 1, 0, 0, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 0, 1, 0]
    ],
    '6': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0]
    ],
    '7': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    '8': [
     [0, 0, 1, 1, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '9': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 1, 1, 0, 0]
    ],
    '0': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    ':': [
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    '.': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    ',': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '\'': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 1]
    ],
    '-': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '_': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '+': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '=': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0]
    ],
    '!': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    '@': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 1, 1, 0, 0]
    ],
    '#': [
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    '$': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [1, 1, 1, 1, 1, 1, 1, 1, 1],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    '\u00a2': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '\u20ac': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    '\u00a3': [
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '\u00a5': [
     [0, 0, 0, 0, 1, 0, 1, 1, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 1, 0]
    ],
    '%': [
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0]
    ],
    '?': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ]
   };

   // crew
   const crewSVG = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000"><style type="text/css">') + '%CSS%' + encodeURIComponent('</style><ellipse cx="533.9" cy="929.8" rx="295.8" ry="39.4" class="st0"/><path d="M812 403c25-28 39-63 36-98-3-41-29-80-72-111l-16-11a193 193 0 0 0-77-105c-34-21-70-31-102-39-18-5-33-4-46-3h-24c-37-5-74 3-108 24-31 19-58 47-76 79-25 44-35 93-41 140l-25 1c-27 0-60 0-84 26-20 23-21 53-22 73-3 73-5 150-3 225 1 44 6 89 39 120 26 24 59 30 89 30l10-1 6 60c4 25 8 49 21 71a113 113 0 0 0 116 51c46-8 84-45 94-90 5-22 3-43 2-62l-1-24h33c-8 44 7 91 40 120a115 115 0 0 0 87 27c31-3 57-17 75-39 19-24 26-54 31-82 21-126 28-254 18-382z"/><path d="m760 495-1-52c-20 10-44 18-72 24-26 6-50 9-73 9a184 184 0 0 1-179-123c-14-42-12-91 7-133 20-45 69-58 99-66 46-13 94-13 140-3-9-10-19-20-29-25-26-17-57-26-85-33-9-2-17-1-28-1-11 1-22 2-37 0-53-8-103 33-126 75l-4 6c-25 50-31 109-35 165-9 156-4 313 15 468 3 19 5 37 13 50 11 18 36 28 58 24 23-4 44-24 49-47 4-14 2-29 1-46-1-19-3-40 2-62 3-12 13-21 26-22h2c23 0 135-1 190-5 0 0-28 52-74 59-9 28-2 62 19 80 11 10 28 15 45 13 15-1 28-8 36-18 11-14 15-34 19-56 16-93 24-187 22-281zm-482-99 3-60h-20c-22 0-36 1-43 8-6 8-7 25-7 37l-1 18c-2 68-4 137-3 204 1 32 5 63 22 80 14 12 34 15 56 15-8-101-10-201-7-302z" class="st1"/><path d="M792 322c-3 20-15 40-33 55-20 16-47 27-84 36-42 9-75 10-103 2-38-12-70-42-83-80-11-29-9-63 4-92l6-9c7-8 21-17 57-26a230 230 0 0 1 188 32c39 28 47 55 48 69v13z" class="st2"/><path d="M285 698c-22 0-42-3-56-15-17-17-21-48-21-80-2-67 0-136 2-204 20-8 45-7 68-3-3 101-1 201 7 302zm475-203c-15 58-56 109-111 133-73 32-165 11-215-49-32-39-45-90-54-140-15-87-18-177-8-266-25 50-31 109-35 165-9 156-4 313 15 468 3 19 5 37 13 50 11 18 36 28 58 24 23-4 44-24 49-47 4-14 2-29 1-46-1-19-3-40 2-62 3-12 13-21 26-22h2c23 0 135-1 190-5 0 0-28 52-74 59-9 28-2 62 19 80 11 10 28 15 45 13 15-1 28-8 36-18 11-14 15-34 19-56 16-93 24-187 22-281z" class="st3"/><path d="M792 322c-3 20-15 40-33 55-20 16-47 27-84 36-42 9-75 10-103 2-38-12-70-42-83-80-11-29-9-63 4-92l6-9c7 11 13 40 18 49 10 17 26 33 44 44 38 23 84 28 128 22 35-4 69-15 103-27z" class="st4"/><path d="M614 274c-7-3-13-9-13-17-1-11 11-18 21-22 30-10 63-8 91 3 9 4 17 9 18 18 1 10-9 18-19 19s-20-3-29-4c-23-4-45 11-69 3z" class="st5"/></svg>');
   const crewColors = [['C51111', '300060'], ['132FD2', '00004A'], ['10802D', '021B2E'], ['ED53B9', '6B05A1'], ['EF7D0E', '730020'], ['F5F558', '8E1800'], ['3F484E', '000000'], ['D5E0EF', '2E4A8D'], ['6B30BC', '0E003C'], ['72491E', '4A040A'], ['39FEDB', '1054A1'], ['50EF3A', '006144'], ['938877', '14000A'], ['E27060', '983262'], ['F5E4A5', 'B89268'], ['F1C6D0', 'DA749C'], ['738593', '162638'], ['761E1C', '4A102C']];

   //////////////////////////////////////////////////////////////////////////////
   // don't mess with things below this line without knowing what you're doing //
   //////////////////////////////////////////////////////////////////////////////

   let cList = [];
   let cSafe = [];
   const wWS = 5;
   const oauthClient = {
    t: '4umzcpmjkg6ar78b81s7302jlj33t8',
    yt: '71876675824-aepsnb3onligbj62r1i2qakfjh9sr8kg.apps.googleusercontent.com'
   };
   const cURLs = {
    ws: {
     twitch: {
      irc: 'wss://irc-ws.chat.twitch.tv',
      eventSub: 'wss://eventsub.wss.twitch.tv/ws'
     },
     kick: 'wss://ws-us2.pusher.com/app/eb1d5f283081a78b932c?protocol=7&client=js&version=7.6.0&flash=false',
     streamlabs: 'wss://sockets.streamlabs.com/socket.io/?transport=websocket&token=%TOKEN%',
     streamelements: 'wss://realtime.streamelements.com/socket.io/?transport=websocket',
     bttv: 'wss://sockets.betterttv.net/ws',
     '7tv': 'wss://events.7tv.io/v3'
    },
    api: {
     twitch: {
      users: {
       name: 'https://api.twitch.tv/helix/users?login=%USER%',
       id: 'https://api.twitch.tv/helix/users?id=%USER_ID%',
      },
      bits: {
       cheermotes: 'https://api.twitch.tv/helix/bits/cheermotes?broadcaster_id=%CHANNEL_ID%'
      },
      channels: {
       root: 'https://api.twitch.tv/helix/channels?broadcaster_id=%CHANNEL_ID%',
       followers: 'https://api.twitch.tv/helix/channels/followers?user_id=%USER_ID%&broadcaster_id=%CHANNEL_ID%'
      },
      chat: {
       emotes: {
        root: 'https://api.twitch.tv/helix/chat/emotes?broadcaster_id=%CHANNEL_ID%',
        global: 'https://api.twitch.tv/helix/chat/emotes/global'
       }
      },
      eventSub: {
       get: 'https://api.twitch.tv/helix/eventsub/subscriptions',
       delete: 'https://api.twitch.tv/helix/eventsub/subscriptions?id=%ID%'
      }
     },
     youtube: {
      broadcasts: 'https://youtube.googleapis.com/youtube/v3/liveBroadcasts?part=snippet,status&broadcastStatus=all&broadcastType=all&maxResults=50',
      livechat: {
       messages: {
        init: 'https://youtube.googleapis.com/youtube/v3/liveChat/messages?liveChatId=%CHAT_ID%&part=%PART%&maxResults=2000',
        page: 'https://youtube.googleapis.com/youtube/v3/liveChat/messages?liveChatId=%CHAT_ID%&part=%PART%&pageToken=%PAGE%&maxResults=2000'
       },
       emojis: 'https://realityripple.com/Tools/Twitch/EmoteWall/yte.json'
      },
      subscriptions: 'https://www.googleapis.com/youtube/v3/subscriptions?part=%PART%&myRecentSubscribers=true&maxResults=50',
      members: {
       init: 'https://www.googleapis.com/youtube/v3/members?part=%PART%&mode=updates&maxResults=1',
       page: 'https://www.googleapis.com/youtube/v3/members?part=%PART%&mode=updates&pageToken=%PAGE%&maxResults=1000'
      }
     },
     kick: {
      users: 'https://kick.com/api/v2/channels/%CHANNEL_NAME%/users/%USER%',
      channels: 'https://kick.com/api/v2/channels/%CHANNEL_NAME%',
      followers: 'https://kick.com/api/internal/v1/channels/%CHANNEL_NAME%/followers-count',
      emotes: 'https://kick.com/emotes/%CHANNEL_NAME%'
     },
     ffz: {
      set: {
       global: 'https://api.frankerfacez.com/v1/set/global'
      },
      room: 'https://api.frankerfacez.com/v1/room/id/%CHANNEL_ID%'
     },
     bttv: {
      emotes: {
       global: 'https://api.betterttv.net/3/cached/emotes/global'
      },
      users: {
       twitch: 'https://api.betterttv.net/3/cached/users/twitch/%CHANNEL_ID%',
       youtube: 'https://api.betterttv.net/3/cached/users/youtube/%CHANNEL_ID%'
      }
     },
     '7tv': {
      emotes: {
       global: 'https://7tv.io/v3/emote-sets/global'
      },
      users: {
       twitch: 'https://7tv.io/v3/users/twitch/%CHANNEL_ID%',
       youtube: 'https://7tv.io/v3/users/youtube/%CHANNEL_ID%',
       kick: 'https://7tv.io/v3/users/kick/%CHANNEL_ID%'
      }
     },
     rr: {
      refresh: {
       t: 'https://realityripple.com/Tools/Twitch/EmoteWall/oauth2t.php',
       yt: 'https://realityripple.com/Tools/Twitch/EmoteWall/oauth2yt.php',
       se: 'https://realityripple.com/Tools/Twitch/EmoteWall/oauth2se.php'
      },
      feedback: {
       ytmonetized: 'https://realityripple.com/Tools/Twitch/EmoteWall/ytsurvey.php',
       yterrors: 'https://realityripple.com/Tools/Twitch/EmoteWall/yterrors.php'
      }
     }
    },
    cdn: {
     twitch: {
      emote: 'https://static-cdn.jtvnw.net/emoticons/v2/%EMOTE_ID%/default/dark/3.0'
     },
     kick: {
      emote: 'https://files.kick.com/emotes/%EMOTE_ID%/fullsize'
     },
     ffz: {
      emoji: 'https://cdn.frankerfacez.com/static/emoji/images/%SET_ID%/'
     },
     bttv: {
      emote: 'https://cdn.betterttv.net/emote/%EMOTE_ID%/3x'
     }
    },
    html: {
     rr: {
      auth: {
       t: 'https://realityripple.com/Tools/Twitch/EmoteWall/twitch.php',
       yt: 'https://realityripple.com/Tools/Twitch/EmoteWall/youtube.php'
      },
      redir: 'https://realityripple.com/Tools/Twitch/tempRedir.php'
     },
     twitch: 'https://id.twitch.tv/oauth2/authorize?client_id=%CLIENT_ID%&redirect_uri=%URL%&response_type=code&scope=%SCOPE%&state=redirto_%ORIGIN%&force_verify=true',
     youtube: 'https://accounts.google.com/o/oauth2/v2/auth?client_id=%CLIENT_ID%&redirect_uri=%URL%&response_type=code&access_type=offline&scope=%SCOPE%&state=redirto_%ORIGIN%&prompt=consent%20select_account&include_granted_scopes=false'
    }
   };

   const notice = function()
   {
    const _visTime = 5000;
    const _errTime = 15000;
    let _states = {};
    let _timers = {};

    function $info(i)
    {
     if (_states.hasOwnProperty(i) && _states[i] === 'i')
      return;
     _states[i] = 'i';
     if (!_timers.hasOwnProperty(i))
      _timers[i] = false;
     _buildNotices();
     switch (i)
     {
      case 0x12:
       _setNotice(i, 'noticeInfo sTwitch', 'IRC Connected', 5);
       break;
      case 0x1A:
       _setNotice(i, 'noticeInfo sTwitch', 'EventSub Connected', 5);
       break;
      case 0x22:
       _setNotice(i, 'noticeInfo sYouTube', 'Connected', 5);
       break;
      case 0x32:
       _setNotice(i, 'noticeInfo sKick', 'Connected', 5);
       break;
      case 0x72:
       _setNotice(i, 'noticeInfo tStreamElements', 'Connected', 5);
       break;
      case 0x82:
       _setNotice(i, 'noticeInfo tStreamlabs', 'Connected', 5);
       break;
      case 0xB2:
       _setNotice(i, 'noticeInfo eBTTV', 'Connected', 5);
       break;
      case 0xC2:
       _setNotice(i, 'noticeInfo e7TV', 'Connected', 5);
       break;
     }
    }

    function $warning(w)
    {
     if (_states.hasOwnProperty(w) && _states[w] === 'w')
      return;
     _states[w] = 'w';
     if (!_timers.hasOwnProperty(w))
      _timers[w] = false;
     _buildNotices();
     switch (w)
     {
      case 0x1A:
       _setNotice(w, 'noticeWarning sTwitch', 'Too Many Instances<br>Please use existing (reference) copies wherever possible.', 20);
       break;
     }
    }

    function $error(e, sMsg = false)
    {
     if (_states.hasOwnProperty(e) && _states[e] === 'e')
      return;
     _states[e] = 'e';
     if (!_timers.hasOwnProperty(e))
      _timers[e] = false;
     _buildNotices();
     switch (e)
     {
      case 0x01:
       _setNotice(e, 'noticeError global', 'Corrupted Configuration');
       break;
      case 0x09:
       _setNotice(e, 'noticeError global', 'OBS Not Detected<br>Please see <a href="https://www.twitch.tv/videos/1784099954" target="_blank" title="Adding Emote Wall to OBS">this &quot;How to&quot; video</a> on adding the Emote Wall to OBS.');
       break;
      case 0x11:
       if (typeof loginT !== 'undefined' && loginT.inUse)
       {
        _setNotice(e, 'noticeError sTwitch', 'OAuth Token Rejected<br>Please click &quot;Re-Auth&quot; to get a new Token.');
        loginT.showOut(true);
        window.setTimeout(function(){loginT.showIn();}, 15500);
       }
       else
        _setNotice(e, 'noticeError sTwitch', 'OAuth Token Rejected<br>Please update your OAuth Refresh token.');
       break;
      case 0x12:
       _setNotice(e, 'noticeError sTwitch', 'IRC Disconnected');
       break;
      case 0x1A:
       _setNotice(e, 'noticeError sTwitch', 'EventSub Disconnected');
       break;
      case 0x21:
       if (typeof loginYT !== 'undefined' && loginYT.inUse)
       {
        _setNotice(e, 'noticeError sYouTube', 'OAuth Token Rejected<br>Please click &quot;Re-Auth&quot; to get a new Token.');
        loginYT.showOut(true);
        window.setTimeout(function(){loginYT.showIn();}, 15500);
       }
       else
        _setNotice(e, 'noticeError sYouTube', 'OAuth Token Rejected<br>Please update your OAuth Refresh token.');
       break;
      case 0x22:
       _setNotice(e, 'noticeError sYouTube', 'Disconnected');
       break;
      case 0x28:
       _setNotice(e, 'noticeError sYouTube', 'YouTube Rate Limit Exceeded<br>You have sent too many requests. Please wait a while.');
       break;
      case 0x29:
       _setNotice(e, 'noticeError sYouTube', 'Unhandled YouTube Error<br>' + sMsg);
       break;
      case 0x31:
       _setNotice(e, 'noticeError sKick', 'Connection Rejected<br>Please check your Kick channel name.');
       break;
      case 0x32:
       _setNotice(e, 'noticeError sKick', 'Disconnected');
       break;
      case 0x39:
       _setNotice(e, 'noticeError sKick', 'Kick Connection Error<br>' + sMsg);
       break;
      case 0x71:
       _setNotice(e, 'noticeError tStreamElements', 'OAuth Token Rejected<br>Please update your StreamElements OAuth Token.');
       break;
      case 0x72:
       _setNotice(e, 'noticeError tStreamElements', 'Disconnected');
       break;
      case 0x81:
       _setNotice(e, 'noticeError tStreamlabs', 'Socket Token Rejected<br>Please update your StreamLabs Socket Token.');
       break;
      case 0x82:
       _setNotice(e, 'noticeError tStreamlabs', 'Disconnected');
       break;
      case 0xB2:
       _setNotice(e, 'noticeError eBTTV', 'Disconnected');
       break;
      case 0xC2:
       _setNotice(e, 'noticeError e7TV', 'Disconnected');
       break;
     }
    }

    function _buildNotices()
    {
     if (document.getElementById('notices'))
      return;
     let n = document.createElement('div');
     n.setAttribute('id', 'notices');
     let b = document.createElement('div');
     b.setAttribute('id', 'badge');
     b.dataset.alerts = 0;
     b.innerHTML = b.dataset.alerts;
     n.appendChild(b);
     document.body.prepend(n);
    }

    function _setNotice(id, state, msg, t = 0)
    {
     let n = document.getElementById('notices');
     if (!n)
      return;
     let b = document.getElementById('badge');
     if (!b)
      return;
     b.classList.remove('fade');
     let hasFader = false;
     const lines = n.getElementsByClassName('noticeLine');
     for (let i = 0; i < lines.length; i++)
     {
      if (!lines[i].classList.contains('fader'))
      {
       hasFader = true;
       break;
      }
     }
     if (!hasFader)
      b.classList.remove('fader');
     let nID = document.getElementById('notice' + id);
     if (!nID)
     {
      b.dataset.alerts++;
      b.innerHTML = b.dataset.alerts;
      nID = document.createElement('div');
      nID.setAttribute('id', 'notice' + id);
      n.appendChild(nID);
     }
     nID.setAttribute('class', 'noticeLine ' + state);
     nID.innerHTML = msg;
     if (t > 0)
     {
      document.removeEventListener('mousemove', _triggerFadeInNotice(id));
      if (_timers[id] !== false)
       window.clearTimeout(_timers[id]);
      _timers[id] = window.setTimeout(_clearNoticeBegin, t * 1000, id);
     }
     else
     {
      if (_timers[id] !== false)
       window.clearTimeout(_timers[id]);
      _timers[id] = window.setTimeout(_hideNotice, _errTime, id);
     }
    }

    function _clearNoticeBegin(id)
    {
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     nID.classList.add('hide');
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     _timers[id] = window.setTimeout(_clearNoticeEnd, 300, id);
    }

    function _clearNoticeEnd(id)
    {
     if (_timers[id] !== false)
     {
      window.clearTimeout(_timers[id]);
      _timers[id] = false;
     }
     let n = document.getElementById('notices');
     if (!n)
      return;
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     n.removeChild(nID);
     let b = document.getElementById('badge');
     if (!b)
      return;
     b.dataset.alerts--;
     b.innerHTML = b.dataset.alerts;
    }

    function _hideNotice(id)
    {
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     nID.classList.add('fader');
     nID.classList.add('fade');
     document.addEventListener('mousemove', _triggerFadeInNotice(id));
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     _timers[id] = window.setTimeout(_fadeOutEnd, 500, id);
     let n = document.getElementById('notices');
     if (!n)
      return;
     let hasVis = false;
     const lines = n.getElementsByClassName('noticeLine');
     for (let i = 0; i < lines.length; i++)
     {
      if (!lines[i].classList.contains('fade'))
      {
       hasVis = true;
       break;
      }
     }
     if (!hasVis)
     {
      let b = document.getElementById('badge');
      if (!b)
       return;
      b.classList.add('fader');
      b.classList.add('fade');
     }
    }

    const _triggerFadeInNotice = function(id)
    {
     return function()
     {
      _fadeInNotice(id);
     };
    };

    function _fadeInNotice(id)
    {
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     nID.classList.remove('faded');
     nID.classList.remove('fade');
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     if (!nID.classList.contains('fader'))
      return;
     _timers[id] = window.setTimeout(_fadeOutNotice, _visTime, id);
     let b = document.getElementById('badge');
     if (!b)
      return;
     b.classList.remove('fade');
    }

    function _fadeOutNotice(id)
    {
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     if (!nID.classList.contains('fader'))
      return;
     _timers[id] = window.setTimeout(_fadeOutEnd, 500, id);
     nID.classList.add('fade');
     let n = document.getElementById('notices');
     if (!n)
      return;
     let hasVis = false;
     const lines = n.getElementsByClassName('noticeLine');
     for (let i = 0; i < lines.length; i++)
     {
      if (!lines[i].classList.contains('fade'))
      {
       hasVis = true;
       break;
      }
     }
     if (!hasVis)
     {
      let b = document.getElementById('badge');
      if (!b)
       return;
      b.classList.add('fade');
     }
    }

    function _fadeOutEnd(id)
    {
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     if (_timers[id] !== false)
     {
      window.clearTimeout(_timers[id]);
      _timers[id] = false;
     }
     if (!nID.classList.contains('fader'))
      return;
     nID.classList.add('faded');
    }

    return {
     info: $info,
     warning: $warning,
     error: $error
    };
   }();

   if (typeof cfg === 'undefined')
   {
    document.title = 'Emote Wall Configuration Error';
    window.addEventListener('load', function(){notice.error(0x01);});
    throw new Error('Corrupted Configuration detected.');
   }
   document.title = 'RealityRipple\'s Home-Made Emote Wall';

   const display = function()
   {
    let _eActive = 0;
    let _iTitanic = 0;
    const _cRadius = Math.PI * 2;
    const _tAnim = {
     fade: {
      in: 8,
      out: 8
     },
     zoom: {
      in: 17,
      out: 8
     }
    };

    const $emote = function()
    {
     let _toShow = [];

     let _tEmote = false;

     const $list = function()
     {
      function $Still(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const h = shared.rnd(sW - eW);
       const v = shared.rnd(sH - eH);
       let s = 'top: ' + v + 'px;';
       s += ' left: ' + h + 'px;';
       s += ' --emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Still.time);
       s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s}, false, {space: false, time: tMS});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s}, false, {space: false, time: tMS});
        }
       }
      }

      function $StraightLine(eInf, sW, sH, eH, x = false, y = false, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eHh = Math.ceil(eH / 2);
       const eWh = Math.ceil(eW / 2);
       let h = x;
       if (h === false)
        h = shared.rnd(sW) - eWh;
       let v = y;
       if (v === false)
        v = shared.rnd(sH) - eHh;
       const r = Math.min(sW, sH) * (shared.rnd() + 1);
       let th = shared.rnd() * _cRadius;
       if (!x && !y)
       {
        const nH = eH * -1;
        const nW = eW * -1;
        while (!_safePoints(h, v, th, r, nW, nH, sW, sH))
        {
         th = shared.rnd() * _cRadius;
        }
       }
       let hD = Math.floor(h + r * Math.cos(th));
       let vD = Math.floor(v + r * Math.sin(th));
       let s = '--emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.StraightLine.time);
       s += ' transform: translate(' + h + 'px, ' + v + 'px);';
       s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s, classes: ['etStraightLine']}, false, {time: tMS}, {x: hD, y: vD});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s, classes: ['etStraightLine']}, false, {time: tMS}, {x: hD, y: vD});
        }
       }
      }

      function $Rise(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const h = shared.rnd(sW) - eWh;
       const v = Math.floor(sH * _rndFromRange(timing.display.Rise.origin));
       let s = 'left: ' + h + 'px;';
       s += ' --emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       if (cfg.emote.out.fade || cfg.emote.out.zoom)
        s += ' offset-path: path("M 0 ' + v + ' L 0 ' + Math.floor(v * 0.05) + '") ;';
       else
        s += ' offset-path: path("M 0 ' + v + ' L 0 -' + eH + '") ;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       if (shared.rnd(2) === 0)
        aNames.push('wiggleL');
       else
        aNames.push('wiggleR');
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Rise.time);
       const d = Math.floor(tMS * _rndFromRange(timing.display.Rise.wiggle.delay));
       aDelays.push(d + 'ms');
       const w = Math.floor(tMS * _rndFromRange(timing.display.Rise.wiggle));
       aDurs.push(w + 'ms');
       aTimings.push('ease-in-out');
       aFills.push('both');
       aIters.push('infinite');
       aNames.push('offsetPath');
       aDelays.push('0s');
       aDurs.push(tMS + 'ms');
       aTimings.push('linear');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s}, false, {space: false, time: tMS});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s}, false, {space: false, time: tMS});
        }
       }
      }

      const $Bounce = function()
      {
       function task(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         eH = Math.ceil(eH / 2);
        else if (variationSize === 2)
         eH = eH * 2;
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const eWh = Math.ceil(eW / 2);
        const sWm = Math.ceil(sW / 2);
        const h = Math.floor(shared.rnd(sW) - eWh);
        const v = Math.floor(sH * _rndFromRange(timing.display.Bounce.origin));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Bounce.time);
        const vMS = (tMS / 300 / (16 + 2 / 3));
        let velH = _rndFromRange(timing.display.Bounce.velocity.h);
        const velV = _rndFromRange(timing.display.Bounce.velocity.v);
        if (h + eWh > sWm)
         velH = -1 * velH;
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        let bX = h;
        let bY = v;
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, eInf.url, variationSize, {style: s}, true, {time: tMS}));
        if (eInf.hasOwnProperty('zwe'))
        {
         for (let i = 0, l = eInf.zwe.length; i < l; i++)
         {
          iArr.push(_addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s}, true, {time: tMS}));
         }
        }
        window.requestAnimationFrame(function(ts){_tLoop(tInit, iArr, bX, bY, velH, velV, vMS, sH, eH, ts, ts);});
       }

       function _tLoop(tInit, iArr, bX, bY, velH, velV, vMS, sH, eH, myT, ts)
       {
        if (_iTitanic > tInit)
         return;
        if (iArr[0].parentElement === null)
         return;
        let steps = 1;
        if (myT === 0)
         myT = ts;
        else
        {
         steps = Math.max(1, Math.floor((ts - myT) / 16));
         myT = ts;
        }
        for (let i = 0; i < steps; i++)
        {
         bX += velH / vMS;
         bY += velV / vMS;
         velV += timing.display.Bounce.gravity / vMS;
         const sB = sH - eH;
         if (bY >= sB)
         {
          bY = sB;
          velV *= -1 * (1 - timing.display.Bounce.velocity.loss);
          velV = Math.floor(velV);
         }
        }
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].style.transform = 'translate(' + bX + 'px, ' + bY + 'px)';
        }
        window.requestAnimationFrame(function(fTS){_tLoop(tInit, iArr, bX, bY, velH, velV, vMS, sH, eH, myT, fTS);});
       }

       return task;
      }();

      function $Speed(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const sWm = Math.ceil(sW / 2);
       const h = shared.rnd(sW) - eWh;
       const v = Math.floor(sH * _rndFromRange(timing.display.Speed.origin));
       let s = 'top: ' + v + 'px;';
       s += ' left: ' + h + 'px;';
       s += ' --emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       let dsO = {};
       if (h + eWh > sWm)
       {
        dsO.origin = 'right';
        aNames.push('speedL');
       }
       else
       {
        dsO.origin = 'left';
        aNames.push('speedR');
       }
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Speed.time);
       const d = Math.floor(tMS * timing.display.Speed.delay);
       aDelays.push(d + 'ms');
       aDurs.push((tMS - d) + 'ms');
       aTimings.push('ease-in');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s, dataset: dsO}, false, {time: tMS});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s, dataset: dsO}, false, {time: tMS});
        }
       }
      }

      function $Drop(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const h = shared.rnd(sW) - eWh;
       let s = 'left: ' + h + 'px;';
       s += ' --emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       let dsO = {};
       if (shared.rnd(2) === 0)
       {
        dsO.origin = 'topleft';
        aNames.push('dropL');
       }
       else
       {
        dsO.origin = 'topright';
        aNames.push('dropR');
       }
       aDelays.push('0s');
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Drop.time);
       aDurs.push(tMS + 'ms');
       aTimings.push('ease-in');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s, dataset: dsO}, false, {space: false, time: tMS});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s, dataset: dsO}, false, {space: false, time: tMS});
        }
       }
      }

      const $Crazy = function()
      {
       /* LAYOUT SHIFTS
        * =============
        * squashes via scale
        * offset-path requires support for offset-anchor/offset-position
        * due to transform-origin changes during squash
        */

       function task(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         eH = Math.ceil(eH / 2);
        else if (variationSize === 2)
         eH = eH * 2;
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const sR = sW - eW;
        const sB = sH - eH;
        const h = shared.rnd(sR - 5) + 10;
        const v = shared.rnd(sB - 5) + 10;
        let s = 'top: ' + v + 'px;';
        s += ' left: ' + h + 'px;';
        s += ' --emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        let dests = [];
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time);
        const rate = Math.sqrt(timing.display.Crazy.distance ** 2 / 2) / tMS;
        let traj = {x: 0, y: 0};
        while (traj.x === 0 && traj.y === 0)
        {
         traj.x = shared.rnd() * (rate * 2) - rate;
         traj.y = shared.rnd() * (rate * 2) - rate;
        }
        let pos = {x: h, y: v, t: 0};
        let lastT = 0;
        let bCt = 0;
        const sqTime = Math.floor(tMS * timing.display.Crazy.squash.time * 2);
        while (bCt * sqTime + pos.t < tMS)
        {
         pos.x += traj.x;
         pos.y += traj.y;
         pos.t += 1;
         let wall = false;
         if (pos.x <= 0)
         {
          pos.x = 0;
          traj.x *= -1;
          wall = 1;
         }
         else if (pos.x >= sR)
         {
          pos.x = sR;
          traj.x *= -1;
          wall = 3;
         }
         if (pos.y <= 0)
         {
          pos.y = 0;
          traj.y *= -1;
          wall = 2;
         }
         else if (pos.y >= sB)
         {
          pos.y = sB;
          traj.y *= -1;
          wall = 4;
         }
         if (wall !== false)
         {
          bCt++;
          dests.push({x: Math.floor(pos.x), y: Math.floor(pos.y), t: pos.t - lastT, w: wall});
          lastT = pos.t;
         }
        }
        dests.push({x: pos.x, y: pos.y, t: pos.t - lastT, w: 0});
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, eInf.url, variationSize, {style: s}, true, {space: false, time: tMS}));
        if (eInf.hasOwnProperty('zwe'))
        {
         for (let i = 0, l = eInf.zwe.length; i < l; i++)
         {
          iArr.push(_addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s}, true, {space: false, time: tMS}));
         }
        }
        let d = 0;
        const lA = iArr.length;
        const lD = dests.length;
        shared.doNextFrame(_tLoop, tInit, lA, iArr, lD, dests, d);
       }

       function _tLoop(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        if (d >= lD)
         return;
        const squashT = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time * timing.display.Crazy.squash.time);
        for (let i = 0; i < lA; i++)
        {
         iArr[i].dataset.origin = 'center';
         iArr[i].dataset.squash = 'no';
         iArr[i].style.top = dests[d].y + 'px';
         iArr[i].style.left = dests[d].x + 'px';
         iArr[i].style.transition = 'top ' + dests[d].t + 'ms linear, left ' + dests[d].t + 'ms linear, transform ' + squashT + 'ms linear';
        }
        d++;
        window.setTimeout(_tSquash, dests[d - 1].t, tInit, lA, iArr, lD, dests, d);
       }

       function _tSquash(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        const squashT = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time * timing.display.Crazy.squash.time);
        for (let i = 0; i < lA; i++)
        {
         switch (dests[d - 1].w)
         {
          case 1:
           iArr[i].dataset.origin = 'left';
           iArr[i].dataset.squash = 'horizontal';
           break;
          case 2:
           iArr[i].dataset.origin = 'top';
           iArr[i].dataset.squash = 'vertical';
           break;
          case 3:
           iArr[i].dataset.origin = 'right';
           iArr[i].dataset.squash = 'horizontal';
           break;
          case 4:
           iArr[i].dataset.origin = 'bottom';
           iArr[i].dataset.squash = 'vertical';
           break;
         }
        }
        window.setTimeout(_tUnsquash, squashT, tInit, lA, iArr, lD, dests, d);
       }

       function _tUnsquash(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        const squashT = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time * timing.display.Crazy.squash.time);
        for (let i = 0; i < lA; i++)
        {
         iArr[i].dataset.squash = 'no';
        }
        window.setTimeout(_tLoop, squashT, tInit, lA, iArr, lD, dests, d);
       }

       return task;
      }();

      function $Confetti(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const h = shared.rnd(sW) - eWh;
       let s = 'left: ' + h + 'px;';
       s += ' --emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       switch (shared.rnd(3))
       {
        case 0:
         aNames.push('confettiA');
         break;
        case 1:
         aNames.push('confettiB');
         break;
        case 2:
         aNames.push('confettiC');
         break;
       }
       aDelays.push('0s');
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Confetti.time);
       aDurs.push(tMS + 'ms');
       aTimings.push('linear');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, false, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s}, false, {space: false, time: tMS});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s}, false, {space: false, time: tMS});
        }
       }
      }

      const $Throw = function()
      {
       function task(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         eH = Math.ceil(eH / 2);
        else if (variationSize === 2)
         eH = eH * 2;
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const sR = sW - eW;
        const sB = sH - eH;
        const h = shared.rnd(2) === 0 ? eW * -1 : sW;
        const v = shared.rnd(sH + eH) - eH;
        const hD = Math.floor(sR * _rndFromRange(timing.display.Throw.dest.h));
        const vD = Math.floor(sB * _rndFromRange(timing.display.Throw.dest.v));
        const dH = shared.rnd() * eH;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Throw.time);
        const t2 = Math.floor(tMS * timing.display.Throw.toss);
        const t3 = Math.floor(tMS * timing.display.Throw.drop);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        let s2 = '--emote-height: ' + eH + 'px;';
        s2 += ' --emote-width: ' + eW + 'px;';
        let r = '360';
        if (h > 0)
         r = '-360';
        s2 += ' transform: translate(' + hD + 'px, ' + (sH - dH) + 'px) rotate(' + r + 'deg);';
        let aNames = [];
        let aDelays = [];
        let aDurs = [];
        let aTimings = [];
        let aFills = [];
        let aIters = [];
        if (cfg.emote.out.fade)
        {
         const fOut = _tAnim.fade.out / 100;
         const t3F = t3 * fOut;
         aNames.push('fadeOut');
         aDelays.push(Math.floor(t3 - t3F) + 'ms');
         aDurs.push(Math.floor(t3F) + 'ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        else
        {
         aNames.push('noFadeOut');
         aDelays.push(t3 - 50 + 'ms');
         aDurs.push('50ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        if (cfg.emote.out.zoom)
        {
         const zOut = _tAnim.zoom.out / 100;
         const t3Z = t3 * zOut;
         aNames.push('zoomOut');
         aDelays.push(Math.floor(t3 - t3Z) + 'ms');
         aDurs.push(Math.floor(t3Z) + 'ms');
         aTimings.push('linear');
         aFills.push('forwards');
         aIters.push('1');
        }
        s2 += _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters, tMS);
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, eInf.url, variationSize, {style: s, classes: ['etThrowTwist']}, true, {space: false, time: tMS}));
        if (eInf.hasOwnProperty('zwe'))
        {
         for (let i = 0, l = eInf.zwe.length; i < l; i++)
         {
          iArr.push(_addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s, classes: ['etThrowTwist']}, true, {space: false, time: tMS}));
         }
        }
        shared.doNextFrame(_tMove, tInit, iArr, hD, vD);
        window.setTimeout(_tDrop, t2, tInit, iArr, s2);
       }

       function _tMove(tInit, iArr, hD, vD)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
        }
       }

       function _tDrop(tInit, iArr, s2)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].classList.replace('etThrowTwist', 'etThrowDrop');
         iArr[i].setAttribute('style', s2);
        }
       }

       return task;
      }();

      const $TheCube = function()
      {
       function task(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let scene = document.createElement('div');
        scene.setAttribute('class', 'scene fit cube');
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         eH = Math.ceil(eH / 2);
        else if (variationSize === 2)
         eH = eH * 2;
        const eHh = Math.ceil(eH / 2);
        const nHh = eHh * -1;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.TheCube.time);
        let cube = document.createElement('div');
        cube.setAttribute('class', 'cube');
        cube.setAttribute('style', 'transform: translateZ(' + nHh + 'px);');
        if (!eInf.hasOwnProperty('zwe') || eInf.zwe.length === 0)
        {
         let cubeF = document.createElement('img');
         _setImgSrc(cubeF, eInf.url);
         cubeF.dataset.face = 'front';
         cube.appendChild(cubeF);
         let cubeB = document.createElement('img');
         _setImgSrc(cubeB, eInf.url);
         cubeB.dataset.face = 'back';
         cube.appendChild(cubeB);
         let cubeR = document.createElement('img');
         _setImgSrc(cubeR, eInf.url);
         cubeR.dataset.face = 'right';
         cube.appendChild(cubeR);
         let cubeL = document.createElement('img');
         _setImgSrc(cubeL, eInf.url);
         cubeL.dataset.face = 'left';
         cube.appendChild(cubeL);
         let cubeT = document.createElement('img');
         _setImgSrc(cubeT, eInf.url);
         cubeT.dataset.face = 'top';
         cube.appendChild(cubeT);
         let cubeU = document.createElement('img');
         _setImgSrc(cubeU, eInf.url);
         cubeU.dataset.face = 'bottom';
         cube.appendChild(cubeU);
        }
        else
        {
         const lZ = eInf.zwe.length;
         let cubeF = document.createElement('div');
         cubeF.dataset.face = 'front';
         let pctF = document.createElement('img');
         _setImgSrc(pctF, eInf.url);
         cubeF.appendChild(pctF);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeF.appendChild(pctZ);
         }
         cube.appendChild(cubeF);
         let cubeB = document.createElement('div');
         cubeB.dataset.face = 'back';
         let pctB = document.createElement('img');
         _setImgSrc(pctB, eInf.url);
         cubeB.appendChild(pctB);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeB.appendChild(pctZ);
         }
         cube.appendChild(cubeB);
         let cubeR = document.createElement('div');
         cubeR.dataset.face = 'right';
         let pctR = document.createElement('img');
         _setImgSrc(pctR, eInf.url);
         cubeR.appendChild(pctR);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeR.appendChild(pctZ);
         }
         cube.appendChild(cubeR);
         let cubeL = document.createElement('div');
         cubeL.dataset.face = 'left';
         let pctL = document.createElement('img');
         _setImgSrc(pctL, eInf.url);
         cubeL.appendChild(pctL);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeL.appendChild(pctZ);
         }
         cube.appendChild(cubeL);
         let cubeT = document.createElement('div');
         cubeT.dataset.face = 'top';
         let pctT = document.createElement('img');
         _setImgSrc(pctT, eInf.url);
         cubeT.appendChild(pctT);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeT.appendChild(pctZ);
         }
         cube.appendChild(cubeT);
         let cubeU = document.createElement('div');
         cubeU.dataset.face = 'bottom';
         let pctU = document.createElement('img');
         _setImgSrc(pctU, eInf.url);
         cubeU.appendChild(pctU);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeU.appendChild(pctZ);
         }
         cube.appendChild(cubeU);
        }
        scene.appendChild(cube);
        const h = shared.rnd(sW) - eHh;
        const v = shared.rnd(sH) - eHh;
        const r = Math.min(sW, sH) * (shared.rnd() + 1);
        let th = shared.rnd() * _cRadius;
        const nH = eH * -1;
        while (!_safePoints(h, v, th, r, nH, nH, sW, sH))
        {
         th = shared.rnd() * _cRadius;
        }
        let hD = Math.floor(h + r * Math.cos(th));
        let vD = Math.floor(v + r * Math.sin(th));
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        s += ' --cube-depth: ' + eHh + 'px;';
        s += ' perspective: ' + eH * 3 + 'px;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false, tMS);
        scene.setAttribute('style', s);
        _eActive += 6;
        document.body.appendChild(scene);
        _gc.hook(scene, true, 6, tMS);
        shared.doNextFrame(_tMove, tInit, cube, scene, hD, vD, eH);
       }

       function _tMove(tInit, cube, scene, hD, vD, eH)
       {
        if (_iTitanic > tInit)
         return;
        const nHh = Math.ceil(eH / 2) * -1;
        let rX = 0;
        let rY = 0;
        while (Math.abs(rX) + Math.abs(rY) < 45)
        {
         rX = (360 - shared.rnd() * 720) * cfg.emote.cube.rotations;
         rY = (360 - shared.rnd() * 720) * cfg.emote.cube.rotations;
        }
        cube.style.transform = 'translateZ(' + nHh + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
        scene.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
       }

       return task;
      }();

      function $Fountain(eInf, sW, sH, eH, fX, fY, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Fountain.time);
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const sR = sW - eH;
       const sB = sH - eW;
       let h = fX;
       if (h === false)
        h = Math.floor(shared.rnd() * (sR * 0.33) + sR * 0.33);
       let hD;
       if (shared.rnd(2) === 0)
        hD = h - shared.rnd(sR * 0.2);
       else
        hD = h + shared.rnd(sR * 0.2);
       let s = '--emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       s += ' transform: translateX(' + h + 'px);';
       s += ' offset-path: path("M 0 ' + sH + ' L 0 ' + Math.floor(fY * sH + shared.rnd(sB / 2)) + ' L 0 ' + (sH + eH) + '");';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       aNames.push('offsetPath');
       aDelays.push('0s');
       aDurs.push(tMS + 'ms');
       aTimings.push('cubic-bezier(0, 0.9, 1, 0.15)');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s, classes: ['etFountain']}, false, {time: tMS, space: false}, {x: hD});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s, classes: ['etFountain']}, false, {time: tMS, space: false}, {x: hD});
        }
       }
      }

      return {
       Still: $Still,
       StraightLine: $StraightLine,
       Rise: $Rise,
       Bounce: $Bounce,
       Speed: $Speed,
       Drop: $Drop,
       Crazy: $Crazy,
       Confetti: $Confetti,
       Throw: $Throw,
       TheCube: $TheCube,
       Fountain: $Fountain
      };
     }();

     function _queueEmote(e)
     {
      const sW = window.innerWidth;
      const sH = window.innerHeight;
      const eH = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
      document.documentElement.style.setProperty('--height', sH + 'px');
      document.documentElement.style.setProperty('--width', sW + 'px');
      let style = cfg.display.styles[shared.rnd(cfg.display.styles.length)];
      if (style === undefined)
       return;
      display.emote.list[style](e, sW, sH, eH);
     }

     function $showEmotes()
     {
      if (_tEmote !== false)
      {
       window.clearTimeout(_tEmote);
       _tEmote = false;
      }
      if (cfg.emote.max > 0 && _eActive >= cfg.emote.max)
      {
       _tEmote = window.setTimeout(display.emote.showEmotes, 500);
       return;
      }
      let e = null;
      while ((e = _toShow.shift()) !== undefined)
      {
       _queueEmote(e);
       if (cfg.emote.max > 0 && _eActive > cfg.emote.max)
       {
        if (cfg.emote.queue > 0 && _toShow.length > cfg.emote.queue)
         _toShow.splice(0, _toShow.length - cfg.emote.queue);
        _tEmote = window.setTimeout(display.emote.showEmotes, 500);
        return;
       }
      }
     }

     function $addToShowList(p)
     {
      _toShow = _toShow.concat(p);
     }

     return {
      showEmotes: $showEmotes,
      addToShowList: $addToShowList,
      list: $list
     };
    }();

    const $kappa = function()
    {
     let _toKappa = [];
     let _conga = [];
     const _dKappa = 500;

     let _tKappa = false;

     const _list = function()
     {
      const $Fireworks = function()
      {
       function task(kList, sW, sH, eH, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const oK = kList[shared.rnd(kList.length)];
        let eW = eH;
        if (oK.hasOwnProperty('width') && oK.hasOwnProperty('height'))
         eW = oK.width / oK.height * eH;
        const eWh = Math.ceil(eW / 2);
        const oX = sW * timing.kappa.Fireworks.origin.x[shared.rnd(timing.kappa.Fireworks.origin.x.length)] - eWh;
        const oY = sH * timing.kappa.Fireworks.origin.y[shared.rnd(timing.kappa.Fireworks.origin.y.length)];
        const cX = sW * timing.kappa.Fireworks.dest.x[shared.rnd(timing.kappa.Fireworks.dest.x.length)];
        const cY = sH * timing.kappa.Fireworks.dest.y[shared.rnd(timing.kappa.Fireworks.dest.y.length)];
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time);
        const sendUp = Math.floor(tMS * timing.kappa.Fireworks.speed.rocket);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
        let iArr = [];
        _eActive--;
        iArr.push(_addEmoteToDoc(tInit, oK.url, 1, {style: s, classes: ['ktFireworkRocket']}, true, false, {x: cX - eWh, y: cY}));
        if (oK.hasOwnProperty('zwe'))
        {
         for (let i = 0, l = oK.zwe.length; i < l; i++)
         {
          iArr.push(_addEmoteToDoc(tInit, oK.zwe[i].url, 1, {style: s, classes: ['ktFireworkRocket']}, true, false, {x: cX - eWh, y: cY}));
         }
        }
        window.setTimeout(_explode, sendUp, tInit, kList, iArr, cX, cY, eH, sW, sH, iKC);
       }

       async function _explode(tInit, kList, iArr, cX, cY, eH, sW, sH, iKC)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         document.body.removeChild(iArr[i]);
         _eActive--;
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time);
        const kTime = Math.floor(tMS * timing.kappa.Fireworks.speed.burst);
        const fA = _kAcTime(iKC, kTime);
        const r = Math.min(sW, sH) * timing.kappa.Fireworks.radius.base;
        const inner = Math.max(3, Math.floor(iKC * timing.kappa.Fireworks.quantity.small));
        const core = Math.floor(iKC * timing.kappa.Fireworks.quantity.medium);
        const outer = Math.max(3, Math.floor(iKC * timing.kappa.Fireworks.quantity.large));
        const lK = kList.length;
        const sR = r * timing.kappa.Fireworks.radius.small;
        for (let v = 0; v < inner; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         let eW = eH;
         if (sK.hasOwnProperty('width') && sK.hasOwnProperty('height'))
          eW = sK.width / sK.height * eH;
         const sA = shared.rnd();
         _eActive--;
         _sparkler(tInit, sK.url, cX, cY, eW, eH, sR, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, eW, eH, sR, sA);
          }
         }
         if (v % fA.ct === fA.ct - 1)
          await _fPause(fA.f);
        }
        await _sleep(Math.floor(tMS * timing.kappa.Fireworks.delays.small));
        const mR = r * timing.kappa.Fireworks.radius.medium;
        const dT = Math.ceil(fA.ct / timing.kappa.Fireworks.spread);
        for (let v = 0; v < core; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         let eW = eH;
         if (sK.hasOwnProperty('width') && sK.hasOwnProperty('height'))
          eW = sK.width / sK.height * eH;
         const sA = shared.rnd();
         _eActive--;
         _sparkler(tInit, sK.url, cX, cY, eW, eH, mR, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, eW, eH, mR, sA);
          }
         }
         if (v % dT === dT - 1)
          await _fPause();
        }
        await _sleep(Math.floor(tMS * timing.kappa.Fireworks.delays.large));
        const lR = r * timing.kappa.Fireworks.radius.large;
        for (let v = 0; v < outer; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         let eW = eH;
         if (sK.hasOwnProperty('width') && sK.hasOwnProperty('height'))
          eW = sK.width / sK.height * eH;
         const sA = shared.rnd();
         _eActive--;
         _sparkler(tInit, sK.url, cX, cY, eW, eH, lR, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, eW, eH, lR, sA);
          }
         }
         if (v % fA.ct === fA.ct - 1)
          await _fPause(fA.f);
        }
       }

       function _sparkler(tInit, url, cX, cY, eW, eH, r, a)
       {
        if (_iTitanic > tInit)
         return;
        const th = a * _cRadius;
        const eWh = Math.ceil(eW / 2);
        const eX = cX - eWh;
        const hD = Math.floor(eX + r * Math.cos(th));
        const vD = Math.floor(cY + r * Math.sin(th));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        s += ' transform: translate(' + eX + 'px, ' + cY + 'px);';
        s += _styleEmote([], [], [], [], [], [], true, false, true, false, tMS);
        _addEmoteToDoc(tInit, url, 1, {style: s, classes: ['ktFireworkSparkler']}, false, {space: false, time: tMS}, {x: hD, y: vD});
       }

       return task;
      }();

      const $Spiral = function()
      {
       function task(kList, sW, sH, eH, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const oX = shared.rnd() * sW;
        const oY = shared.rnd(sH - eH);
        const r = Math.min(sW, sH);
        shared.doNextFrame(_init, tInit, kList, oX, oY, eH, r, iKC);
       }

       async function _init(tInit, kList, oX, oY, eH, r, iKC)
       {
        if (_iTitanic > tInit)
         return;
        const c = _cRadius / (_rndFromRange(timing.kappa.Spiral.vectors) + (shared.rnd() * 2));
        let th = shared.rnd() * _cRadius;
        const o = shared.rnd(2) === 0;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Spiral.time);
        let sA = _kAcTime(iKC, tMS);
        if (sA.ct > timing.kappa.Spiral.bulk)
         sA.ct = timing.kappa.Spiral.bulk;
        for (let i = 0; i < iKC; i++)
        {
         if (_iTitanic > tInit)
          return;
         if (o)
         {
          th -= c;
          if (th <= 0)
           th += _cRadius;
         }
         else
         {
          th += c;
          if (th >= _cRadius)
           th -= _cRadius;
         }
         const oK = kList[shared.rnd(kList.length)];
         let eW = eH;
         if (oK.hasOwnProperty('width') && oK.hasOwnProperty('height'))
          eW = oK.width / oK.height * eH;
         const eWh = Math.ceil(eW / 2);
         _eActive--;
         _sparkler(tInit, oK.url, oX - eWh, oY, eW, eH, r, th);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, m = oK.zwe.length; j < m; j++)
          {
           _sparkler(tInit, oK.zwe[j].url, oX - eWh, oY, eW, eH, r, th);
          }
         }
         if (i % sA.ct === sA.ct - 1)
          await _fPause(sA.f);
        }
       }

       function _sparkler(tInit, url, oX, oY, eW, eH, r, th)
       {
        if (_iTitanic > tInit)
         return;
        const hD = Math.floor(oX + r * Math.cos(th));
        const vD = Math.floor(oY + r * Math.sin(th));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Spiral.time);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
        s += _styleEmote([], [], [], [], [], [], true, false, true, false, tMS);
        _addEmoteToDoc(tInit, url, 1, {style: s, classes: ['ktSpiral']}, false, {space: false, time: tMS}, {x: hD, y: vD});
       }

       return task;
      }();

      const $Pyramid = function()
      {
       function task(kList, sW, sH)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let drawn = [];
        let ct = 0;
        const lP = pyramidDist.length;
        const eH = sW / lP;
        for (let i = 0; i < lP; i++)
        {
         drawn.push(0);
         ct += pyramidDist[i];
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Pyramid.time);
        const sT = tMS * timing.kappa.Pyramid.show.total;
        const tPerB = Math.max(Math.floor(sT / ct), timing.kappa.Pyramid.show.min);
        const eT = tPerB * ct;
        const dT = Math.floor(tMS * timing.kappa.Pyramid.pause);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lP);
         while (drawn[x] >= pyramidDist[x]);
         const oK = kList[shared.rnd(kList.length)];
         _block(tInit, oK.url, x, t, eH, sH, drawn[x] + 1, eT + dT);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _eActive++;
           _block(tInit, oK.zwe[j].url, x, t, eH, sH, drawn[x] + 1, eT + dT);
          }
         }
         drawn[x]++;
         t += tPerB;
        }
       }

       function _block(tInit, url, x, t, eH, sH, dX, aT)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote fit ktPyramid');
        _setImgSrc(img, url);
        const h = Math.floor(eH * x);
        const v = -1 * eH;
        const vD = sH - eH * dX;
        let s = 'top: 0px;';
        s += ' left: ' + h + 'px;';
        s += ' --emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        s += ' transform: translateY(' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tDrop, Math.floor(t / 10 + aT), tInit, img, sH);
        window.setTimeout(_tMove, t, tInit, img, vD);
       }

       function _tMove(tInit, img, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translateY(' + vD + 'px)';
       }

       function _tDrop(tInit, img, sH)
       {
        if (_iTitanic > tInit)
         return;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Pyramid.time);
        const pT = Math.floor(tMS * timing.kappa.Pyramid.hide);
        img.classList.replace('ktPyramid', 'ktPyramidDrop');
        img.style.transform = 'translateY(' + sH + 'px)';
        _gc.hook(img, false, true, pT);
       }

       return task;
      }();

      const $SmallPyramid = function()
      {
       function task(kList, sW, sH)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let drawn = [];
        let ct = 0;
        const lP = pyramidDist.length;
        const eH = Math.min(sW / lP, Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small));
        for (let i = 0; i < lP; i++)
        {
         drawn.push(0);
         ct += pyramidDist[i];
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.SmallPyramid.time);
        const sT = tMS * timing.kappa.SmallPyramid.show.total;
        const tPerB = Math.max(Math.floor(sT / ct), timing.kappa.SmallPyramid.show.min);
        const eT = tPerB * ct;
        const dT = Math.floor(tMS * timing.kappa.SmallPyramid.pause);
        const oX = shared.rnd(sW - eH * lP);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lP);
         while (drawn[x] >= pyramidDist[x]);
         const oK = kList[shared.rnd(kList.length)];
         _block(tInit, oK.url, oX, x, t, eH, sH, drawn[x] + 1, eT + dT);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _eActive++;
           _block(tInit, oK.zwe[j].url, oX, x, t, eH, sH, drawn[x] + 1, eT + dT);
          }
         }
         drawn[x]++;
         t += tPerB;
        }
       }

       function _block(tInit, url, oX, x, t, eH, sH, dX, aT)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote fit ktSmallPyramid');
        _setImgSrc(img, url);
        const h = oX + eH * x;
        const v = -1 * eH;
        const vD = sH - eH * dX;
        let s = 'top: 0px;';
        s += ' left: ' + h + 'px;';
        s += ' --emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        s += ' transform: translateY(' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tDrop, Math.floor(t / 10 + aT), tInit, img, sH);
        window.setTimeout(_tMove, t, tInit, img, vD);
       }

       function _tMove(tInit, img, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translateY(' + vD + 'px)';
       }

       function _tDrop(tInit, img, sH)
       {
        if (_iTitanic > tInit)
         return;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.SmallPyramid.time);
        const pT = Math.floor(tMS * timing.kappa.SmallPyramid.hide);
        img.classList.replace('ktSmallPyramid', 'ktSmallPyramidDrop');
        img.style.transform = 'translateY(' + sH + 'px)';
        _gc.hook(img, false, true, pT);
       }

       return task;
      }();

      const $Stampede = function()
      {
       async function task(kList, sW, sH, eH, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const bandHeight = eH * timing.kappa.Stampede.height;
        const d = shared.rnd(2) === 0;
        const bandTop = shared.rnd(sH - bandHeight + (eH * timing.kappa.Stampede.top.min) + (eH * timing.kappa.Stampede.top.max)) + (eH * (-1 * timing.kappa.Stampede.top.min));
        const b1 = _rndFromRange(timing.kappa.Stampede.bunch[1]);
        const b2 = shared.rnd(timing.kappa.Stampede.bunch[2] - b1) + b1;
        const b4 = _rndFromRange(timing.kappa.Stampede.bunch[4]);
        _eActive += b1 + b2 + iKC + b4;
        const hasB4 = b4 > 0;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Stampede.time);
        const tSpeed = Math.floor(tMS * timing.kappa.Stampede.speed);
        const t1 = Math.floor(tSpeed * timing.kappa.Stampede.pause['1']);
        let maxW = 0;
        for (let i = 0; i < kList.length; i++)
        {
         let eW = eH;
         if (kList[i].hasOwnProperty('width') && kList[i].hasOwnProperty('height'))
          eW = kList[i].width / kList[i].height * eH;
         if (eW > maxW)
          maxW = eW;
        }
        await _stampede(tInit, kList, b1, t1, false, bandTop, bandHeight, d, sW, eH, maxW);
        if (_iTitanic > tInit)
         return;
        const t2 = Math.floor(tSpeed * timing.kappa.Stampede.pause['2']);
        await _stampede(tInit, kList, b2, t2, false, bandTop, bandHeight, d, sW, eH, maxW);
        if (_iTitanic > tInit)
         return;
        let sA = _kAcTime(iKC, tMS);
        if (sA.ct > timing.kappa.Stampede.maxdensity)
         sA.ct = timing.kappa.Stampede.maxdensity;
        await _stampede(tInit, kList, iKC, hasB4, sA, bandTop, bandHeight, d, sW, eH, maxW);
        if (_iTitanic > tInit)
         return;
        if (hasB4)
         await _stampede(tInit, kList, b4, false, false, bandTop, bandHeight, d, sW, eH, maxW);
       }

       async function _stampede(tInit, kList, ct, pause, sA, bandTop, bandHeight, d, sW, eH, maxW)
       {
        if (_iTitanic > tInit)
         return;
        let imgs = [];
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         const oK = kList[shared.rnd(kList.length)];
         let eW = eH;
         if (oK.hasOwnProperty('width') && oK.hasOwnProperty('height'))
          eW = oK.width / oK.height * eH;
         const y = bandTop + shared.rnd(bandHeight);
         _eActive--;
         imgs.push(_run(tInit, oK.url, y, d, sW, eW, eH, maxW));
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _run(tInit, oK.zwe[j].url, y, d, sW, eW, eH, maxW);
          }
         }
         if (sA === false)
          await _sleep(_rndFromRange(timing.kappa.Stampede.smallSleep));
         else
         {
          if (i % sA.ct === sA.ct - 1)
          {
           let wF = sA.f;
           if (wF === 1)
            wF = shared.rnd(3);
           else
            wF *= (shared.rnd() * 3) / 2;
           if (wF !== 0)
            await _fPause(wF);
          }
         }
        }
        if (pause === false)
         return;
        if (pause !== true)
        {
         await _sleep(pause);
         return;
        }
        do
        {
         if (_iTitanic > tInit)
          return;
         await _sleep(100);
         for (let i = imgs.length - 1; i >= 0; i--)
         {
          if (imgs[i] === null || imgs[i].hasAttribute('deleted'))
           imgs.splice(i, 1);
         }
        } while (imgs.length > 0);
       }

       function _run(tInit, url, v, d, sW, eW, eH, maxW)
       {
        if (_iTitanic > tInit)
         return;
        const h = -2 * maxW;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Stampede.time);
        const tSpeed = Math.floor(tMS * timing.kappa.Stampede.speed);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        if (d)
         s += ' transform: translate(' + sW + 'px, ' + v + 'px);';
        else
         s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        s += _styleEmoteString([], [], [], [], [], []);
        let img;
        if (d)
         img = _addEmoteToDoc(tInit, url, 1, {style: s, classes: ['ktStampede']}, true, {space: false, time: tSpeed}, {x: h, y: v});
        else
         img = _addEmoteToDoc(tInit, url, 1, {style: s, classes: ['ktStampede']}, true, {space: false, time: tSpeed}, {x: sW, y: v});
        window.setTimeout(_tMark, tSpeed, tInit, img);
        return img;
       }

       function _tMark(tInit, img)
       {
        if (_iTitanic > tInit)
         return;
        if (img === null)
         return;
        if (img.parentNode !== null)
         document.body.removeChild(img);
        img.setAttribute('deleted', true);
       }

       return task;
      }();

      const $Conga = function()
      {
       async function task(kList, sW, sH, eH, nM)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let v = 0;
        let unique = false;
        const bS = Math.ceil(eH * timing.kappa.Conga.size);
        const seg = Math.floor(eH * timing.kappa.Conga.height);
        const sht = Math.floor(sH / seg);
        let lns = sht;
        if (nM)
         lns = timing.kappa.Conga.avoidMiddle;
        while (_conga.length >= lns)
        {
         if (_iTitanic > tInit)
          return;
         await _sleep(250);
        }
        while (!unique)
        {
         v = shared.rnd(sht) * seg;
         if (nM)
         {
          v = shared.rnd(timing.kappa.Conga.avoidMiddle);
          const hMid = Math.floor(timing.kappa.Conga.avoidMiddle / 2);
          if (v >= hMid)
           v = sht - 1 - (v - hMid);
          v *= seg;
         }
         let found = false;
         for (let i = 0, l = _conga.length; i < l; i++)
         {
          if (_conga[i].row === v)
          {
           found = true;
           break;
          }
         }
         if (!found)
          unique = true;
        }
        _conga.push({row: v, done: false});
        let urls = [];
        let zurls = [];
        const ct = Math.floor(sW / bS);
        for (let i = 0; i < ct; i++)
        {
         const oK = kList[shared.rnd(kList.length)];
         urls.push(oK.url);
         let oZ = [];
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           oZ.push(oK.zwe[j].url);
          }
         }
         zurls.push(oZ);
        }
        const d = v / seg % 2 === 0;
        const xtra = Math.floor((sW - ct * bS) / 2);
        let imgs = [];
        let zimgs = [];
        for (let i = 0; i < ct; i++)
        {
         imgs.push(_dance(tInit, urls[i], i, sW, v, eH, bS, ct, d, xtra));
         let oZ = [];
         for (let j = 0, l = zurls[i].length; j < l; j++)
         {
          oZ.push(_dance(tInit, zurls[i][j], i, sW, v, eH, bS, ct, d, xtra));
         }
         zimgs.push(oZ);
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Conga.time.show);
        await _sleep(tMS);
        let full = false;
        if (_conga.length === sht)
         full = true;
        await _sleep(Math.floor(cfg.display.kappa.conga.time * 1000));
        if (cfg.display.kappa.conga.contagious)
        {
         let ex = false;
         let lC = _conga.length;
         if (lC > 1)
          ex = true;
         for (let i = 0; i < lC; i++)
         {
          if (_conga[i].row !== v)
           continue;
          _conga[i].done = true;
          break;
         }
         let done = false;
         while (!done)
         {
          if (_iTitanic > tInit)
           return;
          lC = _conga.length;
          if (!ex && lC > 1)
           ex = true;
          let notDone = false;
          for (let i = 0; i < lC; i++)
          {
           if (_conga[i].done === false)
           {
            notDone = true;
            break;
           }
          }
          if (notDone === false)
           done = true;
          await _sleep(100);
         }
        }
        for (let i = 0, l = imgs.length; i < l; i++)
        {
         _endDance(tInit, imgs[i], i, sW, v, eH, bS, ct, d, xtra);
         for (let j = 0, m = zimgs[i].length; j < m; j++)
         {
          _endDance(tInit, zimgs[i][j], i, sW, v, eH, bS, ct, d, xtra);
         }
        }
        await _sleep(tMS);
        for (let i = 0, l = _conga.length; i < l; i++)
        {
         if (_conga[i].row !== v)
          continue;
         _conga.splice(i, 1);
         break;
        }
       }

       function _dance(tInit, url, col, sW, v, eH, bS, ct, d, xtra)
       {
        if (_iTitanic > tInit)
         return;
        let box = document.createElement('div');
        box.setAttribute('class', 'scene ktCongaIn');
        let img = document.createElement('img');
        img.setAttribute('class', 'dancer fit');
        _setImgSrc(img, url);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        img.setAttribute('style', s);
        let sE = bS * col + xtra;
        let sB = sE - sW;
        if (d)
        {
         sE = bS * (ct - 1 - col) + xtra;
         sB = sE + sW;
        }
        s = 'top: ' + v + 'px;';
        s += ' left: 0px;';
        s += ' height: ' + bS + 'px;';
        s += ' width: ' + bS + 'px;';
        s += ' z-index: ' + v + ';';
        s += ' transform: translateX(' + sB + 'px);';
        box.setAttribute('style', s);
        _eActive++;
        box.appendChild(img);
        document.body.appendChild(box);
        shared.doNextFrame(_tMove, tInit, box, sE);
        return box;
       }

       function _endDance(tInit, box, col, sW, v, eH, bS, ct, d, xtra)
       {
        if (_iTitanic > tInit)
         return;
        let sB = bS * col + xtra;
        let sE = sB + sW;
        if (d)
        {
         sB = bS * (ct - 1 - col) + xtra;
         sE = sB - sW;
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Conga.time.hide);
        box.classList.replace('ktCongaIn', 'ktCongaOut');
        _gc.hook(box, true, true, Math.ceil(tMS * 1.25));
        shared.doNextFrame(_tMove, tInit, box, sE);
       }

       function _tMove(tInit, box, sE)
       {
        if (_iTitanic > tInit)
         return;
        box.style.transform = 'translateX(' + sE + 'px)';
       }

       return task;
      }();

      const $TheCube = function()
      {
       function task(eInf, sW, sH, eH, bC, iR)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const eHh = Math.ceil(eH / 2);
        const nHh = eHh * -1;
        const sWm = Math.ceil(sW / 2);
        const sHm = Math.ceil(sH / 2);
        let scene = document.createElement('div');
        scene.setAttribute('class', 'scene fit cube kappa');
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.TheCube.time);
        let cube = document.createElement('div');
        cube.setAttribute('class', 'cube');
        cube.setAttribute('style', 'transform: translateZ(' + nHh + 'px);');
        if (!eInf.hasOwnProperty('zwe') || eInf.zwe.length === 0)
        {
         let cubeF = document.createElement('img');
         _setImgSrc(cubeF, eInf.url);
         cubeF.dataset.face = 'front';
         cube.appendChild(cubeF);
         let cubeB = document.createElement('img');
         _setImgSrc(cubeB, eInf.url);
         cubeB.dataset.face = 'back';
         cube.appendChild(cubeB);
         let cubeR = document.createElement('img');
         _setImgSrc(cubeR, eInf.url);
         cubeR.dataset.face = 'right';
         cube.appendChild(cubeR);
         let cubeL = document.createElement('img');
         _setImgSrc(cubeL, eInf.url);
         cubeL.dataset.face = 'left';
         cube.appendChild(cubeL);
         let cubeT = document.createElement('img');
         _setImgSrc(cubeT, eInf.url);
         cubeT.dataset.face = 'top';
         cube.appendChild(cubeT);
         let cubeU = document.createElement('img');
         _setImgSrc(cubeU, eInf.url);
         cubeU.dataset.face = 'bottom';
         cube.appendChild(cubeU);
        }
        else
        {
         const lZ = eInf.zwe.length;
         let cubeF = document.createElement('div');
         cubeF.dataset.face = 'front';
         let pctF = document.createElement('img');
         _setImgSrc(pctF, eInf.url);
         cubeF.appendChild(pctF);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeF.appendChild(pctZ);
         }
         cube.appendChild(cubeF);
         let cubeB = document.createElement('div');
         cubeB.dataset.face = 'back';
         let pctB = document.createElement('img');
         _setImgSrc(pctB, eInf.url);
         cubeB.appendChild(pctB);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeB.appendChild(pctZ);
         }
         cube.appendChild(cubeB);
         let cubeR = document.createElement('div');
         cubeR.dataset.face = 'right';
         let pctR = document.createElement('img');
         _setImgSrc(pctR, eInf.url);
         cubeR.appendChild(pctR);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeR.appendChild(pctZ);
         }
         cube.appendChild(cubeR);
         let cubeL = document.createElement('div');
         cubeL.dataset.face = 'left';
         let pctL = document.createElement('img');
         _setImgSrc(pctL, eInf.url);
         cubeL.appendChild(pctL);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeL.appendChild(pctZ);
         }
         cube.appendChild(cubeL);
         let cubeT = document.createElement('div');
         cubeT.dataset.face = 'top';
         let pctT = document.createElement('img');
         _setImgSrc(pctT, eInf.url);
         cubeT.appendChild(pctT);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeT.appendChild(pctZ);
         }
         cube.appendChild(cubeT);
         let cubeU = document.createElement('div');
         cubeU.dataset.face = 'bottom';
         let pctU = document.createElement('img');
         _setImgSrc(pctU, eInf.url);
         cubeU.appendChild(pctU);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeU.appendChild(pctZ);
         }
         cube.appendChild(cubeU);
        }
        scene.appendChild(cube);
        let h = shared.rnd(sW - eH);
        let v = shared.rnd(sH - eH);
        if (bC)
        {
         h = Math.floor(sWm - eHh);
         v = Math.floor(sHm - eHh);
        }
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        s += ' --cube-depth: ' + eHh + 'px;';
        s += ' perspective: ' + eH * 3 + 'px;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false, tMS);
        scene.setAttribute('style', s);
        document.body.appendChild(scene);
        _gc.hook(scene, false, 6, tMS);
        shared.doNextFrame(_tMove, tInit, cube, iR, eH);
       }

       function _tMove(tInit, cube, iR, eH)
       {
        if (_iTitanic > tInit)
         return;
        const nHh = Math.ceil(eH / 2) * -1;
        let rX = 0;
        let rY = 0;
        while (Math.abs(rX) + Math.abs(rY) < 45)
        {
         rX = (360 - shared.rnd() * 720) * iR;
         rY = (360 - shared.rnd() * 720) * iR;
        }
        cube.style.transform = 'translateZ(' + nHh + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
       }

       return task;
      }();

      const $Text = function()
      {
       let _mL = 0;

       function task(kList, sW, sH, sMsg, iTime)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const msgDist = _buildMsgArr(sMsg);
        let ct = 0;
        let ctT = 0;
        let drawn = [];
        const lM = msgDist.length;
        for (let x = 0; x < lM; x++)
        {
         const lX = msgDist[x].length;
         for (let y = 0; y < lX; y++)
         {
          if (msgDist[x][y] !== 0)
           ctT += 1;
         }
         ct += lX;
         drawn.push(0);
        }
        const eH = Math.min(Math.floor(sW / (lM + 2)), Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small));
        const tMS = Math.floor(iTime * 1000 * timing.kappa.Text.time);
        const sT = tMS * timing.kappa.Text.show.total;
        const tPerB = Math.max(Math.floor(sT / ct), timing.kappa.Text.show.min);
        const eT = tPerB * ctT;
        const lF = msgDist[0].length;
        const lFS = eH * lF;
        const vH = shared.rnd(sH - lFS) + lFS;
        const oX = shared.rnd(sW - eH * lM);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lM);
         while (drawn[x] >= msgDist[x].length);
         if (msgDist[x][drawn[x]] !== 0)
         {
          const oK = kList[shared.rnd(kList.length)];
          _block(tInit, oK.url, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, eH);
          if (oK.hasOwnProperty('zwe'))
          {
           for (let j = 0, l = oK.zwe.length; j < l; j++)
           {
            _block(tInit, oK.zwe[j].url, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, eH);
           }
          }
          t += tPerB;
         }
         drawn[x]++;
        }
       }

       function _buildMsgArr(s)
       {
        let o = [];
        let spc = [];
        if (_mL === 0)
        {
         for (let i = 0, k = Object.keys(alnumDist), l = k.length; i < l; i++)
         {
          _mL = Math.max(_mL, alnumDist[k[i]][0].length);
         }
        }
        for (let y = 0; y < _mL; y++)
        {
         spc.push(0);
        }
        for (let i = 0, l = s.length; i < l; i++)
        {
         if (i > 0)
          o.push(spc);
         if (s[i] === ' ')
         {
          o.push(spc);
          o.push(spc);
          continue;
         }
         const v = s[i];
         if (!alnumDist.hasOwnProperty(v))
          continue;
         const c = alnumDist[v];
         for (let x = 0, m = c.length; x < m; x++)
         {
          o.push(c[x]);
         }
        }
        return o;
       }

       function _block(tInit, url, vH, oX, dX, tPerB, eT, iTime, x, t, sH, eH)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote fit');
        _setImgSrc(img, url);
        const h = oX + eH * x;
        const v = -1 * eH;
        const vD = vH - eH * dX;
        let s = 'top: 0px;';
        s += ' left: ' + h + 'px;';
        s += ' --emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        s += ' transition: transform ' + tPerB + 'ms ease-in;';
        s += ' transform: translateY(' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        _eActive++;
        const tMS = Math.floor(iTime * 1000 * timing.kappa.Text.time);
        window.setTimeout(_tDrop, Math.floor(eT + tMS + t / 10), tInit, img, sH, tMS);
        window.setTimeout(_tMove, t, tInit, img, vD);
       }

       function _tMove(tInit, img, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translateY(' + vD + 'px)';
       }

       function _tDrop(tInit, img, sH, tMS)
       {
        if (_iTitanic > tInit)
         return;
        const pT = Math.floor(tMS * timing.kappa.Text.hide);
        img.style.transform = 'translateY(' + sH + 'px)';
        img.style.transitionDuration = pT + 'ms';
        _gc.hook(img, false, true, pT);
       }

       return task;
      }();

      return {
       Fireworks: $Fireworks,
       Spiral: $Spiral,
       Pyramid: $Pyramid,
       SmallPyramid: $SmallPyramid,
       Stampede: $Stampede,
       Conga: $Conga,
       TheCube: $TheCube,
       Text: $Text
      };
     }();

     function _canShowKappa(k)
     {
      if (cfg.emote.max < 1)
       return true;
      if (_eActive < 1)
       return true;
      let tC = cfg.display.kappa.count;
      if (k !== false)
       tC = _getKappaCountEstimate(k);
      let cM = Math.max(cfg.emote.max, tC);
      return _eActive + tC < cM;
     }

     function _showKappas()
     {
      if (_tKappa !== false)
      {
       window.clearTimeout(_tKappa);
       _tKappa = false;
      }
      if (_toKappa.length < 1)
       return;
      let nK = _getNextKappa(_toKappa[0]);
      if (nK === false)
       return;
      if (!_canShowKappa(nK))
      {
       _tKappa = window.setTimeout(_showKappas, _dKappa);
       return;
      }
      let e = null;
      while ((e = _toKappa.shift()) !== undefined)
      {
       nK = false;
       let a = {};
       a[e.style] = e.prefs;
       display.kappa.show(e.list, a, e.params);
       if (_toKappa.length < 1)
        return;
       nK = _getNextKappa(_toKappa[0]);
       if (nK === false)
        return;
       if (!_canShowKappa(nK))
       {
        if (cfg.emote.queue > 0 && _toKappa.length > cfg.emote.queue)
         _toKappa.splice(0, _toKappa.length - cfg.emote.queue);
        _tKappa = window.setTimeout(_showKappas, _dKappa);
        return;
       }
      }
     }

     function _getNextKappa(k)
     {
      let a = [];
      a[k.style] = k.prefs;
      return _getNextKappaEx(a, k.params);
     }

     function _getKappaCountParam(p)
     {
      const a = p.split(' ');
      for (let i = 0, l = a.length; i < l; i++)
      {
       if (!isNaN(a[i]))
        return parseInt(a[i], 10);
      }
      return false;
     }

     function _getNextKappaEx(kS = false, kP = false)
     {
      if (typeof kS !== 'object')
      {
       if (cfg.display.kappa.styles.length < 1)
        return false;
       kS = cfg.display.kappa.styles;
      }
      let s, p;
      const keys = Object.keys(kS);
      if (cfg.display.kappa.conga.contagious && _conga.length > 0)
      {
       s = 'Conga';
       p = {};
       if (keys.includes(s))
        p = kS[s];
      }
      else
      {
       s = keys[shared.rnd(keys.length)];
       p = kS[s];
      }
      if (s === undefined)
       return false;
      let iKC = cfg.display.kappa.count;
      if (cfg.display.kappa.styles.hasOwnProperty(s) && cfg.display.kappa.styles[s].hasOwnProperty('count') && cfg.display.kappa.styles[s].count > 0)
       iKC = cfg.display.kappa.styles[s].count;
      if (p === undefined)
       p = {};
      let pMax = cfg.emote.max;
      if (p.hasOwnProperty('count'))
      {
       let tKC = 0;
       if (Number.isInteger(p.count))
        tKC = p.count;
       else
       {
        if (p.count.hasOwnProperty('maximum'))
         pMax = p.count.maximum;
        if (p.count.hasOwnProperty('default'))
         tKC = p.count.default;
        if (p.count.hasOwnProperty('dynamic') && p.count.dynamic !== false)
        {
         if (p.hasOwnProperty('params') && p.params !== null)
         {
          const pC = _getKappaCountParam(p.params);
          if (pC !== false)
           tKC = pC;
         }
        }
       }
       if (tKC === -1 && kP !== false && kP.hasOwnProperty('%AMOUNT%') && Math.ceil(kP['%AMOUNT%']) > 0)
        tKC = Math.ceil(kP['%AMOUNT%']);
       if (tKC > 0)
        iKC = tKC;
      }
      if (pMax > 0 && iKC > pMax)
       iKC = pMax;
      return {style: s, prefs: p, count: iKC};
     }

     function _getKappaCountEstimate(k)
     {
      switch (k.style)
      {
       case 'Pyramid':
       case 'SmallPyramid':
        let c = 0;
        for (let i = 0, l = pyramidDist.length; i < l; i++)
         c += pyramidDist[i];
        return c;
       case 'Fireworks':
        const inner = Math.max(3, Math.floor(k.count * timing.kappa.Fireworks.quantity.small));
        const core = Math.floor(k.count * timing.kappa.Fireworks.quantity.medium);
        const outer = Math.max(3, Math.floor(k.count * timing.kappa.Fireworks.quantity.large));
        return 1 + inner + core + outer;
       case 'Conga':
        const sW = window.innerWidth;
        const sH = window.innerHeight;
        const eH = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
        const bS = Math.ceil(eH * timing.kappa.Conga.size);
        return Math.floor(sW / bS);
       case 'TheCube':
        return 6;
      }
      return k.count;
     }

     async function _StringArrayToEmoteArray(s)
     {
      let r = [];
      let idx = 0;
      for (let i = 0, l = s.length; i < l; i++)
      {
       let v = {};
       v.str = s[i];
       v.pos = idx;
       idx += s[i].length + 1;
       if (s[i].includes('//'))
       {
        v.svc = 'u';
        v.scope = 'g';
        v.url = s[i];
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('twitch') && thirdparty.emotes.twitch.hasOwnProperty(s[i]) && thirdparty.emotes.twitch[s[i]].scope === 'c')
       {
        v.svc = 't';
        v.url = thirdparty.emotes.twitch[s[i]].url;
        v.scope = thirdparty.emotes.twitch[s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('youtube') && thirdparty.emotes.youtube.hasOwnProperty(s[i]))
       {
        v.svc = 'y';
        v.url = thirdparty.emotes.youtube[s[i]].url;
        v.scope = thirdparty.emotes.youtube[s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('kick') && thirdparty.emotes.kick.hasOwnProperty(s[i]))
       {
        v.svc = 'k';
        v.url = thirdparty.emotes.kick[s[i]].url;
        v.scope = thirdparty.emotes.kick[s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('ffz') && thirdparty.emotes.ffz.hasOwnProperty(s[i]) && thirdparty.emotes.ffz[s[i]].scope === 'c')
       {
        v.svc = 'f';
        v.url = thirdparty.emotes.ffz[s[i]].url;
        v.scope = thirdparty.emotes.ffz[s[i]].scope;
        v.width = thirdparty.emotes.ffz[s[i]].width;
        v.height = thirdparty.emotes.ffz[s[i]].height;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('bttv') && thirdparty.emotes.bttv.hasOwnProperty(s[i]) && thirdparty.emotes.bttv[s[i]].scope === 'c')
       {
        v.svc = 'b';
        v.url = thirdparty.emotes.bttv[s[i]].url;
        v.scope = thirdparty.emotes.bttv[s[i]].scope;
        v.width = thirdparty.emotes.bttv[s[i]].width;
        v.height = thirdparty.emotes.bttv[s[i]].height;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('7tv') && thirdparty.emotes['7tv'].hasOwnProperty(s[i]) && thirdparty.emotes['7tv'][s[i]].scope === 'c')
       {
        v.svc = '7';
        v.url = thirdparty.emotes['7tv'][s[i]].url;
        v.scope = thirdparty.emotes['7tv'][s[i]].scope;
        v.width = thirdparty.emotes['7tv'][s[i]].width;
        v.height = thirdparty.emotes['7tv'][s[i]].height;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('twitch') && thirdparty.emotes.twitch.hasOwnProperty(s[i]) && thirdparty.emotes.twitch[s[i]].scope === 'g')
       {
        v.svc = 't';
        v.url = thirdparty.emotes.twitch[s[i]].url;
        v.scope = thirdparty.emotes.twitch[s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('ffz') && thirdparty.emotes.ffz.hasOwnProperty(s[i]) && thirdparty.emotes.ffz[s[i]].scope === 'g')
       {
        v.svc = 'f';
        v.url = thirdparty.emotes.ffz[s[i]].url;
        v.scope = thirdparty.emotes.ffz[s[i]].scope;
        v.width = thirdparty.emotes.ffz[s[i]].width;
        v.height = thirdparty.emotes.ffz[s[i]].height;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('bttv') && thirdparty.emotes.bttv.hasOwnProperty(s[i]) && thirdparty.emotes.bttv[s[i]].scope === 'g')
       {
        v.svc = 'b';
        v.url = thirdparty.emotes.bttv[s[i]].url;
        v.scope = thirdparty.emotes.bttv[s[i]].scope;
        v.width = thirdparty.emotes.bttv[s[i]].width;
        v.height = thirdparty.emotes.bttv[s[i]].height;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('7tv') && thirdparty.emotes['7tv'].hasOwnProperty(s[i]) && thirdparty.emotes['7tv'][s[i]].scope === 'g')
       {
        v.svc = '7';
        v.url = thirdparty.emotes['7tv'][s[i]].url;
        v.scope = thirdparty.emotes['7tv'][s[i]].scope;
        v.width = thirdparty.emotes['7tv'][s[i]].width;
        v.height = thirdparty.emotes['7tv'][s[i]].height;
        r.push(v);
        continue;
       }
       if (cfg.display.useEmoji !== false)
       {
        const eMoji = await service.parse.content.emoji(s[i], cfg.display.useEmoji, true);
        if (eMoji.length > 0)
        {
         v.svc = 'e';
         v.scope = 'g';
         const vStart = v.pos;
         for (let j = 0, m = eMoji.length; j < m; j++)
         {
          v.url = eMoji[j].url;
          v.str = eMoji[j].str;
          v.pos = vStart + eMoji[j].pos;
          r.push(v);
         }
         continue;
        }
       }
      }
      return r;
     }

     async function $show(kList, kStyles = false, kParams = false)
     {
      const kStyle = _getNextKappaEx(kStyles, kParams);
      if (kStyle === false)
       return;
      if (kStyle.style === undefined)
       return;
      if (kStyle.prefs.hasOwnProperty('emotes'))
      {
       let kForce = [];
       let bForce = false;
       if (Array.isArray(kStyle.prefs.emotes))
        kForce = kStyle.prefs.emotes;
       else
       {
        if (kStyle.prefs.emotes.hasOwnProperty('list'))
         kForce = kStyle.prefs.emotes.list;
        if (kStyle.prefs.emotes.hasOwnProperty('dynamic') && kStyle.prefs.emotes.dynamic === false)
         bForce = true;
       }
       if (!Array.isArray(kList) || kList.length < 1)
        bForce = true;
       if (bForce)
       {
        const fList = await _StringArrayToEmoteArray(kForce);
        if (fList.length > 0)
         kList = fList;
       }
      }
      if (!Array.isArray(kList) || kList.length < 1)
       kList = cSafe;
      if (!Array.isArray(kList) || kList.length < 1)
       kList = bareList;
      const sW = window.innerWidth;
      const sH = window.innerHeight;
      const eH = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
      const eHh = Math.max(cfg.emote.size.min, Math.min(Math.floor(cfg.emote.size.max / 2), Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small)));
      const sB = sH - eH;
      document.documentElement.style.setProperty('--height', sH + 'px');
      document.documentElement.style.setProperty('--width', sW + 'px');
      const waitFor = _getKappaCountEstimate(kStyle);
      if (!_canShowKappa(kStyle))
      {
       _toKappa.push({list: kList, style: kStyle.style, prefs: kStyle.prefs, params: kParams});
       if (_tKappa !== false)
       {
        window.clearTimeout(_tKappa);
        _tKappa = false;
       }
       _tKappa = window.setTimeout(_showKappas, _dKappa);
       return;
      }
      _eActive += waitFor;
      const lK = kList.length;
      const tInit = new Date().getTime();
      let estMS = Math.floor(cfg.emote.time * 1000);
      if (timing.kappa.hasOwnProperty(kStyle.style) && timing.kappa[kStyle.style].hasOwnProperty('time'))
       estMS = Math.floor(cfg.emote.time * 1000 * timing.kappa[kStyle.style].time);
      else if (timing.display.hasOwnProperty(kStyle.style) && timing.display[kStyle.style].hasOwnProperty('time'))
       estMS = Math.floor(cfg.emote.time * 1000 * timing.display[kStyle.style].time);
      switch (kStyle.style)
      {
       case 'Stampede':
        _eActive -= waitFor;
        await _list.Stampede(kList, sW, sH, eH, kStyle.count);
        break;
       case 'Fireworks':
        _list.Fireworks(kList, sW, sH, eHh, kStyle.count);
        break;
       case 'Spiral':
        _list.Spiral(kList, sW, sH, eHh, kStyle.count);
        break;
       case 'Pyramid':
        _list.Pyramid(kList, sW, sH);
        break;
       case 'SmallPyramid':
        _list.SmallPyramid(kList, sW, sH);
        break;
       case 'Conga':
        _eActive -= waitFor;
        let avoidMiddle = false;
        if (cfg.display.kappa.conga.hasOwnProperty('avoidMiddle') && cfg.display.kappa.conga.avoidMiddle === true)
         avoidMiddle = true;
        if (kStyle.prefs.hasOwnProperty('avoidMiddle') && kStyle.prefs.avoidMiddle === true)
         avoidMiddle = true;
        _list.Conga(kList, sW, sH, eH, avoidMiddle);
        break;
       case 'Text':
        _eActive -= waitFor;
        let sTM = 'HYPE!';
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('message'))
         sTM = cfg.display.kappa.styles[kStyle.style].message[shared.rnd(cfg.display.kappa.styles[kStyle.style].message.length)];
        if (kStyle.prefs.hasOwnProperty('message') && Array.isArray(kStyle.prefs.message) && kStyle.prefs.message.length > 0)
         sTM = kStyle.prefs.message[shared.rnd(kStyle.prefs.message.length)];
        let sTT = cfg.emote.time;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('time'))
         sTT = cfg.display.kappa.styles[kStyle.style].time;
        if (kStyle.prefs.hasOwnProperty('time') && kStyle.prefs.time > 0)
         sTT = kStyle.prefs.time;
        if (kParams !== false)
        {
         const pK = Object.keys(kParams);
         for (let i = 0, l = pK.length; i < l; i++)
         {
          sTM = sTM.replaceAll(pK[i], kParams[pK[i]]);
         }
        }
        _list.Text(kList, sW, sH, sTM, sTT);
        break;
       case 'TheCube':
        const cS = Math.min(sW, sH);
        const rC = shared.rnd(lK);
        let sCS = 8 / 10;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('size'))
         sCS = cfg.display.kappa.styles[kStyle.style].size;
        if (kStyle.prefs.hasOwnProperty('size'))
         sCS = kStyle.prefs.size;
        let sCC = true;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('center'))
         sCC = cfg.display.kappa.styles[kStyle.style].center;
        if (kStyle.prefs.hasOwnProperty('center'))
         sCC = kStyle.prefs.center;
        let sCR = 5;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('rotations'))
         sCR = cfg.display.kappa.styles[kStyle.style].rotations;
        if (kStyle.prefs.hasOwnProperty('rotations'))
         sCR = kStyle.prefs.rotations;
        _list.TheCube(kList[rC], sW, sH, Math.floor(cS * sCS), sCC, sCR);
        break;
       case 'Burst':
        const oH = _rndFromRange(timing.kappa[kStyle.style].left);
        const oV = _rndFromRange(timing.kappa[kStyle.style].top) * sB;
        const bA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rB = shared.rnd(lK);
         _eActive--;
         let eWb = eH;
         if (kList[rB].hasOwnProperty('width') && kList[rB].hasOwnProperty('height'))
          eWb = kList[rB].width / kList[rB].height * eH;
         const sRb = sW - Math.ceil(eWb / 2);
         display.emote.list.StraightLine(kList[rB], sW, sH, eH, oH * sRb, oV, false, tInit);
         if (i % bA.ct === bA.ct - 1)
          await _fPause(bA.f);
        }
        break;
       case 'Fountain':
        const fX = _rndFromRange(timing.kappa[kStyle.style].left) * sW;
        const fY = _rndFromRange(timing.kappa[kStyle.style].top);
        const fA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rF = shared.rnd(lK);
         _eActive--;
         display.emote.list.Fountain(kList[rF], sW, sH, eH, fX, fY, false, tInit);
         if (i % fA.ct === fA.ct - 1)
          await _fPause(fA.f);
        }
        break;
       case 'Confetti':
        const cA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rN = shared.rnd(lK);
         _eActive--;
         display.emote.list.Confetti(kList[rN], sW, sH, eHh, false, tInit);
         if (i % cA.ct === cA.ct - 1)
          await _fPause(cA.f);
        }
        break;
       default:
        if (typeof display.emote.list[kStyle.style] === 'undefined')
         return;
        const kA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const r = shared.rnd(lK);
         _eActive--;
         if (kStyle.style === 'StraightLine')
          display.emote.list.StraightLine(kList[r], sW, sH, eH, false, false, false, tInit);
         else
          display.emote.list[kStyle.style](kList[r], sW, sH, eH, false, tInit);
         if (i % kA.ct === kA.ct - 1)
          await _fPause(kA.f);
        }
      }
     }

     function $hide()
     {
      if (_tKappa !== false)
      {
       window.clearTimeout(_tKappa);
       _tKappa = false;
      }
      _toKappa.length = 0;
      _conga.length = 0;
     }

     function _sleep(ms)
     {
      if (ms < shared.mspf.value)
       return _fPause();
      return new Promise(
       function(resolve)
       {
        let n = 0;
        function _next(ts)
        {
         if (n === 0)
         {
          n = ts;
          window.requestAnimationFrame(_next);
          return;
         }
         else if (ts - n < ms)
         {
          window.requestAnimationFrame(_next);
          return;
         }
         resolve(true);
        }
        window.requestAnimationFrame(_next);
       }
      );
     }

     function _fPause(frames = 1)
     {
      return new Promise(
       function(resolve)
       {
        if (frames < 1)
        {
         resolve(false);
         return;
        }
        let n = 0;
        function _next()
        {
         n++;
         if (n < frames)
         {
          window.requestAnimationFrame(_next);
          return;
         }
         resolve(true);
        }
        window.requestAnimationFrame(_next);
       }
      );
     }

     function _kAcTime(ct, t = false)
     {
      if (t === false)
       t = Math.floor(cfg.emote.time * 1000);
      const f = Math.floor(t / shared.mspf.value);
      const r = f / ct;
      if (r > 1)
       return {f: Math.ceil(r), ct: 1};
      return {f: 1, ct: Math.ceil(1 / r)};
     }

     return {
      show: $show,
      hide: $hide
     };
    }();

    const _gc = function()
    {
     let _toGC = {};

     let _tGC = false;

     function _doGC()
     {
      if (_tGC === false)
       return;
      window.clearTimeout(_tGC);
      _tGC = false;
      let done = true;
      const tNow = new Date().getTime();
      for (const idx in _toGC)
      {
       if (!_toGC.hasOwnProperty(idx))
        continue;
       done = false;
       const i = _toGC[idx].img;
       const t = _toGC[idx].end;
       const d = _toGC[idx].dec;
       if (_toGC[idx].space)
       {
        const r = i.getBoundingClientRect();
        if (t > tNow && r.bottom > 0 && r.right > 0 && r.top < window.innerHeight && r.left < window.innerWidth)
         continue;
       }
       else
       {
        if (t > tNow)
         continue;
       }
       delete _toGC[idx];
       if (i.parentNode !== null)
        document.body.removeChild(i);
       if (d === true)
        _eActive--;
       else if (d !== false && !isNaN(d))
        _eActive -= d;
      }
      if (!done)
       _tGC = window.setTimeout(_doGC, 500);
     }

     function $hook(img, space = true, decActive = true, t = false)
     {
      if (t === false)
       t = Math.floor(cfg.emote.time * 1000);
      let x = 0;
      do
      {
       x++;
      } while (_toGC.hasOwnProperty(x));
      _toGC[x] = {img: img, space: space, dec: decActive, end: new Date().getTime() + t};
      if (_tGC === false)
       _tGC = window.setTimeout(_doGC, 500);
     }

     return {
      hook: $hook
     };
    }();

    function _rndFromRange(range)
    {
     return shared.rnd(range.max - range.min) + range.min;
    }

    function _safePoints(h, v, th, r, fL, fT, fR, fB)
    {
     const hD = Math.floor(h + r * Math.cos(th));
     const vD = Math.floor(v + r * Math.sin(th));
     const slope = Math.tan(th);
     let hL = Number.MAX_SAFE_INTEGER;
     let hU = 0;
     let vL = Number.MAX_SAFE_INTEGER;
     let vU = 0;
     if (hD < fL)
      hL = h - (hU = fL);
     else if (hD > fR)
      hL = (hU = fR) - h;
     if (vD < fT)
      vL = v - (vU = fT);
     else if (vD > fB)
      vL = (vU = fB) - v;
     if (vU === 0 && hU === 0)
      return true;
     let vT = vU;
     let hT = hU;
     if (hL > vL)
      hT = Math.floor((vT - v) / slope + h);
     else
      vT = Math.floor((hT - h) * slope + v);
     const l = Math.sqrt(Math.abs(h - hT) ** 2 + Math.abs(v - vT) ** 2);
     return (l > Math.ceil(r / 2));
    }

    function _addEmoteToDoc(tInit, uri, variationSize, attrs = {}, r = false, oGC = {}, oT = false)
    {
     if (_iTitanic > tInit)
      return;
     let img = document.createElement('img');
     let c = [];
     c.push('emote');
     if (attrs.hasOwnProperty('classes'))
      c.push(...attrs.classes);
     if (variationSize === 0)
      c.push('eHalf');
     else if (variationSize === 2)
      c.push('eDouble');
     else
      c.push('eNorm');
     img.classList.add(...c);
     _setImgSrc(img, uri);
     if (attrs.hasOwnProperty('style'))
      img.setAttribute('style', attrs.style);
     if (attrs.hasOwnProperty('dataset'))
     {
      for (let i = 0, k = Object.keys(attrs.dataset); i < k.length; i++)
      {
       img.setAttribute('data-' + k[i], attrs.dataset[k[i]]);
      }
     }
     _eActive++;
     document.body.appendChild(img);
     let space = true;
     let decActive = true;
     let t = false;
     if (oGC !== false)
     {
      if (oGC.hasOwnProperty('space'))
       space = oGC.space;
      if (oGC.hasOwnProperty('decrement'))
       decActive = oGC.decrement;
      if (oGC.hasOwnProperty('time'))
       t = oGC.time;
      _gc.hook(img, space, decActive, t);
     }
     if (oT !== false)
     {
      let sTF = null;
      if (oT.hasOwnProperty('x') && oT.hasOwnProperty('y'))
       sTF = 'translate(' + oT.x + 'px, ' + oT.y + 'px)';
      else if (oT.hasOwnProperty('x'))
       sTF = 'translateX(' + oT.x + 'px)';
      else if (oT.hasOwnProperty('y'))
       sTF = 'translateY(' + oT.y + 'px)';
      if (sTF !== null)
       shared.doNextFrame(_tMoveOnDock, tInit, img, sTF);
     }
     if (r)
      return img;
    }

    function _tMoveOnDock(tInit, img, sTF)
    {
     if (_iTitanic > tInit)
      return;
     img.style.transform = sTF;
    }

    function _setImgSrc(img, url)
    {
     img.alt = '';
     img.onload = function()
     {
      img.onerror = null;
      img.onload = null;
      if (img.naturalWidth !== img.naturalHeight)
       shared.ec.save(url, img.naturalWidth, img.naturalHeight);
     };
     img.onerror = function()
     {
      img.onerror = null;
      img.onload = null;
      img.src = bareList[shared.rnd(bareList.length)].url;
     };
     img.src = url;
    }

    function _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters)
    {
     let s = '';
     if (aNames.length > 0)
     {
      s += ' animation-name: ' + aNames.join() + ';';
      s += ' animation-delay: ' + aDelays.join() + ';';
      s += ' animation-duration: ' + aDurs.join() + ';';
      s += ' animation-timing-function: ' + aTimings.join() + ';';
      s += ' animation-fill-mode: ' + aFills.join() + ';';
      s += ' animation-iteration-count: ' + aIters.join() + ';';
     }
     if (aNames.includes('fadeIn'))
      s += ' opacity: 0;';
     return s;
    }

    function _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, fadeIn = true, zoomIn = true, fadeOut = true, zoomOut = true, tMS = false)
    {
     if (tMS === false)
      tMS = Math.floor(cfg.emote.time * 1000);
     const tFI = _tAnim.fade.in / 100;
     const tFO = _tAnim.fade.out / 100;
     const tZI = _tAnim.zoom.in / 100;
     const tZO = _tAnim.zoom.out / 100;
     if (fadeIn)
     {
      aNames.push('fadeIn');
      aDelays.push('0s');
      aDurs.push(Math.floor(tMS * tFI) + 'ms');
      aTimings.push('ease-in');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (zoomIn)
     {
      aNames.push('zoomIn');
      aDelays.push('0s');
      aDurs.push(Math.floor(tMS * tZI) + 'ms');
      aTimings.push('linear');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (fadeOut)
     {
      aNames.push('fadeOut');
      aDelays.push(Math.floor(tMS - tMS * tFO) + 'ms');
      aDurs.push(Math.floor(tMS * tFO) + 'ms');
      aTimings.push('ease-out');
      aFills.push('forwards');
      aIters.push('1');
     }
     else
     {
      aNames.push('noFadeOut');
      aDelays.push(tMS - 50 + 'ms');
      aDurs.push('50ms');
      aTimings.push('ease-out');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (zoomOut)
     {
      aNames.push('zoomOut');
      aDelays.push(Math.floor(tMS - tMS * tZO) + 'ms');
      aDurs.push(Math.floor(tMS * tZO) + 'ms');
      aTimings.push('linear');
      aFills.push('forwards');
      aIters.push('1');
     }
     return _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
    }

    function $eraseAll()
    {
     _iTitanic = new Date().getTime();
     display.kappa.hide();
     let cubes = document.getElementsByClassName('scene');
     while (cubes.length)
      cubes[0].parentElement.removeChild(cubes[0]);
     let imgs = document.getElementsByTagName('img');
     while (imgs.length)
      imgs[0].parentElement.removeChild(imgs[0]);
     twitch.parse.clearCooldowns();
     _eActive = 0;
    }

    return {
     emote: $emote,
     kappa: $kappa,
     eraseAll: $eraseAll
    };
   }();

   const twitch = function()
   {
    let _rList = {};
    let _aTagged = {};

    const $net = function()
    {
     async function _loadCheer_channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('cheer'))
       thirdparty.emotes.cheer = {};
      const url = cURLs.api.twitch.bits.cheermotes.replaceAll('%CHANNEL_ID%', chID);
      const h = {
       'Authorization': 'Bearer ' + cfg.twitch.oauth,
       'Client-Id': cfg.twitch.client
      };
      const r = await shared.httpRequest('GET', url, h);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('data'))
       return false;
      for (let c = 0, l = j.data.length; c < l; c++)
      {
       const set = j.data[c];
       if (!set.hasOwnProperty('prefix'))
        continue;
       if (!set.hasOwnProperty('tiers'))
        continue;
       const prefix = set.prefix;
       let tierList = [];
       for (let i = set.tiers.length - 1; i >= 0; i--)
       {
        if (!set.tiers[i].hasOwnProperty('min_bits'))
         continue;
        if (!set.tiers[i].hasOwnProperty('images'))
         continue;
        const amt = set.tiers[i].min_bits;
        let img = null;
        if (set.tiers[i].images.hasOwnProperty('dark'))
        {
         if (set.tiers[i].images.dark.hasOwnProperty('animated'))
         {
          if (set.tiers[i].images.dark.animated.hasOwnProperty('4'))
           img = set.tiers[i].images.dark.animated['4'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('3'))
           img = set.tiers[i].images.dark.animated['3'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('2'))
           img = set.tiers[i].images.dark.animated['2'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('1.5'))
           img = set.tiers[i].images.dark.animated['1.5'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('1'))
           img = set.tiers[i].images.dark.animated['1'];
         }
         else if (set.tiers[i].images.dark.hasOwnProperty('static'))
         {
          if (set.tiers[i].images.dark.static.hasOwnProperty('4'))
           img = set.tiers[i].images.dark.static['4'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('3'))
           img = set.tiers[i].images.dark.static['3'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('2'))
           img = set.tiers[i].images.dark.static['2'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('1.5'))
           img = set.tiers[i].images.dark.static['1.5'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('1'))
           img = set.tiers[i].images.dark.static['1'];
         }
        }
        else if (set.tiers[i].images.hasOwnProperty('light'))
        {
         if (set.tiers[i].images.light.hasOwnProperty('animated'))
         {
          if (set.tiers[i].images.light.animated.hasOwnProperty('4'))
           img = set.tiers[i].images.light.animated['4'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('3'))
           img = set.tiers[i].images.light.animated['3'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('2'))
           img = set.tiers[i].images.light.animated['2'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('1.5'))
           img = set.tiers[i].images.light.animated['1.5'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('1'))
           img = set.tiers[i].images.light.animated['1'];
         }
         else if (set.tiers[i].images.light.hasOwnProperty('static'))
         {
          if (set.tiers[i].images.light.static.hasOwnProperty('4'))
           img = set.tiers[i].images.light.static['4'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('3'))
           img = set.tiers[i].images.light.static['3'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('2'))
           img = set.tiers[i].images.light.static['2'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('1.5'))
           img = set.tiers[i].images.light.static['1.5'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('1'))
           img = set.tiers[i].images.light.static['1'];
         }
        }
        if (img === null)
         continue;
        tierList.push({min: amt, img: img});
       }
       thirdparty.emotes.cheer[prefix] = tierList;
      }
      return true;
     }

     const _eventSub = function()
     {
      let _wsURL = cURLs.ws.twitch.eventSub;
      let _wsRetry = null;
      let _ws = null;
      let _oldWS = null;
      let _lTimeout = 5000;
      let _tTimeout = false;
      const _lOldTimeout = 10000;
      let _tOldTimeout = false;

      function task(chID = null)
      {
       if (chID !== null)
        twitch.net.eventSubCtl.channelID = chID;
       _ws = new WebSocket(_wsURL);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      }

      function _wsClose()
      {
       notice.error(0x1A);
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws !== null)
       {
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
       }
       if (twitch.net.dead)
        return;
       if (_wsURL.length > cURLs.ws.twitch.eventSub.length && _wsURL.slice(0, cURLs.ws.twitch.eventSub.length) === cURLs.ws.twitch.eventSub)
        _wsURL = cURLs.ws.twitch.eventSub;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(_eventSub, wsWait);
      }

      async function _wsMessage(ev)
      {
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (twitch.net.dead)
       {
        if (_ws === null)
         return;
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        return;
       }
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
       const r = JSON.parse(ev.data);
       if (!r.hasOwnProperty('metadata'))
        return;
       if (!r.hasOwnProperty('payload'))
        return;
       notice.info(0x1A);
       switch (r.metadata.message_type)
       {
        case 'session_welcome':
         if (_oldWS !== null)
         {
          _oldWS.close();
          _oldWS = null;
          if (_tOldTimeout !== false)
          {
           window.clearTimeout(_tOldTimeout);
           _tOldTimeout = false;
          }
         }
         if (!r.payload.hasOwnProperty('session'))
          return;
         if (r.payload.session.hasOwnProperty('id'))
          twitch.net.eventSubCtl.sessionID = r.payload.session.id;
         if (r.payload.session.hasOwnProperty('keepalive_timeout_seconds'))
         {
          _lTimeout = parseInt(r.payload.session.keepalive_timeout_seconds, 10) * 2 * 1000;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
         }
         const haveSubs = await twitch.net.eventSubCtl.init();
         if (!haveSubs)
         {
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          if (_ws !== null)
          {
           _ws.onopen = null;
           _ws.onmessage = null;
           _ws.onclose = null;
           _ws.close();
           _ws = null;
          }
          return;
         }
         break;
        case 'session_keepalive':
         _wsRetry = 0;
         break;
        case 'notification':
         if (!r.metadata.hasOwnProperty('subscription_type'))
          return;
         switch (r.metadata.subscription_type)
         {
          case 'channel.follow':
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('user_id'))
            return;
           if (cfg.ignore.users !== false && r.payload.event.hasOwnProperty('user_login') && cfg.ignore.users.includes(r.payload.event.user_login))
            return;
           if (!r.payload.event.hasOwnProperty('user_name'))
            return;
           twitch.net.fList[r.payload.event.user_id] = {value: true, t: new Date().getTime()};
           if (cfg.event.twitch.follow === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           display.kappa.show(false, cfg.event.twitch.follow, {'%USER%': r.payload.event.user_name});
           break;
          case 'channel.channel_points_custom_reward_redemption.add':
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('reward'))
            return;
           if (!r.payload.event.reward.hasOwnProperty('title'))
            return;
           if (cfg.ignore.users !== false && r.payload.event.hasOwnProperty('user_login') && cfg.ignore.users.includes(r.payload.event.user_login))
            return;
           const n = r.payload.event.reward.title;
           if (!r.payload.event.hasOwnProperty('user_input') || r.payload.event.user_input === '')
           {
            await twitch.parse.event.redeem(n, false);
            return;
           }
           if (!r.payload.event.reward.hasOwnProperty('id'))
            return;
           const lnID = r.payload.event.reward.id;
           if (!_rList.hasOwnProperty(lnID))
           {
            _rList[lnID] = {name: n, cmds: []};
            return;
           }
           if (_rList[lnID].name === false)
            _rList[lnID].name = n;
           while (_rList[lnID].cmds.length > 0)
           {
            await twitch.parse.event.redeem(n, _rList[lnID].cmds.shift());
           }
           break;
          case 'channel.shoutout.create':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('to_broadcaster_user_id'))
            return;
           if (!r.payload.event.hasOwnProperty('to_broadcaster_user_name'))
            return;
           await twitch.parse.event.shoutoutCreate(r.payload.event.to_broadcaster_user_id, r.payload.event.to_broadcaster_user_name);
           break;
          case 'channel.shoutout.receive':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('from_broadcaster_user_id'))
            return;
           if (cfg.ignore.users !== false && r.payload.event.hasOwnProperty('from_broadcaster_user_login') && cfg.ignore.users.includes(r.payload.event.from_broadcaster_user_login))
            return;
           if (!r.payload.event.hasOwnProperty('from_broadcaster_user_name'))
            return;
           await twitch.parse.event.shoutoutReceive(r.payload.event.from_broadcaster_user_id, r.payload.event.from_broadcaster_user_name);
           break;
          case 'channel.hype_train.begin':
           if (cfg.event.twitch.hypetrain === false)
            return;
           if (!cfg.event.twitch.hypetrain.hasOwnProperty('begin'))
            return;
           if (cfg.event.twitch.hypetrain.begin === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           display.kappa.show(false, cfg.event.twitch.hypetrain.begin);
           break;
          case 'channel.hype_train.end':
           if (cfg.event.twitch.hypetrain === false)
            return;
           if (!cfg.event.twitch.hypetrain.hasOwnProperty('success'))
            return;
           if (cfg.event.twitch.hypetrain.success === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('level'))
            return;
           const rs = shared.findInMaybeRange(cfg.event.twitch.hypetrain.success, r.payload.event.level);
           if (rs === false)
            return;
           display.kappa.show(false, rs);
           break;
          case 'channel.poll.begin':
           if (cfg.event.twitch.poll === false)
            return;
           if (!cfg.event.twitch.poll.hasOwnProperty('begin'))
            return;
           if (cfg.event.twitch.poll.begin === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           display.kappa.show(false, cfg.event.twitch.poll.begin, {'%TITLE%': r.payload.event.title});
           break;
          case 'channel.poll.end':
           if (cfg.event.twitch.poll === false)
            return;
           if (!cfg.event.twitch.poll.hasOwnProperty('end'))
            return;
           if (cfg.event.twitch.poll.end === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           if (!r.payload.event.hasOwnProperty('status') || r.payload.event.status !== 'completed')
            return;
           if (!r.payload.event.hasOwnProperty('choices'))
            return;
           twitch.parse.event.pollEnd(r.payload.event);
           break;
          case 'channel.prediction.begin':
           if (cfg.event.twitch.prediction === false)
            return;
           if (!cfg.event.twitch.prediction.hasOwnProperty('begin'))
            return;
           if (cfg.event.twitch.prediction.begin === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           display.kappa.show(false, cfg.event.twitch.prediction.begin, {'%TITLE%': r.payload.event.title});
           break;
          case 'channel.prediction.end':
           if (cfg.event.twitch.prediction === false)
            return;
           if (!cfg.event.twitch.prediction.hasOwnProperty('resolved'))
            return;
           if (cfg.event.twitch.prediction.resolved === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           if (!r.payload.event.hasOwnProperty('status') || r.payload.event.status !== 'resolved')
            return;
           if (!r.payload.event.hasOwnProperty('winning_outcome_id'))
            return;
           if (!r.payload.event.hasOwnProperty('outcomes'))
            return;
           twitch.parse.event.predictionEnd(r.payload.event);
           break;
          case 'channel.charity_campaign.donate':
           if (cfg.event.twitch.charity === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('user_name'))
            return;
           const dName = r.payload.event.user_name;
           if (!r.payload.event.hasOwnProperty('amount'))
            return;
           if (!r.payload.event.amount.hasOwnProperty('value'))
            return;
           if (!r.payload.event.amount.hasOwnProperty('decimal_places'))
            return;
           if (!r.payload.event.amount.hasOwnProperty('currency'))
            return;
           const dAmt = r.payload.event.amount.value / Math.pow(10, r.payload.event.decimal_places) + ' ' + r.payload.event.amount.currency;
           const rd = shared.findInMaybeRange(cfg.event.twitch.charity, r.payload.event.amount.value);
           if (rd === false)
            return;
           display.kappa.show(false, rd, {'%USER%': dName, '%AMOUNT%': dAmt});
           break;
          case 'channel.goal.begin':
           if (cfg.event.twitch.goal === false)
            return;
           if (!cfg.event.twitch.goal.hasOwnProperty('begin'))
            return;
           if (cfg.event.twitch.goal.begin === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('type'))
            return;
           if (!r.payload.event.hasOwnProperty('description'))
            return;
           if (!r.payload.event.hasOwnProperty('target_amount'))
            return;
           display.kappa.show(false, cfg.event.twitch.goal.begin, {'%TITLE%': r.payload.event.description, '%TYPE%': r.payload.event.type, '%AMOUNT%': r.payload.event.target_amount});
           break;
          case 'channel.goal.end':
           if (cfg.event.twitch.goal === false)
            return;
           if (!cfg.event.twitch.goal.hasOwnProperty('achieved'))
            return;
           if (cfg.event.twitch.goal.achieved === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('type'))
            return;
           if (!r.payload.event.hasOwnProperty('description'))
            return;
           if (!r.payload.event.hasOwnProperty('current_amount'))
            return;
           if (!r.payload.event.hasOwnProperty('is_achieved') || r.payload.event.is_achieved !== true)
            return;
           display.kappa.show(false, cfg.event.twitch.goal.achieved, {'%TITLE%': r.payload.event.description, '%TYPE%': r.payload.event.type, '%AMOUNT%': r.payload.event.current_amount});
           break;
          case 'channel.update':
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           await _addToChannelTitleTags(r.payload.event.title);
           break;
         }
         break;
        case 'session_reconnect':
         if (!r.payload.hasOwnProperty('session'))
          return;
         if (_tTimeout !== false)
         {
          window.clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         if (r.payload.session.hasOwnProperty('id'))
          twitch.net.eventSubCtl.sessionID = r.payload.session.id;
         if (r.payload.session.hasOwnProperty('keepalive_timeout_seconds') && r.payload.session.keepalive_timeout_seconds !== null)
          _lTimeout = parseInt(r.payload.session.keepalive_timeout_seconds, 10) * 2 * 1000;
         if (_ws !== null)
         {
          if (r.payload.session.hasOwnProperty('reconnect_url'))
           _wsURL = r.payload.session.reconnect_url;
          _oldWS = _ws;
          _oldWS.onclose = null;
          _oldWS.onmessage = null;
          _tOldTimeout = window.setTimeout(_oldWSTimeout, _lOldTimeout);
          _ws = null;
         }
         const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
         if (_wsRetry < 2)
          _wsRetry += 0.2;
         window.setTimeout(_eventSub, wsWait);
         break;
        case 'revocation':
         if (!r.metadata.hasOwnProperty('subscription_type'))
          return;
         const subType = r.metadata.subscription_type;
         let subVer = '1';
         if (r.metadata.hasOwnProperty('subscription_version'))
          subVer = r.metadata.subscription_version;
         await twitch.net.eventSubCtl.subscribe(subType, subVer);
         break;
       }
      }

      function _wsTimeout()
      {
       notice.error(0x1A);
       _lTimeout = 5000;
       if (_wsURL.length > cURLs.ws.twitch.eventSub.length && _wsURL.slice(0, cURLs.ws.twitch.eventSub.length) === cURLs.ws.twitch.eventSub)
        _wsURL = cURLs.ws.twitch.eventSub;
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (twitch.net.dead === true)
        return;
       _eventSub();
      }

      function _oldWSTimeout()
      {
       if (_tOldTimeout !== false)
       {
        window.clearTimeout(_tOldTimeout);
        _tOldTimeout = false;
       }
       if (_oldWS === null)
        return;
       _oldWS.onopen = null;
       _oldWS.onmessage = null;
       _oldWS.onclose = null;
       _oldWS.close();
       _oldWS = null;
      }

      return task;
     }();

     const $eventSubCtl = function()
     {
      async function $init()
      {
       const aSubs = [
        {id: 'channel.follow', v: '2', scope: ['moderator:read:followers'], cfg: ['event.twitch.follow']},
        {id: 'channel.channel_points_custom_reward_redemption.add', scope: ['channel:read:redemptions'], cfg: false},
        {id: 'channel.shoutout.create', scope: ['moderator:read:shoutouts'], cfg: ['event.twitch.shoutout.create.styles']},
        {id: 'channel.shoutout.receive', scope: ['moderator:read:shoutouts'], cfg: ['event.twitch.shoutout.receive.styles']},
        {id: 'channel.hype_train.begin', scope: ['channel:read:hype_train'], cfg: ['event.twitch.hypetrain.begin']},
        {id: 'channel.hype_train.end', scope: ['channel:read:hype_train'], cfg: ['event.twitch.hypetrain.success']},
        {id: 'channel.poll.begin', scope: ['channel:read:polls'], cfg: ['event.twitch.poll.begin']},
        {id: 'channel.poll.end', scope: ['channel:read:polls'], cfg: ['event.twitch.poll.end']},
        {id: 'channel.prediction.begin', scope: ['channel:read:predictions'], cfg: ['event.twitch.prediction.begin']},
        {id: 'channel.prediction.end', scope: ['channel:read:predictions'], cfg: ['event.twitch.prediction.resolved']},
        {id: 'channel.goal.begin', scope: ['channel:read:goals'], cfg: ['event.twitch.goal.begin']},
        {id: 'channel.goal.end', scope: ['channel:read:goals'], cfg: ['event.twitch.goal.achieved']},
        {id: 'channel.charity_campaign.donate', scope: ['channel:read:charity'], cfg: ['event.twitch.charity']},
        {id: 'channel.update', scope: false, cfg: ['event.twitch.tag.styles']}
       ];
       const aActive = await _cleanAndRecover();
       let didSomething = aActive.length > 0;
       for (let i = 0, l = aSubs.length; i < l; i++)
       {
        if (await _handleSub(aSubs[i], aActive) !== false)
         didSomething = true;
       }
       return didSomething;
      }

      async function _handleSub(sub, aActive)
      {
       if (sub.hasOwnProperty('cfg') && sub.cfg !== false)
       {
        let found = true;
        for (let i = 0, l = sub.cfg.length; i < l; i++)
        {
         let aPref = sub.cfg[i].split('.');
         let cPref = cfg;
         found = true;
         for (let j = 0, m = aPref.length; j < m; j++)
         {
          if (!cPref.hasOwnProperty(aPref[j]))
          {
           found = false;
           break;
          }
          if (cPref[aPref[j]] === false)
          {
           found = false;
           break;
          }
          cPref = cPref[aPref[j]];
         }
         if (found !== false)
          break;
        }
        if (found === false)
         return false;
       }
       else if (sub.id === 'channel.channel_points_custom_reward_redemption.add')
       {
        let found = false;
        for (const k of cfg.commands)
        {
         if (!k.hasOwnProperty('redeem') || !Array.isArray(k.redeem) || k.redeem.length < 1)
          continue;
         found = true;
         break;
        }
        if (found === false)
         return false;
       }
       if (sub.hasOwnProperty('scope') && sub.scope !== false)
       {
        for (let i = 0, l = sub.scope.length; i < l; i++)
        {
         if (!cfg.twitch.scope.includes(sub.scope[i]))
          return false;
        }
       }
       if (aActive.includes(sub.id))
        return false;
       if (!sub.hasOwnProperty('v'))
        return twitch.net.eventSubCtl.subscribe(sub.id);
       return twitch.net.eventSubCtl.subscribe(sub.id, sub.v);
      }

      async function _getList()
      {
       const h = {
        'Authorization': 'Bearer ' + cfg.twitch.oauth,
        'Client-Id': cfg.twitch.client
       };
       const r = await shared.httpRequest('GET', cURLs.api.twitch.eventSub.get, h);
       if (!r.success)
        return [];
       const j = r.json;
       if (j === null)
        return [];
       if (!j.hasOwnProperty('data'))
        return [];
       if (!j.hasOwnProperty('total'))
        return [];
       if (j.total < 1)
        return [];
       return j.data;
      }

      async function $erase()
      {
       const d = await _getList();
       if (d.length < 1)
        return;
       for (let i = 0, l = d.length; i < l; i++)
       {
        if (!d[i].hasOwnProperty('id'))
         continue;
        await _unsubscribe(d[i].id);
       }
       window.location.reload();
      }

      async function _cleanAndRecover()
      {
       const d = await _getList();
       if (d.length < 1)
        return [];
       let rList = [];
       for (let i = 0, l = d.length; i < l; i++)
       {
        if (!d[i].hasOwnProperty('id'))
         continue;
        if (!d[i].hasOwnProperty('status'))
         continue;
        switch (d[i].status)
        {
         case 'enabled':
          if (!d[i].hasOwnProperty('type'))
           continue;
          if (!d[i].hasOwnProperty('transport'))
           continue;
          if (!d[i].transport.hasOwnProperty('method'))
           continue;
          if (d[i].transport.method !== 'websocket')
           continue;
          if (!d[i].transport.hasOwnProperty('session_id'))
           continue;
          if (d[i].transport.session_id !== twitch.net.eventSubCtl.sessionID)
           continue;
          rList.push(d[i].type);
          break;
         case 'authorization_revoked':
         case 'moderator_removed':
         case 'user_removed':
         case 'version_removed':
         case 'websocket_disconnected':
         case 'websocket_failed_ping_pong':
         case 'websocket_received_inbound_traffic':
         case 'websocket_connection_unused':
         case 'websocket_internal_error':
         case 'websocket_network_timeout':
         case 'websocket_network_error':
          await _unsubscribe(d[i].id);
          break;
        }
       }
       return rList;
      }

      async function $subscribe(type, version = '1')
      {
       let d = {
        'type': type,
        'version': version,
        'condition': {'broadcaster_user_id': twitch.net.eventSubCtl.channelID},
        'transport': {'method': 'websocket', 'session_id': twitch.net.eventSubCtl.sessionID}
       };
       switch (type)
       {
        case 'channel.follow':
        case 'channel.shoutout.create':
        case 'channel.shoutout.receive':
         d.condition.moderator_user_id = twitch.net.eventSubCtl.channelID;
         break;
       }
       const h = {
        'Authorization': 'Bearer ' + cfg.twitch.oauth,
        'Client-Id': cfg.twitch.client,
        'Content-Type': 'application/json'
       };
       const r = await shared.httpRequest('POST', cURLs.api.twitch.eventSub.get, h, JSON.stringify(d), false);
       if (r.success)
        return true;
       if (r.code === 429)
       {
        const eNote = document.getElementById('notice' + 0x1A);
        if (!eNote || !eNote.classList.contains('noticeWarning'))
         notice.warning(0x1A);
       }
       return false;
      }

      async function _unsubscribe(id)
      {
       const h = {
        'Authorization': 'Bearer ' + cfg.twitch.oauth,
        'Client-Id': cfg.twitch.client
       };
       const r = await shared.httpRequest('DELETE', cURLs.api.twitch.eventSub.delete.replaceAll('%ID%', id), h, null, false);
       if (!r.success)
        return false;
       return true;
      }

      return {
       init: $init,
       subscribe: $subscribe,
       erase: $erase,
       channelID: 0,
       sessionID: null
      };
     }();

     const $irc = function()
     {
      let _wsRetry = 0;
      let _firstRS = true;
      let _ws = null;
      const _lPing = 30000;
      const _lTimeout = 35000;
      const _lExpire = 5000;
      let _tTimeout = false;
      let _tExpire = false;
      let _tPing = 0;

      function task()
      {
       _tPing = 0;
       _firstRS = true;
       _ws = new WebSocket(cURLs.ws.twitch.irc);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
       _tExpire = window.setTimeout(_wsExpire, _lExpire);
       _ws.send('CAP REQ :twitch.tv/commands twitch.tv/tags');
       _ws.send('PASS oauth:' + cfg.twitch.oauth);
       _ws.send('NICK ' + cfg.twitch.channel);
       _ws.send('JOIN #' + cfg.twitch.channel);
      }

      function _wsClose()
      {
       notice.error(0x12);
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(twitch.net.irc, wsWait);
      }

      async function _wsMessage(ev)
      {
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       _tPing = window.setInterval(_wsPing, _lPing);
       if (_ws === null)
        return;
       if (twitch.net.dead)
       {
        if (_tExpire !== false)
        {
         window.clearTimeout(_tExpire);
         _tExpire = false;
        }
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        return;
       }
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
       _wsRetry = 0;
       const data = ev.data.split('\r\n');
       for (let i = 0, l = data.length; i < l; i++)
       {
        if (data[i].length === 0)
         continue;
        let cmd = twitch.parse.message(data[i]);
        if (cmd === false)
        {
         console.log('Unparsed IRC Command: ', data[i]);
         continue;
        }
        notice.info(0x12);
        switch (cmd.command)
        {
         case 'PING':
          if (_ws.readyState === 1)
           _ws.send('PONG ' + cmd.params[0]);
          if ((loginT.cfgVals() & 0x02) === 0x02)
          {
           await twitch.net.oAuth.update();
           if ((loginT.cfgVals() & 0x04) !== 0x04)
            notice.error(0x11);
          }
          break;
         case 'PRIVMSG':
          if (document.visibilityState === 'hidden')
           continue;
          if (cmd.params.length > 1)
           cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d');
          if (await twitch.parse.event.cheer(cmd))
           continue;
          if (await twitch.parse.event.hypechat(cmd))
           continue;
          twitch.parse.line(cmd);
          break;
         case 'NOTICE':
          if (cmd.params.length > 1 && cmd.params[1] === 'Login authentication failed')
          {
           if (_tExpire !== false)
           {
            window.clearTimeout(_tExpire);
            _tExpire = false;
           }
           if (_tTimeout !== false)
           {
            window.clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           if (_tPing !== 0)
           {
            window.clearInterval(_tPing);
            _tPing = 0;
           }
           _ws.onmessage = null;
           _ws.onclose = null;
           _ws.close();
           _ws = null;
           if (await twitch.net.oAuth.reinit())
           {
            window.setTimeout(twitch.net.irc, 1000);
            return;
           }
           twitch.net.dead = true;
           notice.error(0x11);
           if (!loginT.inUse)
            twitch.net.oAuth.clear(true);
          }
          break;
         case 'ROOMSTATE':
          if (!cmd.hasOwnProperty('tags'))
           continue;
          if (!cmd.tags.hasOwnProperty('room-id'))
           continue;
          const newID = twitch.net.channelID !== cmd.tags['room-id'];
          twitch.net.channelID = cmd.tags['room-id'];
          if (_firstRS)
          {
           if (_tExpire !== false)
           {
            window.clearTimeout(_tExpire);
            _tExpire = false;
           }
           _firstRS = false;
           if (newID)
           {
            await _loadEmote_channel(twitch.net.channelID);
            await _loadCheer_channel(twitch.net.channelID);
            if (cfg.event.twitch.tag.hasOwnProperty('styles') && cfg.event.twitch.tag.styles !== false)
             await _getChannelTitleTags(twitch.net.channelID);
            if (cfg.display.extended.useFFZ)
             thirdparty.ffz.channel(twitch.net.channelID);
            if (cfg.display.extended.useBTTV)
            {
             thirdparty.bttv.channel('twitch', twitch.net.channelID);
             thirdparty.bttv.socket.join('twitch', twitch.net.channelID);
            }
            if (cfg.display.extended.use7TV)
            {
             thirdparty['7tv'].channel('twitch', twitch.net.channelID);
             await thirdparty['7tv'].socket.join('twitch', twitch.net.channelID);
            }
            if (cfg.display.extended.useFFZ | cfg.display.extended.use7TV)
             thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval);
            if (cfg.display.extended.useBTTV)
             thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, thirdparty.interval);
            _eventSub(twitch.net.channelID);
           }
          }
          break;
         case 'USERNOTICE':
          if (document.visibilityState === 'hidden')
           continue;
          if (!cmd.hasOwnProperty('tags'))
           continue;
          if (!cmd.tags.hasOwnProperty('msg-id'))
           continue;
          if (cmd.params.length > 1)
           cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d');
          switch (cmd.tags['msg-id'])
          {
           case 'raid':
            twitch.parse.event.raid(cmd);
            break;
           case 'sub':
           case 'resub':
           case 'subgift':
           case 'submysterygift':
           case 'giftpaidupgrade':
           case 'primepaidupgrade':
            twitch.parse.event.sub(cmd);
            break;
           case 'bitsbadgetier':
            twitch.parse.event.badge(cmd);
            break;
           default:
            if (cmd.params.length > 1)
             twitch.parse.line(cmd);
            break;
          }
          break;
         case 'CLEARCHAT':
          switch (cmd.params.length)
          {
           case 1:
            if (cfg.event.twitch.clear)
             display.eraseAll();
            break;
           case 2:
            if (document.visibilityState === 'hidden')
             continue;
            if (cmd.tags.hasOwnProperty('ban-duration'))
            {
             if (cfg.event.twitch.timeout !== false)
             await twitch.parse.event.timeout(cmd);
            }
            else
            {
             if (cfg.event.twitch.ban !== false)
              await twitch.parse.event.ban(cmd);
            }
            break;
          }
          break;
         case 'RECONNECT':
          if (_tExpire !== false)
          {
           window.clearTimeout(_tExpire);
           _tExpire = false;
          }
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          if (_tPing !== 0)
          {
           window.clearInterval(_tPing);
           _tPing = 0;
          }
          _ws.onmessage = null;
          _ws.onclose = null;
          _ws.close();
          _ws = null;
          if (twitch.net.dead === true)
           return;
          window.setTimeout(twitch.net.irc, 1000);
          break;
        }
       }
      }

      function _wsExpire()
      {
       notice.error(0x12);
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_ws === null)
        return;
       if (twitch.net.dead === true)
        return;
       twitch.net.dead = true;
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       _ws.close();
       _ws = null;
      }

      function _wsPing()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send('PING');
      }

      function _wsTimeout()
      {
       notice.error(0x12);
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (twitch.net.dead === true)
        return;
       twitch.net.irc();
      }

      return task;
     }();

     async function _loadEmote_channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('twitch'))
       thirdparty.emotes.twitch = {};
      const r = await _findEmote_channel(chID, thirdparty.emotes.twitch);
      if (r === false)
       return false;
      if (cList.length === 0)
       cList = r;
      else
      {
       for (let n in thirdparty.emotes.twitch)
       {
        if (!thirdparty.emotes.twitch[n].hasOwnProperty('scope'))
         continue;
        if (thirdparty.emotes.twitch[n].scope !== 'c')
         continue;
        for (let c = cList.length - 1; c >= 0; c--)
        {
         if (cList[c].url !== thirdparty.emotes.twitch[n].url)
          continue;
         cList.splice(c, 1);
         break;
        }
       }
       for (let i = 0, l = r.length; i < l; i++)
       {
        if (!cList.includes(r[i]))
         cList.push(r[i]);
       }
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     async function $userInfo(u, isID = false)
     {
      let url = cURLs.api.twitch.users.name.replaceAll('%USER%', u);
      if (isID)
       url = cURLs.api.twitch.users.id.replaceAll('%USER_ID%', u);
      const h = {
       'Authorization': 'Bearer ' + cfg.twitch.oauth,
       'Client-Id': cfg.twitch.client
      };
      const r = await shared.httpRequest('GET', url, h);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('data'))
       return false;
      if (j.data.length !== 1)
       return false;
      return j.data[0];
     }

     async function _getChannelTitleTags(chID)
     {
      const url = cURLs.api.twitch.channels.root.replaceAll('%CHANNEL_ID%', chID);
      const h = {
       'Authorization': 'Bearer ' + cfg.twitch.oauth,
       'Client-Id': cfg.twitch.client
      };
      const r = await shared.httpRequest('GET', url, h);
      if (!r.success)
       return;
      const j = r.json;
      if (j === null)
       return;
      if (!j.hasOwnProperty('data'))
       return;
      if (j.data.length !== 1)
       return;
      if (!j.data[0].hasOwnProperty('title'))
       return;
      await _addToChannelTitleTags(j.data[0].title);
     }

     async function _addToChannelTitleTags(title)
     {
      const tReg = /(?:^| )(?:@([A-Za-z0-9_]+))/g;
      let tList = [];
      let match = '';
      while ((match = tReg.exec(title)) !== null)
      {
       tList.push(match);
      }
      if (tList.length < 1)
       return;
      _aTagged = {};
      for (let i = 0, l = tList.length; i < l; i++)
      {
       if (tList[i][1].length < 1)
        continue;
       let u = await twitch.net.userInfo(tList[i][1]);
       if (u === false)
        continue;
       if (!u.hasOwnProperty('id'))
        continue;
       if (!u.hasOwnProperty('login'))
        continue;
       _aTagged[u.login] = u.id;
      }
     }

     const $oAuth = function()
     {
      async function _getToken(t)
      {
       const url = cURLs.api.rr.refresh.t;
       const h = {'Content-Type': 'application/x-www-form-urlencoded'};
       let b = 'refresh=' + encodeURIComponent(t);
       if (cfg.twitch.share)
        b += '&share=1';
       const r = await shared.httpRequest('POST', url, h, b, false);
       if (!r.success)
       {
        if (r.code === 401)
        {
         notice.error(0x11);
         twitch.net.oAuth.clear(true);
        }
        return false;
       }
       const j = r.json;
       if (j === null)
        return false;
       if (!j.hasOwnProperty('access_token'))
        return false;
       if (!j.hasOwnProperty('refresh_token'))
        return false;
       return j;
      }

      async function $update()
      {
       const lsOAuth = window.localStorage.getItem(loginT.path() + '.oauth');
       const lsRefresh = window.localStorage.getItem(loginT.path() + '.refresh');
       const lsRefreshed = window.localStorage.getItem(loginT.path() + '.refreshed');
       if (lsOAuth !== null)
        cfg.twitch.oauth = lsOAuth;
       if (lsRefresh !== null)
        cfg.twitch.oauth_refresh = lsRefresh;
       if (lsRefreshed !== null)
        cfg.twitch.oauth_refreshed = lsRefreshed;
       if (cfg.twitch.hasOwnProperty('oauth_refreshed') && cfg.twitch.oauth_refreshed > 0)
       {
        const tokAge = Math.floor(new Date().getTime() / 1000) - cfg.twitch.oauth_refreshed;
        if (tokAge < 60 * 60)
         return;
       }
       const ret = await _getToken(cfg.twitch.oauth_refresh);
       if (ret === false)
        return;
       cfg.twitch.oauth = ret.access_token;
       cfg.twitch.oauth_refresh = ret.refresh_token;
       cfg.twitch.oauth_refreshed = Math.floor(new Date().getTime() / 1000);
       window.localStorage.setItem(loginT.path() + '.oauth', cfg.twitch.oauth);
       window.localStorage.setItem(loginT.path() + '.refresh', cfg.twitch.oauth_refresh);
       window.localStorage.setItem(loginT.path() + '.refreshed', cfg.twitch.oauth_refreshed);
      }

      async function $reinit()
      {
       if ((loginT.cfgVals() & 0x02) === 0x02)
       {
        twitch.net.oAuth.clear();
        await twitch.net.oAuth.update();
        if ((loginT.cfgVals() & 0x04) === 0x04)
         return true;
        twitch.net.oAuth.clear(true);
       }
       return false;
      }

      function $clear(clearRefresh = false)
      {
       cfg.twitch.oauth = 'OAUTH_ID';
       delete cfg.twitch.oauth_refreshed;
       window.localStorage.removeItem(loginT.path() + '.oauth');
       window.localStorage.removeItem(loginT.path() + '.refreshed');
       if (!clearRefresh)
        return;
       cfg.twitch.channel = 'CHANNEL_NAME';
       cfg.twitch.oauth_refresh = 'OAUTH_REFRESH';
       cfg.twitch.client = oauthClient.t;
       cfg.twitch.scope = [];
       window.localStorage.removeItem(loginT.path() + '.channel');
       window.localStorage.removeItem(loginT.path() + '.refresh');
       window.localStorage.removeItem(loginT.path() + '.client');
       window.localStorage.removeItem(loginT.path() + '.scope');
      }

      return {
       update: $update,
       reinit: $reinit,
       clear: $clear
      };
     }();

     return {
      channelID: 0,
      fList: {},
      dead: false,
      eventSubCtl: $eventSubCtl,
      irc: $irc,
      userInfo: $userInfo,
      oAuth: $oAuth
     };
    }();

    const $parse = function()
    {
     let _aLast = {};

     function _parseUser(cmd, latinOnly = false)
     {
      let data = cmd.prefix;
      let ret = {};
      if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('display-name'))
       ret['display-name'] = cmd.tags['display-name'];
      const gReg = new RegExp(twitch.parse.uReg, 'g');
      if (data.includes('!'))
      {
       ret.nick = data.slice(0, data.indexOf('!'));
       data = data.slice(data.indexOf('!') + 1);
       if (!ret.hasOwnProperty('display-name') || (latinOnly && ret['display-name'] !== ret['display-name'].replaceAll(gReg, '')))
        ret['display-name'] = ret.nick;
      }
      if (data.includes('@'))
      {
       ret.host = data.slice(0, data.indexOf('@'));
       data = data.slice(data.indexOf('@') + 1);
       if (!ret.hasOwnProperty('display-name') || (latinOnly && ret['display-name'] !== ret['display-name'].replaceAll(gReg, '')))
        ret['display-name'] = ret.host;
      }
      ret.user = data;
      return ret;
     }

     function $message(line)
     {
      let cmd = {};
      if (line.slice(0, 1) === '@')
      {
       line = line.slice(1);
       if (!line.includes(' '))
        return false;
       cmd.tags = {};
       const t = line.slice(0, line.indexOf(' '));
       line = line.slice(line.indexOf(' ') + 1);
       const a = t.split(';');
       for (let i = 0, l = a.length; i < l; i++)
       {
        const k = a[i].slice(0, a[i].indexOf('='));
        let v = a[i].slice(a[i].indexOf('=') + 1);
        v = v.replace(/\\s/g, ' ');
        cmd.tags[k] = v;
       }
      }
      if (line.slice(0, 1) === ':')
      {
       line = line.slice(1);
       if (!line.includes(' '))
        return false;
       cmd.prefix = line.slice(0, line.indexOf(' '));
       line = line.slice(line.indexOf(' ') + 1);
      }
      if (!line.includes(' '))
      {
       cmd.command = line;
       return cmd;
      }
      cmd.command = line.slice(0, line.indexOf(' '));
      line = line.slice(line.indexOf(' ') + 1);
      cmd.params = [];
      if (!line.includes(' '))
      {
       cmd.params.push(line);
       return cmd;
      }
      while (line.includes(' '))
      {
       if (line.slice(0, 1) === ':')
       {
        cmd.params.push(line.slice(1));
        return cmd;
       }
       cmd.params.push(line.slice(0, line.indexOf(' ')));
       line = line.slice(line.indexOf(' ') + 1);
      }
      if (line.slice(0, 1) === ':')
       line = line.slice(1);
      cmd.params.push(line);
      return cmd;
     }

     const $content = function()
     {
      async function $emoji(cmd, set, dup = null)
      {
       if (cmd.params.length < 2)
        return [];
       const msg = cmd.params[1];
       return service.parse.content.emoji(msg, set, dup);
      }

      function $twitch(cmd, dup = null)
      {
       if (!cmd.hasOwnProperty('tags'))
        return [];
       if (!cmd.tags.hasOwnProperty('emotes'))
        return [];
       if (cmd.tags.emotes === '')
        return [];
       if (cmd.params.length < 2)
        return [];
       const m = cmd.params[1];
       const e = cmd.tags.emotes.split('/');
       if (dup === null)
        dup = cfg.display.duplicates;
       let ret = [];
       for (let i = 0, n = e.length; i < n; i++)
       {
        const eID = e[i].slice(0, e[i].indexOf(':'));
        const u = cURLs.cdn.twitch.emote.replaceAll('%EMOTE_ID%', eID);
        const eVals = e[i].slice(e[i].indexOf(':') + 1).split(',');
        const eStart = parseInt(eVals[0].split('-')[0], 10);
        const eEnd = parseInt(eVals[0].split('-')[1], 10);
        const sName = m.slice(eStart, eEnd + 1);
        let sc = 'c';
        if (thirdparty.emotes.twitch.hasOwnProperty(sName) && thirdparty.emotes.twitch[sName].hasOwnProperty('scope'))
         sc = thirdparty.emotes.twitch[sName].scope;
        let l = eVals.length;
        if (dup === false)
         l = 1;
        else if (dup !== true)
         l = Math.min(l, dup);
        for (let c = 0; c < l; c++)
        {
         const p = parseInt(eVals[c].split('-')[0], 10);
         ret.push({svc: 't', url: u, str: sName, pos: p, scope: sc});
        }
       }
       return ret;
      }

      const $3rdparty = function()
      {
       const $ffz = function()
       {
        function $general(cmd, dup = null)
        {
         if (cmd.params.length < 2)
          return [];
         return service.parse.content['3rdparty'].ffz.general(cmd.params[1], dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         if (cmd.params.length < 2)
          return;
         const u = _parseUser(cmd);
         service.parse.content['3rdparty'].ffz.zwe(l, u.host, cmd.params[1], pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          if (cmd.params.length < 2)
           return [];
          const u = _parseUser(cmd);
          return service.parse.content['3rdparty'].ffz.user.general(u.host, cmd.params[1], dup);
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          if (cmd.params.length < 2)
           return;
          const u = _parseUser(cmd);
          service.parse.content['3rdparty'].ffz.user.zwe(l, u.host, cmd.params[1], pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $bttv = function()
       {
        function $general(cmd, dup = null)
        {
         if (cmd.params.length < 2)
          return [];
         return service.parse.content['3rdparty'].bttv.general(cmd.params[1], dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         if (cmd.params.length < 2)
          return;
         const u = _parseUser(cmd);
         service.parse.content['3rdparty'].bttv.zwe(l, u.host, cmd.params[1], pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          if (cmd.params.length < 2)
           return [];
          const u = _parseUser(cmd);
          return service.parse.content['3rdparty'].bttv.user.general(u.host, cmd.params[1], dup);
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          if (cmd.params.length < 2)
           return;
          const u = _parseUser(cmd);
          service.parse.content['3rdparty'].bttv.user.zwe(l, u.host, cmd.params[1], pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $7tv = function()
       {
        function $general(cmd, dup = null)
        {
         if (cmd.params.length < 2)
          return [];
         return service.parse.content['3rdparty']['7tv'].general(cmd.params[1], dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         if (cmd.params.length < 2)
          return;
         const u = _parseUser(cmd);
         return service.parse.content['3rdparty']['7tv'].zwe(l, u.host, cmd.params[1], pass, dup);
        }

        return {
         general: $general,
         zwe: $zwe
        };
       }();

       return {
        ffz: $ffz,
        bttv: $bttv,
        '7tv': $7tv
       };
      }();

      return {
       emoji: $emoji,
       twitch: $twitch,
       '3rdparty': $3rdparty
      };
     }();

     const $line = function()
     {
      async function task(cmd)
      {
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       if (await _parseCustomReward(cmd))
        return;
       if (cmd.params.length < 2)
        return;
       const lv = await _level(cmd);
       if (await _parseTaggedChannel(cmd, lv))
        return;
       if (await _parseCommand(cmd, lv))
        return;
       if ((lv & cfg.display.access) === 0)
        return;
       const p = _handleDuplicates(await _eListFromCmd(cmd));
       if (p.length === 0)
        return;
       display.emote.addToShowList(p);
       display.emote.showEmotes();
      }

      async function _parseCustomReward(cmd)
      {
       if (!cmd.hasOwnProperty('tags'))
        return false;
       if (!cmd.tags.hasOwnProperty('custom-reward-id'))
        return false;
       const lnID = cmd.tags['custom-reward-id'];
       if (!_rList.hasOwnProperty(lnID))
       {
        _rList[lnID] = {name: false, cmds: [cmd]};
        return true;
       }
       _rList[lnID].cmds.push(cmd);
       if (_rList[lnID].name === false)
        return true;
       while (_rList[lnID].cmds.length > 0)
       {
        await twitch.parse.event.redeem(_rList[lnID].name, _rList[lnID].cmds.shift());
       }
       return true;
      }

      async function _parseTaggedChannel(cmd, lv)
      {
       if (Object.keys(_aTagged).length < 1)
        return false;
       if (!cfg.event.twitch.tag.hasOwnProperty('styles'))
        return false;
       if (cfg.event.twitch.tag.styles === false)
        return false;
       const m = cmd.params[1];
       if (m.slice(0, 1) !== '@')
        return false;
       let uTagged = m.slice(1);
       if (uTagged.indexOf(' ') > -1)
        uTagged = uTagged.slice(0, uTagged.indexOf(' '));
       uTagged = uTagged.toLowerCase();
       if (!_aTagged.hasOwnProperty(uTagged))
        return false;
       const uID = _aTagged[uTagged];
       let rq = cfg.display.kappa.access;
       if (cfg.event.twitch.tag.hasOwnProperty('access') && cfg.event.twitch.tag.access >= 0)
        rq = cfg.event.twitch.tag.access;
       if ((lv & rq) === 0)
        return false;
       if (!cfg.event.twitch.tag.targetEmotes)
       {
        display.kappa.show(false, cfg.event.twitch.tag.styles, {'%USER%': uTagged});
        return true;
       }
       const e = await _findEmote_channel(uID);
       if (cfg.event.twitch.tag.targetExtendedEmotes)
       {
        if (cfg.display.extended.useFFZ)
        {
         const rFFZ = await thirdparty.ffz.channelEx(uID);
         if (rFFZ !== false)
         {
          for (let i = 0, l = rFFZ.length; i < l; i++)
          {
           if (rFFZ[i].modifier !== false)
            continue;
           e.push({url: rFFZ[i].url, width: rFFZ[i].width, height: rFFZ[i].height});
          }
         }
        }
        if (cfg.display.extended.useBTTV)
        {
         const rBTTV = await thirdparty.bttv.channelEx('twitch', uID);
         if (rBTTV !== false)
         {
          for (let i = 0, l = rBTTV.length; i < l; i++)
          {
           e.push({url: rBTTV[i].url, width: rBTTV[i].width, height: rBTTV[i].height});
          }
         }
        }
        if (cfg.display.extended.use7TV)
        {
         const r7TV = await thirdparty['7tv'].channelEx('twitch', uID);
         if (r7TV !== false)
         {
          for (let i = 0, l = r7TV.length; i < l; i++)
          {
           if ((r7TV[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
            continue;
           e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
          }
         }
        }
       }
       display.kappa.show(e, cfg.event.twitch.tag.styles, {'%USER%': uTagged});
       return true;
      }

      async function _parseCommand(cmd, lv)
      {
       const kNow = new Date().getTime();
       const m = cmd.params[1].toLowerCase();
       let foundAdvCmd = false;
       if (m === '!cesc' && (lv & 0xC00) !== 0)
       {
        shared.ec.clear();
        return;
       }
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('styles') && !k.hasOwnProperty('erase') && !k.hasOwnProperty('rave') && !k.hasOwnProperty('raveon') && !k.hasOwnProperty('raveoff'))
         continue;
        if (!k.hasOwnProperty('aliases'))
         continue;
        let foundKCmd = false;
        if (k.aliases.includes(m))
         foundKCmd = m;
        if (foundKCmd === false)
        {
         for (let i = 0, l = k.aliases.length; i < l; i++)
         {
          if (m.slice(0, k.aliases[i].length + 1) === k.aliases[i] + ' ')
          {
           foundKCmd = k.aliases[i];
           break;
          }
         }
        }
        if (foundKCmd === false)
         continue;
        let kAccess = cfg.display.kappa.access;
        if (k.hasOwnProperty('access'))
         kAccess = k.access;
        if ((lv & kAccess) === 0)
         continue;
        foundAdvCmd = true;
        if (k.hasOwnProperty('cooldown'))
        {
         let hK = _hashCode(k);
         if (!_aLast.hasOwnProperty(hK))
          _aLast[hK] = 0;
         if (k.cooldown !== 0 && kNow - _aLast[hK] < k.cooldown * 1000)
          continue;
        }
        if (k.hasOwnProperty('erase'))
        {
         display.eraseAll();
         return true;
        }
        if (k.hasOwnProperty('rave'))
        {
         if (document.documentElement.classList.contains('rave'))
          document.documentElement.classList.remove('rave');
         else
          document.documentElement.classList.add('rave');
         return true;
        }
        if (k.hasOwnProperty('raveon'))
        {
         document.documentElement.classList.add('rave');
         return true;
        }
        if (k.hasOwnProperty('raveoff'))
        {
         if (document.documentElement.classList.contains('rave'))
          document.documentElement.classList.remove('rave');
         return true;
        }
        let kC = {};
        let cStyles = k.styles;
        if (typeof cStyles !== 'object')
        {
         if (cStyles === false)
          return foundAdvCmd;
         if (cfg.display.kappa.styles.length < 1)
          return foundAdvCmd;
         cStyles = cfg.display.kappa.styles;
        }
        for (let kS in cStyles)
        {
         if (!cStyles.hasOwnProperty(kS))
          continue;
         kC[kS] = JSON.parse(JSON.stringify(cStyles[kS]));
         kC[kS].command = foundKCmd;
         if (foundKCmd.length === m.length)
          kC[kS].params = null;
         else
          kC[kS].params = m.slice(foundKCmd.length + 1);
        }
        let eA = false;
        if (foundKCmd.length < m.length)
         eA = _handleDuplicates(await _eListFromCmd(cmd, true));
        _aLast[_hashCode(k)] = kNow;
        display.kappa.show(eA, kC);
        return true;
       }
       let foundCmd = false;
       if (cfg.display.kappa.aliases.includes(m))
        foundCmd = m;
       if (foundCmd === false)
       {
        for (let i = 0, l = cfg.display.kappa.aliases.length; i < l; i++)
        {
         if (m.slice(0, cfg.display.kappa.aliases[i].length + 1) === cfg.display.kappa.aliases[i] + ' ')
         {
          foundCmd = cfg.display.kappa.aliases[i];
          break;
         }
        }
       }
       if (foundCmd === false)
        return foundAdvCmd;
       if ((lv & cfg.display.kappa.access) === 0)
        return foundAdvCmd;
       let h = _hashCode(null);
       if (!_aLast.hasOwnProperty(h))
        _aLast[h] = 0;
       if (cfg.display.kappa.cooldown > 0 && kNow - _aLast[h] < cfg.display.kappa.cooldown * 1000)
        return true;
       let a = false;
       if (foundCmd.length < m.length)
        a = _handleDuplicates(await _eListFromCmd(cmd, true));
       _aLast[h] = kNow;
       display.kappa.show(a);
       return true;
      }

      function _hashCode(o)
      {
       const s = JSON.stringify(o);
       let h = 0;
       for (let i = 0, l = s.length; i < l; i++)
        h = Math.imul(31, h) + s.charCodeAt(i) | 0;
       return h;
      }

      return task;
     }();

     const $event = function()
     {
      async function $cheer(cmd)
      {
       if (!thirdparty.emotes.hasOwnProperty('cheer'))
        return false;
       if (cfg.event.twitch.cheer === false)
        return false;
       if (!cfg.event.twitch.cheer.hasOwnProperty('bits'))
        return false;
       if (cfg.event.twitch.cheer.bits === false)
        return false;
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       if (!cmd.hasOwnProperty('tags'))
        return false;
       if (!cmd.tags.hasOwnProperty('bits'))
        return false;
       if (cmd.tags.bits < 1)
        return false;
       let p = [];
       const msg = cmd.params[1].split(' ');
       for (let m = 0, l = msg.length; m < l; m++)
       {
        for (const prefix in thirdparty.emotes.cheer)
        {
         if (!thirdparty.emotes.cheer.hasOwnProperty(prefix))
          continue;
         const firstChars = prefix.length;
         if (msg[m].slice(0, firstChars).toLowerCase() !== prefix.toLowerCase())
          continue;
         const amt = msg[m].slice(firstChars);
         if (isNaN(amt))
          continue;
         for (let i = 0, n = thirdparty.emotes.cheer[prefix].length; i < n; i++)
         {
          if (parseInt(amt, 10) < thirdparty.emotes.cheer[prefix][i].min)
           continue;
          const sName = prefix + thirdparty.emotes.cheer[prefix][i].min;
          p.push({svc: 'c', url: thirdparty.emotes.cheer[prefix][i].img, str: sName});
          break;
         }
        }
       }
       if (cfg.event.twitch.cheer.useMsg)
       {
        const a = await _eListFromCmd(cmd);
        p = p.concat(a);
       }
       else
        await twitch.parse.line(cmd);
       p = _handleDuplicates(p);
       if (p.length === 0)
        return false;
       const r = shared.findInMaybeRange(cfg.event.twitch.cheer.bits, cmd.tags.bits);
       if (r === false)
       {
        display.emote.addToShowList(p);
        display.emote.showEmotes();
        return true;
       }
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       display.kappa.show(p, r, {'%USER%': dn, '%AMOUNT%': cmd.tags.bits});
       return true;
      }

      const $hypechat = function()
      {
       const _levels = ['UNKNOWN', 'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE', 'TEN'];
       const _minUSD = [0, 1, 5, 10, 20, 50, 100, 200, 300, 400, 500];

       async function task(cmd)
       {
        if (cfg.event.twitch.hypechat === false)
         return false;
        if (!cfg.event.twitch.hypechat.hasOwnProperty('level'))
         return false;
        if (cfg.event.twitch.hypechat.level === false)
         return false;
        const u = _parseUser(cmd, true);
        if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
         return;
        if (!cmd.hasOwnProperty('tags'))
         return false;
        if (!cmd.tags.hasOwnProperty('pinned-chat-paid-level') || cmd.tags['pinned-chat-paid-level'] === null)
         return false;
        const lv = _levels.indexOf(cmd.tags['pinned-chat-paid-level']);
        if (lv < 1)
         return false;
        let p = [];
        if (!cmd.tags.hasOwnProperty('pinned-chat-paid-is-system-message') || parseInt(cmd.tags['pinned-chat-paid-is-system-message'], 10) !== 1)
        {
         if (cfg.event.twitch.cheer.useMsg)
         {
          const a = await _eListFromCmd(cmd);
          p = p.concat(a);
         }
         else
          await twitch.parse.line(cmd);
         p = _handleDuplicates(p);
        }
        if (p.length === 0)
         p = false;
        const r = shared.findInMaybeRange(cfg.event.twitch.hypechat.level, lv);
        if (r === false)
        {
         if (p !== false)
         {
          display.emote.addToShowList(p);
          display.emote.showEmotes();
         }
         return true;
        }
        let dn = 'Anonymous';
        if (u.hasOwnProperty('display-name'))
         dn = u['display-name'];
        let amt = _minUSD[lv] + ' USD';
        if (cmd.tags.hasOwnProperty('pinned-chat-paid-canonical-amount') && cmd.tags['pinned-chat-paid-canonical-amount'] !== null)
         amt = parseInt(cmd.tags['pinned-chat-paid-canonical-amount'], 10);
        else if (cmd.tags.hasOwnProperty('pinned-chat-paid-amount') && cmd.tags['pinned-chat-paid-amount'] !== null)
         amt = parseInt(cmd.tags['pinned-chat-paid-amount'], 10);
        if (cmd.tags.hasOwnProperty('pinned-chat-paid-exponent') && cmd.tags['pinned-chat-paid-exponent'] !== null)
         amt = amt / (10 ** parseInt(cmd.tags['pinned-chat-paid-exponent'], 10));
        if (cmd.tags.hasOwnProperty('pinned-chat-paid-currency') && cmd.tags['pinned-chat-paid-currency'] !== null)
         amt += ' ' + cmd.tags['pinned-chat-paid-currency'];
        display.kappa.show(p, r, {'%USER%': dn, '%AMOUNT%': amt});
        return true;
       }

       return task;
      }();

      async function $raid(cmd)
      {
       if (cfg.event.twitch.raid === false)
        return;
       if (!cfg.event.twitch.raid.hasOwnProperty('raiders'))
        return;
       if (cfg.event.twitch.raid.raiders === false)
        return;
       if (!cmd.hasOwnProperty('tags'))
        return;
       if (!cmd.tags.hasOwnProperty('msg-param-viewerCount'))
        return;
       const c = cmd.tags['msg-param-viewerCount'];
       const r = shared.findInMaybeRange(cfg.event.twitch.raid.raiders, c);
       if (r === false)
        return;
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       if (!cfg.event.twitch.raid.originEmotes)
       {
        display.kappa.show(false, r, {'%USER%': dn, '%AMOUNT%': c});
        return;
       }
       const d = cmd.tags['user-id'];
       const e = await _findEmote_channel(d);
       if (cfg.event.twitch.raid.originExtendedEmotes)
       {
        if (cfg.display.extended.useFFZ)
        {
         const rFFZ = await thirdparty.ffz.channelEx(d);
         if (rFFZ !== false)
         {
          for (let i = 0, l = rFFZ.length; i < l; i++)
          {
           if (rFFZ[i].modifier !== false)
            continue;
           e.push({url: rFFZ[i].url, width: rFFZ[i].width, height: rFFZ[i].height});
          }
         }
        }
        if (cfg.display.extended.useBTTV)
        {
         const rBTTV = await thirdparty.bttv.channelEx('twitch', d);
         if (rBTTV !== false)
         {
          for (let i = 0, l = rBTTV.length; i < l; i++)
          {
           e.push({url: rBTTV[i].url, width: rBTTV[i].width, height: rBTTV[i].height});
          }
         }
        }
        if (cfg.display.extended.use7TV)
        {
         const r7TV = await thirdparty['7tv'].channelEx('twitch', d);
         if (r7TV !== false)
         {
          for (let i = 0, l = r7TV.length; i < l; i++)
          {
           if ((r7TV[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
            continue;
           e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
          }
         }
        }
       }
       display.kappa.show(e, r, {'%USER%': dn, '%AMOUNT%': c});
      }

      const $sub = function()
      {
       let _bList = {
        bombs: [],
        bulk: [],
        check: []
       };
       let _tGC = null;

       async function task(cmd)
       {
        if (!cmd.tags.hasOwnProperty('msg-id'))
         return;
        const subPlan = _parsePlan(cmd);
        if (subPlan === false)
         return;
        const mID = cmd.tags['msg-id'];
        let mpoi = false;
        if (cmd.tags.hasOwnProperty('msg-param-origin-id'))
         mpoi = cmd.tags['msg-param-origin-id'];
        const usesBomb = cfg.event.twitch.sub[subPlan].hasOwnProperty('gift') && cfg.event.twitch.sub[subPlan].gift.hasOwnProperty('bomb') && cfg.event.twitch.sub[subPlan].gift.bomb !== false;
        if (mpoi !== false && usesBomb)
        {
         if (_bList.bombs.includes(mpoi))
          return;
         if (mID === 'subgift')
         {
          if (_bList.bulk.includes(mpoi))
           return;
          if (_bList.check.includes(mpoi))
          {
           _bList.bulk.push(mpoi);
           _bList.check.splice(_bList.check.indexOf(mpoi), 1);
           _resetGC();
           return;
          }
         }
        }
        let a = [];
        if (cmd.params.length > 1)
        {
         if (cfg.event.twitch.sub.useMsg)
          a = await _eListFromCmd(cmd, true);
         else
          await twitch.parse.line(cmd);
        }
        let mpm = 1;
        if (cmd.tags.hasOwnProperty('msg-param-months'))
         mpm = parseInt(cmd.tags['msg-param-months'], 10);
        let mpcm = 1;
        if (cmd.tags.hasOwnProperty('msg-param-cumulative-months'))
         mpcm = parseInt(cmd.tags['msg-param-cumulative-months'], 10);
        let mpmgc = 1;
        if (cmd.tags.hasOwnProperty('msg-param-mass-gift-count'))
         mpmgc = parseInt(cmd.tags['msg-param-mass-gift-count'], 10);
        let dn = 'Anonymous';
        let ln = 'anonymous';
        if (cmd.tags.hasOwnProperty('login'))
         ln = cmd.tags.login;
        if (cmd.tags.hasOwnProperty('display-name'))
         dn = cmd.tags['display-name'];
        if (ln === 'anonymous' || dn === 'Anonymous')
        {
         const u = _parseUser(cmd, true);
         if (ln === 'anonymous' && u.hasOwnProperty('host'))
          ln = u.host;
         if (dn === 'Anonymous' && u.hasOwnProperty('display-name'))
          dn = u['display-name'];
        }
        if (cfg.ignore.users !== false && cfg.ignore.users.includes(ln))
         return;
        let mprdn = 'Anonymous';
        if (cmd.tags.hasOwnProperty('msg-param-recipient-display-name'))
         mprdn = cmd.tags['msg-param-recipient-display-name'];
        if (mpoi !== false && usesBomb)
        {
         if (_bList.bombs.includes(mpoi))
          return;
         if (mID === 'subgift')
         {
          if (_bList.bulk.includes(mpoi))
           return;
          if (_bList.check.includes(mpoi))
          {
           _bList.bulk.push(mpoi);
           _bList.check.splice(_bList.check.indexOf(mpoi), 1);
           _resetGC();
           return;
          }
          if (!cmd.tags.hasOwnProperty('msg-param-sender-count') || cmd.tags['msg-param-sender-count'] === '0')
          {
           _bList.check.push(mpoi);
           window.setTimeout(_show, 2000, mID, subPlan, mpoi, mpm, mpcm, mpmgc, dn, mprdn, a);
           _resetGC();
           return;
          }
         }
        }
        _show(mID, subPlan, mpoi, mpm, mpcm, mpmgc, dn, mprdn, a);
       }

       function _show(id, subPlan, mpoi, mpm, mpcm, mpmgc, dn, mprdn, a)
       {
        const usesBomb = cfg.event.twitch.sub.hasOwnProperty(subPlan) && cfg.event.twitch.sub[subPlan].hasOwnProperty('gift') && cfg.event.twitch.sub[subPlan].gift.hasOwnProperty('bomb') && cfg.event.twitch.sub[subPlan].gift.bomb !== false;
        if (mpoi !== false && usesBomb)
        {
         if (_bList.bombs.includes(mpoi))
          return;
         if (id === 'subgift' && _bList.bulk.includes(mpoi))
         {
          _resetGC();
          return;
         }
        }
        switch (id)
        {
         case 'sub':
          if (!cfg.event.twitch.sub.hasOwnProperty(subPlan))
           return;
          if (!cfg.event.twitch.sub[subPlan].hasOwnProperty('first'))
           return;
          if (cfg.event.twitch.sub[subPlan].first === false)
           return;
          display.kappa.show(a, cfg.event.twitch.sub[subPlan].first, {'%USER%': dn});
          break;
         case 'resub':
          if (!cfg.event.twitch.sub.hasOwnProperty(subPlan))
           return;
          if (!cfg.event.twitch.sub[subPlan].hasOwnProperty('resub'))
           return;
          const rs = shared.findInMaybeRange(cfg.event.twitch.sub[subPlan].resub, mpcm);
          if (rs === false)
           return;
          display.kappa.show(a, rs, {'%USER%': dn, '%AMOUNT%': mpcm});
          break;
         case 'primepaidupgrade':
          if (!cfg.event.twitch.sub.hasOwnProperty(subPlan))
           return;
          if (!cfg.event.twitch.sub[subPlan].hasOwnProperty('upgrade'))
           return;
          if (!cfg.event.twitch.sub[subPlan].upgrade.hasOwnProperty('prime'))
           return;
          display.kappa.show(a, cfg.event.twitch.sub[subPlan].upgrade.prime, {'%USER%': dn});
          break;
         case 'giftpaidupgrade':
          if (!cfg.event.twitch.sub.hasOwnProperty(subPlan))
           return;
          if (!cfg.event.twitch.sub[subPlan].hasOwnProperty('upgrade'))
           return;
          if (!cfg.event.twitch.sub[subPlan].upgrade.hasOwnProperty('gift'))
           return;
          display.kappa.show(a, cfg.event.twitch.sub[subPlan].upgrade.gift, {'%USER%': dn});
          break;
         case 'subgift':
          if (!cfg.event.twitch.sub.hasOwnProperty(subPlan))
           return;
          if (!cfg.event.twitch.sub[subPlan].hasOwnProperty('gift'))
           return;
          if (mpm === 1)
          {
           if (!cfg.event.twitch.sub[subPlan].gift.hasOwnProperty('first'))
            return;
           if (cfg.event.twitch.sub[subPlan].gift.first === false)
            return;
           display.kappa.show(a, cfg.event.twitch.sub[subPlan].gift.first, {'%SENDER%': dn, '%USER%': mprdn});
           return;
          }
          if (!cfg.event.twitch.sub[subPlan].gift.hasOwnProperty('resub'))
           return;
          const gpr = shared.findInMaybeRange(cfg.event.twitch.sub[subPlan].gift.resub, mpm);
          if (gpr === false)
           return;
          display.kappa.show(a, gpr, {'%SENDER%': dn, '%USER%': mprdn, '%AMOUNT%': mpm});
          break;
         case 'submysterygift':
          if (!usesBomb)
           return;
          if (mpoi !== false)
          {
           _bList.bombs.push(mpoi);
           if (_bList.bulk.includes(mpoi))
            _bList.bulk.splice(_bList.bulk.indexOf(mpoi), 1);
           if (_bList.check.includes(mpoi))
            _bList.check.splice(_bList.check.indexOf(mpoi), 1);
           _resetGC();
          }
          const gpb = shared.findInMaybeRange(cfg.event.twitch.sub[subPlan].gift.bomb, mpmgc);
          if (gpb === false)
           return;
          display.kappa.show(a, gpb, {'%SENDER%': dn, '%AMOUNT%': mpmgc});
          break;
        }
       }

       function _parsePlan(c)
       {
        if (!c.tags.hasOwnProperty('msg-param-sub-plan'))
         return false;
        const p = c.tags['msg-param-sub-plan'];
        switch (p)
        {
         case '1000': return 't1';
         case '2000': return 't2';
         case '3000': return 't3';
         case 'Prime': return 'prime';
        }
        return false;
       }

       function _resetGC()
       {
        if (_tGC !== null)
        {
         window.clearTimeout(_tGC);
         _tGC = null;
        }
        _tGC = window.setTimeout(_tmrGC, 10000);
       }

       function _tmrGC()
       {
        if (_tGC === null)
         return;
        window.clearTimeout(_tGC);
        _tGC = null;
        _bList.check = [];
        _bList.bulk = [];
       }

       return task;
      }();

      function $badge(cmd)
      {
       if (!cmd.tags.hasOwnProperty('msg-param-threshold'))
        return;
       const c = cmd.tags['msg-param-threshold'];
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       if (cfg.event.twitch.badge.hasOwnProperty(c) && cfg.event.twitch.badge[c] !== false)
       {
        display.kappa.show(false, cfg.event.twitch.badge[c], {'%USER%': dn, '%AMOUNT%': c});
        return;
       }
       let closest = null;
       for (const b in cfg.event.twitch.badge)
       {
        if (!cfg.event.twitch.badge.hasOwnProperty(b))
         continue;
        if (closest === null)
        {
         closest = b;
         continue;
        }
        if (Math.abs(parseInt(closest, 10) - parseInt(c, 10)) > Math.abs(parseInt(b, 10) - parseInt(c, 10)))
         closest = b;
       }
       if (closest === null)
        return;
       if (cfg.event.twitch.badge[closest] === false)
        return;
       display.kappa.show(false, cfg.event.twitch.badge[closest], {'%USER%': dn, '%AMOUNT%': c});
      }

      async function $redeem(title, cmd)
      {
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('redeem'))
         continue;
        if (!k.redeem.includes(title))
         continue;
        let kC = k.styles;
        if (cmd === false)
        {
         display.kappa.show(false, kC);
         return;
        }
        const a = _handleDuplicates(await _eListFromCmd(cmd, true));
        display.kappa.show(a, kC);
        return;
       }
      }

      async function $ban(cmd)
      {
       let dn = cmd.params[1];
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(dn))
        return;
       if (cmd.tags.hasOwnProperty('target-user-id'))
       {
        const r = await twitch.net.userInfo(cmd.tags['target-user-id'], true);
        if (r.hasOwnProperty('display_name'))
         dn = r.display_name;
       }
       display.kappa.show(false, cfg.event.twitch.ban, {'%USER%': dn});
      }

      async function $timeout(cmd)
      {
       let dn = cmd.params[1];
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(dn))
        return;
       if (cmd.tags.hasOwnProperty('target-user-id'))
       {
        const r = await twitch.net.userInfo(cmd.tags['target-user-id'], true);
        if (r.hasOwnProperty('display_name'))
         dn = r.display_name;
       }
       const dDur = cmd.tags['ban-duration'];
       const r = shared.findInMaybeRange(cfg.event.twitch.timeout, dDur);
       if (r === false)
        return;
       display.kappa.show(false, r, {'%USER%': dn, '%AMOUNT%': dDur});
      }

      async function $shoutoutCreate(uID, uName)
      {
       if (cfg.event.twitch.shoutout === false)
        return false;
       if (!cfg.event.twitch.shoutout.hasOwnProperty('create'))
        return false;
       if (cfg.event.twitch.shoutout.create === false)
        return false;
       if (!cfg.event.twitch.shoutout.create.hasOwnProperty('styles'))
        return false;
       if (cfg.event.twitch.shoutout.create.styles === false)
        return false;
       if (!cfg.event.twitch.shoutout.create.targetEmotes)
       {
        display.kappa.show(false, cfg.event.twitch.shoutout.create.styles, {'%USER%': uName});
        return;
       }
       const e = await _findEmote_channel(uID);
       if (cfg.event.twitch.shoutout.create.targetExtendedEmotes)
       {
        if (cfg.display.extended.useFFZ)
        {
         const rFFZ = await thirdparty.ffz.channelEx(uID);
         if (rFFZ !== false)
         {
          for (let i = 0, l = rFFZ.length; i < l; i++)
          {
           if (rFFZ[i].modifier !== false)
            continue;
           e.push({url: rFFZ[i].url, width: rFFZ[i].width, height: rFFZ[i].height});
          }
         }
        }
        if (cfg.display.extended.useBTTV)
        {
         const rBTTV = await thirdparty.bttv.channelEx('twitch', uID);
         if (rBTTV !== false)
         {
          for (let i = 0, l = rBTTV.length; i < l; i++)
          {
           e.push({url: rBTTV[i].url, width: rBTTV[i].width, height: rBTTV[i].height});
          }
         }
        }
        if (cfg.display.extended.use7TV)
        {
         const r7TV = await thirdparty['7tv'].channelEx('twitch', uID);
         if (r7TV !== false)
         {
          for (let i = 0, l = r7TV.length; i < l; i++)
          {
           if ((r7TV[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
            continue;
           e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
          }
         }
        }
       }
       display.kappa.show(e, cfg.event.twitch.shoutout.create.styles, {'%USER%': uName});
      }

      async function $shoutoutReceive(uID, uName)
      {
       if (cfg.event.twitch.shoutout === false)
        return false;
       if (!cfg.event.twitch.shoutout.hasOwnProperty('receive'))
        return false;
       if (cfg.event.twitch.shoutout.receive === false)
        return false;
       if (!cfg.event.twitch.shoutout.receive.hasOwnProperty('styles'))
        return false;
       if (cfg.event.twitch.shoutout.receive.styles === false)
        return false;
       if (!cfg.event.twitch.shoutout.receive.originEmotes)
       {
        display.kappa.show(false, cfg.event.twitch.shoutout.receive.styles, {'%USER%': uName});
        return;
       }
       const e = await _findEmote_channel(uID);
       if (cfg.event.twitch.shoutout.receive.originExtendedEmotes)
       {
        if (cfg.display.extended.useFFZ)
        {
         const rFFZ = await thirdparty.ffz.channelEx(uID);
         if (rFFZ !== false)
         {
          for (let i = 0, l = rFFZ.length; i < l; i++)
          {
           if (rFFZ[i].modifier !== false)
            continue;
           e.push({url: rFFZ[i].url, width: rFFZ[i].width, height: rFFZ[i].height});
          }
         }
        }
        if (cfg.display.extended.useBTTV)
        {
         const rBTTV = await thirdparty.bttv.channelEx('twitch', uID);
         if (rBTTV !== false)
         {
          for (let i = 0, l = rBTTV.length; i < l; i++)
          {
           e.push({url: rBTTV[i].url, width: rBTTV[i].width, height: rBTTV[i].height});
          }
         }
        }
        if (cfg.display.extended.use7TV)
        {
         const r7TV = await thirdparty['7tv'].channelEx('twitch', uID);
         if (r7TV !== false)
         {
          for (let i = 0, l = r7TV.length; i < l; i++)
          {
           if ((r7TV[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
            continue;
           e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
          }
         }
        }
       }
       display.kappa.show(e, cfg.event.twitch.shoutout.receive.styles, {'%USER%': uName});
      }

      function $pollEnd(e)
      {
       let vPoll = 0;
       for (let i = 0, l = e.choices.length; i < l; i++)
       {
        if (!e.choices[i].hasOwnProperty('title'))
         continue;
        if (!e.choices[i].hasOwnProperty('votes'))
         continue;
        vPoll = Math.max(vPoll, e.choices[i].votes);
       }
       let rPoll = [];
       for (let i = 0, l = e.choices.length; i < l; i++)
       {
        if (!e.choices[i].hasOwnProperty('title'))
         continue;
        if (!e.choices[i].hasOwnProperty('votes'))
         continue;
        if (e.choices[i].votes === vPoll)
         rPoll.push(e.choices[i].title);
       }
       let sPoll = 'None';
       if (rPoll.length > 0)
        sPoll = rPoll.join(' + ');
       display.kappa.show(false, cfg.event.twitch.poll.end, {'%TITLE%': e.title, '%RESULT%': sPoll});
      }

      function $predictionEnd(e)
      {
       let sPrediction = 'None';
       for (let i = 0, l = e.outcomes.length; i < l; i++)
       {
        if (!e.outcomes[i].hasOwnProperty('id'))
         continue;
        if (e.outcomes[i].id !== e.winning_outcome_id)
         continue;
        if (!e.outcomes[i].hasOwnProperty('title'))
         continue;
        sPrediction = e.outcomes[i].title;
        break;
       }
       display.kappa.show(false, cfg.event.twitch.prediction.resolved, {'%TITLE%': e.title, '%RESULT%': sPrediction});
      }

      return {
       cheer: $cheer,
       hypechat: $hypechat,
       raid: $raid,
       sub: $sub,
       badge: $badge,
       redeem: $redeem,
       ban: $ban,
       timeout: $timeout,
       shoutoutCreate: $shoutoutCreate,
       shoutoutReceive: $shoutoutReceive,
       pollEnd: $pollEnd,
       predictionEnd: $predictionEnd
      };
     }();

     const _level = function()
     {
      const _rFH = 3600000;

      async function task(cmd)
      {
       let r = 0x001;
       if (cmd.tags.hasOwnProperty('mod') && cmd.tags.mod === '1')
        r |= 0x400;
       if (cmd.tags.hasOwnProperty('vip') && cmd.tags.vip === '1')
        r |= 0x100;
       if (cmd.tags.hasOwnProperty('badges'))
       {
        const badges = cmd.tags.badges.split(',');
        for (let i = 0, l = badges.length; i < l; i++)
        {
         const bData = _jSplit(badges[i], '/', 2);
         switch (bData[0])
         {
          case 'broadcaster':
           r |= 0x800;
           break;
          case 'moderator':
           r |= 0x400;
           break;
          case 'vip':
           r |= 0x100;
           break;
          case 'artist-badge':
           r |= 0x080;
           break;
          case 'founder':
           r |= 0x200;
           break;
          case 'bits':
           r |= 0x004;
           break;
          case 'subscriber':
           const badge = parseInt(bData[1], 10);
           if (badge < 2000)
            r |= 0x010;
           else if (badge < 3000)
            r |= 0x020;
           else
            r |= 0x040;
           break;
         }
        }
       }
       /* api-heavy, only check if follower access is allowed and there's a chance it matters */
       let needF = false;
       if ((cfg.display.access & 0x002) === 0x002 && (cfg.display.access & 0x001) !== 0x001)
        needF = true;
       else if ((cfg.display.kappa.access & 0x002) === 0x002 && (cfg.display.kappa.access & 0x001) !== 0x001)
        needF = true;
       else
       {
        for (const k of cfg.commands)
        {
         if (!k.hasOwnProperty('styles'))
          continue;
         if (!k.hasOwnProperty('access'))
          continue;
         if ((k.access & 0x002) === 0x002 && (k.access & 0x001) !== 0x001)
         {
          needF = true;
          break;
         }
        }
       }
       if (needF)
       {
        const f = await _checkFollower(cmd);
        if (f)
         r |= 0x002;
       }
       if ((r & 0x800) === 0x800 && (r & 0x070) !== 0)
        return r & ~0x070;
       return r;
      }

      async function _checkFollower(cmd)
      {
       const uID = cmd.tags['user-id'];
       if (twitch.net.fList.hasOwnProperty(uID))
       {
        const tDif = new Date().getTime() - twitch.net.fList[uID].t;
        if (tDif < _rFH)
         return twitch.net.fList[uID].value;
       }
       const url = cURLs.api.twitch.channels.followers.replaceAll('%USER_ID%', uID).replaceAll('%CHANNEL_ID%', cmd.tags['room-id']);
       const h = {
        'Authorization': 'Bearer ' + cfg.twitch.oauth,
        'Client-Id': cfg.twitch.client
       };
       const r = await shared.httpRequest('GET', url, h);
       if (!r.success)
       {
        if (r.code === 401)
        {
         if (await twitch.net.oAuth.reinit())
          return _checkFollower(cmd);
         notice.error(0x11);
         if (!loginT.inUse)
          twitch.net.oAuth.clear(true);
        }
        return false;
       }
       const j = r.json;
       if (j === null)
        return false;
       if (j.hasOwnProperty('data') && j.data.length > 0)
       {
        twitch.net.fList[uID] = {value: true, t: new Date().getTime()};
        return true;
       }
       twitch.net.fList[uID] = {value: false, t: new Date().getTime()};
       return false;
      }

      function _jSplit(s, sep, limit)
      {
       let arr = [];
       let v = '';
       for (let i = 0, l = s.length; i < l; i++)
       {
        if (arr.length < limit - 1)
        {
         if (s[i] === sep)
         {
          arr.push(v);
          v = '';
          continue;
         }
        }
        v += s[i];
       }
       if (v.length > 0)
        arr.push(v);
       return arr;
      }

      return task;
     }();

     function _handleDuplicates(a)
     {
      const lA = a.length;
      if (lA < 1)
       return a;
      let r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 'c')
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'u')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 't' && a[i].scope === 'c')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'c' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 't' && a[i].scope === 'g')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'g' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 'e')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      return r;
     }

     function _notDupe(add, pend)
     {
      for (let i = 0, l = pend.length; i < l; i++)
      {
       if (pend[i].str === add.str)
        return (pend[i].svc === add.svc);
      }
      return true;
     }

     async function _eListFromCmd(cmd, dup = null)
     {
      let r = [];
      const u = _parseUser(cmd, true);
      if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
       return r;
      r = r.concat(twitch.parse.content.twitch(cmd, dup));
      if (cfg.display.useEmoji)
       r = r.concat(await twitch.parse.content.emoji(cmd, cfg.display.useEmoji, dup));
      if (cfg.display.extended.useFFZ)
      {
       r = r.concat(twitch.parse.content['3rdparty'].ffz.general(cmd, dup));
       r = r.concat(twitch.parse.content['3rdparty'].ffz.user.general(cmd, dup));
      }
      if (cfg.display.extended.useBTTV)
      {
       r = r.concat(twitch.parse.content['3rdparty'].bttv.general(cmd, dup));
       r = r.concat(twitch.parse.content['3rdparty'].bttv.user.general(cmd, dup));
      }
      if (cfg.display.extended.use7TV)
       r = r.concat(twitch.parse.content['3rdparty']['7tv'].general(cmd, dup));
      if (cfg.display.extended.useFFZ)
      {
       twitch.parse.content['3rdparty'].ffz.zwe(r, cmd, 1, dup);
       twitch.parse.content['3rdparty'].ffz.user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       twitch.parse.content['3rdparty'].bttv.zwe(r, cmd, 1, dup);
       twitch.parse.content['3rdparty'].bttv.user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.use7TV)
       twitch.parse.content['3rdparty']['7tv'].zwe(r, cmd, 1, dup);
      if (cfg.display.extended.useFFZ)
      {
       twitch.parse.content['3rdparty'].ffz.zwe(r, cmd, 2, dup);
       twitch.parse.content['3rdparty'].ffz.user.zwe(r, cmd, 2, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       twitch.parse.content['3rdparty'].bttv.zwe(r, cmd, 2, dup);
       twitch.parse.content['3rdparty'].bttv.user.zwe(r, cmd, 2, dup);
      }
      if (cfg.display.extended.use7TV)
       twitch.parse.content['3rdparty']['7tv'].zwe(r, cmd, 2, dup);
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.length > 0)
      {
       for (let i = r.length - 1; i >= 0; i--)
       {
        let m = r[i].str;
        if (r[i].svc === 'e')
         m = String.fromCharCode(parseInt(m, 16));
        if (cfg.ignore.emotes.includes(m))
         r.splice(i, 1);
       }
      }
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (r[i].hasOwnProperty('width') || r[i].hasOwnProperty('height'))
        continue;
       if (!r[i].hasOwnProperty('url'))
        continue;
       const sz = await shared.ec.get(r[i].url);
       if (sz === null)
        continue;
       r[i].width = sz.width;
       r[i].height = sz.height;
      }
      return r;
     }

     function $clearCooldowns()
     {
      _aLast = {};
     }

     return {
      message: $message,
      content: $content,
      line: $line,
      event: $event,
      clearCooldowns: $clearCooldowns,
      uReg: /[^A-Za-z0-9_]/
     };
    }();

    const _findEmote_channel = function()
    {
     const _rCH = 300000;
     let _chList = {};

     async function task(chID, n = false)
     {
      if (n === false && _chList.hasOwnProperty(chID))
      {
       const tDif = new Date().getTime() - _chList[chID].t;
       if (tDif < _rCH)
        return _chList[chID].value;
      }
      const url = cURLs.api.twitch.chat.emotes.root.replaceAll('%CHANNEL_ID%', chID);
      const h = {
       'Authorization': 'Bearer ' + cfg.twitch.oauth,
       'Client-Id': cfg.twitch.client
      };
      const r = await shared.httpRequest('GET', url, h);
      if (!r.success)
      {
       if (r.code === 401)
       {
        if (await twitch.net.oAuth.reinit())
         return _findEmote_channel(chID, n);
        notice.error(0x11);
        if (!loginT.inUse)
         twitch.net.oAuth.clear(true);
       }
       return false;
      }
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('data'))
       return false;
      if (!Array.isArray(j.data))
       return false;
      let ret = [];
      for (let i = 0, l = j.data.length; i < l; i++)
      {
       if (!j.data[i].hasOwnProperty('id'))
        continue;
       if (cfg.ignore.emotes !== false && j.data[i].hasOwnProperty('name') && cfg.ignore.emotes.includes(j.data[i].name))
        continue;
       const eURL = cURLs.cdn.twitch.emote.replaceAll('%EMOTE_ID%', j.data[i].id);
       if (n !== false && j.data[i].hasOwnProperty('name'))
       {
        n[j.data[i].name] = {
         scope: 'c',
         url: eURL,
         id: j.data[i].id
        };
       }
       ret.push({url: eURL});
      }
      _chList[chID] = {t: new Date().getTime(), value: ret};
      return ret;
     }

     return task;
    }();

    async function $global()
    {
     if (!thirdparty.emotes.hasOwnProperty('twitch'))
      thirdparty.emotes.twitch = {};
     const url = cURLs.api.twitch.chat.emotes.global;
     const h = {
      'Authorization': 'Bearer ' + cfg.twitch.oauth,
      'Client-Id': cfg.twitch.client
     };
     const r = await shared.httpRequest('GET', url, h);
     if (!r.success)
     {
      if (r.code === 401)
      {
       if (await twitch.net.oAuth.reinit())
        return twitch.global();
       notice.error(0x11);
       if (!loginT.inUse)
        twitch.net.oAuth.clear(true);
      }
      return false;
     }
     const j = r.json;
     if (j === null)
      return false;
     if (!j.hasOwnProperty('data'))
      return false;
     if (!Array.isArray(j.data))
      return false;
     for (let i = 0, l = j.data.length; i < l; i++)
     {
      if (!j.data[i].hasOwnProperty('id'))
       continue;
      if (!j.data[i].hasOwnProperty('name'))
       continue;
      thirdparty.emotes.twitch[j.data[i].name] = {
       scope: 'g',
       url: cURLs.cdn.twitch.emote.replaceAll('%EMOTE_ID%', j.data[i].id),
       id: j.data[i].id
      };
     }
     return true;
    }

    return {
     net: $net,
     parse: $parse,
     global: $global
    };
   }();

   const youtube = function()
   {
    const $net = function()
    {
     let _scope = [];

     const $broadcasts = function()
     {
      let _aC = [];
      let _tS = false;

      async function $updateStream()
      {
       if (_tS !== false)
       {
        window.clearTimeout(_tS);
        _tS = false;
       }
       const lStreams = await _getActiveStreams();
       if (lStreams === null)
       {
        notice.error(0x22);
        return;
       }
       notice.info(0x22);
       if (lStreams === false)
       {
        _tS = window.setTimeout(youtube.net.broadcasts.updateStream, 30 * 1000);
        return;
       }
       let didSomething = false;
       for (let i = 0; i < lStreams.length; i++)
       {
        if (!youtube.net.channelIDs.includes(lStreams[i].channel))
        {
         youtube.net.channelIDs.push(lStreams[i].channel);
         if (cfg.display.extended.useBTTV)
         {
          thirdparty.bttv.channel('youtube', lStreams[i].channel);
          thirdparty.bttv.socket.join('youtube', lStreams[i].channel);
         }
         if (cfg.display.extended.use7TV)
         {
          thirdparty['7tv'].channel('youtube', lStreams[i].channel);
          await thirdparty['7tv'].socket.join('youtube', lStreams[i].channel);
         }
         if (cfg.display.extended.useBTTV)
          thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, thirdparty.interval);
        }
        if (!_aC.includes(lStreams[i].chat))
        {
         didSomething = true;
         _aC.push(lStreams[i].chat);
         window.setTimeout(youtube.net.broadcasts.getMessages.start, 48, lStreams[i].chat);
        }
       }
       if (didSomething && cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('recheck') && cfg.youtube.connect_to.recheck === false)
        return;
       _tS = window.setTimeout(youtube.net.broadcasts.updateStream, 30 * 1000);
       for (let i = _aC.length - 1; i >= 0; i--)
       {
        let found = false;
        for (let j = 0, m = lStreams.length; j < m; j++)
        {
         if (lStreams[j].chat === _aC[i])
         {
          found = true;
          break;
         }
        }
        if (!found)
        {
         youtube.net.broadcasts.getMessages.stop(_aC[i]);
         _aC.splice(i, 1);
        }
       }
      }

      async function _getActiveStreams()
      {
       if ((loginYT.cfgVals() & 0x02) === 0x02)
       {
        await youtube.net.oAuth.update();
        if ((loginYT.cfgVals() & 0x04) !== 0x04)
        {
         notice.error(0x21);
         return null;
        }
       }
       if ((loginYT.cfgVals() & 0x04) !== 0x04)
        return null;
       if (!_scope.includes('https://www.googleapis.com/auth/youtube.readonly'))
       {
        notice.error(0x21);
        return null;
       }
       let h = {
        'Authorization': 'Bearer ' + cfg.youtube.oauth,
        'Accept': 'application/json'
       };
       let r = await shared.httpRequest('GET', cURLs.api.youtube.broadcasts, h);
       const j = r.json;
       if (!r.success)
       {
        if (j !== null)
        {
         const e = _flatJSON(j);
         console.log(e);
         if (e.hasOwnProperty('error.status') && e['error.status'] === 'UNAUTHENTICATED')
         {
          notice.error(0x21);
          youtube.net.oAuth.clear(true);
          return null;
         }
         console.log(j);
        }
        console.log(r.code);
        notice.error(0x29, 'Error Getting Streams: ' + r.code);
        _errorReport('broadcasts._getActiveStreams', cURLs.api.youtube.broadcasts, r);
        return null;
       }
       if (j === null)
        return false;
       if (!j.hasOwnProperty('pageInfo'))
        return false;
       if (!j.pageInfo.hasOwnProperty('totalResults'))
        return false;
       if (j.pageInfo.totalResults < 1)
        return false;
       if (!j.hasOwnProperty('items'))
        return false;
       if (!Array.isArray(j.items))
        return false;
       let lcList = [];
       if (cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('title') && cfg.youtube.connect_to.title !== false && cfg.youtube.connect_to.title !== '')
       {
        for (let i = 0, l = j.items.length; i < l; i++)
        {
         if (!j.items[i].hasOwnProperty('id'))
          continue;
         if (!j.items[i].hasOwnProperty('snippet'))
          continue;
         if (!j.items[i].snippet.hasOwnProperty('liveChatId'))
          continue;
         if (!j.items[i].snippet.hasOwnProperty('channelId'))
          continue;
         if (!j.items[i].snippet.hasOwnProperty('title'))
          continue;
         if (j.items[i].snippet.title === '')
          continue;
         const sTitle = j.items[i].snippet.title;
         if (sTitle.toLowerCase() !== cfg.youtube.connect_to.title.toLowerCase())
          continue;
         let nPublished = false;
         if (j.items[i].snippet.hasOwnProperty('publishedAt') && j.items[i].snippet.publishedAt !== '')
          nPublished = new Date(j.items[i].snippet.publishedAt).getTime();
         let nStarted = false;
         if (j.items[i].snippet.hasOwnProperty('actualStartTime') && j.items[i].snippet.actualStartTime !== '')
          nStarted = new Date(j.items[i].snippet.actualStartTime).getTime();
         let sDesc = false;
         if (j.items[i].snippet.hasOwnProperty('description') && j.items[i].snippet.description !== '')
          sDesc = j.items[i].snippet.description;
         lcList.push({channel: j.items[i].snippet.channelId, chat: j.items[i].snippet.liveChatId, publishedAt: nPublished, actualStartTime: nStarted, title: sTitle, description: sDesc});
        }
        lcList.sort(_ytSort);
        if (cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('max') && !isNaN(cfg.youtube.connect_to.max) && cfg.youtube.connect_to.max > 0 && lcList.length > cfg.youtube.connect_to.max)
         lcList.length = cfg.youtube.connect_to.max;
        return lcList;
       }
       for (let i = 0, l = j.items.length; i < l; i++)
       {
        if (!j.items[i].hasOwnProperty('id'))
         continue;
        if (!j.items[i].hasOwnProperty('snippet'))
         continue;
        if (!j.items[i].snippet.hasOwnProperty('liveChatId'))
         continue;
        if (!j.items[i].snippet.hasOwnProperty('channelId'))
         continue;
        if (j.items[i].hasOwnProperty('status') && j.items[i].status.hasOwnProperty('lifeCycleStatus') && cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('list') && Array.isArray(cfg.youtube.connect_to.list) && cfg.youtube.connect_to.list.length > 0 && !cfg.youtube.connect_to.list.includes(j.items[i].status.lifeCycleStatus))
         continue;
        let nPublished = false;
        if (j.items[i].snippet.hasOwnProperty('publishedAt') && j.items[i].snippet.publishedAt !== '')
         nPublished = new Date(j.items[i].snippet.publishedAt).getTime();
        let nStarted = false;
        if (j.items[i].snippet.hasOwnProperty('actualStartTime') && j.items[i].snippet.actualStartTime !== '')
         nStarted = new Date(j.items[i].snippet.actualStartTime).getTime();
        let sTitle = false;
        if (j.items[i].snippet.hasOwnProperty('title') && j.items[i].snippet.title !== '')
         sTitle = j.items[i].snippet.title;
        let sDesc = false;
        if (j.items[i].snippet.hasOwnProperty('description') && j.items[i].snippet.description !== '')
         sDesc = j.items[i].snippet.description;
        lcList.push({channel: j.items[i].snippet.channelId, chat: j.items[i].snippet.liveChatId, publishedAt: nPublished, actualStartTime: nStarted, title: sTitle, description: sDesc});
       }
       lcList.sort(_ytSort);
       if (cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('max') && !isNaN(cfg.youtube.connect_to.max) && cfg.youtube.connect_to.max > 0 && lcList.length > cfg.youtube.connect_to.max)
        lcList.length = cfg.youtube.connect_to.max;
       return lcList;
      }

      function _ytSort(a, b)
      {
       let sortOrder = {
        'actualStartTime': 'desc',
        'publishedAt': 'desc'
       };
       if (cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('sort') && typeof cfg.youtube.connect_to.sort === 'object' && cfg.youtube.connect_to.sort !== null && Object.keys(cfg.youtube.connect_to.sort).length > 0)
        sortOrder = cfg.youtube.connect_to.sort;
       const sortAttrs = Object.keys(sortOrder);
       for (let i = 0; i < sortAttrs.length; i++)
       {
        const chooseA = sortOrder[sortAttrs[i]] === 'asc' ? 1 : -1;
        const chooseB = -1 * chooseA;
        if (!a.hasOwnProperty(sortAttrs[i]))
         return chooseB;
        if (!b.hasOwnProperty(sortAttrs[i]))
         return chooseA;
        const aA = a[sortAttrs[i]];
        const aB = b[sortAttrs[i]];
        if (aA === aB)
         continue;
        if (aA === false)
         return chooseB;
        if (aB === false)
         return chooseA;
        if (isNaN(aA) || isNaN(aB))
        {
         const cmp = aA.localeCompare(aB);
         if (cmp === 0)
          continue;
         if (cmp < 0)
          return chooseA;
         else
          return chooseB;
        }
        else
        {
         if (aA > aB)
          return chooseA;
         else
          return chooseB;
        }
       }
       return 0;
      }

      const $getMessages = function()
      {
       let _tM = [];

       async function $start(chatID, page = false)
       {
        if (_tM.hasOwnProperty(chatID) && _tM[chatID] !== false)
         window.clearTimeout(_tM[chatID]);
        _tM[chatID] = false;
        if ((loginYT.cfgVals() & 0x02) === 0x02)
        {
         await youtube.net.oAuth.update();
         if ((loginYT.cfgVals() & 0x04) !== 0x04)
         {
          notice.error(0x22);
          notice.error(0x21);
          return;
         }
        }
        if ((loginYT.cfgVals() & 0x04) !== 0x04)
         return;
        if (!_scope.includes('https://www.googleapis.com/auth/youtube.readonly'))
        {
         notice.error(0x22);
         notice.error(0x21);
         return;
        }
        let q = cURLs.api.youtube.livechat.messages.init;
        if (page !== false)
        {
         q = cURLs.api.youtube.livechat.messages.page;
         q = q.replaceAll('%PAGE%', encodeURIComponent(page));
        }
        q = q.replaceAll('%CHAT_ID%', encodeURIComponent(chatID));
        q = q.replaceAll('%PART%', encodeURIComponent('snippet,authorDetails'));
        let h = {
         'Authorization': 'Bearer ' + cfg.youtube.oauth,
         'Accept': 'application/json'
        };
        let r = await shared.httpRequest('GET', q, h);
        const j = r.json;
        if (!r.success)
        {
         if (r.code === 404)
         {
          notice.info(0x22);
          youtube.net.broadcasts.updateStream();
          return;
         }
         notice.error(0x22);
         if (j !== null)
         {
          const e = _flatJSON(j);
          console.log(e);
          if (e.hasOwnProperty('error.errors.0.reason') && e['error.errors.0.reason'] === 'quotaExceeded')
          {
           notice.error(0x28);
           return;
          }
          if (e.hasOwnProperty('error.errors.0.reason') && e['error.errors.0.reason'] === 'liveChatEnded')
          {
           for (let i = 0; i < _aC.length; i++)
           {
            if (_aC[i] !== chatID)
             continue;
            _aC.splice(i, 1);
            break;
           }
           youtube.net.broadcasts.getMessages.stop(chatID);
           return;
          }
          console.log(j);
         }
         console.log(r.code);
         notice.error(0x29, 'Error Getting Messages: ' + r.code);
         _errorReport('broadcasts.getMessages.start', q, r);
         return;
        }
        if (j === null)
         return;
        notice.info(0x22);
        let minPoll = 1000;
        if (j.hasOwnProperty('pollingIntervalMillis'))
         minPoll = j.pollingIntervalMillis;
        let nextPage = false;
        if (j.hasOwnProperty('nextPageToken'))
         nextPage = j.nextPageToken;
        if (j.hasOwnProperty('items') && Array.isArray(j.items) && j.items.length > 0)
        {
         const pNow = new Date().getTime();
         for (let i = 0, l = j.items.length; i < l; i++)
         {
          if (!j.items[i].hasOwnProperty('snippet'))
           continue;
          if (!j.items[i].snippet.hasOwnProperty('type'))
           continue;
          if (!j.items[i].hasOwnProperty('authorDetails'))
           continue;
          const access = 0;
          switch (j.items[i].snippet.type)
          {
           case 'textMessageEvent':
            if (j.items[i].snippet.hasOwnProperty('publishedAt'))
            {
             const pTime = new Date(j.items[i].snippet.publishedAt).getTime();
             if (pNow - pTime > 1000 * 30)
              continue;
            }
            youtube.parse.line(j.items[i]);
            break;
           case 'superChatEvent':
           case 'newSponsorEvent':
           case 'memberMilestoneChatEvent':
           case 'superStickerEvent':
           case 'membershipGiftingEvent':
         //case 'giftMembershipReceivedEvent':
           case 'userBannedEvent':
            _feedback(j.items[i].snippet.type, JSON.stringify(j.items[i].snippet));
            if (j.items[i].snippet.hasOwnProperty('textMessageDetails') && j.items[i].snippet.textMessageDetails.hasOwnProperty('messageText'))
             console.log(j.items[i].snippet.textMessageDetails.messageText, access);
            else if (j.items[i].snippet.hasOwnProperty('displayMessage'))
             console.log(j.items[i].snippet.displayMessage, access);
            else
             console.log(j.items[i].snippet, access);
            break;
           default:
            _feedback('other', JSON.stringify(j.items[i].snippet));
            console.log(j.items[i]);
            break;
          }
         }
        }
        if (!_tM.hasOwnProperty(chatID))
         return;
        const nextPoll = Math.max(1000, minPoll); // youtube's rate limit is 610,000 requests per 24 hours
                                                  // but there's also preflight requests and up to three
                                                  // instances to think about
        _tM[chatID] = window.setTimeout(youtube.net.broadcasts.getMessages.start, nextPoll, chatID, nextPage);
       }

       function $stop(chatID)
       {
        if (!_tM.hasOwnProperty(chatID))
         return;
        if (_tM[chatID] === false)
         return;
        window.clearTimeout(_tM[chatID]);
        delete _tM[chatID];
       }

       return {
        start: $start,
        stop: $stop
       };
      }();

      return {
       updateStream: $updateStream,
       getMessages: $getMessages
      };
     }();

     const $subscribers = function()
     {
      let _uLS = false;
      let _tS = false;
      const _rSC = 12000;

      function task()
      {
       if (!_scope.includes('https://www.googleapis.com/auth/youtube.readonly'))
       {
        notice.error(0x21);
        return;
       }
       _tS = window.setTimeout(_detect, _rSC);
      }

      async function _detect()
      {
       if (_tS === false)
        return;
       window.clearTimeout(_tS);
       _tS = false;
       const fRet = await _getChange();
       if (document.visibilityState !== 'hidden' && fRet !== false && fRet.length > 0)
       {
        for (let i = 0, l = fRet.length; i < l; i++)
         display.kappa.show(false, cfg.event.youtube.sub, {'%USER%': fRet[i]});
       }
       _tS = window.setTimeout(_detect, _rSC);
      }

      async function _getChange()
      {
       const url = cURLs.api.youtube.subscriptions.replaceAll('%PART%', encodeURIComponent('subscriberSnippet'));
       const h = {
        'Authorization': 'Bearer ' + cfg.youtube.oauth,
        'Accept': 'application/json'
       };
       const r = await shared.httpRequest('GET', url, h);
       const j = r.json;
       if (!r.success)
       {
        if (j !== null)
        {
         const e = _flatJSON(j);
         if (e.hasOwnProperty('error.status') && e['error.status'] === 'UNAUTHENTICATED')
         {
          notice.error(0x21);
          youtube.net.oAuth.clear(true);
          return false;
         }
         console.log(e);
         console.log(j);
        }
        console.log(r.code);
        notice.error(0x29, 'Error Getting Subscribers: ' + r.code);
        _errorReport('subscribers._getChange', url, r);
        return false;
       }
       if (j === null)
        return false;
       if (!j.hasOwnProperty('items') || !Array.isArray(j.items) || j.items.length < 1)
        return false;
       const findU = _uLS;
       _uLS = j.items[0].subscriberSnippet.channelId;
       if (findU === false)
        return false;
       let s = [];
       for (let i = 0, l = j.items.length; i < l; i++)
       {
        if (j.items[i].subscriberSnippet.channelId === findU)
         return s;
        //youtube.net.sList[j.items[i].subscriberSnippet.channelId] = {value: true, t: new Date().getTime()};
        s.push(j.items[i].subscriberSnippet.title);
       }
       return [];
      }

      return task;
     }();

     const $members = function()
     {
      let _uLS = false;
      let _tS = false;
      const _rSC = 12000;

      async function task()
      {
       if (!_scope.includes('https://www.googleapis.com/auth/youtube.channel-memberships.creator'))
       {
        notice.error(0x21);
        return;
       }
       const mID = await _init();
       if (mID === false)
        return;
       _tS = window.setTimeout(_detect, _rSC, mID);
      }

      async function _init()
      {
       const url = cURLs.api.youtube.members.init.replaceAll('%PART%', encodeURIComponent('snippet'));
       const h = {
        'Authorization': 'Bearer ' + cfg.youtube.oauth,
        'Accept': 'application/json'
       };
       const r = await shared.httpRequest('GET', url, h);
       const j = r.json;
       if (!r.success)
       {
        if (j !== null)
        {
         const e = _flatJSON(j);
         if (e.hasOwnProperty('error.errors.0.reason') && e['error.errors.0.reason'] === 'forbidden')
         {
          // not a monetized account
          return false;
         }
         console.log(e);
         console.log(j);
        }
        console.log(r.code);
        notice.error(0x29, 'Error Getting Members: ' + r.code);
        _errorReport('members._init', url, r);
        return false;
       }
       if (j === null)
        return false;
       if (!j.hasOwnProperty('nextPageToken'))
        return false;
       return j.nextPageToken;
      }

      async function _detect(mID)
      {
       if (_tS === false)
        return;
       window.clearTimeout(_tS);
       _tS = false;
       const fRet = await _getChange(mID);
       if (document.visibilityState !== 'hidden' && fRet !== false && fRet.length > 0)
       {
        for (let i = 0, l = fRet.length; i < l; i++)
        {
         if (fRet[i].hasOwnProperty('gift') && fRet[i].gift > 0)
         {
          const gpb = shared.findInMaybeRange(cfg.event.youtube.member.giftbomb, fRet[i].gift);
          if (gpb === false)
           return;
          display.kappa.show(false, gpb, {'%SENDER%': fRet[i].user, '%AMOUNT%': fRet[i].gift});
         }
         else
         {
          if (fRet[i].months === 1)
          {
           if (cfg.event.youtube.member.first !== false)
            display.kappa.show(false, cfg.event.youtube.member.first, {'%USER%': fRet[i].user});
          }
          else
          {
           const rs = shared.findInMaybeRange(cfg.event.youtube.member.milestone, fRet[i].months);
           if (rs === false)
            return;
           display.kappa.show(false, rs, {'%USER%': fRet[i].user, '%AMOUNT%': fRet[i].months});
          }
         }
        }
       }
       _tS = window.setTimeout(_detect, _rSC, mID);
      }

      async function _getChange(mID)
      {
       const url = cURLs.api.youtube.members.page.replaceAll('%PART%', encodeURIComponent('snippet')).replaceAll('%PAGE%', encodeURIComponent(mID));
       const h = {
        'Authorization': 'Bearer ' + cfg.youtube.oauth,
        'Accept': 'application/json'
       };
       const r = await shared.httpRequest('GET', url, h);
       const j = r.json;
       if (!r.success)
       {
        if (j !== null)
        {
         const e = _flatJSON(j);
         console.log(e);
         console.log(j);
        }
        console.log(r.code);
        notice.error(0x29, 'Unknown Error Getting Members: ' + r.code);
        _errorReport('members._getChange', url, r);
        return false;
       }
       _feedback('memberChange', r.data);
       if (j === null)
        return false;
       if (!j.hasOwnProperty('items') || !Array.isArray(j.items) || j.items.length < 1)
        return false;
       const findU = _uLS;
       _uLS = j.items[0].snippet.memberDetails.channelId;
       if (findU === false)
        return false;
       let s = [];
       for (let i = 0, l = j.items.length; i < l; i++)
       {
        const uID = j.items[i].snippet.memberDetails.channelId;
        if (uID === findU)
         return s;
        const uName = j.items[i].snippet.memberDetails.displayName;
        const uMonths = parseInt(j.items[i].snippet.membershipsDetails.membershipsDuration.memberTotalDurationMonths, 10);
        s.push({user: uName, months: uMonths});
       }
       return [];
      }

      return task;
     }();

     const $oAuth = function()
     {
      async function _getToken(t)
      {
       const url = cURLs.api.rr.refresh.yt;
       const h = {'Content-Type': 'application/x-www-form-urlencoded'};
       let b = 'refresh=' + encodeURIComponent(t);
       if (cfg.youtube.share)
        b += '&share=1';
       const r = await shared.httpRequest('POST', url, h, b, false);
       const j = r.json;
       if (!r.success)
       {
        if (j !== null)
        {
         const e = _flatJSON(j);
         console.log(e);
         if (e.hasOwnProperty('error') && e.error === 'invalid_grant' & e.hasOwnProperty('error_description'))
         {
          switch(e.error_description)
          {
           case 'Token has been expired or revoked.':
            notice.error(0x21);
            youtube.net.oAuth.clear(true);
            return false;
           case 'Bad Request':
            notice.error(0x29, 'The server did not like the request.');
            youtube.net.oAuth.clear(false);
            return false;
          }
         }
         console.log(j);
        }
        console.log(r.code);
        notice.error(0x29, 'Error Getting OAuth Token: ' + r.code);
        _errorReport('oAuth._getToken', url, r);
        return false;
       }
       if (j === null)
        return false;
       if (!j.hasOwnProperty('access_token'))
        return false;
       return j;
      }

      async function $update()
      {
       const now = Math.floor(new Date().getTime() / 1000);
       const lsRefresh = window.localStorage.getItem(loginYT.path() + '.refresh');
       if (lsRefresh !== null)
        cfg.youtube.oauth_refresh = lsRefresh;
       if (cfg.youtube.hasOwnProperty('expires') && cfg.youtube.expires > 0)
       {
        const tokAge = cfg.youtube.expires - now;
        if (tokAge > 15 * 60)
         return;
       }
       const ret = await _getToken(cfg.youtube.oauth_refresh);
       if (ret === false)
        return;
       cfg.youtube.oauth = ret.access_token;
       if (ret.hasOwnProperty('scope'))
        _scope = ret.scope.split(' ');
       if (ret.hasOwnProperty('expires_in'))
        cfg.youtube.expires = now + ret.expires_in;
       else
        cfg.youtube.expires = now + 60 * 60;
       if (ret.hasOwnProperty('refresh_token'))
       {
        _errorReport('oAuth.update', cURLs.api.rr.refresh.yt, 'Received a Refresh Token during OAuth Token refresh!');
        console.log('REFRESH TOKEN SENT FROM YT! OMG!');
        cfg.youtube.oauth_refresh = ret.refresh_token;
        if (window.localStorage.getItem(loginYT.path() + '.refresh') !== null)
         window.localStorage.setItem(loginYT.path() + '.refresh', ret.refresh_token);
       }
      }

      async function $reinit()
      {
       if ((loginYT.cfgVals() & 0x02) === 0x02)
       {
        youtube.net.oAuth.clear();
        await youtube.net.oAuth.update();
        if ((loginYT.cfgVals() & 0x04) === 0x04)
         return true;
        youtube.net.oAuth.clear(true);
       }
       return false;
      }

      function $clear(clearRefresh = false)
      {
       cfg.youtube.oauth = 'OAUTH_ID';
       if (!clearRefresh)
        return;
       cfg.youtube.oauth_refresh = 'OAUTH_REFRESH';
       cfg.youtube.client = oauthClient.yt;
       cfg.youtube.scope = [];
       window.localStorage.removeItem(loginYT.path() + '.refresh');
       window.localStorage.removeItem(loginYT.path() + '.client');
       window.localStorage.removeItem(loginYT.path() + '.scope');
      }

      return {
       update: $update,
       reinit: $reinit,
       clear: $clear
      };
     }();

     function _flatJSON(j, r = {}, p = '')
     {
      for (let k in j)
      {
       if (typeof j[k] !== 'object')
        r[p + k] = j[k];
       else
        _flatJSON(j[k], r, p + k + '.');
      }
      return r;
     }

     return {
      channelIDs: [],
      dead: false,
      broadcasts: $broadcasts,
      subscribers: $subscribers,
      members: $members,
      oAuth: $oAuth
     };
    }();

    const $parse = function()
    {
     let _aLast = {};

     function _parseUser(cmd)
     {
      if (!cmd.hasOwnProperty('authorDetails'))
       return false;
      if (!cmd.authorDetails.hasOwnProperty('displayName'))
       return false;
      let ret = {};
      ret['display-name'] = cmd.authorDetails.displayName;
      if (cmd.authorDetails.hasOwnProperty('channelId'))
       ret.id = cmd.authorDetails.channelId;
      return ret;
     }

     function _getMessage(cmd)
     {
      let msg = false;
      if (cmd.snippet.hasOwnProperty('textMessageDetails') && cmd.snippet.textMessageDetails.hasOwnProperty('messageText'))
       msg = cmd.snippet.textMessageDetails.messageText;
      else if (cmd.snippet.hasOwnProperty('displayMessage'))
       msg = cmd.snippet.displayMessage;
      return msg;
     }

     const $content = function()
     {
      async function $emoji(cmd, set, dup = null)
      {
       const msg = _getMessage(cmd);
       if (msg === false)
        return [];
       return service.parse.content.emoji(msg, set, dup);
      }

      const $youtube = function()
      {
       function task(cmd, dup = null)
       {
        let msg = _getMessage(cmd);
        if (msg === false)
         return [];
        msg = msg.toLowerCase();
        const emSeg = /(:[a-z\-]+:)/g;
        let emList = [];
        let match = '';
        while ((match = emSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        if (emList.length === 0)
         return [];
        let ret = [];
        if (dup === null)
         dup = cfg.display.duplicates;
        if (dup === false)
         dup = 1;
        for (let i = 0, l = emList.length; i < l; i++)
        {
         const u = _ttu(emList[i][0]);
         if (u === false)
          continue;
         if (dup !== true)
         {
          let ct = 0;
          for (let j = 0, m = ret.length; j < m; j++)
          {
           if (ret[j].str === emList[i][0])
            ct++;
          }
          if (ct >= dup)
           continue;
         }
         ret.push({svc: 'y', url: u, str: emList[i][0], pos: emList[i].index});
        }
        return ret;
       }

       function _ttu(t)
       {
        if (t.slice(0, 1) !== ':')
         return false;
        t = t.slice(1);
        if (t.slice(-1) !== ':')
         return false;
        t = t.slice(0, -1);
        if (!thirdparty.emotes.youtube.hasOwnProperty(t))
         return false;
        return thirdparty.emotes.youtube[t].url;
       }

       return task;
      }();

      const $3rdparty = function()
      {
       const $ffz = function()
       {
        function $general(cmd, dup = null)
        {
         const msg = _getMessage(cmd);
         if (msg === false)
          return [];
         return service.parse.content['3rdparty'].ffz.general(msg, dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         const u = _parseUser(cmd);
         if (u === false)
          return [];
         const msg = _getMessage(cmd);
         if (msg === false)
          return [];
         return service.parse.content['3rdparty'].ffz.zwe(l, u.displayName, msg, pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          if (!thirdparty.emotes.hasOwnProperty('ffzU'))
           return [];
          const u = _parseUser(cmd);
          if (u === false)
           return [];
          const msg = _getMessage(cmd);
          if (msg === false)
           return [];
          if (!thirdparty.emotes.ffzU.hasOwnProperty(u.displayName))
           return [];
          return service.parse.content['3rdparty'].ffz.user.general(u.displayName, msg, dup);
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          if (!cfg.display.extended.useZWE)
           return;
          if (!thirdparty.emotes.hasOwnProperty('zwe'))
           return;
          if (!thirdparty.emotes.zwe.hasOwnProperty('ffzU'))
           return;
          const u = _parseUser(cmd);
          if (u === false)
           return [];
          const msg = _getMessage(cmd);
          if (msg === false)
           return [];
          if (!thirdparty.emotes.zwe.ffzU.hasOwnProperty(u.displayName))
           return [];
          return service.parse.content['3rdparty'].ffz.user.zwe(l, u.displayName, msg, pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $bttv = function()
       {
        function $general(cmd, dup = null)
        {
         const msg = _getMessage(cmd);
         if (msg === false)
          return [];
         return service.parse.content['3rdparty'].bttv.general(msg, dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         const u = _parseUser(cmd);
         if (u === false)
          return [];
         const msg = _getMessage(cmd);
         if (msg === false)
          return;
         return service.parse.content['3rdparty'].bttv.zwe(l, u.displayName, msg, pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          if (!thirdparty.emotes.hasOwnProperty('bttvU'))
           return [];
          const msg = _getMessage(cmd);
          if (msg === false)
           return [];
          const u = _parseUser(cmd);
          if (u === false)
           return [];
          if (!thirdparty.emotes.bttvU.hasOwnProperty(u.displayName))
           return [];
          return service.parse.content['3rdparty'].bttv.user.general(u.displayName, msg, dup);
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          if (!cfg.display.extended.useZWE)
           return;
          if (!thirdparty.emotes.hasOwnProperty('zwe'))
           return;
          if (!thirdparty.emotes.zwe.hasOwnProperty('bttvU'))
           return;
          const msg = _getMessage(cmd);
          if (msg === false)
           return [];
          const u = _parseUser(cmd);
          if (u === false)
           return [];
          if (!thirdparty.emotes.zwe.bttvU.hasOwnProperty(u.displayName))
           return [];
          return service.parse.content['3rdparty'].bttv.user.zwe(l, u.displayName, msg, pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $7tv = function()
       {
        function $general(cmd, dup = null)
        {
         const msg = _getMessage(cmd);
         if (msg === false)
          return [];
         return service.parse.content['3rdparty']['7tv'].general(msg, dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         const u = _parseUser(cmd);
         if (u === false)
          return [];
         const msg = _getMessage(cmd);
         if (msg === false)
          return;
         return service.parse.content['3rdparty']['7tv'].zwe(l, u.displayName, msg, pass, dup);
        }

        return {
         general: $general,
         zwe: $zwe
        };
       }();

       return {
        ffz: $ffz,
        bttv: $bttv,
        '7tv': $7tv
       };
      }();

      return {
       emoji: $emoji,
       youtube: $youtube,
       '3rdparty': $3rdparty
      };
     }();

     const $line = function()
     {
      async function task(cmd)
      {
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       const lv = await _level(cmd);
       if (await _parseCommand(cmd, lv))
        return;
       if ((lv & cfg.display.access) === 0)
        return;
       const p = _handleDuplicates(await _eListFromCmd(cmd));
       if (p.length === 0)
        return;
       display.emote.addToShowList(p);
       display.emote.showEmotes();
      }

      async function _parseCommand(cmd, lv)
      {
       const kNow = new Date().getTime();
       const m = _getMessage(cmd).toLowerCase();
       let foundAdvCmd = false;
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('styles') && !k.hasOwnProperty('erase'))
         continue;
        if (!k.hasOwnProperty('aliases'))
         continue;
        let foundKCmd = false;
        if (k.aliases.includes(m))
         foundKCmd = m;
        if (foundKCmd === false)
        {
         for (let i = 0, l = k.aliases.length; i < l; i++)
         {
          if (m.slice(0, k.aliases[i].length + 1) === k.aliases[i] + ' ')
          {
           foundKCmd = k.aliases[i];
           break;
          }
         }
        }
        if (foundKCmd === false)
         continue;
        let kAccess = cfg.display.kappa.access;
        if (k.hasOwnProperty('access'))
         kAccess = k.access;
        if ((lv & kAccess) === 0)
         continue;
        foundAdvCmd = true;
        if (k.hasOwnProperty('cooldown'))
        {
         let hK = _hashCode(k);
         if (!_aLast.hasOwnProperty(hK))
          _aLast[hK] = 0;
         if (k.cooldown !== 0 && kNow - _aLast[hK] < k.cooldown * 1000)
          continue;
        }
        if (k.hasOwnProperty('erase'))
        {
         display.eraseAll();
         return true;
        }
        let kC = {};
        let cStyles = k.styles;
        if (typeof cStyles !== 'object')
        {
         if (cStyles === false)
          return foundAdvCmd;
         if (cfg.display.kappa.styles.length < 1)
          return foundAdvCmd;
         cStyles = cfg.display.kappa.styles;
        }
        for (let kS in cStyles)
        {
         if (!cStyles.hasOwnProperty(kS))
          continue;
         kC[kS] = JSON.parse(JSON.stringify(cStyles[kS]));
         kC[kS].command = foundKCmd;
         if (foundKCmd.length === m.length)
          kC[kS].params = null;
         else
          kC[kS].params = m.slice(foundKCmd.length + 1);
        }
        let eA = false;
        if (foundKCmd.length < m.length)
         eA = _handleDuplicates(await _eListFromCmd(cmd, true));
        _aLast[_hashCode(k)] = kNow;
        display.kappa.show(eA, kC);
        return true;
       }
       let foundCmd = false;
       if (cfg.display.kappa.aliases.includes(m))
        foundCmd = m;
       if (foundCmd === false)
       {
        for (let i = 0, l = cfg.display.kappa.aliases.length; i < l; i++)
        {
         if (m.slice(0, cfg.display.kappa.aliases[i].length + 1) === cfg.display.kappa.aliases[i] + ' ')
         {
          foundCmd = cfg.display.kappa.aliases[i];
          break;
         }
        }
       }
       if (foundCmd === false)
        return foundAdvCmd;
       if ((lv & cfg.display.kappa.access) === 0)
        return foundAdvCmd;
       let h = _hashCode(null);
       if (!_aLast.hasOwnProperty(h))
        _aLast[h] = 0;
       if (cfg.display.kappa.cooldown > 0 && kNow - _aLast[h] < cfg.display.kappa.cooldown * 1000)
        return true;
       let a = false;
       if (foundCmd.length < m.length)
        a = _handleDuplicates(await _eListFromCmd(cmd, true));
       _aLast[h] = kNow;
       display.kappa.show(a);
       return true;
      }

      function _hashCode(o)
      {
       const s = JSON.stringify(o);
       let h = 0;
       for (let i = 0, l = s.length; i < l; i++)
        h = Math.imul(31, h) + s.charCodeAt(i) | 0;
       return h;
      }

      return task;
     }();

     const _level = function()
     {
      function task(cmd)
      {
       let r = 0x001;
       if (!cmd.hasOwnProperty('authorDetails'))
       {
        console.log('no author details in', cmd);
        return r;
       }
       const author = cmd.authorDetails;
       if (author.hasOwnProperty('isChatOwner') && author.isChatOwner !== false)
        r |= 0x800;
       if (author.hasOwnProperty('isChatModerator') && author.isChatModerator !== false)
        r |= 0x400;
       if (author.hasOwnProperty('isChatSponsor') && author.isChatSponsor !== false)
        r |= 0x010;
       if (author.hasOwnProperty('isMember') && author.isMember !== false)
        r |= 0x010;
       if (author.hasOwnProperty('isVerified') && author.isVerified !== false)
        r |= 0x008;
       if (author.hasOwnProperty('isSubscriber') && author.isSubscriber !== false)
        r |= 0x002;
       return r;
      }

      return task;
     }();

     function _handleDuplicates(a)
     {
      const lA = a.length;
      if (lA < 1)
       return a;
      let r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'u')
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 'y' || a[i].svc === 'c' || a[i].svc === 'e')
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'c' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        let f = false;
        for (let j = 0, l = r.length; j < l; j++)
        {
         if (r[j].str === a[i].str)
         {
          f = true;
          if (r[j].svc === a[i].svc)
           r.push(a[i]);
          break;
         }
        }
        if (!f)
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope !== 'c' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        let f = false;
        for (let j = 0, l = r.length; j < l; j++)
        {
         if (r[j].str === a[i].str)
         {
          f = true;
          if (r[j].svc === a[i].svc)
           r.push(a[i]);
          break;
         }
        }
        if (!f)
         r.push(a[i]);
       }
      }
      return r;
     }

     async function _eListFromCmd(cmd, dup = null)
     {
      let r = [];
      const u = _parseUser(cmd, true);
      if (u !== false && cfg.ignore.users !== false && cfg.ignore.users.includes(u.displayName))
       return r;
      r = r.concat(youtube.parse.content.youtube(cmd, dup));
      if (cfg.display.useEmoji)
       r = r.concat(await youtube.parse.content.emoji(cmd, cfg.display.useEmoji, dup));
      if (cfg.display.extended.useFFZ)
      {
       r = r.concat(youtube.parse.content['3rdparty'].ffz.general(cmd, dup));
       r = r.concat(youtube.parse.content['3rdparty'].ffz.user.general(cmd, dup));
      }
      if (cfg.display.extended.useBTTV)
      {
       r = r.concat(youtube.parse.content['3rdparty'].bttv.general(cmd, dup));
       r = r.concat(youtube.parse.content['3rdparty'].bttv.user.general(cmd, dup));
      }
      if (cfg.display.extended.use7TV)
       r = r.concat(youtube.parse.content['3rdparty']['7tv'].general(cmd, dup));
      if (cfg.display.extended.useFFZ)
      {
       youtube.parse.content['3rdparty'].ffz.zwe(r, cmd, 1, dup);
       youtube.parse.content['3rdparty'].ffz.user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       youtube.parse.content['3rdparty'].bttv.zwe(r, cmd, 1, dup);
       youtube.parse.content['3rdparty'].bttv.user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.use7TV)
       youtube.parse.content['3rdparty']['7tv'].zwe(r, cmd, 1, dup);
      if (cfg.display.extended.useFFZ)
      {
       youtube.parse.content['3rdparty'].ffz.zwe(r, cmd, 2, dup);
       youtube.parse.content['3rdparty'].ffz.user.zwe(r, cmd, 2, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       youtube.parse.content['3rdparty'].bttv.zwe(r, cmd, 2, dup);
       youtube.parse.content['3rdparty'].bttv.user.zwe(r, cmd, 2, dup);
      }
      if (cfg.display.extended.use7TV)
       youtube.parse.content['3rdparty']['7tv'].zwe(r, cmd, 2, dup);
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.length > 0)
      {
       for (let i = r.length - 1; i >= 0; i--)
       {
        let m = r[i].str;
        if (r[i].svc === 'e')
         m = String.fromCharCode(parseInt(m, 16));
        if (cfg.ignore.emotes.includes(m))
         r.splice(i, 1);
       }
      }
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (r[i].hasOwnProperty('width') || r[i].hasOwnProperty('height'))
        continue;
       if (!r[i].hasOwnProperty('url'))
        continue;
       const sz = await shared.ec.get(r[i].url);
       if (sz === null)
        continue;
       r[i].width = sz.width;
       r[i].height = sz.height;
      }
      return r;
     }

     return {
      content: $content,
      line: $line
     };
    }();

    async function $global()
    {
     if (!thirdparty.emotes.hasOwnProperty('youtube'))
      thirdparty.emotes.youtube = {};
     const url = cURLs.api.youtube.livechat.emojis;
     const r = await shared.httpRequest('GET', url);
     if (!r.success)
      return false;
     const j = r.json;
     if (j === null)
      return false;
     let eCDN;
     if (j.hasOwnProperty('template'))
      eCDN = j.template;
     else
      eCDN = 'https://yt3.ggpht.com/%EMOJI_ID%=w112-h112-c-k-nd';
     if (!j.hasOwnProperty('list'))
      return false;
     if (typeof j.list !== 'object')
      return false;
     if (j.list === null)
      return false;
     const jNames = Object.keys(j.list);
     for (let i = 0, l = jNames.length; i < l; i++)
     {
      thirdparty.emotes.youtube[jNames[i]] = {
       scope: 'g',
       url: eCDN.replaceAll('%EMOJI_ID%', j.list[jNames[i]]),
       id: j.list[jNames[i]]
      };
     }
     return true;
    }

    function _feedback(type, data)
    {
     if (cfg.youtube.feedback !== true)
      return;
     const h = {'Content-Type': 'application/x-www-form-urlencoded'};
     const b = 'type=' + encodeURIComponent(type) + '&value=' + encodeURIComponent(window.btoa(data));
     shared.httpRequest('POST', cURLs.api.rr.feedback.ytmonetized, h, b, false, false);
    }

    function _errorReport(f, u, r)
    {
     if (cfg.youtube.feedback !== true)
      return;
     const h = {'Content-Type': 'application/x-www-form-urlencoded'};
     const b = 'function=' + encodeURIComponent(window.btoa(f)) + '&url=' + encodeURIComponent(window.btoa(u)) + '&code=' + encodeURIComponent(window.btoa(r.code)) + '&data=' + encodeURIComponent(window.btoa(r.data));
     shared.httpRequest('POST', cURLs.api.rr.feedback.yterrors, h, b, false, false);
    }

    return {
     net: $net,
     parse: $parse,
     global: $global
    };
   }();

   const kick = function()
   {
    let _usesHyphen = 0;

    const $net = function()
    {
     const $socket = function()
     {
      let _wsRetry = 0;
      let _firstRS = true;
      let _ws = null;
      const _lPing = 30000;
      const _lTimeout = 35000;
      const _lExpire = 5000;
      let _tTimeout = false;
      let _tExpire = false;
      let _tPing = 0;
      let _tPoll = false;

      async function task()
      {
       if (kick.net.channelID === 0 || kick.net.chatID === 0)
       {
        await _getChIDs();
        if (kick.net.channelID === 0 || kick.net.chatID === 0)
        {
         notice.error(0x31);
         kick.net.dead = true;
         return;
        }
       }
       _tPing = 0;
       _firstRS = true;
       _ws = new WebSocket(cURLs.ws.kick);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
       _tExpire = window.setTimeout(_wsExpire, _lExpire);
      }

      function _wsClose()
      {
       notice.error(0x32);
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (kick.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(kick.net.socket, wsWait);
      }

      async function _wsMessage(ev)
      {
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       _tPing = window.setInterval(_wsPing, _lPing);
       if (_ws === null)
        return;
       if (kick.net.dead)
       {
        if (_tExpire !== false)
        {
         window.clearTimeout(_tExpire);
         _tExpire = false;
        }
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        return;
       }
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
       _wsRetry = 0;
       const j = JSON.parse(ev.data);
       if (!j.hasOwnProperty('event') || j.event === null)
        return;
       if (j.event === 'pusher:error')
       {
        if (j.hasOwnProperty('data') && j.data !== null)
        {
         if (j.data.hasOwnProperty('code') && j.data.code !== null)
         {
          if (j.data.code >= 4000 && j.data.code <= 4099)
          {
           if (_tExpire !== false)
           {
            window.clearTimeout(_tExpire);
            _tExpire = false;
           }
           if (_tTimeout !== false)
           {
            window.clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           _ws.onmessage = null;
           _ws.onclose = null;
           _ws.close();
           _ws = null;
           if (kick.net.dead === true)
            return;
           if (j.data.hasOwnProperty('message') && j.data.message !== null)
            notice.error(0x39, j.data.message);
           notice.error(0x32);
           return;
          }
          else if (j.data.code >= 4100 && j.data.code <= 4199)
          {
           if (_tExpire !== false)
           {
            window.clearTimeout(_tExpire);
            _tExpire = false;
           }
           if (_tTimeout !== false)
           {
            window.clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           _ws.onmessage = null;
           _ws.onclose = null;
           _ws.close();
           _ws = null;
           if (kick.net.dead === true)
            return;
           const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
           if (_wsRetry < 2)
            _wsRetry += 0.2;
           window.setTimeout(kick.net.socket, wsWait);
           return;
          }
          else if (j.data.code >= 4200 && j.data.code <= 4299)
          {
           if (_tExpire !== false)
           {
            window.clearTimeout(_tExpire);
            _tExpire = false;
           }
           if (_tTimeout !== false)
           {
            window.clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           _ws.onmessage = null;
           _ws.onclose = null;
           _ws.close();
           _ws = null;
           if (kick.net.dead === true)
            return;
           window.setTimeout(kick.net.socket, 200);
           return;
          }
         }
         console.log(j.data);
        }
        else
         console.log(j);
        return;
       }
       if (!j.hasOwnProperty('data') || j.data === null)
        return;
       const jData = JSON.parse(j.data);
       notice.info(0x32);
       if (j.event.startsWith('pusher:'))
       {
        switch (j.event.slice(7))
        {
         case 'pong':
          return;
         case 'connection_established':
          if (jData.hasOwnProperty('activity_timeout') && jData.activity_timeout !== null)
          {
           if (_tTimeout !== false)
           {
            window.clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           _tTimeout = window.setTimeout(_wsTimeout, jData.activity_timeout);
           if (_tPing !== 0)
           {
            window.clearInterval(_tPing);
            _tPing = 0;
           }
           _tPing = window.setInterval(_wsPing, Math.floor(jData.activity_timeout / 2) * 1000);
          }
          _ws.send(JSON.stringify({event:'pusher:subscribe', data: {auth: '', channel: 'chatrooms.' + kick.net.chatID + '.v2'}}));
          return;
        }
        console.log('unknown pusher event:', j.event.slice(7), jData);
        return;
       }
       if (j.event.startsWith('pusher_internal:'))
       {
        switch (j.event.slice(16))
        {
         case 'subscription_succeeded':
          if (!j.hasOwnProperty('channel') || j.channel === null)
           return;
          if (j.channel === 'chatrooms.' + kick.net.chatID + '.v2')
          {
           if (_tExpire !== false)
           {
            window.clearTimeout(_tExpire);
            _tExpire = false;
           }
           await _loadEmote_channel(cfg.kick.channel);
           if (cfg.display.extended.use7TV && kick.net.userID !== 0)
           {
            thirdparty['7tv'].channel('kick', kick.net.userID);
            await thirdparty['7tv'].socket.join('kick', kick.net.userID);
            thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval);
           }
          }
          return;
        }
        console.log('unknown internal pusher event:', j.event.slice(16), jData);
        return;
       }
       if (j.event.startsWith('App\\Events\\'))
       {
        switch (j.event.slice(11))
        {
         case 'ChatMessageEvent':
          if (document.visibilityState === 'hidden')
           return;
          kick.parse.line(jData);
          return;
         case 'UserBannedEvent':
          if (document.visibilityState === 'hidden')
           return;
          if (jData.hasOwnProperty('expires_at') && jData.expires_at !== null)
          {
           if (cfg.event.kick.timeout !== false)
            await kick.parse.event.timeout(jData);
          }
          else
          {
           if (cfg.event.kick.ban !== false)
            await kick.parse.event.ban(jData);
          }
          return;
         case 'StreamHostEvent':
          if (jData.optional_message !== '')
           console.log(jData.host_username + ' hosted for ' + jData.number_viewers + ' viewers with the message: ' + jData.optional_message);
          if (document.visibilityState === 'hidden')
           return;
          kick.parse.event.raid(jData);
          return;
         case 'SubscriptionEvent':
          if (document.visibilityState === 'hidden')
           return;
          kick.parse.event.sub(jData);
          return;
         case 'GiftedSubscriptionsEvent':
          if (document.visibilityState === 'hidden')
           return;
          kick.parse.event.gift(jData);
          return;
         case 'PollUpdateEvent':
          if (cfg.event.kick.poll === false)
           return;
          if ((!cfg.event.kick.poll.hasOwnProperty('begin') || cfg.event.kick.poll.begin === false) && (!cfg.event.kick.poll.hasOwnProperty('end') || cfg.event.kick.poll.end === false))
           return;
          if (!jData.hasOwnProperty('poll') || jData.poll === null)
           return;
          if (!jData.poll.hasOwnProperty('remaining') || jData.poll.remaining === null)
           return;
          if (_tPoll !== false)
          {
           window.clearTimeout(_tPoll);
           _tPoll = false;
          }
          _tPoll = window.setTimeout(
           function()
           {
            kick.parse.event.pollEnd(jData.poll);
            _tPoll = false;
           },
           jData.poll.remaining * 1000
          );
          if (!jData.poll.hasOwnProperty('duration') || jData.poll.duration === null)
           return;
          if (jData.poll.duration === jData.poll.remaining)
          {
           if (!cfg.event.kick.poll.hasOwnProperty('begin'))
            return;
           if (cfg.event.kick.poll.begin === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!jData.poll.hasOwnProperty('title') || jData.poll.title === null)
            return;
           display.kappa.show(false, cfg.event.kick.poll.begin, {'%TITLE%': jData.poll.title});
           return;
          }
          return;
         case 'PollDeleteEvent':
          if (_tPoll !== false)
          {
           window.clearTimeout(_tPoll);
           _tPoll = false;
          }
          return;
         case 'ChatroomClearEvent':
          if (cfg.event.kick.clear)
           display.eraseAll();
          return;
        }
        console.log('unhandled app event:', j.event.slice(11), jData);
        return;
       }
       console.log('unknown event:', j.event, jData);
      }

      function _wsExpire()
      {
       notice.error(0x32);
       if (_ws === null)
        return;
       if (kick.net.dead === true)
        return;
       kick.net.dead = true;
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       _ws.close();
       _ws = null;
      }

      function _wsPing()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send(JSON.stringify({event: 'pusher:ping', data: {}}));
      }

      function _wsTimeout()
      {
       notice.error(0x32);
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (kick.net.dead === true)
        return;
       kick.net.socket();
      }

      async function _getChIDs()
      {
       const slug = _usesHyphen === true ? cfg.kick.channel.replaceAll('_', '-') : cfg.kick.channel;
       const url = cURLs.api.kick.channels.replaceAll('%CHANNEL_NAME%', encodeURIComponent(slug));
       const r = await shared.httpRequest('GET', url);
       if (!r.success)
       {
        if (r.code === 404 && _usesHyphen === 0)
        {
         _usesHyphen = true;
         return _getChIDs();
        }
        console.log(r.code);
        console.log(r.data);
        return false;
       }
       const j = r.json;
       if (j === null)
        return false;
       if (!j.hasOwnProperty('id') || j.id === null)
        return false;
       if (!j.hasOwnProperty('chatroom') || j.chatroom === null)
        return false;
       if (!j.hasOwnProperty('user_id') || j.user_id === null)
        return false;
       if (!j.chatroom.hasOwnProperty('id') || j.chatroom.id === null)
        return false;
       if (_usesHyphen === 0)
        _usesHyphen = false;
       kick.net.channelID = j.id;
       kick.net.chatID = j.chatroom.id;
       kick.net.userID = j.user_id;
       return true;
      }

      return task;
     }();

     const $followers = function()
     {
      let _uLC = -1;
      let _tS = false;
      const _rSC = 5000;

      async function task()
      {
       _tS = window.setTimeout(_detect, _rSC);
      }

      async function _detect()
      {
       if (_tS === false)
        return;
       window.clearTimeout(_tS);
       _tS = false;
       if (kick.net.dead === true)
        return;
       const fRet = await _getChange();
       if (document.visibilityState !== 'hidden' && fRet > 0)
       {
        for (let i = 0, l = fRet; i < l; i++)
         display.kappa.show(false, cfg.event.kick.follow, {'%USER%': 'Kick User'});
       }
       _tS = window.setTimeout(_detect, _rSC);
      }

      async function _getChange()
      {
       const slug = _usesHyphen === true ? cfg.kick.channel.replaceAll('_', '-') : cfg.kick.channel;
       const url = cURLs.api.kick.followers.replaceAll('%CHANNEL_NAME%', encodeURIComponent(slug));
       const r = await shared.httpRequest('GET', url);
       if (!r.success)
       {
        if (r.code === 404 && _usesHyphen === 0)
        {
         _usesHyphen = true;
         return _getChange();
        }
        console.log(r.code);
        console.log(r.data);
        return 0;
       }
       const j = r.json;
       if (j === null)
        return 0;
       if (!j.hasOwnProperty('data') || j.data === null)
        return 0;
       if (!j.data.hasOwnProperty('count') || j.data.count === null)
        return 0;
       if (_usesHyphen === 0)
        _usesHyphen = false;
       if (_uLC === -1)
        _uLC = j.data.count;
       if (j.data.count !== _uLC)
       {
        if (j.data.count > _uLC)
        {
         const cDif = j.data.count - _uLC;
         _uLC = j.data.count;
         return cDif;
        }
        _uLC = j.data.count;
       }
       return 0;
      }

      return task;
     }();

     async function _loadEmote_channel(chName)
     {
      if (!thirdparty.emotes.hasOwnProperty('kick'))
       thirdparty.emotes.kick = {};
      const r = await _findEmote_channel(chName, thirdparty.emotes.kick);
      if (r === false)
       return false;
      if (cList.length === 0)
       cList = r;
      else
      {
       for (let n in thirdparty.emotes.kick)
       {
        if (!thirdparty.emotes.kick[n].hasOwnProperty('scope'))
         continue;
        if (thirdparty.emotes.kick[n].scope !== 'c')
         continue;
        for (let c = cList.length - 1; c >= 0; c--)
        {
         if (cList[c].url !== thirdparty.emotes.kick[n].url)
          continue;
         cList.splice(c, 1);
         break;
        }
       }
       for (let i = 0, l = r.length; i < l; i++)
       {
        if (!cList.includes(r[i]))
         cList.push(r[i]);
       }
      }
      cSafe = JSON.parse(JSON.stringify(cList));
     }

     return {
      channelID: 0,
      chatID: 0,
      userID: 0,
      sckID: false,
      fList: {},
      dead: false,
      socket: $socket,
      followers: $followers
     };
    }();

    const $parse = function()
    {
     let _aLast = {};

     const $content = function()
     {
      async function $emoji(cmd, set, dup = null)
      {
       if (!cmd.hasOwnProperty('content') || cmd.content === null)
        return [];
       const msg = cmd.content;
       return service.parse.content.emoji(msg, set, dup);
      }

      function $kick(cmd, dup = null)
      {
       if (!cmd.hasOwnProperty('content') || cmd.content === null)
        return [];
       const m = cmd.content;
       if (dup === null)
        dup = cfg.display.duplicates;
       if (dup === false)
        dup = 1;
       const emSeg = /(\[emote:(\d+):([^\]]*)\])/gu;
       let ret = [];
       let ids = [];
       let emList = [];
       let match = '';
       while ((match = emSeg.exec(m)) !== null)
       {
        emList.push(match);
       }
       if (emList.length === 0)
        return [];
       for (let i = 0, n = emList.length; i < n; i++)
       {
        if (emList[i].length !== 4)
         continue;
        const eID = emList[i][2];
        if (dup !== true)
        {
         let ct = 0;
         for (let j = 0, l = ids.length; j < l; j++)
         {
          if (ids[j] === eID)
           ct++;
         }
         if (ct >= dup)
          continue;
        }
        const u = cURLs.cdn.kick.emote.replaceAll('%EMOTE_ID%', eID);
        const p = emList[i].index;
        let sc = 'c';
        const sName = emList[i][3];
        if (sName !== '')
        {
         if (thirdparty.emotes.kick.hasOwnProperty(sName) && thirdparty.emotes.kick[sName].hasOwnProperty('scope'))
          sc = thirdparty.emotes.kick[sName].scope;
        }
        ret.push({svc: 'k', url: u, str: emList[i][0], pos: p, scope: sc});
        ids.push(eID);
       }
       return ret;
      }

      const $3rdparty = function()
      {
       const $7tv = function()
       {
        function $general(cmd, dup = null)
        {
         if (!cmd.hasOwnProperty('content') || cmd.content === null)
          return [];
         return service.parse.content['3rdparty']['7tv'].general(cmd.content, dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         if (!cmd.hasOwnProperty('content') || cmd.content === null)
          return [];
         if (!cmd.hasOwnProperty('sender') || cmd.sender === null)
          return [];
         if (!cmd.sender.hasOwnProperty('slug') || cmd.sender.slug === null)
          return [];
         return service.parse.content['3rdparty']['7tv'].zwe(l, cmd.sender.slug, cmd.content, pass, dup);
        }

        return {
         general: $general,
         zwe: $zwe
        };
       }();

       return {
        '7tv': $7tv
       };
      }();

      return {
       emoji: $emoji,
       kick: $kick,
       '3rdparty': $3rdparty
      };
     }();

     const $line = function()
     {
      async function task(cmd)
      {
       let u = null;
       if (cmd.hasOwnProperty('sender') && cmd.sender !== null)
       {
        if (cmd.sender.hasOwnProperty('slug') && cmd.sender.slug !== null)
         u = cmd.sender.slug;
       }
       if (cfg.ignore.users !== false && u !== null && cfg.ignore.users.includes(u))
        return;
       if (!cmd.hasOwnProperty('content') || cmd.content === null)
        return;
       const lv = await _level(cmd);
       if (await _parseCommand(cmd, lv))
        return;
       if ((lv & cfg.display.access) === 0)
        return;
       const p = _handleDuplicates(await _eListFromCmd(cmd));
       if (p.length === 0)
        return;
       display.emote.addToShowList(p);
       display.emote.showEmotes();
      }

      async function _parseCommand(cmd, lv)
      {
       const kNow = new Date().getTime();
       const m = cmd.content.toLowerCase();
       let foundAdvCmd = false;
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('styles') && !k.hasOwnProperty('erase') && !k.hasOwnProperty('rave') && !k.hasOwnProperty('raveon') && !k.hasOwnProperty('raveoff'))
         continue;
        if (!k.hasOwnProperty('aliases'))
         continue;
        let foundKCmd = false;
        if (k.aliases.includes(m))
         foundKCmd = m;
        if (foundKCmd === false)
        {
         for (let i = 0, l = k.aliases.length; i < l; i++)
         {
          if (m.slice(0, k.aliases[i].length + 1) === k.aliases[i] + ' ')
          {
           foundKCmd = k.aliases[i];
           break;
          }
         }
        }
        if (foundKCmd === false)
         continue;
        let kAccess = cfg.display.kappa.access;
        if (k.hasOwnProperty('access'))
         kAccess = k.access;
        if ((lv & kAccess) === 0)
         continue;
        foundAdvCmd = true;
        if (k.hasOwnProperty('cooldown'))
        {
         let hK = _hashCode(k);
         if (!_aLast.hasOwnProperty(hK))
          _aLast[hK] = 0;
         if (k.cooldown !== 0 && kNow - _aLast[hK] < k.cooldown * 1000)
          continue;
        }
        if (k.hasOwnProperty('erase'))
        {
         display.eraseAll();
         return true;
        }
        if (k.hasOwnProperty('rave'))
        {
         if (document.documentElement.classList.contains('rave'))
          document.documentElement.classList.remove('rave');
         else
          document.documentElement.classList.add('rave');
         return true;
        }
        if (k.hasOwnProperty('raveon'))
        {
         document.documentElement.classList.add('rave');
         return true;
        }
        if (k.hasOwnProperty('raveoff'))
        {
         if (document.documentElement.classList.contains('rave'))
          document.documentElement.classList.remove('rave');
         return true;
        }
        let kC = {};
        let cStyles = k.styles;
        if (typeof cStyles !== 'object')
        {
         if (cStyles === false)
          return foundAdvCmd;
         if (cfg.display.kappa.styles.length < 1)
          return foundAdvCmd;
         cStyles = cfg.display.kappa.styles;
        }
        for (let kS in cStyles)
        {
         if (!cStyles.hasOwnProperty(kS))
          continue;
         kC[kS] = JSON.parse(JSON.stringify(cStyles[kS]));
         kC[kS].command = foundKCmd;
         if (foundKCmd.length === m.length)
          kC[kS].params = null;
         else
          kC[kS].params = m.slice(foundKCmd.length + 1);
        }
        let eA = false;
        if (foundKCmd.length < m.length)
         eA = _handleDuplicates(await _eListFromCmd(cmd, true));
        _aLast[_hashCode(k)] = kNow;
        display.kappa.show(eA, kC);
        return true;
       }
       let foundCmd = false;
       if (cfg.display.kappa.aliases.includes(m))
        foundCmd = m;
       if (foundCmd === false)
       {
        for (let i = 0, l = cfg.display.kappa.aliases.length; i < l; i++)
        {
         if (m.slice(0, cfg.display.kappa.aliases[i].length + 1) === cfg.display.kappa.aliases[i] + ' ')
         {
          foundCmd = cfg.display.kappa.aliases[i];
          break;
         }
        }
       }
       if (foundCmd === false)
        return foundAdvCmd;
       if ((lv & cfg.display.kappa.access) === 0)
        return foundAdvCmd;
       let h = _hashCode(null);
       if (!_aLast.hasOwnProperty(h))
        _aLast[h] = 0;
       if (cfg.display.kappa.cooldown > 0 && kNow - _aLast[h] < cfg.display.kappa.cooldown * 1000)
        return true;
       let a = false;
       if (foundCmd.length < m.length)
        a = _handleDuplicates(await _eListFromCmd(cmd, true));
       _aLast[h] = kNow;
       display.kappa.show(a);
       return true;
      }

      function _hashCode(o)
      {
       const s = JSON.stringify(o);
       let h = 0;
       for (let i = 0, l = s.length; i < l; i++)
        h = Math.imul(31, h) + s.charCodeAt(i) | 0;
       return h;
      }

      return task;
     }();

     const $event = function()
     {
      async function $raid(cmd)
      {
       if (!cmd.hasOwnProperty('host_username') || cmd.host_username === null)
        return;
       if (!cmd.hasOwnProperty('number_viewers') || cmd.number_viewers === null)
        return;
       const c = cmd.number_viewers;
       const r = shared.findInMaybeRange(cfg.event.kick.raid.raiders, c);
       if (r === false)
        return;
       const dn = cmd.host_username;
       const u = await _getUserProfile(dn);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.name))
        return;
       if (!cfg.event.kick.raid.originEmotes)
       {
        display.kappa.show(false, r, {'%USER%': u.display, '%AMOUNT%': c});
        return;
       }
       const e = await _findEmote_channel(u.display);
       if (cfg.event.kick.raid.originExtendedEmotes)
       {
        if (cfg.display.extended.use7TV)
        {
         const r7TV = await thirdparty['7tv'].channelEx('kick', u.id);
         if (r7TV !== false)
         {
          for (let i = 0, l = r7TV.length; i < l; i++)
          {
           if ((r7TV[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
            continue;
           e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
          }
         }
        }
       }
       display.kappa.show(e, r, {'%USER%': u.display, '%AMOUNT%': c});
      }

      async function $sub(cmd)
      {
       if (!cmd.hasOwnProperty('months') || cmd.months === null)
        return;
       if (!cmd.hasOwnProperty('username') || cmd.username === null)
        return;
       if (cmd.months === 1)
       {
        if (!cfg.event.kick.sub.hasOwnProperty('first'))
         return;
        if (cfg.event.kick.sub.first === false)
         return;
        display.kappa.show(false, cfg.event.kick.sub.first, {'%USER%': cmd.username});
        return;
       }
       if (!cfg.event.kick.sub.hasOwnProperty('resub'))
        return;
       const rs = shared.findInMaybeRange(cfg.event.kick.sub.resub, cmd.months);
       if (rs === false)
        return;
       display.kappa.show(false, rs, {'%USER%': cmd.username, '%AMOUNT%': cmd.months});
      }

      async function $gift(cmd)
      {
       if (!cmd.hasOwnProperty('gifter_username') || cmd.gifter_username === null)
        return;
       if (!cmd.hasOwnProperty('gifted_usernames') || cmd.gifted_usernames === null)
        return;
       const mpmgc = cmd.gifted_usernames.length;
       if (mpmgc === 1)
       {
        if (!cfg.event.kick.sub.hasOwnProperty('gift'))
         return;
        if (cfg.event.kick.sub.gift === false)
         return;
        display.kappa.show(false, cfg.event.kick.sub.gift, {'%SENDER%': cmd.gifter_username, '%USER%': cmd.gifted_usernames[0]});
        return;
       }
       if (!cfg.event.kick.sub.hasOwnProperty('giftbomb'))
        return;
       const gpb = shared.findInMaybeRange(cfg.event.kick.sub.giftbomb, mpmgc);
       if (gpb === false)
        return;
       display.kappa.show(false, gpb, {'%SENDER%': cmd.gifter_username, '%AMOUNT%': mpmgc});
      }

      async function $ban(cmd)
      {
       if (!cmd.hasOwnProperty('user') || cmd.user === null)
        return;
       if (cfg.ignore.users !== false && cmd.user.hasOwnProperty('slug') && cmd.user.slug !== null && cfg.ignore.users.includes(cmd.user.slug))
        return;
       if (!cmd.user.hasOwnProperty('username') || cmd.user.username === null)
        return;
       display.kappa.show(false, cfg.event.kick.ban, {'%USER%': cmd.user.username});
      }

      async function $timeout(cmd)
      {
       if (!cmd.hasOwnProperty('user') || cmd.user === null)
        return;
       if (cfg.ignore.users !== false && cmd.user.hasOwnProperty('slug') && cmd.user.slug !== null && cfg.ignore.users.includes(cmd.user.slug))
        return;
       if (!cmd.user.hasOwnProperty('username') || cmd.user.username === null)
        return;
       if (!cmd.hasOwnProperty('expires_at') || cmd.expires_at === null)
        return;
       const tExp = new Date(cmd.expires_at).getTime();
       const dDur = Math.ceil((tExp - new Date().getTime()) / 1000);
       const r = shared.findInMaybeRange(cfg.event.kick.timeout, dDur);
       if (r === false)
        return;
       display.kappa.show(false, r, {'%USER%': cmd.user.username, '%AMOUNT%': dDur});
      }

      function $pollEnd(e)
      {
       let vPoll = 0;
       for (let i = 0, l = e.options.length; i < l; i++)
       {
        if (!e.options[i].hasOwnProperty('label') || e.options[i].label === null)
         continue;
        if (!e.options[i].hasOwnProperty('votes') || e.options[i].votes === null)
         continue;
        vPoll = Math.max(vPoll, e.options[i].votes);
       }
       let rPoll = [];
       for (let i = 0, l = e.options.length; i < l; i++)
       {
        if (!e.options[i].hasOwnProperty('label') || e.options[i].label === null)
         continue;
        if (!e.options[i].hasOwnProperty('votes') || e.options[i].votes === null)
         continue;
        if (e.options[i].votes === vPoll)
         rPoll.push(e.options[i].label);
       }
       let sPoll = 'None';
       if (rPoll.length > 0)
        sPoll = rPoll.join(' + ');
       if (cfg.event.kick.poll !== false && cfg.event.kick.poll.hasOwnProperty('end'))
        display.kappa.show(false, cfg.event.kick.poll.end, {'%TITLE%': e.title, '%RESULT%': sPoll});
      }

      return {
       raid: $raid,
       sub: $sub,
       gift: $gift,
       ban: $ban,
       timeout: $timeout,
       pollEnd: $pollEnd
      };
     }();

     const _level = function()
     {
      const _rFH = 3600000;

      async function task(cmd)
      {
       let r = 0x001;
       if (!cmd.hasOwnProperty('sender') || cmd.sender === null)
        return r;
       if (!cmd.sender.hasOwnProperty('identity') || cmd.sender.identity === null)
        return r;
       if (!cmd.sender.identity.hasOwnProperty('badges') || cmd.sender.identity.badges === null)
        return r;
       if (!Array.isArray(cmd.sender.identity.badges))
        return r;
       if (cmd.sender.identity.badges.length < 1)
        return r;
       for (let i = 0, l = cmd.sender.identity.badges.length; i < l; i++)
       {
        if (!cmd.sender.identity.badges[i].hasOwnProperty('type') || cmd.sender.identity.badges[i].type === null)
         continue;
        switch (cmd.sender.identity.badges[i].type)
        {
         case 'broadcaster':
          r |= 0x800;
          break;
         case 'moderator':
          r |= 0x400;
          break;
         case 'founder':
          r |= 0x200;
          break;
         case 'vip':
          r |= 0x100;
          break;
         case 'og':
          r |= 0x040;
          break;
         case 'subscriber':
          r |= 0x010;
          break;
         case 'verified':
          r |= 0x008;
          break;
         case 'sub_gifter':
          break;
         case 'staff':
          break;
         default:
          console.log(cmd.sender.identity.badges[i]);
        }
       }
       /* api-heavy, only check if follower access is allowed and there's a chance it matters */
       let needF = false;
       if ((cfg.display.access & 0x002) === 0x002 && (cfg.display.access & 0x001) !== 0x001)
        needF = true;
       else if ((cfg.display.kappa.access & 0x002) === 0x002 && (cfg.display.kappa.access & 0x001) !== 0x001)
        needF = true;
       else
       {
        for (const k of cfg.commands)
        {
         if (!k.hasOwnProperty('styles'))
          continue;
         if (!k.hasOwnProperty('access'))
          continue;
         if ((k.access & 0x002) === 0x002 && (k.access & 0x001) !== 0x001)
         {
          needF = true;
          break;
         }
        }
       }
       if (needF)
       {
        const f = await _checkFollower(cmd);
        if (f)
         r |= 0x002;
       }
       if ((r & 0x800) === 0x800 && (r & 0x070) !== 0)
        return r & ~0x070;
       return r;
      }

      async function _checkFollower(cmd)
      {
       const uID = cmd.sender.id;
       if (kick.net.fList.hasOwnProperty(uID))
       {
        const tDif = new Date().getTime() - kick.net.fList[uID].t;
        if (tDif < _rFH)
         return kick.net.fList[uID].value;
       }
       const u = await _getUserProfile(cmd.sender.username);
       if (u === false)
        return false;
       if (u.follower !== false)
       {
        kick.net.fList[uID] = {value: true, t: new Date().getTime()};
        return true;
       }
       kick.net.fList[uID] = {value: false, t: new Date().getTime()};
       return false;
      }

      return task;
     }();

     function _handleDuplicates(a)
     {
      const lA = a.length;
      if (lA < 1)
       return a;
      let r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 'c')
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'u')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 'k' && a[i].scope === 'c')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'c' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 'k' && a[i].scope === 'g')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'g' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 'e')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      return r;
     }

     function _notDupe(add, pend)
     {
      for (let i = 0, l = pend.length; i < l; i++)
      {
       if (pend[i].str === add.str)
        return (pend[i].svc === add.svc);
      }
      return true;
     }

     async function _eListFromCmd(cmd, dup = null)
     {
      let r = [];
      let u = null;
      if (cmd.hasOwnProperty('sender') && cmd.sender !== null)
      {
       if (cmd.sender.hasOwnProperty('slug') && cmd.sender.slug !== null)
        u = cmd.sender.slug;
      }
      if (cfg.ignore.users !== false && u !== false && cfg.ignore.users.includes(u))
       return r;
      r = r.concat(kick.parse.content.kick(cmd, dup));
      if (cfg.display.useEmoji)
       r = r.concat(await kick.parse.content.emoji(cmd, cfg.display.useEmoji, dup));
      if (cfg.display.extended.use7TV)
       r = r.concat(kick.parse.content['3rdparty']['7tv'].general(cmd, dup));
      if (cfg.display.extended.use7TV)
       kick.parse.content['3rdparty']['7tv'].zwe(r, cmd, 1, dup);
      if (cfg.display.extended.use7TV)
       kick.parse.content['3rdparty']['7tv'].zwe(r, cmd, 2, dup);
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.length > 0)
      {
       for (let i = r.length - 1; i >= 0; i--)
       {
        let m = r[i].str;
        if (r[i].svc === 'e')
         m = String.fromCharCode(parseInt(m, 16));
        if (cfg.ignore.emotes.includes(m))
         r.splice(i, 1);
       }
      }
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (r[i].hasOwnProperty('width') || r[i].hasOwnProperty('height'))
        continue;
       if (!r[i].hasOwnProperty('url'))
        continue;
       const sz = await shared.ec.get(r[i].url);
       if (sz === null)
        continue;
       r[i].width = sz.width;
       r[i].height = sz.height;
      }
      return r;
     }

     function $clearCooldowns()
     {
      _aLast = {};
     }

     return {
      content: $content,
      line: $line,
      event: $event,
      clearCooldowns: $clearCooldowns,
      uReg: /[^A-Za-z0-9_]/
     };
    }();

    const _findEmote_channel = function()
    {
     const _rCH = 300000;
     let _chList = {};

     async function task(chName, n = false, useHyphen = false)
     {
      if (n === false && _chList.hasOwnProperty(chName))
      {
       const tDif = new Date().getTime() - _chList[chName].t;
       if (tDif < _rCH)
        return _chList[chName].value;
      }
      const slug = useHyphen === true ? chName.replaceAll('_', '-') : chName;
      const url = cURLs.api.kick.emotes.replaceAll('%CHANNEL_NAME%', encodeURIComponent(slug));
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
      {
       if (r.code === 404 && chName.includes('_'))
        return _findEmote_channel(chName, n, true);
       console.log(r.code);
       console.log(r.data);
       return false;
      }
      const j = r.json;
      if (j === null)
       return false;
      if (!Array.isArray(j))
       return false;
      let ret = [];
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('id') || j[i].id === null)
        continue;
       if (j[i].id === 'Global')
       {
        _scrapeGlobal(j[i]);
        continue;
       }
       if (j[i].id === 'Emoji')
        continue;
       if (!j[i].hasOwnProperty('emotes') || j[i].emotes === null)
        continue;
       if (!Array.isArray(j[i].emotes))
        continue;
       for (let e = 0, m = j[i].emotes.length; e < m; e++)
       {
        if (cfg.ignore.emotes !== false && j[i].emotes[e].hasOwnProperty('name') && j[i].emotes[e].name !== null && cfg.ignore.emotes.includes(j[i].emotes[e].name))
         continue;
        const eURL = cURLs.cdn.kick.emote.replaceAll('%EMOTE_ID%', j[i].emotes[e].id);
        if (n !== false && j[i].emotes[e].hasOwnProperty('name') && j[i].emotes[e].name !== null)
        {
         n[j[i].emotes[e].name] = {
          scope: 'c',
          url: eURL,
          id: j[i].emotes[e].id
         };
        }
        ret.push({url: eURL});
       }
       _chList[chName] = {t: new Date().getTime(), value: ret};
      }
      return ret;
     }

     function _scrapeGlobal(d)
     {
      if (!d.hasOwnProperty('emotes') || d.emotes === null)
       return;
      if (!Array.isArray(d.emotes))
       return;
      if (!thirdparty.emotes.hasOwnProperty('kick'))
       thirdparty.emotes.kick = {};
      for (let e = 0, m = d.emotes.length; e < m; e++)
      {
       if (!d.emotes[e].hasOwnProperty('name') || d.emotes[e].name === null)
        continue;
       if (cfg.ignore.emotes !== false && cfg.ignore.emotes.includes(d.emotes[e].name))
        continue;
       const eURL = cURLs.cdn.kick.emote.replaceAll('%EMOTE_ID%', d.emotes[e].id);
       thirdparty.emotes.kick[d.emotes[e].name] = {
        scope: 'g',
        url: eURL,
        id: d.emotes[e].id
       };
      }
     }

     return task;
    }();

    async function _getUserProfile(dn)
    {
     const slug = _usesHyphen === true ? cfg.kick.channel.replaceAll('_', '-') : cfg.kick.channel;
     const url = cURLs.api.kick.users.replaceAll('%CHANNEL_NAME%', encodeURIComponent(slug)).replaceAll('%USER%', encodeURIComponent(dn));
     const r = await shared.httpRequest('GET', url);
     if (!r.success)
     {
      if (r.code === 404 && _usesHyphen === 0)
      {
       _usesHyphen = true;
       return _getUserProfile(dn);
      }
      return false;
     }
     const j = r.json;
     if (j === null)
      return false;
     if (_usesHyphen === 0)
      _usesHyphen = false;
     let u = {};
     if (j.hasOwnProperty('slug') && j.slug !== null)
      u.name = j.slug;
     else
      u.name = dn.toLowerCase();
     if (j.hasOwnProperty('username') && j.username !== null)
      u.display = j.username;
     else
      u.display = dn;
     if (j.hasOwnProperty('id') && j.id !== null)
      u.id = j.id;
     else
      u.id = 0;
     if (j.hasOwnProperty('following_since') && j.following_since !== null)
      u.follower = j.following_since;
     else
      u.follower = false;
     return u;
    }

    return {
     net: $net,
     parse: $parse
    };
   }();

   const service = function()
   {
    const $parse = function()
    {
     const $content = function()
     {
      const $emoji = function()
      {
       let _uList = {};

       async function task(msg, set, dup = null)
       {
        const emSeg = /((?:[\p{EPres}\p{ExtPict}]\ufe0f?\u200d?)+)+/gu;
        let emList = [];
        let match = '';
        while ((match = emSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        const kcSeg = /((?:[0-9#\*]\ufe0f\u20e3)+)+/gu;
        match = '';
        while ((match = kcSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        const acSeg = /(\u0d9e)/gu;
        match = '';
        while ((match = acSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        if (emList.length === 0)
         return [];
        if (dup === null)
         dup = cfg.display.duplicates;
        if (set === true)
         set = 'twemoji';
        let ret = [];
        const uri = cURLs.cdn.ffz.emoji.replaceAll('%SET_ID%', set);
        let addList = {};
        function __showEmoji(c, p)
        {
         if (c.slice(-5) === '-fe0f' && !c.match(/-200d-264[0|2]-/) && !c.match(/-200d-269[5|6]-/) && !c.match(/-200d-26a7/) && !c.match(/-200d-2620/) && !c.match(/-200d-2708/))
          c = c.slice(0, -5);
         if (!addList.hasOwnProperty(c))
          addList[c] = 0;
         else
         {
          if (dup === false)
           return false;
          if (dup !== true && addList[c] >= dup)
           return false;
         }
         addList[c]++;
         ret.push({svc: 'e', url: uri + c + '.png', str: c, pos: p});
         return true;
        }
        function __showCrew(p)
        {
         if (!addList.hasOwnProperty('0d9e'))
          addList['0d9e'] = 0;
         else
         {
          if (dup === false)
           return false;
          if (dup !== true && addList['0d9e'] >= dup)
           return false;
         }
         addList['0d9e']++;
         const svgC = shared.rnd(18);
         const svgCSS = '.st0{fill:#484C4D;}.st1{fill:#' + crewColors[svgC][0] + ';}.st2{fill:#A3D3E3;}.st3{opacity:0.5;fill:#' + crewColors[svgC][1] + ';}.st4{opacity:0.45;fill:#5B7882;}.st5{fill:#FFFFFF;}' + (shared.rnd(2) === 1 ? 'svg{transform: scaleX(-1);}' : '');
         const crew = crewSVG.replace('%CSS%', encodeURIComponent(svgCSS));
         ret.push({svc: 'e', url: crew, str: '0d9e', pos: p});
         return true;
        }
        for (let i = 0, l = emList.length; i < l; i++)
        {
         let cpList = [];
         for (const c of emList[i][0])
         {
          const p = c.codePointAt(0).toString(16).padStart(4, '0');
          if (cpList.length === 0)
          {
           cpList.push(p);
           continue;
          }
          const lL = cpList.length - 1;
          if (p === 'fe0f')
           cpList[lL] += '-' + p;
          else if (p === '200d')
           cpList[lL] += '-' + p;
          else if (p === '20e3')
           cpList[lL] += '-' + p;
          else if (p.match(/1f3f[b-f]/))
           cpList[lL] += '-' + p;
          else if (p.match(/1f9b[0-3]/))
          {
           if (cpList[lL].slice(-5) === '-200d')
            cpList[lL] += '-' + p;
           else
            cpList[lL] += '-200d-' + p;
          }
          else if (p.match(/264[0|2]/) || p.match(/26a7/))
          {
           if (cpList[lL].slice(-5) === '-200d')
            cpList[lL] += '-' + p;
           else
            cpList[lL] += '-200d-' + p;
          }
          else if (p.match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].length < 11)
           cpList[lL] += '-' + p;
          else if (p === '1f308' && cpList[lL] === '1f3f3-fe0f')
           cpList[lL] += '-200d-' + p;
          else if (p === '2620' && cpList[lL] === '1f3f4')
           cpList[lL] += '-200d-' + p;
          else if (cpList[lL].slice(-5) === '-200d')
           cpList[lL] += '-' + p;
          else
           cpList.push(p);
         }
         let found = false;
         const lP = cpList.length;
         if (lP === 1)
         {
          let s = cpList[0];
          if (s === '0d9e')
          {
           __showCrew(emList[i].index);
           continue;
          }
          let tU;
          if (s.slice(-5) === '-fe0f')
          {
           if (s.match(/-200d-264[0|2]-/) || s.match(/-200d-264[0|2]-/) || s.match(/-200d-26a7/) || s.match(/-200d-2620/) || s.match(/-200d-2708/))
            tU = uri + s + '.png';
           else
            tU = uri + s.slice(0, -5) + '.png';
          }
          else
           tU = uri + s + '.png';
          found = await _checkURL(tU);
          if (found)
          {
           __showEmoji(s, emList[i].index);
           continue;
          }
          while (s.includes('-'))
          {
           s = s.slice(0, s.lastIndexOf('-'));
           if (s.slice(-5) === '-fe0f')
            tU = uri + s.slice(0, -5) + '.png';
           else
            tU = uri + s + '.png';
           found = await _checkURL(tU);
           if (found)
           {
            __showEmoji(s, emList[i].index);
            break;
           }
          }
          continue;
         }
         let p = emList[i].index;
         for (let j = 0; j < lP; j++)
         {
          p += cpList[j].replaceAll(/[^\-]/g, '').length + 1;
          found = await _checkURL(uri + cpList[j] + '.png');
          if (found)
           __showEmoji(cpList[j], p);
         }
        }
        return ret;
       }

       function _checkURL(url)
       {
        const p = new Promise(
         function(resolve)
         {
          if (_uList.hasOwnProperty(url))
          {
           resolve(_uList[url]);
           return;
          }
          const x = new XMLHttpRequest();
          x.open('HEAD', url);
          x.onreadystatechange = function()
          {
           if (x.readyState < 2)
            return;
           x.onreadystatechange = null;
           const r = x.status === 200;
           _uList[url] = r;
           resolve(r);
          };
          x.send();
         }
        );
        return p;
       }

       return task;
      }();

      const $3rdparty = function()
      {
       const $ffz = function()
       {
        function $general(msg, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('ffz'))
          return [];
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes.ffz.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          ret.push({svc: 'f', url: thirdparty.emotes.ffz[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.ffz[m[i]].scope, width: thirdparty.emotes.ffz[m[i]].width, height: thirdparty.emotes.ffz[m[i]].height});
         }
         return ret;
        }

        function $zwe(l, usr, msg, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!thirdparty.emotes.hasOwnProperty('zwe'))
          return;
         if (!thirdparty.emotes.zwe.hasOwnProperty('ffz'))
          return;
         l.sort(_posSort);
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!thirdparty.emotes.zwe.ffz.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: 'f', url: thirdparty.emotes.zwe.ffz[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffz[m[i]].scope, width: thirdparty.emotes.zwe.ffz[m[i]].width, height: thirdparty.emotes.zwe.ffz[m[i]].height});
          }
          else
          {
           let t = msg.slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(thirdparty.emotes.zwe.ffz);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('ffzU') && thirdparty.emotes.zwe.ffzU.hasOwnProperty(usr))
           {
            z = Object.keys(thirdparty.emotes.zwe.ffzU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttv'))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttv);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttvU') && thirdparty.emotes.zwe.bttvU.hasOwnProperty(usr))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttvU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('7tv'))
           {
            z = Object.keys(thirdparty.emotes.zwe['7tv']);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: 'f', url: thirdparty.emotes.zwe.ffz[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffz[m[i]].scope, width: thirdparty.emotes.zwe.ffz[m[i]].width, height: thirdparty.emotes.zwe.ffz[m[i]].height});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: 'f', url: thirdparty.emotes.zwe.ffz[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffz[m[i]].scope, width: thirdparty.emotes.zwe.ffz[m[i]].width, height: thirdparty.emotes.zwe.ffz[m[i]].height});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== 'f')
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        const $user = function()
        {
         function $userGeneral(usr, msg, dup = null)
         {
          if (!thirdparty.emotes.hasOwnProperty('ffzU'))
           return [];
          const m = msg.split(' ');
          if (!thirdparty.emotes.ffzU.hasOwnProperty(usr))
           return [];
          if (dup === null)
           dup = cfg.display.duplicates;
          let ret = [];
          let addList = {};
          for (let i = 0, l = m.length; i < l; i++)
          {
           if (!thirdparty.emotes.ffzU[usr].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p += m[j].length + 1;
           }
           ret.push({svc: 'f', url: thirdparty.emotes.ffzU[usr][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.ffzU[usr][m[i]].scope, width: thirdparty.emotes.ffzU[usr][m[i]].width, height: thirdparty.emotes.ffzU[usr][m[i]].height});
          }
          return ret;
         }

         function $userZWE(l, usr, msg, pass, dup = null)
         {
          if (!cfg.display.extended.useZWE)
           return;
          if (!thirdparty.emotes.hasOwnProperty('zwe'))
           return;
          if (!thirdparty.emotes.zwe.hasOwnProperty('ffzU'))
           return;
          if (!thirdparty.emotes.zwe.ffzU.hasOwnProperty(usr))
           return;
          l.sort(_posSort);
          const m = msg.split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          let addList = {};
          for (let i = 0, n = m.length; i < n; i++)
          {
           if (!thirdparty.emotes.zwe.ffzU[usr].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p += m[j].length + 1;
           }
           let f = -1;
           let h = -1;
           for (let j = 0, o = l.length; j < o; j++)
           {
            if (l[j].pos > h)
             h = l[j].pos;
            else
             continue;
            if (l[j].pos < p)
             f = j;
           }
           if (f === -1)
           {
            if (pass === 1)
             l.push({svc: 'f', url: thirdparty.emotes.zwe.ffzU[usr][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffzU[usr][m[i]].scope, width: thirdparty.emotes.zwe.ffzU[usr][m[i]].width, height: thirdparty.emotes.zwe.ffzU[usr][m[i]].height});
           }
           else
           {
            let t = msg.slice(l[f].pos + l[f].str.length, p);
            let z = Object.keys(thirdparty.emotes.zwe.ffzU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('ffz'))
            {
             z = Object.keys(thirdparty.emotes.zwe.ffz);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('bttv'))
            {
             z = Object.keys(thirdparty.emotes.zwe.bttv);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('bttvU') && thirdparty.emotes.zwe.bttvU.hasOwnProperty(usr))
            {
             z = Object.keys(thirdparty.emotes.zwe.bttvU[usr]);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('7tv'))
            {
             z = Object.keys(thirdparty.emotes.zwe['7tv']);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            t = t.trim();
            if (t.length > 0)
            {
             if (pass === 1)
              l.push({svc: 'f', url: thirdparty.emotes.zwe.ffzU[usr][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffzU[usr][m[i]].scope, width: thirdparty.emotes.zwe.ffzU[usr][m[i]].width, height: thirdparty.emotes.zwe.ffzU[usr][m[i]].height});
            }
            else if (pass === 2)
            {
             if (!l[f].hasOwnProperty('zwe'))
              l[f].zwe = [];
             l[f].zwe.push({svc: 'f', url: thirdparty.emotes.zwe.ffzU[usr][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffzU[usr][m[i]].scope, width: thirdparty.emotes.zwe.ffzU[usr][m[i]].width, height: thirdparty.emotes.zwe.ffzU[usr][m[i]].height});
             l[f].zwe.sort(_posSort);
             for (let j = 0, o = l.length; j < o; j++)
             {
              if (l[j].svc !== 'f')
               continue;
              if (l[j].pos !== p)
               continue;
              l.splice(j, 1);
              break;
             }
            }
           }
          }
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $bttv = function()
       {
        function $general(msg, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('bttv'))
          return [];
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes.bttv.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          ret.push({svc: 'b', url: thirdparty.emotes.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.bttv[m[i]].scope, width: thirdparty.emotes.bttv[m[i]].width, height: thirdparty.emotes.bttv[m[i]].height});
         }
         return ret;
        }

        function $zwe(l, usr, msg, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!thirdparty.emotes.hasOwnProperty('zwe'))
          return;
         if (!thirdparty.emotes.zwe.hasOwnProperty('bttv'))
          return;
         l.sort(_posSort);
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!thirdparty.emotes.zwe.bttv.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope, width: thirdparty.emotes.zwe.bttv[m[i]].width, height: thirdparty.emotes.zwe.bttv[m[i]].height});
          }
          else
          {
           let t = msg.slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(thirdparty.emotes.zwe.bttv);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('ffz'))
           {
            z = Object.keys(thirdparty.emotes.zwe.ffz);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('ffzU') && thirdparty.emotes.zwe.ffzU.hasOwnProperty(usr))
           {
            z = Object.keys(thirdparty.emotes.zwe.ffzU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttvU') && thirdparty.emotes.zwe.bttvU.hasOwnProperty(usr))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttvU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('7tv'))
           {
            z = Object.keys(thirdparty.emotes.zwe['7tv']);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope, width: thirdparty.emotes.zwe.bttv[m[i]].width, height: thirdparty.emotes.zwe.bttv[m[i]].height});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope, width: thirdparty.emotes.zwe.bttv[m[i]].width, height: thirdparty.emotes.zwe.bttv[m[i]].height});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== 'b')
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        const $user = function()
        {
         function $userGeneral(usr, msg, dup = null)
         {
          if (!thirdparty.emotes.hasOwnProperty('bttvU'))
           return [];
          if (!thirdparty.emotes.bttvU.hasOwnProperty(usr))
           return [];
          const m = msg.split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          let ret = [];
          let addList = {};
          for (let i = 0, l = m.length; i < l; i++)
          {
           if (!thirdparty.emotes.bttvU[usr].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p += m[j].length + 1;
           }
           ret.push({svc: 'b', url: thirdparty.emotes.bttvU[usr][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.bttvU[usr][m[i]].scope, width: thirdparty.emotes.bttvU[usr][m[i]].width, height: thirdparty.emotes.bttvU[usr][m[i]].height});
          }
          return ret;
         }

         function $userZWE(l, usr, msg, pass, dup = null)
         {
          if (!cfg.display.extended.useZWE)
           return;
          if (!thirdparty.emotes.hasOwnProperty('zwe'))
           return;
          if (!thirdparty.emotes.zwe.hasOwnProperty('bttvU'))
           return;
          if (!thirdparty.emotes.zwe.bttvU.hasOwnProperty(usr))
           return;
          l.sort(_posSort);
          const m = msg.split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          let addList = {};
          for (let i = 0, n = m.length; i < n; i++)
          {
           if (!thirdparty.emotes.zwe.bttvU[usr].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p += m[j].length + 1;
           }
           let f = -1;
           let h = -1;
           for (let j = 0, o = l.length; j < o; j++)
           {
            if (l[j].pos > h)
             h = l[j].pos;
            else
             continue;
            if (l[j].pos < p)
             f = j;
           }
           if (f === -1)
           {
            if (pass === 1)
             l.push({svc: 'b', url: thirdparty.emotes.zwe.bttvU[usr][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttvU[usr][m[i]].scope, width: thirdparty.emotes.zwe.bttvU[usr][m[i]].width, height: thirdparty.emotes.zwe.bttvU[usr][m[i]].height});
           }
           else
           {
            let t = msg.slice(l[f].pos + l[f].str.length, p);
            let z = Object.keys(thirdparty.emotes.zwe.bttvU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('ffz'))
            {
             z = Object.keys(thirdparty.emotes.zwe.ffz);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('ffzU') && thirdparty.emotes.zwe.ffzU.hasOwnProperty(usr))
            {
             z = Object.keys(thirdparty.emotes.zwe.ffzU[usr]);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('bttv'))
            {
             z = Object.keys(thirdparty.emotes.zwe.bttv);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('7tv'))
            {
             z = Object.keys(thirdparty.emotes.zwe['7tv']);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            t = t.trim();
            if (t.length > 0)
            {
             if (pass === 1)
              l.push({svc: 'b', url: thirdparty.emotes.zwe.bttvU[usr][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttvU[usr][m[i]].scope, width: thirdparty.emotes.zwe.bttvU[usr][m[i]].width, height: thirdparty.emotes.zwe.bttvU[usr][m[i]].height});
            }
            else if (pass === 2)
            {
             if (!l[f].hasOwnProperty('zwe'))
              l[f].zwe = [];
             l[f].zwe.push({svc: 'b', url: thirdparty.emotes.zwe.bttvU[usr][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttvU[usr][m[i]].scope, width: thirdparty.emotes.zwe.bttvU[usr][m[i]].width, height: thirdparty.emotes.zwe.bttvU[usr][m[i]].height});
             l[f].zwe.sort(_posSort);
             for (let j = 0, o = l.length; j < o; j++)
             {
              if (l[j].svc !== 'b')
               continue;
              if (l[j].pos !== p)
               continue;
              l.splice(j, 1);
              break;
             }
            }
           }
          }
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $7tv = function()
       {
        function $general(msg, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('7tv'))
          return [];
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes['7tv'].hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          ret.push({svc: '7', url: thirdparty.emotes['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes['7tv'][m[i]].scope, width: thirdparty.emotes['7tv'][m[i]].width, height: thirdparty.emotes['7tv'][m[i]].height});
         }
         return ret;
        }

        function $zwe(l, usr, msg, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!thirdparty.emotes.hasOwnProperty('zwe'))
          return;
         if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
          return;
         l.sort(_posSort);
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!thirdparty.emotes.zwe['7tv'].hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope, width: thirdparty.emotes.zwe['7tv'][m[i]].width, height: thirdparty.emotes.zwe['7tv'][m[i]].height});
          }
          else
          {
           let t = msg.slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(thirdparty.emotes.zwe['7tv']);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('ffz'))
           {
            z = Object.keys(thirdparty.emotes.zwe.ffz);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('ffzU') && thirdparty.emotes.zwe.ffzU.hasOwnProperty(usr))
           {
            z = Object.keys(thirdparty.emotes.zwe.ffzU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttv'))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttv);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttvU') && thirdparty.emotes.zwe.bttvU.hasOwnProperty(usr))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttvU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope, width: thirdparty.emotes.zwe['7tv'][m[i]].width, height: thirdparty.emotes.zwe['7tv'][m[i]].height});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope, width: thirdparty.emotes.zwe['7tv'][m[i]].width, height: thirdparty.emotes.zwe['7tv'][m[i]].height});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== '7')
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: $general,
         zwe: $zwe
        };
       }();

       return {
        ffz: $ffz,
        bttv: $bttv,
        '7tv': $7tv
       };
      }();

      return {
       emoji: $emoji,
       '3rdparty': $3rdparty
      };
     }();

     return {
      content: $content
     };
    }();

    return {
     parse: $parse
    };
   }();

   const streamlabs = function()
   {
    async function _showStreamlabsDonations(dRet)
    {
     for (let i = 0, l = dRet.length; i < l; i++)
     {
      const n = dRet[i].name;
      const a = dRet[i].amt;
      const v = Math.floor(a * cfg.streamlabs.curMul);
      const r = shared.findInMaybeRange(cfg.event.tip.streamlabs.donation, v);
      if (r === false)
       continue;
      let p = false;
      if (cfg.event.tip.useProfileImage && n !== false)
      {
       let u = false;
       if (!twitch.parse.uReg.test(n))
        u = await twitch.net.userInfo(n);
       if (u !== false)
       {
        if (u.hasOwnProperty('profile_image_url'))
         p = [
          {url: u.profile_image_url}
         ];
       }
      }
      let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
      if (cfg.streamlabs.dispDec > 0)
       s = s.toFixed(cfg.streamlabs.dispDec);
      else
       s = Math.floor(s);
      if (cfg.streamlabs.dispPre !== false)
       s = cfg.streamlabs.dispPre + s;
      if (cfg.streamlabs.dispSuf !== false)
       s += cfg.streamlabs.dispSuf;
      display.kappa.show(p, r, {'%USER%': n, '%AMOUNT%': s});
     }
    }

    async function _showStreamlabsPledges(pRet)
    {
     for (let i = 0, l = pRet.length; i < l; i++)
     {
      const n = pRet[i].name;
      const a = pRet[i].amt;
      const v = Math.floor(a * cfg.streamlabs.curMul);
      const r = shared.findInMaybeRange(cfg.event.tip.streamlabs.pledge, v);
      if (r === false)
       continue;
      let p = false;
      if (cfg.event.tip.useProfileImage && n !== false)
      {
       let u = false;
       if (!twitch.parse.uReg.test(n))
        u = await twitch.net.userInfo(n);
       if (u !== false)
       {
        if (u.hasOwnProperty('profile_image_url'))
         p = [
          {url: u.profile_image_url}
         ];
       }
      }
      let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
      if (cfg.streamlabs.dispDec > 0)
       s = s.toFixed(cfg.streamlabs.dispDec);
      else
       s = Math.floor(s);
      if (cfg.streamlabs.dispPre !== false)
       s = cfg.streamlabs.dispPre + s;
      if (cfg.streamlabs.dispSuf !== false)
       s += cfg.streamlabs.dispSuf;
      display.kappa.show(p, r, {'%USER%': n, '%AMOUNT%': s});
     }
    }

    const $socket = function()
    {
     let _wsRetry = 0;
     let _tPing = false;
     let _ws = null;
     let _lTimeout = 5000;
     let _tTimeout = false;

     function task()
     {
      _tPing = 0;
      _ws = new WebSocket(cURLs.ws.streamlabs.replaceAll('%TOKEN%', cfg.streamlabs.token));
      _ws.onopen = _wsOpen;
      _ws.onclose = _wsClose;
      _ws.onmessage = _wsMessage;
     }

     function _wsOpen()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.onopen = null;
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
     }

     function _wsClose()
     {
      notice.error(0x82);
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws = null;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead)
       return;
      const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
      if (_wsRetry < 2)
       _wsRetry += 0.2;
      window.setTimeout(streamlabs.socket, wsWait);
     }

     async function _wsMessage(ev)
     {
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_ws === null)
       return;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead)
      {
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       return;
      }
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      _wsRetry = 0;
      const d = ev.data;
      if (d.length < 1)
       return;
      notice.info(0x82);
      switch (d.slice(0, 1))
      {
       case '0':
        let t = 25000;
        let u = 5000;
        if (d.length > 1)
        {
         const c = JSON.parse(d.slice(1));
         if (c.hasOwnProperty('pingInterval'))
          t = c.pingInterval;
         if (c.hasOwnProperty('pingTimeout'))
          u = c.pingTimeout;
        }
        _lTimeout = t + u;
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, t);
        break;
       case '4':
        if (document.visibilityState === 'hidden')
         return;
        if (d.slice(1, 2) !== '2')
        {
         if (d.slice(1, 2) === '4')
         {
          notice.error(0x81);
          notice.error(0x82);
          _lTimeout = 5000;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          if (_tPing !== 0)
          {
           window.clearInterval(_tPing);
           _tPing = 0;
          }
          if (_ws === null)
           return;
          _ws.onopen = null;
          _ws.onmessage = null;
          _ws.onclose = null;
          _ws.close();
          _ws = null;
         }
         return;
        }
        if (d.length < 2)
         return;
        const o = JSON.parse(d.slice(2));
        if (o.length < 2)
         return;
        if (o[0] !== 'event')
         return;
        if (!o[1].hasOwnProperty('message'))
         return;
        let rD = [];
        let rP = [];
        for (let i = 0, l = o[1].message.length; i < l; i++)
        {
         if (!o[1].message[i].hasOwnProperty('amount'))
          continue;
         if (!o[1].message[i].hasOwnProperty('type'))
          continue;
         if (o[1].message[i].type === 'donation')
         {
          let n = false;
          if (o[1].message[i].hasOwnProperty('name'))
           n = o[1].message[i].name;
          rD.push({amt: o[1].message[i].amount, name: n});
         }
         if (o[1].message[i].type === 'pledge')
         {
          let n = false;
          if (o[1].message[i].hasOwnProperty('name'))
           n = o[1].message[i].name;
          rP.push({amt: o[1].message[i].amount, name: n});
         }
        }
        if (rD.length > 0)
         await _showStreamlabsDonations(rD);
        if (rP.length > 0)
         await _showStreamlabsPledges(rP);
        break;
      }
     }

     function _wsPing()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.send('2');
     }

     function _wsTimeout()
     {
      notice.error(0x82);
      _lTimeout = 5000;
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws.close();
      _ws = null;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead)
       return;
      streamlabs.socket();
     }

     return task;
    }();

    function $cfgVals()
    {
     if (!cfg.hasOwnProperty('streamlabs'))
      return 0;
     let r = 0;
     if (cfg.streamlabs.hasOwnProperty('token') && cfg.streamlabs.token !== false && cfg.streamlabs.token !== null && cfg.streamlabs.token !== 'SOCKET_TOKEN')
      r |= 0x01;
     return r;
    }

    return {
     socket: $socket,
     cfgVals: $cfgVals
    };
   }();

   const streamelements = function()
   {
    async function _showStreamElementsTip(dAmt, dName)
    {
     const v = Math.floor(dAmt * cfg.streamelements.curMul);
     if (v < 1)
      return;
     const r = shared.findInMaybeRange(cfg.event.tip.streamelements, v);
     if (r === false)
      return;
     let p = false;
     if (cfg.event.tip.useProfileImage && dName !== false)
     {
      let u = false;
      if (!twitch.parse.uReg.test(dName))
       u = await twitch.net.userInfo(dName);
      if (u !== false)
      {
       if (u.hasOwnProperty('profile_image_url'))
        p = [
         {url: u.profile_image_url}
        ];
      }
     }
     let s = Number.parseFloat(dAmt * cfg.streamelements.dispMul);
     if (cfg.streamelements.dispDec > 0)
      s = s.toFixed(cfg.streamelements.dispDec);
     else
      s = Math.floor(s);
     if (cfg.streamelements.dispPre !== false)
      s = cfg.streamelements.dispPre + s;
     if (cfg.streamelements.dispSuf !== false)
      s += cfg.streamelements.dispSuf;
     display.kappa.show(p, r, {'%USER%': dName, '%AMOUNT%': s});
    }

    const $socket = function()
    {
     let _wsRetry = 0;
     let _tPing = 0;
     let _ws = null;
     let _lTimeout = 5000;
     let _tTimeout = false;

     function task()
     {
      _tPing = 0;
      _ws = new WebSocket(cURLs.ws.streamelements);
      _ws.onopen = _wsOpen;
      _ws.onclose = _wsClose;
      _ws.onmessage = _wsMessage;
     }

     function _wsOpen()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.onopen = null;
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
     }

     function _wsClose()
     {
      notice.error(0x72);
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws = null;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead)
       return;
      const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
      if (_wsRetry < 2)
       _wsRetry += 0.2;
      window.setTimeout(streamelements.socket, wsWait);
     }

     async function _wsMessage(ev)
     {
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_ws === null)
       return;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead)
      {
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       return;
      }
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      _wsRetry = 0;
      const d = ev.data;
      if (d.length < 1)
       return;
      notice.info(0x72);
      switch (d.slice(0, 1))
      {
       case '0':
        let t = 25000;
        let u = 20000;
        if (d.length > 1)
        {
         const c = JSON.parse(d.slice(1));
         if (c.hasOwnProperty('pingInterval'))
          t = c.pingInterval;
         if (c.hasOwnProperty('pingTimeout'))
          u = c.pingTimeout;
        }
        _lTimeout = t + u;
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, t);
        break;
       case '4':
        if (d.slice(1, 2) === '0')
        {
         let a = '';
         const seCfg = streamelements.cfgVals();
         if ((seCfg & 0x04) === 0x04)
          a = JSON.stringify(['authenticate', {'method': 'oauth2', 'token': cfg.streamelements.oauth}]);
         else if ((seCfg & 0x01) === 0x01)
          a = JSON.stringify(['authenticate', {'method': 'jwt', 'token': cfg.streamelements.token}]);
         if (_ws.readyState === 1)
          _ws.send('42' + a);
         return;
        }
        if (d.slice(1, 2) !== '2')
         return;
        if (d.length < 2)
         return;
        const o = JSON.parse(d.slice(2));
        if (o.length < 2)
         return;
        if (o[0] === 'unauthorized')
        {
         notice.error(0x71);
         notice.error(0x72);
         _lTimeout = 5000;
         if (_tTimeout !== false)
         {
          window.clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         if (_tPing !== 0)
         {
          window.clearInterval(_tPing);
          _tPing = 0;
         }
         if (_ws === null)
          return;
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         return;
        }
        if (document.visibilityState === 'hidden')
         return;
        if (o[0] !== 'event:update')
         return;
        if (!o[1].hasOwnProperty('name'))
         return;
        if (o[1].name !== 'tip-latest')
         return;
        if (!o[1].hasOwnProperty('data'))
         return;
        if (!o[1].data.hasOwnProperty('amount'))
         return;
        let n = false;
        if (o[1].data.hasOwnProperty('name'))
         n = o[1].data.name;
        await _showStreamElementsTip(o[1].data.amount, n);
        break;
      }
     }

     function _wsPing()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.send('2');
     }

     function _wsTimeout()
     {
      notice.error(0x72);
      _lTimeout = 5000;
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws.close();
      _ws = null;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead)
       return;
      streamelements.socket();
     }

     return task;
    }();

    async function _getOAuthToken(t)
    {
     const url = cURLs.api.rr.refresh.se;
     const h = {'Content-Type': 'application/x-www-form-urlencoded'};
     const b = 'refresh=' + encodeURIComponent(t);
     const r = await shared.httpRequest('POST', url, h, b, false);
     if (!r.success)
      return false;
     const j = r.json;
     if (j === null)
      return false;
     if (!j.hasOwnProperty('access_token'))
      return false;
     if (!j.hasOwnProperty('refresh_token'))
      return false;
     if (!j.hasOwnProperty('expires_in'))
      return false;
     return j;
    }

    async function $updateOAuth()
    {
     const lsOAuth = window.localStorage.getItem('streamelements.tips:read.oauth');
     const lsRefresh = window.localStorage.getItem('streamelements.tips:read.refresh');
     const lsExpires = window.localStorage.getItem('streamelements.tips:read.expires');
     const lsRefreshed = window.localStorage.getItem('streamelements.tips:read.refreshed');
     if (lsOAuth !== null)
      cfg.streamelements.oauth = lsOAuth;
     if (lsRefresh !== null)
      cfg.streamelements.oauth_refresh = lsRefresh;
     if (lsExpires !== null)
      cfg.streamelements.oauth_expires = lsExpires;
     if (lsRefreshed !== null)
      cfg.streamelements.oauth_refreshed = lsRefreshed;
     let mustR = true;
     if (cfg.streamelements.hasOwnProperty('oauth_refreshed') && cfg.streamelements.oauth_refreshed > 0)
     {
      const tokAge = Math.floor(new Date().getTime() / 1000) - cfg.streamelements.oauth_refreshed;
      if (tokAge < 24 * 60 * 60)
       mustR = false;
     }
     if (cfg.streamelements.hasOwnProperty('oauth_expires') && cfg.streamelements.oauth_expires > 0)
     {
      const expTime = cfg.streamelements.oauth_expires - Math.floor(new Date().getTime() / 1000);
      if (expTime < 0)
       mustR = true;
     }
     if (!mustR)
      return;
     const ret = await _getOAuthToken(cfg.streamelements.oauth_refresh);
     if (ret === false)
     {
      window.localStorage.removeItem('streamelements.tips:read.oauth');
      window.localStorage.removeItem('streamelements.tips:read.refresh');
      window.localStorage.removeItem('streamelements.tips:read.expires');
      window.localStorage.removeItem('streamelements.tips:read.refreshed');
      notice.error(0x71);
      return;
     }
     cfg.streamelements.oauth = ret.access_token;
     cfg.streamelements.oauth_refresh = ret.refresh_token;
     cfg.streamelements.oauth_expires = Math.floor(new Date().getTime() / 1000) + ret.expires_in;
     cfg.streamelements.oauth_refreshed = Math.floor(new Date().getTime() / 1000);
     window.localStorage.setItem('streamelements.tips:read.oauth', cfg.streamelements.oauth);
     window.localStorage.setItem('streamelements.tips:read.refresh', cfg.streamelements.oauth_refresh);
     window.localStorage.setItem('streamelements.tips:read.expires', cfg.streamelements.oauth_expires);
     window.localStorage.setItem('streamelements.tips:read.refreshed', cfg.streamelements.oauth_refreshed);
    }

    function $cfgVals()
    {
     if (!cfg.hasOwnProperty('streamelements'))
      return 0;
     let r = 0;
     if (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== null && cfg.streamelements.token !== 'JWT_TOKEN')
      r |= 0x01;
     if (cfg.streamelements.hasOwnProperty('oauth_refresh') && cfg.streamelements.oauth_refresh !== false && cfg.streamelements.oauth_refresh !== null && cfg.streamelements.oauth_refresh !== 'OAUTH_REFRESH')
      r |= 0x02;
     if (cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== null && cfg.streamelements.oauth !== 'OAUTH_ID')
      r |= 0x04;
     return r;
    }

    return {
     socket: $socket,
     updateOAuth: $updateOAuth,
     cfgVals: $cfgVals
    };
   }();

   const thirdparty = function()
   {
    const _defSize = 28;

    function _addEmote(list, scope, code, id, url, w = false, h = false, zwe = false)
    {
     if (typeof list === 'undefined')
      return;
     if (cfg.ignore.emotes !== false && cfg.ignore.emotes.includes(code))
      return;
     if (w === false)
      w = _defSize;
     if (h === false)
      h = _defSize;
     if (list.hasOwnProperty(code))
     {
      if (scope === 'g' && list[code].scope === 'c')
       return;
      _removeEmote(list, scope, code);
     }
     list[code] = {scope: scope, url: url, id: id, width: w, height: h};
     if (scope === 'c' && !zwe)
      cList.push({url: url, width: w, height: h});
    }

    function _removeEmote(list, scope, code)
    {
     if (typeof list === 'undefined')
      return;
     if (!list.hasOwnProperty(code))
      return;
     if (list[code].scope !== scope)
      return;
     if (scope === 'c')
     {
      for (let c = cList.length - 1; c >= 0; c--)
      {
       if (cList[c].url !== list[code].url)
        continue;
       cList.splice(c, 1);
       break;
      }
     }
     delete list[code];
    }

    function _removeEmoteByID(list, scope, id)
    {
     if (typeof list === 'undefined')
      return;
     for (let i = Object.keys(list).length - 1; i >= 0; i--)
     {
      const k = Object.keys(list)[i];
      if (list[k].scope !== scope)
       continue;
      if (list[k].id !== id)
       continue;
      _removeEmote(list, scope, k);
      break;
     }
    }

    const $ffz = function()
    {
     function _readFFZ_URL(entry)
     {
      let g = entry.animated ?? entry.urls ?? false;
      if (g === false)
       return false;
      let find = ['4', '2', '1'];
      for (let i = 0, l = find.length; i < l; i++)
      {
       if (!g.hasOwnProperty(find[i]))
        continue;
       return g[find[i]];
      }
      return false;
     }

     async function $global()
     {
      if (!thirdparty.emotes.hasOwnProperty('ffz'))
       thirdparty.emotes.ffz = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('ffz'))
       thirdparty.emotes.zwe.ffz = {};
      const url = cURLs.api.ffz.set.global;
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('sets'))
       return false;
      let usedSets = [];
      if (j.hasOwnProperty('default_sets'))
      {
       for (let i = 0, l = j.default_sets.length; i < l; i++)
        usedSets.push(j.default_sets[i]);
      }
      for (const set in j.sets)
      {
       if (!j.sets.hasOwnProperty(set))
        continue;
       if (!usedSets.includes(j.sets[set].id))
        continue;
       if (!j.sets[set].hasOwnProperty('emoticons'))
        continue;
       for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
       {
        if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
         continue;
        const u = _readFFZ_URL(j.sets[set].emoticons[i]);
        if (u === false)
         continue;
        let w = false;
        let h = false;
        if (j.sets[set].emoticons[i].hasOwnProperty('width'))
         w = j.sets[set].emoticons[i].width;
        if (j.sets[set].emoticons[i].hasOwnProperty('height'))
         h = j.sets[set].emoticons[i].height;
        if (j.sets[set].emoticons[i].hasOwnProperty('modifier') && j.sets[set].emoticons[i].modifier === true)
        {
         if (j.sets[set].emoticons[i].hasOwnProperty('modifier_flags') && (j.sets[set].emoticons[i].modifier_flags & 0x01) === 0x01)
          continue;
         if (cfg.display.extended.useZWE)
          _addEmote(thirdparty.emotes.zwe.ffz, 'g', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, w, h, true);
         continue;
        }
        _addEmote(thirdparty.emotes.ffz, 'g', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, w, h);
       }
      }
      if (!j.hasOwnProperty('users'))
      {
       cSafe = JSON.parse(JSON.stringify(cList));
       return true;
      }
      for (const setID in j.users)
      {
       if (!j.users.hasOwnProperty(setID))
        continue;
       const aList = j.users[setID];
       if (!Array.isArray(aList))
        continue;
       for (const set in j.sets)
       {
        if (!j.sets.hasOwnProperty(set))
         continue;
        if (setID !== set)
         continue;
        if (!j.sets[set].hasOwnProperty('emoticons'))
         continue;
        for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
        {
         if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
          continue;
         const u = _readFFZ_URL(j.sets[set].emoticons[i]);
         if (u === false)
          continue;
         let w = false;
         let h = false;
         if (j.sets[set].emoticons[i].hasOwnProperty('width'))
          w = j.sets[set].emoticons[i].width;
         if (j.sets[set].emoticons[i].hasOwnProperty('height'))
          h = j.sets[set].emoticons[i].height;
         if (j.sets[set].emoticons[i].hasOwnProperty('modifier') && j.sets[set].emoticons[i].modifier === true)
         {
          if (j.sets[set].emoticons[i].hasOwnProperty('modifier_flags') && (j.sets[set].emoticons[i].modifier_flags & 0x01) === 0x01)
           continue;
          if (cfg.display.extended.useZWE)
          {
           if (!thirdparty.emotes.zwe.hasOwnProperty('ffzU'))
            thirdparty.emotes.zwe.ffzU = {};
           for (let k = 0, m = aList.length; k < m; k++)
           {
            if (!thirdparty.emotes.zwe.ffzU.hasOwnProperty(aList[k]))
             thirdparty.emotes.zwe.ffzU[aList[k]] = {};
            _addEmote(thirdparty.emotes.zwe.ffzU[aList[k]], 'u', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, w, h, true);
           }
          }
          continue;
         }
         if (!thirdparty.emotes.hasOwnProperty('ffzU'))
          thirdparty.emotes.ffzU = {};
         for (let k = 0, m = aList.length; k < m; k++)
         {
          if (!thirdparty.emotes.ffzU.hasOwnProperty(aList[k]))
           thirdparty.emotes.ffzU[aList[k]] = {};
          _addEmote(thirdparty.emotes.ffzU[aList[k]], 'u', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, w, h);
         }
        }
       }
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     async function $channelEx(chID)
     {
      const url = cURLs.api.ffz.room.replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('sets'))
       return false;
      let ret = [];
      for (const set in j.sets)
      {
       if (!j.sets[set].hasOwnProperty('emoticons'))
        continue;
       for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
       {
        if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
         continue;
        let m = false;
        if (j.sets[set].emoticons[i].hasOwnProperty('modifier') && j.sets[set].emoticons[i].modifier === true)
        {
         if (j.sets[set].emoticons[i].hasOwnProperty('modifier_flags'))
          m = j.sets[set].emoticons[i].modifier_flags;
         else
          m = 0;
        }
        const u = _readFFZ_URL(j.sets[set].emoticons[i]);
        if (u === false)
         continue;
        let w = false;
        let h = false;
        if (j.sets[set].emoticons[i].hasOwnProperty('width'))
         w = j.sets[set].emoticons[i].width;
        if (j.sets[set].emoticons[i].hasOwnProperty('height'))
         h = j.sets[set].emoticons[i].height;
        ret.push({name: j.sets[set].emoticons[i].name, id: j.sets[set].emoticons[i].id, url: u, modifier: m, width: w, height: h});
       }
      }
      return ret;
     }

     async function $channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('ffz'))
       thirdparty.emotes.ffz = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('ffz'))
       thirdparty.emotes.zwe.ffz = {};
      const r = await thirdparty.ffz.channelEx(chID);
      if (r === false)
       return false;
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (r[i].modifier !== false)
       {
        if ((r[i].modifier & 0x01) === 0x01)
         continue;
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe.ffz, 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height, true);
        continue;
       }
       _addEmote(thirdparty.emotes.ffz, 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height);
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     return {
      global: $global,
      channel: $channel,
      channelEx: $channelEx
     };
    }();

    const $bttv = function()
    {
     const _rBE = 600000;

     function $reload()
     {
      if (thirdparty.bttv.timer === false)
       return;
      window.clearTimeout(thirdparty.bttv.timer);
      thirdparty.bttv.timer = false;
      if (cfg.display.extended.useBTTV)
      {
       if (!twitch.net.dead && twitch.net.channelID !== 0)
        thirdparty.bttv.channel('twitch', twitch.net.channelID);
       if (!youtube.net.dead && youtube.net.channelIDs.length > 0)
       {
        for (let i = 0; i < youtube.net.channelIDs.length; i++)
        {
         thirdparty.bttv.channel('youtube', youtube.net.channelIDs[i]);
        }
       }
      }
      thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, thirdparty.interval);
     }

     async function $global()
     {
      if (!thirdparty.emotes.hasOwnProperty('bttv'))
       thirdparty.emotes.bttv = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('bttv'))
       thirdparty.emotes.zwe.bttv = {};
      const url = cURLs.api.bttv.emotes.global;
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!Array.isArray(j))
       return false;
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('code'))
        continue;
       if (!j[i].hasOwnProperty('id'))
        continue;
       const eURL = cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', j[i].id);
       let w = _defSize;
       let h = _defSize;
       if (j[i].hasOwnProperty('width'))
        w = j[i].width;
       if (j[i].hasOwnProperty('height'))
        h = j[i].height;
       if (bttvZWE.includes(j[i].id))
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe.bttv, 'g', j[i].code, j[i].id, eURL, w, h, true);
        continue;
       }
       _addEmote(thirdparty.emotes.bttv, 'g', j[i].code, j[i].id, eURL, w, h);
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     async function $channelEx(svcName, chID)
     {
      if (!cURLs.api.bttv.users.hasOwnProperty(svcName))
       return [];
      const url = cURLs.api.bttv.users[svcName].replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      let ret = [];
      if (j.hasOwnProperty('channelEmotes'))
      {
       for (let i = 0, l = j.channelEmotes.length; i < l; i++)
       {
        if (!j.channelEmotes[i].hasOwnProperty('code'))
         continue;
        if (!j.channelEmotes[i].hasOwnProperty('id'))
         continue;
        let w = _defSize;
        let h = _defSize;
        if (j.channelEmotes[i].hasOwnProperty('width'))
         w = j.channelEmotes[i].width;
        if (j.channelEmotes[i].hasOwnProperty('height'))
         h = j.channelEmotes[i].height;
        ret.push({name: j.channelEmotes[i].code, id: j.channelEmotes[i].id, url: cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', j.channelEmotes[i].id), width: w, height: h});
       }
      }
      if (j.hasOwnProperty('sharedEmotes'))
      {
       for (let i = 0, l = j.sharedEmotes.length; i < l; i++)
       {
        if (!j.sharedEmotes[i].hasOwnProperty('code'))
         continue;
        if (!j.sharedEmotes[i].hasOwnProperty('id'))
         continue;
        let w = _defSize;
        let h = _defSize;
        if (j.sharedEmotes[i].hasOwnProperty('width'))
         w = j.sharedEmotes[i].width;
        if (j.sharedEmotes[i].hasOwnProperty('height'))
         h = j.sharedEmotes[i].height;
        ret.push({name: j.sharedEmotes[i].code, id: j.sharedEmotes[i].id, url: cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', j.sharedEmotes[i].id), width: w, height: h});
       }
      }
      return ret;
     }

     async function $channel(svcName, chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('bttv'))
       thirdparty.emotes.bttv = {};
      const r = await thirdparty.bttv.channelEx(svcName, chID);
      if (r === false)
       return false;
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (bttvZWE.includes(r[i].id))
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe.bttv, 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height, true);
        continue;
       }
       _addEmote(thirdparty.emotes.bttv, 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height);
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     const $socket = function()
     {
      let _wsRetry = 0;
      let _chList = [];
      let _ws = null;

      function $init()
      {
       _ws = new WebSocket(cURLs.ws.bttv);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       notice.info(0xB2);
       _ws.onopen = null;
       for (let i = 0, l = _chList.length; i < l; i++)
       {
        _wsJoin(_chList[i].svc, _chList[i].ch);
       }
      }

      function _wsClose()
      {
       notice.error(0xB2);
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead && youtube.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(thirdparty.bttv.socket.init, wsWait);
      }

      function _wsMessage(ev)
      {
       if (_ws === null)
        return;
       if (twitch.net.dead && youtube.net.dead)
       {
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        return;
       }
       _wsRetry = 0;
       const d = JSON.parse(ev.data);
       if (!d.hasOwnProperty('name'))
        return;
       if (!d.hasOwnProperty('data'))
        return;
       switch (d.name)
       {
        case 'lookup_user':
         if (!d.data.hasOwnProperty('name'))
          return;
         if (!d.data.hasOwnProperty('emotes') || !Array.isArray(d.data.emotes) || d.data.emotes.length < 1)
          return;
         if (!thirdparty.emotes.hasOwnProperty('bttvU'))
          thirdparty.emotes.bttvU = {};
         thirdparty.emotes.bttvU[d.data.name] = {};
         if (!thirdparty.emotes.zwe.hasOwnProperty('bttvU'))
          thirdparty.emotes.zwe.bttvU = {};
         thirdparty.emotes.zwe.bttvU[d.data.name] = {};
         for (let i = 0, l = d.data.emotes.length; i < l; i++)
         {
          if (!d.data.emotes[i].hasOwnProperty('code'))
           continue;
          if (!d.data.emotes[i].hasOwnProperty('id'))
           continue;
          let w = _defSize;
          let h = _defSize;
          if (d.data.emotes[i].hasOwnProperty('width'))
           w = d.data.emotes[i].width;
          if (d.data.emotes[i].hasOwnProperty('height'))
           h = d.data.emotes[i].height;
          if (bttvZWE.includes(d.data.emotes[i].id))
          {
           if (cfg.display.extended.useZWE)
            _addEmote(thirdparty.emotes.zwe.bttvU[d.data.name], 'u', d.data.emotes[i].code, d.data.emotes[i].id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emotes[i].id), w, h, true);
           continue;
          }
          _addEmote(thirdparty.emotes.bttvU[d.data.name], 'u', d.data.emotes[i].code, d.data.emotes[i].id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emotes[i].id), w, h);
         }
         cSafe = JSON.parse(JSON.stringify(cList));
         break;
        case 'emote_create':
         if (!d.data.hasOwnProperty('channel'))
          return;
         if (!d.data.hasOwnProperty('emote'))
          return;
         if (!d.data.emote.hasOwnProperty('id'))
          return;
         if (!d.data.emote.hasOwnProperty('code'))
          return;
         let wC = _defSize;
         let hC = _defSize;
         if (d.data.emote.hasOwnProperty('width'))
          wC = d.data.emote.width;
         if (d.data.emote.hasOwnProperty('height'))
          hC = d.data.emote.height;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _addEmote(thirdparty.emotes.bttv, 'c', d.data.emote.code, d.data.emote.id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emote.id), wC, hC);
         cSafe = JSON.parse(JSON.stringify(cList));
         thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, _rBE);
         break;
        case 'emote_delete':
         if (!d.data.hasOwnProperty('channel'))
          return;
         if (!d.data.hasOwnProperty('emoteId'))
          return;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _removeEmoteByID(thirdparty.emotes.bttv, 'c', d.data.emoteId);
         cSafe = JSON.parse(JSON.stringify(cList));
         thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, _rBE);
         break;
        case 'emote_update':
         if (!d.data.hasOwnProperty('channel'))
          return;
         if (!d.data.hasOwnProperty('emote'))
          return;
         if (!d.data.emote.hasOwnProperty('id'))
          return;
         if (!d.data.emote.hasOwnProperty('code'))
          return;
         let wU = _defSize;
         let hU = _defSize;
         if (d.data.emote.hasOwnProperty('width'))
          wU = d.data.emote.width;
         if (d.data.emote.hasOwnProperty('height'))
          hU = d.data.emote.height;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _removeEmoteByID(thirdparty.emotes.bttv, 'c', d.data.emote.id);
         _addEmote(thirdparty.emotes.bttv, 'c', d.data.emote.code, d.data.emote.id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emote.id), wU, hU);
         cSafe = JSON.parse(JSON.stringify(cList));
         thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, _rBE);
         break;
       }
      }

      function $join(svcName, chID)
      {
       for (let i = 0, l = _chList.length; i < l; i++)
       {
        if (_chList[i].svc !== svcName)
         continue;
        if (_chList[i].ch === chID)
         return;
       }
       _chList.push({svc: svcName, ch: chID});
       _wsJoin(svcName, chID);
      }

      function _wsJoin(s, c)
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send(JSON.stringify({name: 'join_channel', data: {name: s + ':' + c}}));
      }

      return {
       init: $init,
       join: $join
      };
     }();

     return {
      timer: {},
      global: $global,
      channel: $channel,
      channelEx: $channelEx,
      socket: $socket,
      reload: $reload
     };
    }();

    const $7tv = function()
    {
     function _read7tv_URL(entry)
     {
      if (!entry.hasOwnProperty('host') || entry.host === null)
       return false;
      if (!entry.host.hasOwnProperty('url') || entry.host.url === null)
       return false;
      if (!entry.host.hasOwnProperty('files') || entry.host.files === null)
       return false;
      if (!Array.isArray(entry.host.files))
       return false;
      let g = [];
      let findFormat = 'WEBP';
      if (typeof cfg.display.extended.use7TV === 'string')
       findFormat = cfg.display.extended.use7TV.toUpperCase();
      for (let i = 0, l = entry.host.files.length; i < l; i++)
      {
       if (!entry.host.files[i].hasOwnProperty('format') || entry.host.files[i].format === null)
        continue;
       if (!entry.host.files[i].hasOwnProperty('name') || entry.host.files[i].name === null)
        continue;
       if (entry.host.files[i].format !== findFormat)
        continue;
       const dpp = entry.host.files[i].name.slice(0, 1);
       const addr = 'https:' + entry.host.url + '/' + entry.host.files[i].name;
       let w = false;
       let h = false;
       if (entry.host.files[i].hasOwnProperty('width') && entry.host.files[i].width !== null)
        w = entry.host.files[i].width;
       if (entry.host.files[i].hasOwnProperty('height') && entry.host.files[i].height !== null)
        h = entry.host.files[i].height;
       g.push({dpp: dpp, url: addr, width: w, height: h});
      }
      if (g.length < 1)
       return false;
      let find = ['4', '3', '2', '1'];
      for (let i = 0, l = find.length; i < l; i++)
      {
       for (let j = 0, m = g.length; j < m; j++)
       {
        if (g[j].dpp === find[i])
         return g[j];
       }
      }
      return false;
     }

     async function $global()
     {
      if (!thirdparty.emotes.hasOwnProperty('7tv'))
       thirdparty.emotes['7tv'] = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
       thirdparty.emotes.zwe['7tv'] = {};
      const url = cURLs.api['7tv'].emotes.global;
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('emotes') || j.emotes === null)
       return false;
      if (!Array.isArray(j.emotes))
       return false;
      for (let i = 0, l = j.emotes.length; i < l; i++)
      {
       if (!j.emotes[i].hasOwnProperty('data') || j.emotes[i].data === null)
        continue;
       if (!j.emotes[i].data.hasOwnProperty('id') || j.emotes[i].data.id === null)
        continue;
       if (!j.emotes[i].data.hasOwnProperty('name') || j.emotes[i].data.name === null)
        continue;
       const jInf = _read7tv_URL(j.emotes[i].data);
       if (jInf === false)
        continue;
       if (j.emotes[i].data.hasOwnProperty('flags') && j.emotes[i].data.flags !== null && (j.emotes[i].data.flags & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe['7tv'], 'g', j.emotes[i].data.name, j.emotes[i].data.id, jInf.url, jInf.width, jInf.height, true);
        continue;
       }
       _addEmote(thirdparty.emotes['7tv'], 'g', j.emotes[i].data.name, j.emotes[i].data.id, jInf.url, jInf.width, jInf.height);
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     async function $channelEx(svcName, chID)
     {
      const url = cURLs.api['7tv'].users[svcName].replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('emote_set') || j.emote_set === null)
       return false;
      if (!j.emote_set.hasOwnProperty('emotes') || j.emote_set.emotes === null)
       return false;
      if (!Array.isArray(j.emote_set.emotes))
       return false;
      let ret = [];
      for (let i = 0, l = j.emote_set.emotes.length; i < l; i++)
      {
       if (!j.emote_set.emotes[i].hasOwnProperty('data') || j.emote_set.emotes[i].data === null)
        continue;
       if (!j.emote_set.emotes[i].data.hasOwnProperty('id') || j.emote_set.emotes[i].data.id === null)
        continue;
       if (!j.emote_set.emotes[i].hasOwnProperty('name') || j.emote_set.emotes[i].name === null)
        continue;
       const jInf = _read7tv_URL(j.emote_set.emotes[i].data);
       if (jInf === false)
        continue;
       let vis = 0;
       if (j.emote_set.emotes[i].data.hasOwnProperty('flags') && j.emote_set.emotes[i].data.flags !== null)
        vis = j.emote_set.emotes[i].data.flags;
       ret.push({name: j.emote_set.emotes[i].name, id: j.emote_set.emotes[i].data.id, url: jInf.url, vis: vis, width: jInf.width, height: jInf.height});
      }
      return ret;
     }

     async function $channel(svcName, chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('7tv'))
       thirdparty.emotes['7tv'] = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
       thirdparty.emotes.zwe['7tv'] = {};
      const r = await thirdparty['7tv'].channelEx(svcName, chID);
      if (r === false)
       return false;
      for (let i = 0, l = r.length; i < l; i++)
      {
       if ((r[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe['7tv'], 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height, true);
        continue;
       }
       _addEmote(thirdparty.emotes['7tv'], 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height);
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     async function _load7TV_channelID(svcName, chID)
     {
      const url = cURLs.api['7tv'].users[svcName].replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('user') || j.user === null)
       return false;
      if (!j.user.hasOwnProperty('id') || j.user.id === null)
       return false;
      return j.user.id;
     }

     const $socket = function()
     {
      const _lDelay = 500;
      let _wsRetry = 0;
      let _wsR_RL = 0;
      let _wsR_M = 0;
      let _chList = [];
      let _ws = null;
      let _sess = null;
      let _lTimeout = 5000;
      let _tTimeout = false;
      let _okCt = 0;
      let _recvd = false;

      async function $init()
      {
       _recvd = false;
       _ws = new WebSocket(cURLs.ws['7tv']);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      }

      function _wsClose()
      {
       if (!_recvd)
        notice.error(0xC2);
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead && youtube.net.dead && kick.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(thirdparty['7tv'].socket.init, wsWait);
      }

      function _wsMessage(ev)
      {
       _recvd = true;
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       if (twitch.net.dead && youtube.net.dead && kick.net.dead)
       {
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        return;
       }
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
       const d = JSON.parse(ev.data);
       if (!d.hasOwnProperty('op') || d.op === null)
        return;
       if (!d.hasOwnProperty('d'))
        return;
       notice.info(0xC2);
       switch (d.op)
       {
        case 0:
         if (thirdparty.timer !== false)
          window.clearTimeout(thirdparty.timer);
         thirdparty.timer = window.setTimeout(thirdparty.reload, _lDelay);
         break;
        case 1:
         if (d.d === null)
          return;
         _okCt = 0;
         if (_sess !== null)
         {
          if (_ws.readyState === 1)
           _ws.send(JSON.stringify({'op': 34, 'd': {'session_id': _sess}}));
         }
         else
         {
          for (let i = 0, l = _chList.length; i < l; i++)
          {
           _wsSub(_chList[i].acct);
          }
         }
         if (d.d.hasOwnProperty('session_id') && d.d.session_id !== null)
          _sess = d.d.session_id;
         if (d.d.hasOwnProperty('heartbeat_interval') && d.d.heartbeat_interval !== null)
         {
          _lTimeout = parseInt(d.d.heartbeat_interval, 10) * 3;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
         }
         break;
        case 2:
         if (_okCt !== 3)
         {
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _ws.onopen = null;
          _ws.onmessage = null;
          _ws.onclose = null;
          _ws.close();
          _ws = null;
          const wsRedo = Math.floor(wWS ** (1 + _wsRetry) * 1000);
          if (_wsRetry < 2)
           _wsRetry += 0.2;
          window.setTimeout(thirdparty['7tv'].socket.init, wsRedo);
          return;
         }
         _wsRetry = 0;
         _wsR_RL = 0;
         _wsR_M = 0;
         break;
        case 5:
         if (d.d === null)
          return;
         if (!d.d.hasOwnProperty('command') || d.d.command === null)
          return;
         switch (d.d.command)
         {
          case 'RESUME':
           if (!d.d.hasOwnProperty('data') || d.d.data === null)
            return;
           if (!d.d.data.hasOwnProperty('success'))
            return;
           if (d.d.data.success === false || d.d.data.success === null)
           {
            for (let i = 0, l = _chList.length; i < l; i++)
            {
             _wsSub(_chList[i].acct);
            }
           }
           else
           {
            if (!d.d.data.hasOwnProperty('subscriptions_restored') || d.d.data.subscriptions_restored === null)
             return;
            if (d.d.data.subscriptions_restored !== _chList.length * 3)
            {
             if (d.d.data.subscriptions_restored > 0)
             {
              for (let i = 0, l = _chList.length; i < l; i++)
              {
               _wsUnsub(_chList[i].acct);
              }
             }
             for (let i = 0, l = _chList.length; i < l; i++)
             {
              _wsSub(_chList[i].acct);
             }
            }
            else
             _okCt = d.d.data.subscriptions_restored;
           }
           break;
          case 'SUBSCRIBE':
           _okCt++;
           break;
         }
         break;
        case 7:
         if (d.d === null)
          return;
         if (_tTimeout !== false)
         {
          window.clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         let wsWait = _lDelay;
         if (d.d.hasOwnProperty('code') && d.d.code !== null)
         {
          switch (d.d.code)
          {
           case 4001:
           case 4002:
           case 4003:
           case 4004:
           case 4009:
           case 4010:
           case 4011:
            _sess = null;
            return;
           case 4005:
            wsWait = Math.floor((5 ** (1 + _wsR_RL) / 5) * 60 * 1000);
            if (_wsR_RL < 2.6)
             _wsR_RL += 0.2;
            break;
           case 4006:
            wsWait = Math.max(wsWait, 5 * 60 * 1000);
            break;
           case 4007:
            wsWait = 5 * 60 * 1000 + Math.floor(wWS ** (1 + _wsR_M) * 1000) - 5000;
            if (_wsR_M < 2)
             _wsR_M += 0.2;
            break;
           case 4000:
           case 4008:
            wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
            if (_wsRetry < 2)
             _wsRetry += 0.2;
            break;
          }
         }
         window.setTimeout(thirdparty['7tv'].socket.init, wsWait);
         break;
       }
      }

      function _wsUnsub(accID)
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send(JSON.stringify({'op': 36, 'd': {'type':'user.*', 'condition': {'object_id': accID}}}));
       _ws.send(JSON.stringify({'op': 36, 'd': {'type':'emote.*', 'condition': {'object_id': accID}}}));
       _ws.send(JSON.stringify({'op': 36, 'd': {'type':'emote_set.*', 'condition': {'object_id': accID}}}));
      }

      function _wsSub(accID)
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send(JSON.stringify({'op': 35, 'd': {'type':'user.*', 'condition': {'object_id': accID}}}));
       _ws.send(JSON.stringify({'op': 35, 'd': {'type':'emote.*', 'condition': {'object_id': accID}}}));
       _ws.send(JSON.stringify({'op': 35, 'd': {'type':'emote_set.*', 'condition': {'object_id': accID}}}));
      }

      function _wsTimeout()
      {
       notice.error(0xC2);
       _lTimeout = 5000;
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (twitch.net.dead && youtube.net.dead && kick.net.dead)
        return;
       thirdparty['7tv'].socket.init();
      }

      async function $join(svcName, chID)
      {
       for (let i = 0, l = _chList.length; i < l; i++)
       {
        if (_chList[i].ch.includes(chID))
         return;
       }
       const accID = await _load7TV_channelID(svcName, chID);
       if (accID === false)
        return;
       for (let i = 0, l = _chList.length; i < l; i++)
       {
        if (_chList[i].acct === accID)
        {
         _chList[i].ch.push(chID);
         return;
        }
       }
       _chList.push({ch: [chID], acct: accID});
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _wsSub(accID);
      }

      return {
       init: $init,
       join: $join
      };
     }();

     return {
      global: $global,
      channel: $channel,
      channelEx: $channelEx,
      socket: $socket,
      zweFlag: 0x100
     };
    }();

    function $reload()
    {
     if (thirdparty.timer === false)
      return;
     window.clearTimeout(thirdparty.timer);
     thirdparty.timer = false;
     if (cfg.display.extended.useFFZ)
     {
      if (!twitch.net.dead && twitch.net.channelID !== 0)
       thirdparty.ffz.channel(twitch.net.channelID);
     }
     if (cfg.display.extended.use7TV)
     {
      if (!twitch.net.dead && twitch.net.channelID !== 0)
       thirdparty['7tv'].channel('twitch', twitch.net.channelID);
      if (!youtube.net.dead && youtube.net.channelIDs.length > 0)
      {
       for (let i = 0, l = youtube.net.channelIDs.length; i < l; i++)
       {
        thirdparty['7tv'].channel('youtube', youtube.net.channelIDs[i]);
       }
      }
      if (!kick.net.dead && kick.net.userID !== 0)
       thirdparty['7tv'].channel('kick', kick.net.userID);
     }
     thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval);
    }

    return {
     emotes: {},
     timer: false,
     interval: 60000,
     ffz: $ffz,
     bttv: $bttv,
     '7tv': $7tv,
     reload: $reload
    };
   }();

   const shared = function()
   {
    function $rnd(m)
    {
     let r = new Uint32Array(1);
     window.crypto.getRandomValues(r);
     const f = r[0] / 4294967295;
     if (m === undefined)
      return f;
     if (m < 1)
      return f * m;
     return Math.floor(f * m);
    }

    function $httpRequest(type, url, hdrs = {}, body = null, nocache = true, ret = true)
    {
     const p = new Promise(
      function(resolve)
      {
       const x = new XMLHttpRequest();
       if (nocache)
       {
        if (url.includes('?'))
         url += '&';
        else
         url += '?';
        url += 'nocache=' + shared.rnd(0xFFFFFFFF);
       }
       x.open(type, url);
       for (const hK in hdrs)
       {
        if (!hdrs.hasOwnProperty(hK))
         continue;
        x.setRequestHeader(hK, hdrs[hK]);
       }
       x.onreadystatechange = function()
       {
        if (ret === false)
        {
         if (x.readyState < 2)
          return;
         x.onreadystatechange = null;
         resolve(Math.floor(x.status / 100) === 2);
         return;
        }
        if (x.readyState !== 4)
         return;
        x.onreadystatechange = null;
        resolve({code: x.status, data: x.responseText, get success(){return Math.floor(this.code / 100) === 2;}, get json(){try{return JSON.parse(this.data);}catch(ex){return null;}}});
       };
       if (body === null)
        x.send();
       else
        x.send(body);
      }
     );
     return p;
    }

    function $findInMaybeRange(r, v)
    {
     const t = typeof r;
     switch (t)
     {
      case 'undefined':
       return false;
      case 'boolean':
       return r === true;
      case 'number':
       if (r > 0 && v >= r)
        return true;
       return false;
      case 'object':
       if (r === null)
        return false;
       for (const k in r)
       {
        if (!r.hasOwnProperty(k))
         continue;
        let lower = 0;
        let upper = 0;
        if (k.slice(-1) === '+')
        {
         lower = parseInt(k.slice(0, -1), 10);
         upper = Number.MAX_SAFE_INTEGER;
        }
        else if (k.indexOf('-') !== -1)
        {
         lower = parseInt(k.slice(0, k.indexOf('-')), 10);
         upper = parseInt(k.slice(k.indexOf('-') + 1), 10);
        }
        else
        {
         lower = parseInt(k, 10);
         upper = parseInt(k, 10);
        }
        if (v >= lower && v <= upper)
         return r[k];
       }
     }
     return false;
    }

    function $clearAddr(query)
    {
     const o = window.location.toString();
     let u = o;
     if (u.indexOf('#') > -1)
      u = u.slice(0, u.indexOf('#'));
     if (query && u.indexOf('?') > -1)
      u = u.slice(0, u.indexOf('?'));
     if (u !== o)
      window.history.replaceState(null, '', u);
    }

    function $doNextFrame(cb)
    {
     let a = [];
     for (let i = 1, l = arguments.length; i < l; i++)
     {
      a.push(arguments[i]);
     }
     let n = false;
     function _next()
     {
      if (n === false)
      {
       n = true;
       window.requestAnimationFrame(_next);
       return;
      }
      cb(...a);
     }
     window.requestAnimationFrame(_next);
    }

    const $mspf = function()
    {
     let _init = 0;
     let _avg = [];

     function $init()
     {
      if (shared.mspf.value !== 0)
       return;
      window.requestAnimationFrame(_test);
     }

     function _test(ms)
     {
      if (_init !== 0)
       _avg.push(ms - _init);
      if (_avg.length > 2)
       shared.mspf.value = _avg.reduce((a,b) => (a+b)) / _avg.length;
      if (_avg.length > 300)
      {
       shared.mspf.value = Math.round(shared.mspf.value * 1000) / 1000;
       return;
      }
      _init = ms;
      window.requestAnimationFrame(_test);
     }

     return {
      init: $init,
      value: 0
     };
    }();

    const $ec = function()
    {
     const _dbName = 'ewec';
     const _tblName = 'emotes';

     function $save(url, w, h)
     {
      const o = window.indexedDB.open(_dbName, 1);
      o.onupgradeneeded = function(ev)
      {
       const d = ev.target.result;
       d.createObjectStore(_tblName, {keyPath: 'url'});
      };
      o.onerror = function()
      {
       window.indexedDB.deleteDatabase(_dbName);
      };
      o.onsuccess = function(ev)
      {
       const d = ev.target.result;
       if (d.objectStoreNames[0] !== _tblName)
       {
        d.close();
        window.indexedDB.deleteDatabase(_dbName);
        return;
       }
       let tx;
       try
       {
        tx = d.transaction(_tblName, 'readwrite');
       }
       catch(ex)
       {
        d.close();
        window.indexedDB.deleteDatabase(_dbName);
        return;
       }
       const s = tx.objectStore(_tblName);
       const p = s.put({url: url, w: w, h: h});
       p.onerror = function()
       {
        d.close();
       };
       p.onsuccess = function()
       {
        d.close();
       };
      };
     }

     function $get(url)
     {
      return new Promise(
       function(resolve)
       {
        const o = window.indexedDB.open(_dbName, 1);
        o.onupgradeneeded = function()
        {
         resolve(null);
        };
        o.onblocked = function()
        {
         resolve(null);
        };
        o.onerror = function()
        {
         resolve(null);
        };
        o.onsuccess = function(ev)
        {
         const dbr = ev.target.result;
         if (dbr.objectStoreNames[0] !== _tblName)
         {
          dbr.close();
          resolve(null);
          return;
         }
         let tx;
         try
         {
          tx = dbr.transaction(_tblName, 'readonly');
         }
         catch(ex)
         {
          dbr.close();
          resolve(null);
          return;
         }
         const s = tx.objectStore(_tblName);
         let g = s.get(url);
         g.onerror = function()
         {
          dbr.close();
          resolve(null);
         };
         g.onsuccess = function(ev2)
         {
          dbr.close();
          if (typeof ev2.currentTarget.result !== 'undefined')
           resolve({width: ev2.currentTarget.result.w, height: ev2.currentTarget.result.h});
          else
           resolve(null);
         };
        };
       }
      );
     }

     function $clear()
     {
      window.indexedDB.deleteDatabase(_dbName);
     }

     return {
      save: $save,
      get: $get,
      clear: $clear
     };
    }();

    return {
     rnd: $rnd,
     httpRequest: $httpRequest,
     findInMaybeRange: $findInMaybeRange,
     clearAddr: $clearAddr,
     doNextFrame: $doNextFrame,
     mspf: $mspf,
     ec: $ec
    };
   }();

   const loginT = function()
   {
    let _tL = false;
    const _visTime = 5000;

    function _activeScope()
    {
     let r = [];
     r.push('chat:read');
     for (const k of cfg.commands)
     {
      if (!k.hasOwnProperty('redeem') || !Array.isArray(k.redeem) || k.redeem.length < 1)
       continue;
      r.push('channel:read:redemptions');
      break;
     }
     let needF = false;
     if (cfg.event.twitch.follow !== false)
      needF = true;
     else
     {
      if ((cfg.display.access & 0x002) === 0x002 && (cfg.display.access & 0x001) !== 0x001)
       needF = true;
      else if ((cfg.display.kappa.access & 0x002) === 0x002 && (cfg.display.kappa.access & 0x001) !== 0x001)
       needF = true;
      else
      {
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('styles'))
         continue;
        if (!k.hasOwnProperty('access'))
         continue;
        if ((k.access & 0x002) === 0x002 && (k.access & 0x001) !== 0x001)
        {
         needF = true;
         break;
        }
       }
      }
     }
     if (needF)
      r.push('moderator:read:followers');
     if (cfg.event.twitch.hypetrain !== false && ((cfg.event.twitch.hypetrain.hasOwnProperty('begin') && cfg.event.twitch.hypetrain.begin !== false) || (cfg.event.twitch.hypetrain.hasOwnProperty('success') && cfg.event.twitch.hypetrain.success !== false)))
      r.push('channel:read:hype_train');
     if (cfg.event.twitch.goal !== false && ((cfg.event.twitch.goal.hasOwnProperty('begin') && cfg.event.twitch.goal.begin !== false) || (cfg.event.twitch.goal.hasOwnProperty('achieved') && cfg.event.twitch.goal.achieved !== false)))
      r.push('channel:read:goals');
     if (cfg.event.twitch.poll !== false && ((cfg.event.twitch.poll.hasOwnProperty('begin') && cfg.event.twitch.poll.begin !== false) || (cfg.event.twitch.poll.hasOwnProperty('end') && cfg.event.twitch.poll.end !== false)))
      r.push('channel:read:polls');
     if (cfg.event.twitch.prediction !== false && ((cfg.event.twitch.prediction.hasOwnProperty('begin') && cfg.event.twitch.prediction.begin !== false) || (cfg.event.twitch.prediction.hasOwnProperty('resolved') && cfg.event.twitch.prediction.resolved !== false)))
      r.push('channel:read:predictions');
     if (cfg.event.twitch.charity !== false)
      r.push('channel:read:charity');
     if (cfg.event.twitch.shoutout !== false && ((cfg.event.twitch.shoutout.hasOwnProperty('create') && cfg.event.twitch.shoutout.create !== false && cfg.event.twitch.shoutout.create.hasOwnProperty('styles') && cfg.event.twitch.shoutout.create.styles !== false) || (cfg.event.twitch.shoutout.hasOwnProperty('receive') && cfg.event.twitch.shoutout.receive !== false && cfg.event.twitch.shoutout.receive.hasOwnProperty('styles') && cfg.event.twitch.shoutout.receive.styles !== false)))
      r.push('moderator:read:shoutouts');
     return r;
    }

    function _uScope()
    {
     return encodeURIComponent(_activeScope().join(' '));
    }

    function $path()
    {
     return 'twitch.' + _activeScope().join('+');
    }

    function $cfgVals()
    {
     if (!cfg.hasOwnProperty('twitch'))
      return 0;
     let r = 0;
     if (cfg.twitch.hasOwnProperty('channel') && cfg.twitch.channel !== false && cfg.twitch.channel !== null && cfg.twitch.channel !== 'CHANNEL_NAME')
      r |= 0x01;
     if (cfg.twitch.hasOwnProperty('oauth_refresh') && cfg.twitch.oauth_refresh !== false && cfg.twitch.oauth_refresh !== null && cfg.twitch.oauth_refresh !== 'OAUTH_REFRESH')
      r |= 0x02;
     if (cfg.twitch.hasOwnProperty('oauth') && cfg.twitch.oauth !== false && cfg.twitch.oauth !== null && cfg.twitch.oauth !== 'OAUTH_ID')
      r |= 0x04;
     return r;
    }

    function $use()
    {
     loginT.inUse = false;
     if (loginT.cfgVals() > 0x01)
      return false;
     loginT.inUse = true;
     let lsChannel = window.localStorage.getItem(loginT.path() + '.channel');
     let lsClient = window.localStorage.getItem(loginT.path() + '.client');
     let lsOAuth = window.localStorage.getItem(loginT.path() + '.oauth');
     let lsRefresh = window.localStorage.getItem(loginT.path() + '.refresh');
     let lsScope = window.localStorage.getItem(loginT.path() + '.scope');
     if (lsChannel === null || lsRefresh === null)
     {
      const h = _getHashParams();
      if (!h.hasOwnProperty('channel') || !h.hasOwnProperty('client') || !h.hasOwnProperty('oauth') || !h.hasOwnProperty('oauth_refresh') || !h.hasOwnProperty('scope'))
      {
       loginT.showIn(true);
       return true;
      }
      if (h.hasOwnProperty('service') && h.service !== 'twitch')
      {
       loginT.showIn();
       return true;
      }
      lsChannel = h.channel;
      lsClient = h.client;
      lsOAuth = h.oauth;
      lsRefresh = h.oauth_refresh;
      lsScope = decodeURIComponent(h.scope);
      window.localStorage.setItem(loginT.path() + '.channel', lsChannel);
      window.localStorage.setItem(loginT.path() + '.oauth', lsOAuth);
      window.localStorage.setItem(loginT.path() + '.refresh', lsRefresh);
      window.localStorage.setItem(loginT.path() + '.client', lsClient);
      window.localStorage.setItem(loginT.path() + '.scope', lsScope);
     }
     cfg.twitch.channel = lsChannel;
     cfg.twitch.oauth = lsOAuth;
     cfg.twitch.oauth_refresh = lsRefresh;
     cfg.twitch.client = lsClient;
     cfg.twitch.scope = decodeURIComponent(lsScope).split(' ');
     loginT.showOut();
     return false;
    }

    function _getHashParams()
    {
     const d = function(s) {
      const a = /\+/g;
      return decodeURIComponent(s.replace(a, ' '));
     };
     let hashParams = {};
     const r = /([^&;=]+)=?([^&;]*)/g;
     const q = window.location.hash.substring(1);
     let e;
     while ((e = r.exec(q)) !== null)
     {
      hashParams[d(e[1])] = d(e[2]);
     }
     return hashParams;
    }

    function $begin()
    {
     twitch.net.oAuth.clear(true);
     let loc = window.location.toString();
     if (window.location.hash.length > 1)
      loc = loc.slice(0, -1 * window.location.hash.length);
     const o = encodeURIComponent(window.btoa(loc));
     const c = encodeURIComponent(oauthClient.t);
     const r = encodeURIComponent(cURLs.html.rr.auth.t);
     const u = cURLs.html.twitch.replaceAll('%CLIENT_ID%', c).replaceAll('%URL%', r).replaceAll('%SCOPE%', _uScope()).replaceAll('%ORIGIN%', o);
     if (u.length < 1500)
     {
      window.location = u;
      return;
     }
     const f = document.createElement('form');
     f.setAttribute('method', 'POST');
     f.setAttribute('action', cURLs.html.rr.redir);
     const ft = document.createElement('input');
     ft.setAttribute('type', 'hidden');
     ft.setAttribute('name', 't');
     ft.setAttribute('value', 'code');
     f.appendChild(ft);
     const fv = document.createElement('input');
     fv.setAttribute('type', 'hidden');
     fv.setAttribute('name', 'v');
     fv.setAttribute('value', 'twitch');
     f.appendChild(fv);
     const fc = document.createElement('input');
     fc.setAttribute('type', 'hidden');
     fc.setAttribute('name', 'c');
     fc.setAttribute('value', oauthClient.t);
     f.appendChild(fc);
     const fr = document.createElement('input');
     fr.setAttribute('type', 'hidden');
     fr.setAttribute('name', 'r');
     fr.setAttribute('value', cURLs.html.rr.auth.t);
     f.appendChild(fr);
     const fs = document.createElement('input');
     fs.setAttribute('type', 'hidden');
     fs.setAttribute('name', 's');
     fs.setAttribute('value', _activeScope().join(' '));
     f.appendChild(fs);
     const fu = document.createElement('input');
     fu.setAttribute('type', 'hidden');
     fu.setAttribute('name', 'u');
     fu.setAttribute('value', loc);
     f.appendChild(fu);
     document.body.appendChild(f);
     f.submit();
    }

    function $showIn(auto = false)
    {
     if (document.getElementById('cmdTLogout'))
      document.body.removeChild(document.getElementById('cmdTLogout'));
     twitch.net.oAuth.clear(true);
     let cmdLogin = document.createElement('button');
     cmdLogin.setAttribute('id', 'cmdTLogin');
     cmdLogin.setAttribute('type', 'button');
     cmdLogin.classList.add('twitch');
     cmdLogin.classList.add('login');
     document.addEventListener('mouseover', _fadeInLogin);
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
     cmdLogin.setAttribute('onclick', 'loginT.begin();');
     cmdLogin.innerHTML = 'Authenticate Emote Wall<br><span>on Twitch</span>';
     if (auto && (loginYT.cfgVals() > 0x01 || loginK.cfgVals() > 0))
      cmdLogin.classList.add('hidden');
     document.body.appendChild(cmdLogin);
    }

    function _fadeInLogin()
    {
     if (document.getElementById('cmdTLogin'))
      document.getElementById('cmdTLogin').classList.remove('hidden');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
    }

    function _fadeOutLogin()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById('cmdTLogin'))
      document.getElementById('cmdTLogin').classList.add('hidden');
    }

    function $showOut(v = false)
    {
     if (document.getElementById('cmdTLogout'))
      document.body.removeChild(document.getElementById('cmdTLogout'));
     let cmdLogout = document.createElement('button');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     cmdLogout.setAttribute('id', 'cmdTLogout');
     cmdLogout.setAttribute('type', 'button');
     cmdLogout.classList.add('twitch');
     cmdLogout.classList.add('logout');
     document.addEventListener('mousemove', _fadeInLogout);
     if (v)
     {
      cmdLogout.setAttribute('onclick', 'loginT.begin();');
      cmdLogout.innerHTML = 'Re-Auth';
      _tL = window.setTimeout(_fadeOutLogout, _visTime);
     }
     else
     {
      cmdLogout.setAttribute('onclick', 'loginT.showIn();');
      cmdLogout.innerHTML = 'Log Out';
      cmdLogout.classList.add('hidden');
     }
     document.body.appendChild(cmdLogout);
    }

    function _fadeInLogout()
    {
     if (document.getElementById('cmdTLogout'))
      document.getElementById('cmdTLogout').classList.remove('hidden');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogout, _visTime);
    }

    function _fadeOutLogout()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById('cmdTLogout'))
      document.getElementById('cmdTLogout').classList.add('hidden');
    }

    return {
     inUse: false,
     use: $use,
     begin: $begin,
     showIn: $showIn,
     showOut: $showOut,
     path: $path,
     cfgVals: $cfgVals
    };
   }();

   const loginYT = function()
   {
    let _tL = false;
    const _visTime = 5000;

    function _activeScope()
    {
     let r = [];
     r.push('https://www.googleapis.com/auth/youtube.readonly');
     let hasM = false;
     if ((cfg.event.youtube.member.first === true) || (Array.isArray(cfg.event.youtube.member.first) && cfg.event.youtube.member.first.length > 0))
      hasM = true;
     if ((cfg.event.youtube.member.milestone === true) || (typeof cfg.event.youtube.member.milestone === 'object' && cfg.event.youtube.member.milestone !== null && Object.keys(cfg.event.youtube.member.milestone).length > 0))
      hasM = true;
     if ((cfg.event.youtube.member.giftbomb === true) || (typeof cfg.event.youtube.member.giftbomb === 'object' && cfg.event.youtube.member.giftbomb !== null && Object.keys(cfg.event.youtube.member.giftbomb).length > 0))
      hasM = true;
     if (hasM)
      r.push('https://www.googleapis.com/auth/youtube.channel-memberships.creator');
     return r;
    }

    function _uScope()
    {
     return encodeURIComponent(_activeScope().join(' '));
    }

    function $path()
    {
     return 'youtube.' + _activeScope().join('+');
    }

    function $cfgVals()
    {
     if (!cfg.hasOwnProperty('youtube'))
      return 0;
     let r = 0;
     if (cfg.youtube.hasOwnProperty('oauth_refresh') && cfg.youtube.oauth_refresh !== false && cfg.youtube.oauth_refresh !== null && cfg.youtube.oauth_refresh !== 'OAUTH_REFRESH')
      r |= 0x02;
     if (cfg.youtube.hasOwnProperty('oauth') && cfg.youtube.oauth !== false && cfg.youtube.oauth !== null && cfg.youtube.oauth !== 'OAUTH_ID')
      r |= 0x04;
     return r;
    }

    function $use()
    {
     loginYT.inUse = false;
     if (loginYT.cfgVals() > 0x01)
      return false;
     loginYT.inUse = true;
     let lsClient  = window.localStorage.getItem(loginYT.path() + '.client');
     let lsRefresh = window.localStorage.getItem(loginYT.path() + '.refresh');
     if (lsRefresh === null)
     {
      const h = _getHashParams();
      if (!h.hasOwnProperty('client') || !h.hasOwnProperty('oauth_refresh'))
      {
       loginYT.showIn(true);
       return true;
      }
      if (h.hasOwnProperty('service') && h.service !== 'youtube')
      {
       loginYT.showIn();
       return true;
      }
      lsClient = h.client;
      lsRefresh = h.oauth_refresh;
      window.localStorage.setItem(loginYT.path() + '.refresh', lsRefresh);
      window.localStorage.setItem(loginYT.path() + '.client', lsClient);
     }
     cfg.youtube.oauth_refresh = lsRefresh;
     cfg.youtube.client = lsClient;
     document.title = 'RealityRipple\'s Home-Made Emote Wall';
     loginYT.showOut();
     return false;
    }

    function _getHashParams()
    {
     const d = function(s) {
      const a = /\+/g;
      return decodeURIComponent(s.replace(a, ' '));
     };
     let hashParams = {};
     const r = /([^&;=]+)=?([^&;]*)/g;
     const q = window.location.hash.substring(1);
     let e;
     while ((e = r.exec(q)) !== null)
     {
      hashParams[d(e[1])] = d(e[2]);
     }
     return hashParams;
    }

    function $begin()
    {
     youtube.net.oAuth.clear(true);
     let loc = window.location.toString();
     if (window.location.hash.length > 1)
      loc = loc.slice(0, -1 * window.location.hash.length);
     const o = encodeURIComponent(btoa(loc));
     const c = encodeURIComponent(oauthClient.yt);
     const r = encodeURIComponent(cURLs.html.rr.auth.yt);
     const u = cURLs.html.youtube.replaceAll('%CLIENT_ID%', c).replaceAll('%URL%', r).replaceAll('%SCOPE%', _uScope()).replaceAll('%ORIGIN%', o);
     if (u.length < 1500)
     {
      window.location = u;
      return;
     }
     const f = document.createElement('form');
     f.setAttribute('method', 'POST');
     f.setAttribute('action', cURLs.html.rr.redir);
     const ft = document.createElement('input');
     ft.setAttribute('type', 'hidden');
     ft.setAttribute('name', 't');
     ft.setAttribute('value', 'code');
     f.appendChild(ft);
     const fv = document.createElement('input');
     fv.setAttribute('type', 'hidden');
     fv.setAttribute('name', 'v');
     fv.setAttribute('value', 'youtube');
     f.appendChild(fv);
     const fc = document.createElement('input');
     fc.setAttribute('type', 'hidden');
     fc.setAttribute('name', 'c');
     fc.setAttribute('value', oauthClient);
     f.appendChild(fc);
     const fr = document.createElement('input');
     fr.setAttribute('type', 'hidden');
     fr.setAttribute('name', 'r');
     fr.setAttribute('value', cURLs.html.rr.auth.yt);
     f.appendChild(fr);
     const fs = document.createElement('input');
     fs.setAttribute('type', 'hidden');
     fs.setAttribute('name', 's');
     fs.setAttribute('value', _activeScope().join(' '));
     f.appendChild(fs);
     const fu = document.createElement('input');
     fu.setAttribute('type', 'hidden');
     fu.setAttribute('name', 'u');
     fu.setAttribute('value', loc);
     f.appendChild(fu);
     document.body.appendChild(f);
     f.submit();
    }

    function $showIn(auto = false)
    {
     if (document.getElementById('cmdYTLogout'))
      document.body.removeChild(document.getElementById('cmdYTLogout'));
     youtube.net.oAuth.clear(true);
     let cmdLogin = document.createElement('button');
     cmdLogin.setAttribute('id', 'cmdYTLogin');
     cmdLogin.setAttribute('type', 'button');
     cmdLogin.classList.add('youtube');
     cmdLogin.classList.add('login');
     document.addEventListener('mouseover', _fadeInLogin);
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
     cmdLogin.setAttribute('onclick', 'loginYT.begin();');
     cmdLogin.innerHTML = 'Authenticate Emote Wall<br><span>on YouTube</span>';
     if (auto && (loginT.cfgVals() > 0x01 || loginK.cfgVals() > 0))
      cmdLogin.classList.add('hidden');
     document.body.appendChild(cmdLogin);
    }

    function _fadeInLogin()
    {
     if (document.getElementById('cmdYTLogin'))
      document.getElementById('cmdYTLogin').classList.remove('hidden');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
    }

    function _fadeOutLogin()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById('cmdYTLogin'))
      document.getElementById('cmdYTLogin').classList.add('hidden');
    }

    function $showOut(v = false)
    {
     if (document.getElementById('cmdYTLogout'))
      document.body.removeChild(document.getElementById('cmdYTLogout'));
     let cmdLogout = document.createElement('button');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     cmdLogout.setAttribute('id', 'cmdYTLogout');
     cmdLogout.setAttribute('type', 'button');
     cmdLogout.classList.add('youtube');
     cmdLogout.classList.add('logout');
     document.addEventListener('mouseover', _fadeInLogout);
     if (v)
     {
      cmdLogout.setAttribute('onclick', 'loginYT.begin();');
      cmdLogout.innerHTML = 'Re-Auth';
      _tL = window.setTimeout(_fadeOutLogout, _visTime);
     }
     else
     {
      cmdLogout.setAttribute('onclick', 'loginYT.showIn();');
      cmdLogout.innerHTML = 'Log Out';
      cmdLogout.classList.add('hidden');
     }
     document.body.appendChild(cmdLogout);
    }

    function _fadeInLogout()
    {
     if (document.getElementById('cmdYTLogout'))
      document.getElementById('cmdYTLogout').classList.remove('hidden');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogout, _visTime);
    }

    function _fadeOutLogout()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById('cmdYTLogout'))
      document.getElementById('cmdYTLogout').classList.add('hidden');
    }

    return {
     inUse: false,
     use: $use,
     begin: $begin,
     showIn: $showIn,
     showOut: $showOut,
     path: $path,
     cfgVals: $cfgVals
    };
   }();

   const loginK = function()
   {
    function $cfgVals()
    {
     if (!cfg.hasOwnProperty('kick'))
      return 0;
     let r = 0;
     if (cfg.kick.hasOwnProperty('channel') && cfg.kick.channel !== false && cfg.kick.channel !== null && cfg.kick.channel !== 'CHANNEL_NAME')
      r |= 0x01;
     return r;
    }

    return {
     cfgVals: $cfgVals
    };
   }();

   const startup = function()
   {
    async function task()
    {
     shared.mspf.init();
     if (cfg.display.hasOwnProperty('hue') && cfg.display.hue === 'rave' && !_hasRaveToggle())
      document.documentElement.classList.add('rave');
     _css();
     if (!window.hasOwnProperty('obsstudio') && !window.localStorage.getItem('emotewall.obs_notfound'))
     {
      window.localStorage.setItem('emotewall.obs_notfound', '1');
      notice.error(0x09);
     }
     if ((loginK.cfgVals() & 0x01) !== 0x01)
      kick.net.dead = true;
     else
     {
      if (await _kick() === false)
       kick.net.dead = true;
     }
     const usesT = loginT.use();
     const usesYT = loginYT.use();
     if (usesT === true && usesYT === true)
     {
      if (!kick.net.dead)
       await _7tv();
      twitch.net.dead = true;
      youtube.net.dead = true;
      return;
     }
     shared.clearAddr(false);
     if (usesT !== true && usesYT !== true)
      shared.clearAddr(true);
     _streamlabs();
     await _streamelements();
     await _bttv();
     await _7tv();
     if (loginT.cfgVals() > 0x01)
     {
      if (await _twitch() === false)
       twitch.net.dead = true;
     }
     else
      twitch.net.dead = true;
     if (loginYT.cfgVals() > 0x01)
     {
      if (await _youtube() === false)
       youtube.net.dead = true;
     }
     else
      youtube.net.dead = true;
    }

    async function _twitch()
    {
     let tCfg = loginT.cfgVals();
     if ((tCfg & (0x02 | 0x01)) === (0x02 | 0x01))
     {
      await twitch.net.oAuth.update();
      tCfg = loginT.cfgVals();
      if ((tCfg & 0x04) !== 0x04)
      {
       notice.error(0x11);
       return false;
      }
     }
     if ((tCfg & (0x04 | 0x01)) !== (0x04 | 0x01))
      return false;
     if (await twitch.global() === false)
      return false;
     await _ffz();
     twitch.net.irc();
     return true;
    }

    async function _youtube()
    {
     let yCfg = loginYT.cfgVals();
     if ((yCfg & 0x02) === 0x02)
     {
      await youtube.net.oAuth.update();
      yCfg = loginYT.cfgVals();
      if ((yCfg & 0x04) !== 0x04)
      {
       notice.error(0x21);
       return false;
      }
     }
     if ((yCfg & 0x04) !== 0x04)
      return false;
     if (await youtube.global() === false)
      return false;
     if (cfg.event.youtube.sub !== false)
      youtube.net.subscribers();
     youtube.net.members();
     youtube.net.broadcasts.updateStream();
     return true;
    }

    async function _kick()
    {
     if ((loginK.cfgVals() & 0x01) !== 0x01)
      return false;
     kick.net.socket();
     if (cfg.event.kick.follow !== false)
      kick.net.followers();
     return true;
    }

    function _streamlabs()
    {
     const slCfg = streamlabs.cfgVals();
     if ((slCfg & 0x01) !== 0x01)
      return;
     streamlabs.socket();
    }

    async function _streamelements()
    {
     let seCfg = streamelements.cfgVals();
     if (seCfg === 0)
      return;
     if ((seCfg & 0x02) === 0x02)
      await streamelements.updateOAuth();
     seCfg = streamelements.cfgVals();
     if ((seCfg & 0x01) !== 0x01 && (seCfg & 0x04) !== 0x04)
      return;
     streamelements.socket();
    }

    async function _ffz()
    {
     if (!cfg.display.extended.useFFZ)
      return;
     await thirdparty.ffz.global();
    }

    async function _bttv()
    {
     if (!cfg.display.extended.useBTTV)
      return;
     thirdparty.bttv.socket.init();
     await thirdparty.bttv.global();
    }

    async function _7tv()
    {
     if (!cfg.display.extended.use7TV)
      return;
     thirdparty['7tv'].socket.init();
     await thirdparty['7tv'].global();
    }

    function _css()
    {
     const css = document.getElementsByTagName('STYLE')[0];
     let h = css.innerHTML;
     if (cfg.display.hasOwnProperty('hue') && cfg.display.hue !== false)
     {
      if (cfg.display.hue === 'rave')
      {
       let r = '   html.rave\n';
       r += '   {\n';
       r += '    animation: rave 3s linear infinite;\n';
       r += '   }\n';
       r += '   @keyframes rave\n';
       r += '   {\n';
       for (let i = 0; i <= 100; i += 10)
       {
        r += '    ' + i + '%\n';
        r += '    {\n';
        r += '     filter: hue-rotate(' + i * 3.6 + 'deg);\n';
        r += '    }\n';
       }
       r += '   }\n';
       r += '   html.rave button, html.rave div#notices\n';
       r += '   {\n';
       r += '    animation: antirave 3s linear infinite;\n';
       r += '   }\n';
       r += '   @keyframes antirave\n';
       r += '   {\n';
       for (let i = 0; i <= 100; i += 10)
       {
        r += '    ' + i + '%\n';
        r += '    {\n';
        r += '     filter: hue-rotate(' + (360 - i * 3.6) + 'deg);\n';
        r += '    }\n';
       }
       r += '   }\n';
       h = r + h;
      }
      else if (!isNaN(cfg.display.hue))
      {
       const iHue = parseInt(cfg.display.hue, 10);
       if (iHue > 0 && iHue < 360)
        h = '   html\n   {\n    filter: hue-rotate(' + iHue + 'deg);\n   }\n   button, div#notices\n   {\n    filter: hue-rotate(' + (360 - iHue) + 'deg);\n   }' + h;
      }
     }
     let a = '   [data-squash="vertical"]\n';
     a += '   {\n';
     a += '    transform: scale(' + timing.display.Crazy.squash.width + ', ' + timing.display.Crazy.squash.height + ');\n';
     a += '   }\n';
     a += '   [data-squash="horizontal"]\n';
     a += '   {\n';
     a += '    transform: scale(' + timing.display.Crazy.squash.height + ', ' + timing.display.Crazy.squash.width + ');\n';
     a += '   }\n';
     h = h.replace('   [data-squash="no"]\n', a + '   [data-squash="no"]\n');
     if (cfg.display.extended.useZWE && cfg.display.extended.hasOwnProperty('fillZWE') && cfg.display.extended.fillZWE)
     {
      h = h.replace('padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) 0;', 'padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) calc((var(--zoom-width) - (var(--zoom-width) * 0.1)) / 2);');
      h = h.replace('padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.8)) / 2) 0;', 'padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.8)) / 2) calc((var(--zoom-width) - (var(--zoom-width) * 0.8)) / 2);');
      h = h.replace('padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.95)) / 2) 0;', 'padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.95)) / 2) calc((var(--zoom-width) - (var(--zoom-width) * 0.95)) / 2);');
      h = h.replace('padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) 0;', 'padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) calc((var(--zoom-width) - (var(--zoom-width) * 0.1)) / 2);');
      let z = '   img.fit,\n';
      z += '   .fit img\n';
      z += '   {\n';
      z += '    object-fit: contain;\n';
      z += '    object-position: 50% 50%;\n';
      z += '   }\n';
      h = h.replace('   img\n   {\n', z + '   img\n   {\n');
     }
     else
     {
      let z = '   img\n';
      z += '   {\n';
      z += '    object-fit: contain;\n';
      z += '    object-position: 50% 50%;\n';
      h = h.replace('   img\n   {\n', z);
     }
     let t = '   .etStraightLine\n';
     t += '   {\n';
     t += '    transition: transform linear ' + Math.floor(cfg.emote.time * 1000 * timing.display.StraightLine.time) + 'ms;\n';
     t += '   }\n';
     t += '   .etThrowTwist\n';
     t += '   {\n';
     t += '    transition: transform cubic-bezier(0.32, 0, 0.67, 0) ' + Math.floor(cfg.emote.time * 1000 * timing.display.Throw.time * timing.display.Throw.twist) + 'ms;\n';
     t += '   }\n';
     t += '   .etThrowDrop\n';
     t += '   {\n';
     t += '    transition: transform cubic-bezier(0.5, 0, 0.75, 0) ' + Math.floor(cfg.emote.time * 1000 * timing.display.Throw.time * timing.display.Throw.drop) + 'ms;\n';
     t += '   }\n';
     t += '   .etFountain\n';
     t += '   {\n';
     t += '    transition: transform cubic-bezier(0, 0, 0.58, 1) ' + Math.floor(cfg.emote.time * 1000 * timing.display.Fountain.time) + 'ms;\n';
     t += '   }\n';
     t += '   div.scene.cube:not(.kappa),\n';
     t += '   div.scene.cube:not(.kappa) div.cube\n';
     t += '   {\n';
     t += '    transition: transform linear ' + Math.floor(cfg.emote.time * 1000 * timing.display.TheCube.time) + 'ms;\n';
     t += '   }\n';
     t += '   .ktFireworkRocket\n';
     t += '   {\n';
     t += '    transition: transform linear ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time * timing.kappa.Fireworks.speed.rocket) + 'ms;\n';
     t += '   }\n';
     t += '   .ktFireworkSparkler\n';
     t += '   {\n';
     t += '    transition: transform ease-out ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time) + 'ms;\n';
     t += '   }\n';
     t += '   .ktSpiral\n';
     t += '   {\n';
     t += '    transition: transform ease-out ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.Spiral.time) + 'ms;\n';
     t += '   }\n';
     t += '   .ktPyramid\n';
     t += '   {\n';
     let ctP = 0;
     const lP = pyramidDist.length;
     for (let i = 0; i < lP; i++)
      ctP += pyramidDist[i];
     const tP = Math.floor(cfg.emote.time * 1000 * timing.kappa.Pyramid.time * timing.kappa.Pyramid.show.total);
     const tPerB = Math.max(Math.floor(tP / ctP), timing.kappa.Pyramid.show.min);
     t += '    transition: transform ease-in ' + tPerB + 'ms;\n';
     t += '   }\n';
     t += '   .ktPyramidDrop\n';
     t += '   {\n';
     t += '    transition: transform ease-in ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.Pyramid.time * timing.kappa.Pyramid.hide) + 'ms;\n';
     t += '   }\n';
     t += '   .ktSmallPyramid\n';
     t += '   {\n';
     const tSP = Math.floor(cfg.emote.time * 1000 * timing.kappa.SmallPyramid.time * timing.kappa.SmallPyramid.show.total);
     const tPerSB = Math.max(Math.floor(tSP / ctP), timing.kappa.SmallPyramid.show.min);
     t += '    transition: transform ease-in ' + tPerSB + 'ms;\n';
     t += '   }\n';
     t += '   .ktSmallPyramidDrop\n';
     t += '   {\n';
     t += '    transition: transform ease-in ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.SmallPyramid.time * timing.kappa.SmallPyramid.hide) + 'ms;\n';
     t += '   }\n';
     t += '   .ktStampede\n';
     t += '   {\n';
     t += '    transition: transform linear ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.Stampede.time * timing.kappa.Stampede.speed) + 'ms;\n';
     t += '   }\n';
     const congaShowMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Conga.time.show);
     const congaHideMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Conga.time.hide);
     t += '   .ktCongaIn\n';
     t += '   {\n';
     t += '    transition: transform linear ' + congaShowMS + 'ms;\n';
     t += '   }\n';
     t += '   .ktCongaOut\n';
     t += '   {\n';
     t += '    transition: transform ease-in ' + congaHideMS + 'ms;\n';
     t += '   }\n';
     t += '   div.scene.cube.kappa,\n';
     t += '   div.scene.cube.kappa div.cube\n';
     t += '   {\n';
     t += '    transition: transform linear ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.TheCube.time) + 'ms;\n';
     t += '   }\n';
     h = h.replace('   [data-squash="vertical"]\n', t + '\n   [data-squash="vertical"]\n');
     if (cfg.display.hasOwnProperty('statuses') && cfg.display.statuses === false)
      h = h.replace('#notices\n   {\n', '#notices\n   {\n    display: none;\n');
     css.innerHTML = h;
    }

    function _hasRaveToggle()
    {
     for (const k of cfg.commands)
     {
      if (k.hasOwnProperty('rave'))
       return true;
      if (k.hasOwnProperty('raveon'))
       return true;
     }
     return false;
    }

    return task;
   }();

   window.addEventListener('load', startup);
  </script>
  <style>
   :root
   {
    --height: 0px;
    --width: 0px;
    --emote-height: 0px;
    --emote-width: 0px;
    --zoom-height: var(--emote-height);
    --zoom-width: var(--emote-width);
   }
   body
   {
    margin: 0;
    overflow: hidden;
   }
   img
   {
    box-sizing: border-box;
    height: var(--emote-height);
    width: var(--emote-width);
   }
   img.emote
   {
    position: fixed;
    border: 0;
    margin: 0;
    padding: 0;
    offset-rotate: 0deg;
   }

   div.scene
   {
    position: fixed;
    border: 0;
    margin: 0;
    padding: 0;
   }
   div.scene.cube
   {
    height: var(--emote-height);
    width: var(--emote-width);
   }
   div.scene div.cube
   {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
   }
   div.scene div.cube div[data-face]
   {
    height: var(--emote-height);
    width: var(--emote-width);
   }
   div.scene div.cube div[data-face] img
   {
    position: absolute;
    transform: translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face]
   {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.2);
   }
   div.scene div.cube [data-face="front"]
   {
    transform: translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="back"]
   {
    transform: rotateY(90deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="right"]
   {
    transform: rotateY(180deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="left"]
   {
    transform: rotateY(-90deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="top"]
   {
    transform: rotateX(90deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="bottom"]
   {
    transform: rotateX(-90deg) translateZ(var(--cube-depth));
   }

   div.scene img.dancer
   {
    text-align: center;
    position: relative;
    animation: dance 4s linear infinite;
   }

   @keyframes dance
   {
    0%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    6%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    13%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    19%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    25%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    31%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    38%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    44%
    {
     transform: translate(20%, 10%) rotate(-30deg);
    }
    50%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    56%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    63%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    69%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    75%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    81%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    88%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    94%
    {
     transform: translate(80%, 10%) rotate(30deg);
    }
    100%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
   }

   @keyframes wiggleL
   {
    33%
    {
     transform: translateX(-50%);
    }
    66%
    {
     transform: translateX(50%);
    }
   }
   @keyframes wiggleR
   {
    33%
    {
     transform: translateX(50%);
    }
    66%
    {
     transform: translateX(-50%);
    }
   }

   @keyframes speedL
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(-1 * var(--width) * 4), 0);
    }
   }
   @keyframes speedR
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(var(--width) * 4), 0);
    }
   }

   @keyframes dropL
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(350deg);
    }
   }
   @keyframes dropR
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(-35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(-350deg);
    }
   }

   @keyframes confettiA
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0.5, 0, -4500deg);
    }
   }

   @keyframes confettiB
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0, 0, -4500deg);
    }
   }

   @keyframes confettiC
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, -0.5, 0, -4500deg);
    }
   }

   @keyframes offsetPath
   {
    0%
    {
     offset-distance: 0%;
    }
    100%
    {
     offset-distance: 100%;
    }
   }

   .eNorm
   {
    --zoom-height: var(--emote-height);
    --zoom-width: var(--emote-width);
   }
   .eHalf
   {
    --zoom-height: calc(var(--emote-height) / 2);
    --zoom-width: calc(var(--emote-width) / 2);
   }
   .eDouble
   {
    --zoom-height: calc(var(--emote-height) * 2);
    --zoom-width: calc(var(--emote-width) * 2);
   }

   [data-squash="no"]
   {
    transform: scale(1, 1);
   }

   [data-origin="center"]
   {
    transform-origin: center center;
   }
   [data-origin="topleft"]
   {
    transform-origin: left top;
   }
   [data-origin="topright"]
   {
    transform-origin: right top;
   }
   [data-origin="top"]
   {
    transform-origin: center top;
   }
   [data-origin="bottom"]
   {
    transform-origin: center bottom;
   }
   [data-origin="left"]
   {
    transform-origin: left center;
   }
   [data-origin="right"]
   {
    transform-origin: right center;
   }

   @keyframes fadeIn
   {
    0%
    {
     opacity: 0;
    }
    100% /* 8% */
    {
     opacity: 1;
    }
   }

   @keyframes fadeOut
   {
    0% /* 95% */
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes noFadeOut
   {
    99%
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes zoomIn
   {
    0%
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) 0;
    }
    24% /* 4% */
    {
     padding: 0;
    }
    47% /* 8% */
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.8)) / 2) 0;
    }
    71% /* 12% */
    {
     padding: 0;
    }
    88% /* 15% */
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.95)) / 2) 0;
    }
    100% /* 17% */
    {
     padding: 0;
    }
   }

   @keyframes zoomOut
   {
    0% /* 95% */
    {
     padding: 0;
    }
    100%
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) 0;
    }
   }

   #notices
   {
    position: absolute;
    top: 8px;
    left: 8px;
    width: 35em;
   }
   #notices #badge
   {
    position: fixed;
    font-family: sans-serif;
    font-size: 14px;
    left: 8px;
    width: 16px;
    height: 16px;
    display: inline-block;
    border: 1.5px solid #000000;
    border-radius: 8px;
    text-align: center;
    background-color: #E0E0E0;
    color: #000000;
    opacity: 0.75;
    transition: opacity 1s ease-in;
    cursor: default;
   }
   #notices #badge[data-alerts="0"]
   {
    opacity: 0;
   }
   #notices #badge.fader
   {
    transition: all 300ms ease-out;
   }
   #notices #badge.fade
   {
    opacity: 0;
   }
   #notices .noticeLine
   {
    position: relative;
    font-family: sans-serif;
    font-size: 14px;
    border: 1.5px solid #000000;
    border-radius: 8px;
    padding-left: 24px;
    padding-right: 8px;
    margin-left: 24px;
    margin-bottom: 4px;
    white-space: nowrap;
    max-width: fit-content;
    width: 100%;
    transition: all 300ms ease-out;
    opacity: 0.75;
    cursor: default;
   }
   #notices .noticeLine:hover
   {
    opacity: 1;
   }
   #notices .noticeLine.hide
   {
    width: 0%;
    overflow: hidden;
   }
   #notices .noticeLine.fader
   {
    transition: opacity 0.5s;
    opacity: 0.75;
   }
   #notices .noticeLine.fader:hover
   {
    opacity: 1;
   }
   #notices .noticeLine.fader.fade
   {
    opacity: 0;
   }
   #notices .noticeLine.fader.faded
   {
    height: 0;
    margin: 0;
    padding: 0;
    border: 0;
   }
   #notices .noticeInfo
   {
    background-image: linear-gradient(to right, transparent 0, transparent 20px, #E0E0E0 24px);
   }
   #notices .noticeWarning
   {
    background-image: linear-gradient(to right, transparent 0, transparent 20px, #FFFF00 24px);
   }
   #notices .noticeError
   {
    color: #FFFFFF;
    background-image: linear-gradient(to right, transparent 0, transparent 20px, #FF0000 24px);
   }
   #notices .noticeError a
   {
    color: #FFFF00;
    text-decoration: none;
   }
   #notices .noticeError a:hover
   {
    color: #FFFFC0;
   }
   #notices .global
   {
    background-color: #FFFFFF;
   }
   #notices .sTwitch
   {
    background-color: #7D5BBE;
   }
   #notices .sTwitch:after
   {
    position: absolute;
    top: 0;
    left: 7px;
    content: 'T';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .sYouTube
   {
    background-color: #E93223;
   }
   #notices .sYouTube:after
   {
    position: absolute;
    top: 0;
    left: 2px;
    content: 'YT';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .sKick
   {
    background-color: #53FC18;
   }
   #notices .sKick:after
   {
    position: absolute;
    top: 0;
    left: 7px;
    content: 'K';
    color: #000000;
    font-size: 14px;
   }
   #notices .tStreamElements
   {
    background-color: #0000FF;
   }
   #notices .tStreamElements:after
   {
    position: absolute;
    top: 0;
    left: 2px;
    content: 'SE';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .tStreamlabs
   {
    background-color: #80F5D2;
   }
   #notices .tStreamlabs:after
   {
    position: absolute;
    top: 0;
    left: 3px;
    content: 'SL';
    color: #000000;
    font-size: 14px;
   }
   #notices .eBTTV
   {
    background-color: #FF0000;
   }
   #notices .eBTTV:after
   {
    position: absolute;
    top: 0;
    left: 7px;
    content: 'B';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .e7TV
   {
    background-color: #00FFFF;
   }
   #notices .e7TV:after
   {
    position: absolute;
    top: 0;
    left: 8px;
    content: '7';
    color: #000000;
    font-size: 14px;
   }

   button
   {
    transition: background 0.12s ease-in, color 0.12s ease-in;
    white-space: nowrap;
    cursor: pointer;
    color: #FFFFFF;
    border-radius: 4px;
    border: none;
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    z-index: 1000;
    opacity: 1;
    position: absolute;
   }
   button.hidden
   {
    opacity: 0;
   }
   button:focus
   {
    outline: none;
   }

   button.twitch
   {
    background-color: #7D5BBE;
   }
   button.twitch:focus, button.twitch:hover
   {
    background-color: #772CE8;
   }
   button.twitch:active
   {
    background-color: #5C16C5;
   }

   button.youtube
   {
    background-color: #E93223;
   }
   button.youtube:focus, button.youtube:hover
   {
    background-color: #D00000;
   }
   button.youtube:active
   {
    background-color: #FF0000;
   }

   button.login
   {
    transition: opacity 0.5s;
    left: calc(50% - 6.5em);
    width: 13em;
    font-size: 6vmin;
    padding: 0.5em;
   }
   button.login span
   {
    font-size: 40%;
    padding: 0;
    position: absolute;
    bottom: 0.25em;
    right: 0.5em;
   }
   button.login.twitch
   {
    top: calc(50% - 1em - 1.25em);
   }
   .notice + button.login.twitch
   {
    top: calc(100% - 10vmin - 2.5em);
   }
   .notice.hiding + button.login.twitch
   {
    transition: top 500ms ease-out;
    top: calc(50% - 1em - 1.25em);
   }
   button.login.youtube
   {
    top: calc(50% - 1em + 1.25em);
   }
   .notice ~ button.login.youtube
   {
    top: calc(100% - 10vmin);
   }
   .notice.hiding ~ button.login.youtube
   {
    transition: top 500ms ease-out;
    top: calc(50% - 1em + 1.25em);
   }

   button.logout
   {
    transition: opacity 0.5s;
    right: 1em;
    width: 5em;
    font-size: 2vmin;
    padding: 0.5em;
   }
   button#cmdTLogout
   {
    top: 1em;
   }
   button#cmdYTLogout
   {
    top: 4em;
   }
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
 </head>
</html>