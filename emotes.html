<!doctype html>
<html lang="en">
 <head>
  <meta charset="utf-8" />
  <script>
   /* RealityRipple's Home-Made Emote Wall
    * ====================================
    *
    * v0.6.3 BETA
    *
    *  <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *
    *
    * Help
    * ----
    *
    *  Please contact RealityRipple for assistance, bug reports, or questions.
    *
    *   <https://realityripple.com>
    *   <https://twitch.tv/realityripple>
    *   <https://discord.gg/fcxJ9tq3XS>
    *
    *
    * Configuration Information
    * -------------------------
    *
    * channel     The name of the channel to join. Also used to choose an IRC nickname.
    *             If FALSE, the interactive login process will be enabled.
    *
    * login       Settings related to the login process.
    *
    *             NOTE: OAuth tokens expire automatically (usually after 60 days). Please make sure to update
    *                   these values on a regular basis, if not using the interactive login process.
    *
    *  client     The Client ID value is used to track which third-party project is accessing your account.
    *             This emote wall does not require a constant ID, and will work with whatever tool you use to
    *             get an OAuth ID (see below).
    *
    *  oauth      The OAuth ID value is used in lieu of a password to access the Twitch API.
    *             Please generate an OAuth ID and matching Client ID:
    *             - Visit https://realityripple.com/Tools/Twitch/EmoteWall/
    *             - Click the "Authenticate on Twitch" button under "Do-it-Yourself" and log in
    *             - Fill out the captcha prompt, if necessary
    *             - Copy the Client ID value and paste it into "client:"
    *             - Copy the OAuth ID value and paste it into "oauth:"
    *             If you ever stop using this emote wall, please log into Twitch and visit
    *             https://www.twitch.tv/settings/connections . Under "Other Connections", click the "Disconnect" button
    *             next to "RealityRipple's Home-Made Emote Wall". If you want to use a different Twitch OAuth generator
    *             (or do it yourself), feel free.
    *             If FALSE, the interactive login process will be enabled.
    *
    * streamlabs  Settings related to Streamlabs tips.
    *
    *  token      The Socket Token is used in lieu of a password to access the Streamlabs API.
    *             Please generate a Socket Token:
    *             - Visit https://realityripple.com/Tools/Twitch/EmoteWall/
    *             - Click the "Streamlabs Tip Support" button and log in
    *             - Copy the Token value and paste it into "token:"
    *             If you ever stop using this emote wall, please log into Streamlabs and visit
    *             https://streamlabs.com/dashboard#/settings/api-settings . Under "Connected Apps", click the
    *             "Revoke Access" button next to "RealityRipple's Home-Made Emote Wall". If you want to use a different
    *             Streamlabs OAuth generator (or do it yourself), feel free.
    *
    *  curMul     This value is the currency multiplier. The ranges of Streamlabs tip entries (see below) will
    *             match against this multiplier. For example, if you use USD and want to set ranges by penny amount,
    *             then set this value to 100. If you want to use dollar amounts, set the value to 1.
    *             Note: Any decimal amount will be rounded down after multiplying, so $3.95 will be handled as "395"
    *                   pennies when multiplied by 100, or "3" dollars when multiplied by 1.
    *
    *  dispMul    This value is the currency multiplier when the currency is being displayed. For kappagen events such
    *             as Text, the Streamlabs tip amount will be multiplied by this number before being displayed.
    *             For example, if you use USD and want to display the value as cents, then set this value to 100. If
    *             you want to show dollar amounts, set this value to 1.
    *
    *  dispDec    This value is the decimal count when the currency is being displayed. After being multiplied by the
    *             dispMul value above, the Streamlabs tip amount will be rounded to this many decimal places.
    *             For example, an amount of $3.95 rounded to "0" decimal places will be "3", to "1" would be "3.9", and
    *             to "2" would be "3.95".
    *
    *  dispPre    This value should be added before any currency amount as a prefix, such as a dollar sign '$'.
    *
    *  dispSuf    This value should be added after any currency amount as a suffix, such as the word " dollars". Usually
    *             only the prefix or the suffix should be used, not both at the same time.
    *
    * streamelements  Settings related to StreamElements tips.
    *
    *  oauth      The OAuth ID value is used in lieu of a password to access the StreamElements API.
    *             Please generate an OAuth ID:
    *             - Visit https://realityripple.com/Tools/Twitch/EmoteWall/
    *             - Click the "StreamElements Tip Support" button and log in
    *             - Copy the OAuth ID value and paste it into "oauth:"
    *             If you ever stop using this emote wall, please log into StreamElements and visit
    *             https://streamelements.com/dashboard/account/security. Click the "Reset my Personal Access Token"
    *             button. If you want to use a different StreamElements OAuth generator (or do it yourself), feel free.
    *             Please only use oauth or token, not both. Token does not expire, but is also less secure. OAuth is
    *             recommended, if possible.
    *
    *  token      The JWT Token is used in lieu of a password to access the StreamElements API.
    *             Please grab your JWT Token from the StreamElements Dashboard:
    *             - Visit https://streamelements.com/dashboard/account/channels
    *             - Click the "Show secrets" button
    *             - Copy the JWT Token value and paste it into "token:"
    *             Please only use oauth or token, not both. Token does not expire, but is also less secure. OAuth is
    *             recommended, if possible.
    *
    *  curMul     This value is the currency multiplier. The ranges of StreamElements tip entries (see below) will
    *             match against this multiplier. For example, if you use USD and want to set ranges by penny amount,
    *             then set this value to 100. If you want to use dollar amounts, set the value to 1.
    *             Note: Any decimal amount will be rounded down after multiplying, so $3.95 will be handled as "395"
    *                   pennies when multiplied by 100, or "3" dollars when multiplied by 1.
    *
    *  dispMul    This value is the currency multiplier when the currency is being displayed. For kappagen events such
    *             as Text, the StreamElements tip amount will be multiplied by this number before being displayed.
    *             For example, if you use USD and want to display the value as cents, then set this value to 100. If
    *             you want to show dollar amounts, set this value to 1.
    *
    *  dispDec    This value is the decimal count when the currency is being displayed. After being multiplied by the
    *             dispMul value above, the StreamElements tip amount will be rounded to this many decimal places.
    *             For example, an amount of $3.95 rounded to "0" decimal places will be "3", to "1" would be "3.9", and
    *             to "2" would be "3.95".
    *
    *  dispPre    This value should be added before any currency amount as a prefix, such as a dollar sign '$'.
    *
    *  dispSuf    This value should be added after any currency amount as a suffix, such as the word " dollars". Usually
    *             only the prefix or the suffix should be used, not both at the same time.
    *
    * display     Settings related to the animation of the emote wall.
    *
    *  styles     An array of animation styles which individual emotes randomly perform. You may turn on and off
    *             elements in this array by "commenting out" a style, by putting two slashes before the name:
    *              // 'Still',        < disabled
    *                 'StraightLine', < allowed
    *
    *  access     A bitwise flag representing which users' messages show up on the emote wall. Account types are
    *             represented by the following values:
    *
    *              0x800 = broadcaster
    *              0x400 = moderator badge
    *              0x200 = founder badge
    *              0x100 = vip badge
    *              0x080 = artist badge
    *              0x040 = tier 3 subscriber badge
    *              0x020 = tier 2 subscriber badge
    *              0x010 = tier 1 subscriber badge
    *              0x004 = cheer badge
    *              0x002 = follower
    *              0x001 = stranger
    *
    *             Just put a vertical pipe " | " in between each of the values representing levels of access:
    *
    *              ACCESS                                 MEANING 
    *             0x800 | 0x400                           broadcaster and moderator only
    *             0x800 | 0x400 | 0x100 | 0x040 | 0x020   broadcasters, mods, VIPs, and tier 2 and 3 subscribers
    *             0x800 | 0x010 | 0x002                   boradcaster, tier 1 subscribers, and followers
    *
    *             If you know how bitwise flags work, you can also use them
    *             in more complicated ways:
    *               ACCESS           MEANING
    *             0xFF7             all users from the broadcaster to strangers
    *             0xFF7 ^ 0x003     all users except followers and strangers
    *             0x070             all subscribers
    *
    *  duplicates  A boolean or integer to toggle duplicate emotes per message.
    *             If TRUE, every emote posted in chat will be shown.
    *             If FALSE, only one of each emote per message will be shown.
    *             If greater than 1, sets the maximum number of identical emotes shown from any message.
    *
    *  useEmoji   Toggles display of emojis on the emote wall, and lets you choose an emoji font style.
    *             If TRUE, emojis will be shown using the "twemoji" font.
    *             If FALSE, emojis will not be shown on the emote wall.
    *             If 'twemoji', emojis will be shown using the "twemoji" font.
    *             If 'openmoji', emojis will be shown using the "openmoji" font.
    *             If 'noto', emojis will be shown using the "noto" font.
    *             If 'blob', emojis will be shown using the "blobmoji" font.
    *
    *  extended   Settings related to third-party emotes.
    *
    *   useFFZ    Toggles display of FrankerFaceZ emotes.
    *
    *   useBTTV   Toggles display of BetterTTV emotes.
    *
    *   use7TV    Toggles display of 7TV emotes.
    *
    *   useZWE    Toggles display of Zero-Width (overlapping) emotes. If disabled, this will hide ZWEs entirely.
    *             Note: ZWE display requires more objects on-screen, which can be process-intensive, and precise
    *                   timing is required for accurate overlay.
    *                   CHAOS MAY ENSUE.
    *
    *  kappa      Settings related to emote-splosions and the !kappagen command.
    *
    *   count     The number of emotes to display per kappagen. This value should be less than the "emote max" value
    *             seen below (best would be 1/4th or less), if "emote max" is used, or it will be truncated to match.
    *
    *   styles    Similar to the array of styles for normal emotes, but this one lists emote-splosion types.
    *             Please do not try to add normal styles to the kappa list or vice versa. This is an associative array
    *             which can have custom settings for certain styles (namely The Cube and Text - see below).
    *
    *    [ALL]    Settings related to multiple kappagens. These settings will be the default for all instances of their
    *             respective kappagens. Each setting below may or may not apply to a specific kappagen style.
    *
    *     count   The number of emotes to display for this specific kappagen. This value should be less than the
    *             "emote max" value seen below (best would be 1/4th or less), if "emote max" is used, or it will be
    *             truncated to match. If unset, this will default to the global kappa count preference listed above.
    *             Note: If this preference is in an event below (not in this general kappa context), then an additional
    *                   value is possible: -1, which will refer to the AMOUNT value present in the event. This can be
    *                   the number of raiders, bits cheered, dollars tipped, subs gifted, or months subscribed.
    *
    *     command Settings related to triggering a specific kappagen style by chat command.
    *
    *      access A bitwise flag representing which users can trigger this kappagen with a command.
    *
    *      aliases  An array of style-specific kappa command aliases which can be used to force-trigger this kappagen.
    *
    *     redeem  An array of style-specific channel point reward names which can be used to force-trigger this kappagen.
    *
    *    Conga    Settings related to Conga kappagen. These settings will be the default for all instances of
    *             Conga kappagen.
    *
    *     avoidMiddle  If TRUE, conga lines will only show up on the top or bottom three rows to avoid the middle off
    *                 the screen.
    *             If FALSE, conga lines will show up on any row of the screen.
    *
    *    TheCube  Settings related to The Cube kappagen. These settings will be the default for all instances of
    *             TheCube kappagen.
    *
    *     size    A decimal value representing the height of The Cube kappagen, relative to the smallest
    *             screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "8 / 10" (80%).
    *
    *     center  If TRUE, The Cube will show up in the exact center of the screen.
    *             If FALSE, The Cube will show up in a random location.
    *
    *     rotations  The maximum number of rotations a kappa cube might spin while on screen. This effectively controls
    *               the maximum possible speed at which cubes will rotate.
    *
    *    Text     Settings related to Text kappagen. These settings will be the default for all instances of Text
    *             kappagen.
    *
    *     message  An array of alphanumeric strings (letters, numbers, and spaces), one of which will randomly be used.
    *
    *     time    The number of seconds the Text kappagen should show the final result for.
    *             This value should be adjusted depending on the average message length, for readability.
    *
    *   access    Similar to the access flag for normal emotes, but controls which users can use the !kappagen command.
    *
    *   aliases   An array of kappagen command aliases which can be used to force-trigger kappagens.
    *
    *   cooldown  The number of seconds between force-triggered kappagens using an above alias. Any commands sent before
    *             the cooldown will be treated like normal text, which may include showing any emotes in the message as
    *             normal emotes rather than in a kappagen.
    *
    *   conga     Settings related to Conga kappagen.
    *
    *    contagious  If TRUE, while one Conga kappagen is visible, all additional kappagens will also be Conga.
    *               If FALSE, Conga kappagns will behave like any other kappagen.
    *
    *    time     The number of seconds the Conga kappagen should show up on the screen for.
    *             This value lets you increase or decrease the chances of keeping a "contagious" Conga line going.
    *
    *    avoidMiddle  If TRUE, conga lines will only show up on the top or bottom three rows to avoid the middle off
    *                the screen globally.
    *             If FALSE, the setting will default to any more specific avoidMiddle Conga settings.
    *
    * emote       Settings related to individual emote display.
    *
    *  time       The number of seconds an emote should show up on the screen for.
    *
    *  max        The maximum nuber of emotes to show on the screen at one time. Set this value to 0 for
    *             infinite emotes. This value should be greater than any "kappa count" values seen above or below
    *             (best would be 4x or more), as it will limit any single kappagen events to this maximum.
    *
    *  queue      The maximum number of emotes to save in queue. Set this value to 0 for an infinite queue.
    *             This value will be ignored if the previous value (cfg.emote.max) is infinite (0).
    *
    *  size       Settings related to the size of emotes.
    *
    *   ratio     Emotes show up in multiple sizes due to the kappagen feature. There are a total of four sizes
    *             that an emote can be:
    *              - The Cube kappagen's faces are squares equal to 80% of the smaller screen dimension
    *                (usually height on PC).
    *              - Pyramid kappagen emotes have a height equal to 1/19th of the screen's width.
    *              - Fireworks, Spiral, and Confetti kappagen emotes have a height equal to the small ratio (see below).
    *              - All standard emotes and kappagens not listed above will use the normal ratio (see below).
    *                Most normal emotes will limit by height, except The Cube, which fits in the center of every side.
    *
    *    normal   A decimal value representing the height of each emote, relative to the smallest screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "1 / n" where n is greater than 10.
    *
    *    small    A decimal value representing the height of small emotes, relative to the smallest screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "1 / n" where n is greater than 20.
    *
    *   min       The minimum height of an emote, in pixels.
    *
    *   max       The maximum height of an emote, in pixels.
    *
    *   variation  An integer variable that determines how often occasional random large or small emotes show up.
    *             If FALSE, no variations will occur.
    *
    *  cube      Settings related to The Cube emote.
    *
    *   rotations  The maximum number of rotations a cube might spin while on screen. This effectively controls the
    *             maximum possible speed at which cubes will rotate.
    *
    *  in         Settings related to the showing of an emote.
    *             Note: Some kappagen styles do not use these. See the notes next to each kappagen style name.
    *
    *   fade      A boolean to toggle the "fade in" style.
    *
    *   zoom      A boolean to toggle the "zoom in" style.
    *
    *  out        Settings related to the hiding of an emote.
    *             Note: Some kappagen styles do not use these. See the notes next to each kappagen style name.
    *
    *   fade      A boolean to toggle the "fade out" style.
    *
    *   zoom      A boolean to toggle the "zoom out" style.
    *
    * event       Settings related to channel events which trigger emote-splosions (kappagen).
    *
    *  raid       Settings related to kappagens when being raided.
    *
    *   raiders   A streamer raids the channel with viewers. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all raids.
    *              If FALSE, no kappagen will occur on raids.
    *              If Integer, the value is the minimum raiders required for a raid to trigger a kappagen.
    *               If 0, no kappagen will occur on raid.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *                Keep in mind that kappagen arrays are also associative, and may have independent settings for
    *                kappas such as TheCube and Text. This applies to all such arrays listed below as well.
    *
    *   originEmotes  A boolean to toggle the use of the raiding streamer's channel emotes for raid kappagens.
    *                If TRUE, raid kappagens will use channel emotes from the raider's channel (not including third-party).
    *               If FALSE, raid kappagens will use your channel's emotes (including third-party).
    *
    *  follow     A user follows the channel.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  sub        Settings related to kappagens on a subscribe event.
    *             Note: Sub event booleans can also be arrays of kappa styles. This will override the default list
    *                   of kappa styles for the particular event in question.
    *
    *   useMsg    If TRUE, any emotes in resub messages will be used for the kappagen.
    *             If FALSE, any emotes in resub messages will show up like normal emotes.
    *
    *   t1        Settings related to kappagens on a tier 1 subscribe event.
    *
    *    first    A user subscribes at Tier 1 for the first time.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    resub    A user resubscribes at Tier 1. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Tier 1 resubs.
    *              If FALSE, no kappagen will occur on T1 resubs.
    *              If Integer, the value is the minimum months required for a Tier 1 resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    upgrade  Settings related to "converted" subscriptions.
    *
    *     gift     A user upgrades a gift sub to Tier 1.
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     prime    A user upgrades a Prime sub to Tier 1.
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    gift     Settings related to tier 1 gifts.
    *
    *     first   A user gifts another user their first Tier 1 subscription.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     resub   A user gifts another user a Tier 1 resubscription. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Tier 1 gift resubs.
    *              If FALSE, no kappagen will occur on T1 gift resubs.
    *              If Integer, the value is the minimum months required for a Tier 1 gift resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     bomb    A user gifts multiple Tier 1 subscriptions. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on any random gift.
    *              If FALSE, no kappagen will occur on giftbombs.
    *              If Integer, the value is the minimum gifts required for a gift bomb to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur on any random gift.
    *               If greater than 1, the number of gifted users in a Tier 1 giftbomb must be greater than or equal to
    *               this number to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   t2        Identical to t1, but for Tier 2 subscriptions.
    *
    *   t3        Identical to t1, but for Tier 3 subscriptions.
    *
    *   prime     Settings related to kappagens on an Amazon Prime subscribe event.
    *
    *    first    A user subscribes with Prime for the first time.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    resub    A user resubscribes with Prime. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Prime resubs.
    *              If FALSE, no kappagen will occur on Prime resubs.
    *              If Integer, the value is the minimum months required for a Prime resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  cheer      Settings related to kappagens on a cheer event.
    *
    *   useMsg    If TRUE, any emotes in cheer messages will also be included in the kappagen.
    *             If FALSE, any emotes in cheer messages will show up like normal emotes.
    *
    *   bits       Minimum number of bits for a kappagen. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all cheers.
    *              If FALSE, no kappagen will occur on cheers.
    *              If Integer, the value is the minimum bits required for a cheer to trigger a kappagen.
    *               If 0, no kappagen will occur on cheer.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-499' or '2500-4999', or an open-maximum range such as '7500+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  badge      Settings related to users earning bits badges.
    *             This section is more "fluid" than other sections.
    *             Each entry is a number representing a bits badge and a kappa boolean value.
    *             For example:
    *   '1'        If TRUE, a kappagen will occur when a user gets their 1 bit badge.
    *              If FALSE, no kappagen will occur for 1 bit badges.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *             If a user earns a bits badge for a number not listed in the array, the system will find the number
    *             which is closest to the badge, favoring the lower number in case of a tie.
    *             For example:
    *   '100': false
    *   '5000': true
    *              If a user earns their 1000 bits badge, no kappagen will occur because 1000 is closer to 100
    *              than 5000.
    *              If a user earns their 10000 bits badge, a kappagen will occur because 5000 is the closest
    *              listed number.
    *             Note: The numbers must be strings (in 'single quotes') to function properly.
    *
    *  tip        Settings related to third-party tip systems.
    *
    *   useProfileImage  If TRUE, tips will use the tipper's profile image instead of emotes.
    *                   If FALSE, tips will use your standard kappagen emotes.
    *
    *   streamlabs  Settings related to Streamlabs payment events.
    *
    *    donation  Minimum tip amount through Streamlabs for a kappagen. This value can be a boolean, integer,
    *              or array:
    *              If TRUE, a kappagen will occur on all Streamlabs tips.
    *              If FALSE, no kappagen will occur on tips.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on tips through Streamlabs.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamlabs.curMul setting (see above)
    *              based on your default currency in Streamlabs.
    *
    *    pledge    Minimum pledge amount through Streamlabs for a kappagen. This value can be a boolean, integer,
    *              or array:
    *              If TRUE, a kappagen will occur on all Streamlabs pledges.
    *              If FALSE, no kappagen will occur on pledges.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on pledges through Streamlabs.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamlabs.curMul setting (see above)
    *              based on your default currency in Streamlabs.
    *
    *   streamelements  Minimum tip amount through StreamElements for a kappagen. This value can be a boolean,
    *                  integer, or array:
    *              If TRUE, a kappagen will occur on all StreamElements tips.
    *              If FALSE, no kappagen will occur on tips.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on tips through StreamElements.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamelements.curMul setting (see above)
    *              based on your default currency in StreamElements.
    *
    */

   var cfg = {
    channel: 'CHANNEL_NAME',
    login: {
     client: '4umzcpmjkg6ar78b81s7302jlj33t8',
     oauth: 'OAUTH_ID' //Requires chat:read; channel:read:redemptions
    },
    streamlabs: {
     token: 'SOCKET_TOKEN', //Requires socket.token
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    streamelements: {
     oauth: 'OAUTH_ID', //Requires tips:read
     token: 'JWT_TOKEN',
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    display: {
     styles: [
    //'Still',        // No movement
      'StraightLine', // Gentle movement in a random straight line
      'Rise',         // Slowly rise to top while wobbling back and forth
      'Bounce',       // Fall from the top at an angle and bounce along the bottom (Windows Solitaire style)
      'Speed',        // Zoom across the screen
      'Drop',         // Get stuck at the top and tumble down (no fade/zoom in, only out)
      'Crazy',        // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
      'Confetti',     // Fall like confetti                   (no zoom, no fade in, only fade out)
      'Throw',        // Toss at the middle and tumble down   (no fade/zoom in, only out)
      'TheCube',      // Rotate a 3D cube of an emote         (no zoom, only fade)
     ],
     access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x004 | 0x002 | 0x001,
     duplicates: true,
     useEmoji: true,
     extended: {
      useFFZ: true,
      useBTTV: true,
      use7TV: true,
      useZWE: true
     },
     kappa: {
      count: 150,
      styles: {
       'Rise': {},        // Slowly rise to top while wobbling back and forth
       'Speed': {},       // Zoom across the screen
       'Crazy': {},       // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
       'Burst': {},       // Expand from a center point
       'Fireworks': {},   // Burst out from a single emote (no fade/zoom; small emotes)
       'Spiral': {},      // Burst out from a single emote in a spiral (no fade/zoom; small emotes)
       'Pyramid': {},     // Build a pyramid        (no fade/zoom; specific-size emotes)
       'SmallPyramid': {},// Build a small pyramid  (no fade/zoom; small emotes)
       'Fountain': {},    // Spout from a fountain  (no fade/zoom)
       'Stampede': {},    // Stampede of emotes     (no fade/zoom)
       'Confetti': {},    // Fall like confetti     (no zoom, no fade in, only fade out; small emotes)
       'Conga': {},       // Start a conga line     (no fade/zoom)
       'TheCube': {       // Rotate a 3D cube of an emote (no zoom, only fade)
        size: 8/10,
        center: true,
        rotations: 5
       },
       'Text': {          // Show a message         (no fade/zoom; specific-size emotes)
        message: ['HYPE!'],
        time: 3
       },
      },
      access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x004 | 0x002,
      aliases: [      // !kappagen command aliases (must be lower-case)
       '!kappagen',
       '-kappagen'
      ],
      cooldown: 0,
      conga: {
       contagious: false,
       time: 5,
       avoidMiddle: false
      }
     }
    },
    emote: {
     time: 5,
     max: 0,
     queue: 0,
     size: {
      ratio: {
       normal: 1/12,
       small: 1/24
      },
      min: 16,
      max: 112,
      variation: false
     },
     cube: {
      rotations: 5
     },
     in: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     },
     out: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     }
    },
    event: {
     raid: {
      raiders: 2,
      originEmotes: false
     },
     follow: true,
     sub: {
      useMsg: true,
      t1: {
       first: false,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: false,
        resub: false,
        bomb: 5
       }
      },
      t2: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      t3: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      prime: {
       first: true,
       resub: true
      }
     },
     cheer: {
      useMsg: true,
      bits: 50
     },
     badge: {
      '1': false,
      '100': true
     },
     tip: {
      useProfileImage: false,
      streamlabs: {
       donation: false,
       pledge: false
      },
      streamelements: false
     }
    }
   };

   /* Additional Notes and Caveats
    * ============================
    *
    * Update Procedure
    * ----------------
    * 
    *  To update this emote wall, simply use the Wizard to import and download it.
    *   1) Visit the official page <https://realityripple.com/Tools/Twitch/EmoteWall/>.
    *   2) Under "Config Wizard", click "Authorize on Twitch".
    *   3) Import this HTML file by clicking Import.
    *   4) Make any changes you need to make on each page.
    *   5) At the end of your configuration, hit "Download".
    *  You will receive a new version of this HTML file with your previous settings.
    *
    *
    * Emojis
    * ------
    *
    *  Twitch filters out the ZWJ (Zero-Width Joiner) character which is used for merging many emojis.
    *  This system makes use of basic character detection to correctly parse many standard ZWJ-style emojis even without
    *  the ZWJ character, however more complicated sets such as the "family units" are not possible to correctly handle.
    *  The alternative character 0xE0002 used by some third-party Twitch chat projects will be correctly parsed as a
    *  ZWJ according to the rules laid out in the RFC:
    *   <https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f>
    *
    *
    * Emote Dimensions
    * ----------------
    *
    *  Emotes that are not square will be shrunk to fit while maintaining the original aspect ratio.
    *
    *
    * Following
    * ---------
    *
    *  Detecting followers on the current Twitch API is limited and relies on server-to-server events.
    *  The current system uses a kludge and may have issues in rare situations. The current system regularly grabs the
    *  most recent 100 followers and tries to find the previous request's latest follower, counting how many followers
    *  exist in the list before the last known follower. If the latest follower is removed from the list, or if more
    *  than 100 followers join between one check and another, the system will ignore the event and assign a new latest
    *  follower. Real support for follow events requires an API change:
    *   <https://twitch.uservoice.com/forums/310213/suggestions/41794465>
    *   <https://twitch.uservoice.com/forums/310213/suggestions/40423873>
    *
    *
    * Cheers
    * ------
    *
    *  The cheer style will be used for kappagens. If a user cheers 1000 bits in a single 1000 bit emote, then the
    *  kappagen will be made of the 1000-bit cheers. However, if the user cheers 1000 bits using multiple smaller cheer
    *  emotes, those emotes will be used for the kappagen instead.
    *
    *
    * Kappagen
    * --------
    *
    *  Each emote-splosion uses the number of emotes defined in the kappa count preference mentioned above, except
    *  Pyramid, which uses a constant number based on the pyramidDist array (below). If the trigger includes specific
    *  emotes (via kappagen, cheer, or resub message), the ratio of one emote to another will be maintained.
    *  If a user with kappa access posts "!kappagen PunchTrees PunchTrees SSSsss" then two thirds of the emotes in
    *  the emote-splosion will be "PunchTrees", and one third will be "SSSsss".
    *
    *
    * OBS
    * ---
    *
    *  This emote wall may do better if the browser source has a frame rate limit of 30 or 60.
    *  If you use your GPU while streaming, you may wish to disable Browser Source Hardware Acceleration.
    *  It may also work better using a smaller screen resolution (such as 720p on a 1080p screen) and then stretching
    *  the browser source to fit to the screen using the OBS Transform feature.
    *
    *
    * Inefficiencies
    * --------------
    *
    *  This emote wall uses normal <img> objects rather than a HTML Canvas. While this lowers efficiency, it also adds
    *  better GIF file support and allows easier user manipulation.
    *
    *  At present, the "zoom in" and "zoom out" feature uses a resource-heavy design. I had hoped the new CSS directive
    *  "scale: " would have helped, however it's useless without a "scale-origin" directive to accompany it.
    *
    *  The Bounce animation uses specific position-based drawing rather than actually being animated.
    *
    *  The Cube animation uses eight objects on screen for every image, making it a particularly resource-heavy drawing.
    * 
    *  If your computer has trouble with this emote wall, please try disabling these options.
    *
    */

   /* potentially alterable arrays */

   // distribution of emojis for Pyramid and SmallPyramid kappagen
   var pyramidDist = [1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1];

   // distribution of emojis for letters in message kappagens
   var alnumDist = {
    'A': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'a': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'B': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    'b': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'C': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0]
    ],
    'c': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'D': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'd': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'E': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'e': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'F': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'f': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    'G': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 1, 0, 0]
    ],
    'g': [
     [1, 0, 0, 1, 1, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'H': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'h': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0]
    ],
    'I': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'i': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'J': [
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'j': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0]
    ],
    'K': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'k': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
    ],
    'L': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'l': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'M': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'm': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'N': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'n': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'O': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'o': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'P': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    'p': [
     [1, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 1, 0, 0, 0, 0]
    ],
    'Q': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [1, 1, 0, 1, 1, 1, 1, 0, 0]
    ],
    'q': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'R': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 1, 0, 0]
    ],
    'r': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'S': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    's': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    'T': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    't': [
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0]
    ],
    'U': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'u': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'V': [
     [0, 0, 0, 0, 1, 1, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 1, 1, 0]
    ],
    'v': [
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0]
    ],
    'W': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'w': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 0, 0, 0]
    ],
    'X': [
     [0, 1, 1, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 0, 1, 1, 0]
    ],
    'x': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'Y': [
     [0, 0, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    'y': [
     [1, 0, 0, 1, 1, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'Z': [
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0]
    ],
    'z': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '1': [
     [0, 1, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '2': [
     [0, 1, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '3': [
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '4': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0]
    ],
    '5': [
     [0, 0, 1, 0, 0, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 0, 1, 0]
    ],
    '6': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0]
    ],
    '7': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    '8': [
     [0, 0, 1, 1, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '9': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 1, 1, 0, 0]
    ],
    '0': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    ':': [
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    '.': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    ',': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '\'': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 1]
    ],
    '-': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '_': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '+': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '=': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0]
    ],
    '!': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    '@': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 1, 1, 0, 0]
    ],
    '#': [
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    '$': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [1, 1, 1, 1, 1, 1, 1, 1, 1],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    '\u00a2': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '\u20ac': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    '\u00a3': [
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '\u00a5': [
     [0, 0, 0, 0, 1, 0, 1, 1, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 1, 0]
    ],
    '%': [
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0]
    ],
    '?': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ]
   };

   // treat these BTTV emotes as zero-width (overlapping) emotes
   var bttvZWE = [
    'SoSnowy',  'IceCold',   'SantaHat', 'TopHat',
    'ReinDeer', 'CandyCane', 'cvMask',   'cvHazmat',
   ];

   // list of default images to use if your channel has no emotes
   var bareList = [
    {url: 'https://cdn.frankerfacez.com/emoticon/675080/4'}
   ];
   //////////////////////////////////////////////////////////////////////////////
   // don't mess with things below this line without knowing what you're doing //
   //////////////////////////////////////////////////////////////////////////////
  </script>
  <title>Emote Wall</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
   :root
   {
    --height: 0px;
    --width: 0px;
    --emote-height: 0px;
    --emote-height-s: 0px;
    --emote-height-l: 0px;
   }
   body
   {
    margin: 0;
    overflow: hidden;
   }
   img
   {
    object-fit: contain;
    object-position: 50% 50%;
   }
   img.emote
   {
    position: fixed;
    height: 100%;
    border: 0;
    margin: 0;
    padding: 0;
    offset-rotate: 0deg;
   }

   div.scene
   {
    position: fixed;
    border: 0;
    margin: 0;
    padding: 0;
   }
   div.scene div.cube
   {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
   }
   div.scene div.cube .cubeFace
   {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.2);
   }

   div.scene img.dancer
   {
    text-align: center;
    position: relative;
    animation: dance 4s linear infinite;
   }

   @keyframes dance
   {
    0%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    6%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    13%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    19%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    25%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    31%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    38%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    44%
    {
     transform: translate(20%, 10%) rotate(-30deg);
    }
    50%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    56%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    63%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    69%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    75%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    81%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    88%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    94%
    {
     transform: translate(80%, 10%) rotate(30deg);
    }
    100%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
   }

   @keyframes wiggleL
   {
    33%
    {
     transform: translateX(-50%);
    }
    66%
    {
     transform: translateX(50%);
    }
   }
   @keyframes wiggleR
   {
    33%
    {
     transform: translateX(50%);
    }
    66%
    {
     transform: translateX(-50%);
    }
   }

   @keyframes speedL
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(-1 * var(--width) * 4), 0);
    }
   }
   @keyframes speedR
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(var(--width) * 4), 0);
    }
   }

   @keyframes dropL
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(350deg);
    }
   }
   @keyframes dropR
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(-35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(-350deg);
    }
   }

   @keyframes confettiA
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0.5, 0, -4500deg);
    }
   }

   @keyframes confettiB
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0, 0, -4500deg);
    }
   }

   @keyframes confettiC
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, -0.5, 0, -4500deg);
    }
   }

   @keyframes offsetPath
   {
    0%
    {
     offset-distance: 0%;
    }
    100%
    {
     offset-distance: 100%;
    }
   }

   @keyframes fadeIn
   {
    0%
    {
     opacity: 0;
    }
    100% /* 8% */
    {
     opacity: 1;
    }
   }

   @keyframes fadeOut
   {
    0% /* 95% */
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes noFadeOut
   {
    99%
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes zoomIn
   {
    0%
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.1)) / 2);
     max-height: calc(var(--emote-height) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 1.2)) / 2);
     max-height: calc(var(--emote-height) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.8)) / 2);
     max-height: calc(var(--emote-height) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.95)) / 2);
     max-height: calc(var(--emote-height) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
   }

   @keyframes zoomOut
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    100%
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.1)) / 2);
     max-height: calc(var(--emote-height) * 0.1);
    }
   }

   @keyframes zoomInS
   {
    0%
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.1)) / 2);
     max-height: calc(var(--emote-height-s) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 1.2)) / 2);
     max-height: calc(var(--emote-height-s) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.8)) / 2);
     max-height: calc(var(--emote-height-s) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.95)) / 2);
     max-height: calc(var(--emote-height-s) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
   }

   @keyframes zoomOutS
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    100%
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.1)) / 2);
     max-height: calc(var(--emote-height-s) * 0.1);
    }
   }

   @keyframes zoomInL
   {
    0%
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.1)) / 2);
     max-height: calc(var(--emote-height-l) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 1.2)) / 2);
     max-height: calc(var(--emote-height-l) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.8)) / 2);
     max-height: calc(var(--emote-height-l) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.95)) / 2);
     max-height: calc(var(--emote-height-l) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
   }

   @keyframes zoomOutL
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    100%
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.1)) / 2);
     max-height: calc(var(--emote-height-l) * 0.1);
    }
   }

   button
   {
    background-color: #7D5BBE;
    transition: background 0.12s ease-in, color 0.12s ease-in;
    white-space: nowrap;
    cursor: pointer;
    color: #FFFFFF;
    border-radius: 4px;
    border: none;
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
   }
   button:focus, button:hover
   {
    background-color: #772CE8;
   }
   button:focus
   {
    outline: none;
   }
   button:active
   {
    background-color: #5C16C5;
   }
  </style>
  <script>
   if (typeof cfg === 'undefined')
    throw new Error('Corrupted Configuration detected.');
   document.title = cfg.channel + ' Emote Wall';
   /* global variables */
   var channelID = 0;
   var dead = false;   // hard disconnect (usually caused by an error)
   var useL = false;   // interactive login in use
   var toShow = [];    // emote queue
   var toKappa = [];   // kappagen queue
   var toGC = {};      // list of image elements to garbage collect
   var eList = {};     // pre-listed emotes, sub-grouped into: cheer, ffz, 7tv, bttv, and bttvU (user-specific BTTV)
   var cList = [];     // list of channel-specific emotes, used for kappagens
   var fList = {};     // cache of users in chat and their follow status
   var bList = [];     // list of giftbomb event origin ids (to prevent kappas for each gift in a bomb)
   var rList = {};     // list of triggered channel point redeems to match to PubSub events
   var uList = {};     // checkURL Cache
   var conga = [];     // CONGA TIME!
   var kLast = 0;      // last kappagen command event (for cooldown)
   var eActive = 0;    // active emote count (effective, not actual)
   var tStart = 48;    // time to wait for transition trigger (ms)
   var uLF = false;    // user id of the most recent follower
   var rFC = 2500;     // follower count interval (ms)
   var rFH = 3600000;  // follower state cache time (ms)
   var rTE = 60000;    // third-party channel emote recheck interval (ms)
   var rBE = 600000;   // bttv post-event emote recheck (ms)
   var wWS = 5;        // websocket retry backoff base (ms = base ^ (1.0 + (0.2 per retry, max 1.0)))
   var tAnim = {       // animation timing constants
    fade: {
     in: 8,            // percentage of animation spent on fading in (8% of 5 seconds)
     out: 8            // percentage of animation spent on fading out
    },
    zoom: {
     in: 17,           // percentage of animation spent on zooming in (17% of 5 seconds)
     out: 8            // percentage of animation spent on zooming out
    }
   };
   /* Timers */
   var tIRC = false;   // irc connection timeout
   var tEmote = false; // emote queue timer
   var tKappa = false; // kappagen queue timer
   var tGC = false;    // garbage collection
   var tFC = false;    // follower kludge
   var tTE = false;    // third-party channel emote kludge
   var tBE = false;    // third-party channel emote kludge
   var tL = false;     // logout button display

   function sleep(ms)
   {
    return new Promise(resolve => setTimeout(resolve, ms));
   }

   function rnd(m)
   {
    let r = new Uint32Array(1);
    window.crypto.getRandomValues(r);
    let f = r[0] / 4294967295;
    if (m === undefined)
     return f;
    if (m < 1)
     return f * m;
    return Math.floor(f * m);
   }

   function checkURL(url)
   {
    let p = new Promise(
     async function(resolve, reject)
     {
      if (uList.hasOwnProperty(url))
      {
       resolve(uList[url]);
       return;
      }
      let x = new XMLHttpRequest();
      x.open('HEAD', url);
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       x.onreadystatechange = null;
       if (x.status === 200)
       {
        uList[url] = true;
        resolve(true);
       }
       else
       {
        uList[url] = false;
        resolve(false);
       }
      };
      x.send();
     }
    );
    return p;
   }

   function jSplit(s, sep, limit)
   {
    let arr = [];
    let v = '';
    for (let i = 0, l = s.length; i < l; i++)
    {
     if (arr.length < limit - 1)
     {
      if (s[i] === sep)
      {
       arr.push(v);
       v = '';
       continue;
      }
     }
     v += s[i];
    }
    if (v.length > 0)
     arr.push(v);
    return arr;
   }

   function findInMaybeRange(r, v)
   {
    let t = typeof r;
    switch (t)
    {
     case 'undefined':
      return false;
     case 'boolean':
      return (r === true);
     case 'number':
      if (r > 0 && v >= r)
       return true;
      return false;
     case 'object':
      if (r === null)
       return false;
      for (const k in r)
      {
       if (!r.hasOwnProperty(k))
        continue;
       let lower = 0;
       let upper = 0;
       if (k.slice(-1) === '+')
       {
        lower = parseInt(k.slice(0, -1), 10);
        upper = Number.MAX_SAFE_INTEGER;
       }
       else if (k.indexOf('-') !== -1)
       {
        lower = parseInt(k.slice(0, k.indexOf('-')), 10);
        upper = parseInt(k.slice(k.indexOf('-') + 1), 10);
       }
       else
       {
        lower = parseInt(k, 10);
        upper = parseInt(k, 10);
       }
       if (v >= lower && v <= upper)
        return r[k];
      }
    }
    return false;
   }

   function parseMsg(line)
   {
    let cmd = {};
    if (line.slice(0, 1) === '@')
    {
     line = line.slice(1);
     if (!line.includes(' '))
      return false;
     cmd.tags = {};
     let t = line.slice(0, line.indexOf(' '));
     line = line.slice(line.indexOf(' ') + 1);
     let a = t.split(';');
     for (let i = 0, l = a.length; i < l; i++)
     {
      let k = a[i].slice(0, a[i].indexOf('='));
      let v = a[i].slice(a[i].indexOf('=') + 1);
      v = v.replace(/\\s/g, ' ');
      cmd.tags[k] = v;
     }
    }
    if (line.slice(0, 1) === ':')
    {
     line = line.slice(1);
     if (!line.includes(' '))
      return false;
     cmd.prefix = line.slice(0, line.indexOf(' '));
     line = line.slice(line.indexOf(' ') + 1);
    }
    if (!line.includes(' '))
    {
     cmd.command = line;
     return cmd;
    }
    cmd.command = line.slice(0, line.indexOf(' '));
    line = line.slice(line.indexOf(' ') + 1);
    cmd.params = [];
    if (!line.includes(' '))
    {
     cmd.params.push(line);
     return cmd;
    }
    while (line.includes(' '))
    {
     if (line.slice(0, 1) === ':')
     {
      cmd.params.push(line.slice(1));
      return cmd;
     }
     cmd.params.push(line.slice(0, line.indexOf(' ')));
     line = line.slice(line.indexOf(' ') + 1);
    }
    if (line.slice(0, 1) === ':')
     line = line.slice(1);
    cmd.params.push(line);
    return cmd;
   }

   function parseUser(cmd, latinOnly = false)
   {
    let data = cmd.prefix;
    let ret = {};
    if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('display-name'))
     ret['display-name'] = cmd.tags['display-name'];
    if (data.includes('!'))
    {
     ret.nick = data.slice(0, data.indexOf('!'));
     data = data.slice(data.indexOf('!') + 1);
     if (!ret.hasOwnProperty('display-name') || (latinOnly && ret['display-name'] !== ret['display-name'].replaceAll(/[^A-Za-z0-9_]/g, '')))
      ret['display-name'] = ret.nick;
    }
    if (data.includes('@'))
    {
     ret.host = data.slice(0, data.indexOf('@'));
     data = data.slice(data.indexOf('@') + 1);
     if (!ret.hasOwnProperty('display-name') || (latinOnly && ret['display-name'] !== ret['display-name'].replaceAll(/[^A-Za-z0-9_]/g, '')))
      ret['display-name'] = ret.host;
    }
    ret.user = data;
    return ret;
   }

   function getUserInfo(u)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.twitch.tv/helix/users?login=' + u + '&nocache=' + rnd(0xFFFFFFFF));
      x.setRequestHeader('Authorization', 'Bearer ' + cfg.login.oauth);
      x.setRequestHeader('Client-Id', cfg.login.client);
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        if (x.status === 401)
         blargIAmDead(3);
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('data'))
       {
        resolve(false);
        return;
       }
       if (j.data.length !== 1)
       {
        console.log('returned ', j.data.length, ' entries: ', j.data);
        resolve(false);
        return;
       }
       resolve(j.data[0]);
      };
      x.send();
     }
    );
    return p;
   }

   function findEmote_channel(chID)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.twitch.tv/helix/chat/emotes?broadcaster_id=' + chID + '&nocache=' + rnd(0xFFFFFFFF));
      x.setRequestHeader('Authorization', 'Bearer ' + cfg.login.oauth);
      x.setRequestHeader('Client-Id', cfg.login.client);
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        if (x.status === 401)
         blargIAmDead(3);
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('data'))
       {
        resolve(false);
        return;
       }
       let ret = [];
       let f = 'default';
       let t = 'dark';
       let r = '3.0';
       for (let i = 0, l = j.data.length; i < l; i++)
        ret.push({url: 'https://static-cdn.jtvnw.net/emoticons/v2/' + j.data[i].id + '/' + f + '/' + t + '/' + r});
       resolve(ret);
      };
      x.send();
     }
    );
    return p;
   }

   async function loadEmote_channel(chID)
   {
    cList = [];
    let r = await findEmote_channel(chID);
    if (r === false)
     return false;
    cList = r;
    return true;
   }

   function addEmote(list, scope, code, id, url, users = null, zwe = false)
   {
    list[code] = {scope: scope, url: url, id: id, users: users};
    if (scope === 'c' && !zwe)
     cList.push({url: url});
   }

   function removeEmote(list, scope, code)
   {
    if (!list.hasOwnProperty(code))
     return;
    if (list[code].scope !== scope)
     return;
    if (scope === 'c')
    {
     for (let c = cList.length - 1; c >= 0; c--)
     {
      if (cList[c].url !== list[code].url)
       continue;
      cList.splice(c, 1);
      break;
     }
    }
    delete list[code];
   }

   function removeEmoteByID(list, scope, id)
   {
    for (let i = Object.keys(list).length - 1; i >= 0; i--)
    {
     let k = Object.keys(list)[i];
     if (list[k].scope !== scope)
      continue;
     if (list[k].id !== id)
      continue;
     removeEmote(list, scope, k);
     break;
    }
   }

   function removeEmoteByScope(list, scope)
   {
    for (let i = Object.keys(list).length - 1; i >= 0; i--)
    {
     let k = Object.keys(list)[i];
     if (list[k].scope !== scope)
      continue;
     removeEmote(list, scope, k);
    }
   }

   function loadCheer_channel(chID)
   {
    eList.cheer = {};
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.twitch.tv/helix/bits/cheermotes?broadcaster_id=' + chID + '&nocache=' + rnd(0xFFFFFFFF));
      x.setRequestHeader('Authorization', 'Bearer ' + cfg.login.oauth);
      x.setRequestHeader('Client-Id', cfg.login.client);
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        if (x.status === 401)
         blargIAmDead(3);
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('data'))
       {
        resolve(false);
        return;
       }
       for (let c = 0, l = j.data.length; c < l; c++)
       {
        let set = j.data[c];
        if (!set.hasOwnProperty('prefix'))
         continue;
        if (!set.hasOwnProperty('tiers'))
         continue;
        let prefix = set.prefix;
        let tierList = [];
        for (let i = set.tiers.length - 1; i >= 0; i--)
        {
         if (!set.tiers[i].hasOwnProperty('min_bits'))
          continue;
         if (!set.tiers[i].hasOwnProperty('images'))
          continue;
         let amt = set.tiers[i].min_bits;
         let img = null;
         if (set.tiers[i].images.hasOwnProperty('dark'))
         {
          if (set.tiers[i].images.dark.hasOwnProperty('animated'))
          {
           if (set.tiers[i].images.dark.animated.hasOwnProperty('4'))
            img = set.tiers[i].images.dark.animated['4'];
           else if (set.tiers[i].images.dark.animated.hasOwnProperty('3'))
            img = set.tiers[i].images.dark.animated['3'];
           else if (set.tiers[i].images.dark.animated.hasOwnProperty('2'))
            img = set.tiers[i].images.dark.animated['2'];
           else if (set.tiers[i].images.dark.animated.hasOwnProperty('1.5'))
            img = set.tiers[i].images.dark.animated['1.5'];
           else if (set.tiers[i].images.dark.animated.hasOwnProperty('1'))
            img = set.tiers[i].images.dark.animated['1'];
          }
          else if (set.tiers[i].images.dark.hasOwnProperty('static'))
          {
           if (set.tiers[i].images.dark.static.hasOwnProperty('4'))
            img = set.tiers[i].images.dark.static['4'];
           else if (set.tiers[i].images.dark.static.hasOwnProperty('3'))
            img = set.tiers[i].images.dark.static['3'];
           else if (set.tiers[i].images.dark.static.hasOwnProperty('2'))
            img = set.tiers[i].images.dark.static['2'];
           else if (set.tiers[i].images.dark.static.hasOwnProperty('1.5'))
            img = set.tiers[i].images.dark.static['1.5'];
           else if (set.tiers[i].images.dark.static.hasOwnProperty('1'))
            img = set.tiers[i].images.dark.static['1'];
          }
         }
         else if (set.tiers[i].images.hasOwnProperty('light'))
         {
          if (set.tiers[i].images.light.hasOwnProperty('animated'))
          {
           if (set.tiers[i].images.light.animated.hasOwnProperty('4'))
            img = set.tiers[i].images.light.animated['4'];
           else if (set.tiers[i].images.light.animated.hasOwnProperty('3'))
            img = set.tiers[i].images.light.animated['3'];
           else if (set.tiers[i].images.light.animated.hasOwnProperty('2'))
            img = set.tiers[i].images.light.animated['2'];
           else if (set.tiers[i].images.light.animated.hasOwnProperty('1.5'))
            img = set.tiers[i].images.light.animated['1.5'];
           else if (set.tiers[i].images.light.animated.hasOwnProperty('1'))
            img = set.tiers[i].images.light.animated['1'];
          }
          else if (set.tiers[i].images.light.hasOwnProperty('static'))
          {
           if (set.tiers[i].images.light.static.hasOwnProperty('4'))
            img = set.tiers[i].images.light.static['4'];
           else if (set.tiers[i].images.light.static.hasOwnProperty('3'))
            img = set.tiers[i].images.light.static['3'];
           else if (set.tiers[i].images.light.static.hasOwnProperty('2'))
            img = set.tiers[i].images.light.static['2'];
           else if (set.tiers[i].images.light.static.hasOwnProperty('1.5'))
            img = set.tiers[i].images.light.static['1.5'];
           else if (set.tiers[i].images.light.static.hasOwnProperty('1'))
            img = set.tiers[i].images.light.static['1'];
          }
         }
         if (img === null)
          continue;
         tierList.push({min: amt, img: img});
        }
        eList.cheer[prefix] = tierList;
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function load3rdParty(chID)
   {
    if (tTE === false)
     return;
    window.clearTimeout(tTE);
    tTE = false;
    if (cfg.display.extended.useFFZ)
     loadFFZ_channel(channelID);
    if (cfg.display.extended.use7TV)
     load7TV_channel(channelID);
    tTE = window.setTimeout(load3rdParty, rTE, chID);
   }

   function loadBTTV(chID)
   {
    if (tBE === false)
     return;
    window.clearTimeout(tBE);
    tBE = false;
    if (cfg.display.extended.useBTTV)
     loadBTTV_channel(channelID);
    tBE = window.setTimeout(loadBTTV, rTE, chID);
   }

   function readFFZ_URL(entry)
   {
    if (!entry.hasOwnProperty('urls'))
     return false;
    if (entry.urls.hasOwnProperty('4'))
    {
     let u4 = entry.urls[4];
     if (u4.slice(0, 2) === '//')
      u4 = 'https:' + u4;
     return u4;
    }
    if (entry.urls.hasOwnProperty('2'))
    {
     let u2 = entry.urls[2];
     if (u2.slice(0, 2) === '//')
      u2 = 'https:' + u2;
     let u24 = u2;
     if (u24.slice(-2) === '/2')
      u24 = u24.slice(0, -1) + '4';
     return u24;
    }
    if (entry.urls.hasOwnProperty('1'))
    {
     let u1 = entry.urls[1];
     if (u1.slice(0, 2) === '//')
      u1 = 'https:' + u1;
     let u14 = u1;
     if (u14.slice(-2) === '/1')
      u14 = u14.slice(0, -1) + '4';
     return u14;
    }
    return false;
   }

   function loadFFZ_global()
   {
    eList.ffz = {};
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.frankerfacez.com/v1/set/global?nocache=' + rnd(0xFFFFFFFF));
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('sets'))
       {
        resolve(false);
        return;
       }
       let usedSets = [];
       if (j.hasOwnProperty('default_sets'))
       {
        for (let i = 0, l = j.default_sets.length; i < l; i++)
         usedSets.push(j.default_sets[i]);
       }
       for (const set in j.sets)
       {
        if (!j.sets.hasOwnProperty(set))
         continue;
        if (!usedSets.includes(j.sets[set].id))
         continue;
        if (!j.sets[set].hasOwnProperty('emoticons'))
         continue;
        for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
        {
         if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
          continue;
         let u = readFFZ_URL(j.sets[set].emoticons[i]);
         if (u === false)
          continue;
         addEmote(eList.ffz, 'g', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u);
        }
       }
       //user-specific, from here on everything resolve()s true
       if (!j.hasOwnProperty('users'))
       {
        resolve(true);
        return;
       }
       for (const setID in j.users)
       {
        if (!j.users.hasOwnProperty(setID))
         continue;
        let aList = j.users[setID];
        if (!Array.isArray(aList))
         continue;
        for (const set in j.sets)
        {
         if (!j.sets.hasOwnProperty(set))
          continue;
         if (setID !== set)
          continue;
         if (!j.sets[set].hasOwnProperty('emoticons'))
          continue;
         for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
         {
          if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
           continue;
          let u = readFFZ_URL(j.sets[set].emoticons[i]);
          if (u === false)
           continue;
          addEmote(eList.ffz, 'g', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, aList);
         }
        }
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function loadFFZ_channel(chID)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.frankerfacez.com/v1/room/id/' + chID + '?nocache=' + rnd(0xFFFFFFFF));
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('sets'))
       {
        resolve(false);
        return;
       }
       removeEmoteByScope(eList.ffz, 'c');
       for (const set in j.sets)
       {
        if (!j.sets[set].hasOwnProperty('emoticons'))
         continue;
        for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
        {
         if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
          continue;
         let u = readFFZ_URL(j.sets[set].emoticons[i]);
         if (u === false)
          continue;
         addEmote(eList.ffz, 'c', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u);
        }
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function loadBTTV_global()
   {
    eList.bttv = {};
    if (!eList.hasOwnProperty('zwe'))
     eList.zwe = {};
    eList.zwe.bttv = {};
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.betterttv.net/3/cached/emotes/global?nocache=' + rnd(0xFFFFFFFF));
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       let j = JSON.parse(x.responseText);
       if (!Array.isArray(j))
       {
        resolve(false);
        return;
       }
       for (let i = 0, l = j.length; i < l; i++)
       {
        if (!j[i].hasOwnProperty('code'))
         continue;
        if (!j[i].hasOwnProperty('id'))
         continue;
        if (bttvZWE.includes(j[i].code))
        {
         if (cfg.display.extended.useZWE)
          addEmote(eList.zwe.bttv, 'g', j[i].code, j[i].id, 'https://cdn.betterttv.net/emote/' + j[i].id + '/3x', null, true);
         continue;
        }
        addEmote(eList.bttv, 'g', j[i].code, j[i].id, 'https://cdn.betterttv.net/emote/' + j[i].id + '/3x');
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function loadBTTV_channel(chID)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.betterttv.net/3/cached/users/twitch/' + chID + '?nocache=' + rnd(0xFFFFFFFF));
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       removeEmoteByScope(eList.bttv, 'c');
       let j = JSON.parse(x.responseText);
       if (j.hasOwnProperty('channelEmotes'))
       {
        for (let i = 0, l = j.channelEmotes.length; i < l; i++)
        {
         if (!j.channelEmotes[i].hasOwnProperty('code'))
          continue;
         if (!j.channelEmotes[i].hasOwnProperty('id'))
          continue;
         addEmote(eList.bttv, 'c', j.channelEmotes[i].code, j.channelEmotes[i].id, 'https://cdn.betterttv.net/emote/' + j.channelEmotes[i].id + '/3x');
        }
       }
       if (j.hasOwnProperty('sharedEmotes'))
       {
        for (let i = 0, l = j.sharedEmotes.length; i < l; i++)
        {
         if (!j.sharedEmotes[i].hasOwnProperty('code'))
          continue;
         if (!j.sharedEmotes[i].hasOwnProperty('id'))
          continue;
         addEmote(eList.bttv, 'c', j.sharedEmotes[i].code, j.sharedEmotes[i].id, 'https://cdn.betterttv.net/emote/' + j.sharedEmotes[i].id + '/3x');
        }
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function loadBTTV_ws_channel(chID)
   {
    let wsRetry = 0;
    const ws = new WebSocket('wss://sockets.betterttv.net/ws');
    ws.onopen = function(event)
    {
     ws.onopen = null;
     ws.send('{"name":"join_channel","data":{"name":"twitch:' + chID + '"}}');
     ws.send('{"name":"broadcast_me","data":{"name":"' + cfg.channel + '","channel":"twitch:' + chID + '"}}');
    };
    ws.onclose = function()
    {
     ws.onopen = null;
     ws.onmessage = null;
     ws.onclose = null;
     if (dead)
      return;
     let wsWait = Math.floor((wWS ** (1 + wsRetry)) * 1000);
     if (wsRetry < 2)
      wsRetry += 0.2;
     window.setTimeout(function(){loadBTTV_ws_channel(chID);}, wsWait);
    };
    ws.onmessage = function(event)
    {
     if (dead)
     {
      ws.close();
      return;
     }
     wsRetry = 0;
     let d = JSON.parse(event.data);
     if (!d.hasOwnProperty('name'))
      return;
     if (!d.hasOwnProperty('data'))
      return;
     switch (d.name)
     {
      case 'lookup_user':
       if (!d.data.hasOwnProperty('name'))
        return;
       if (!d.data.hasOwnProperty('emotes') || !Array.isArray(d.data.emotes) || d.data.emotes.length < 1)
        return;
       if (!eList.hasOwnProperty('bttvU'))
        eList.bttvU = {};
       eList.bttvU[d.data.name] = {};
       for (let i = 0, l = d.data.emotes.length; i < l; i++)
       {
        if (!d.data.emotes[i].hasOwnProperty('code'))
         continue;
        if (!d.data.emotes[i].hasOwnProperty('id'))
         continue;
        addEmote(eList.bttvU[d.data.name], 'u', d.data.emotes[i].code, d.data.emotes[i].id, 'https://cdn.betterttv.net/emote/' + d.data.emotes[i].id + '/3x');
       }
       break;
      case 'emote_create':
       if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + chID)
        return;
       if (!d.data.hasOwnProperty('emote'))
        return;
       if (!d.data.emote.hasOwnProperty('id'))
        return;
       if (!d.data.emote.hasOwnProperty('code'))
        return;
       if (tBE !== false)
        window.clearTimeout(tBE);
       addEmote(eList.bttv, 'c', d.data.emote.code, d.data.emote.id, 'https://cdn.betterttv.net/emote/' + d.data.emote.id + '/3x');
       tBE = window.setTimeout(loadBTTV, rBE, chID);
       break;
      case 'emote_delete':
       if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + chID)
        return;
       if (!d.data.hasOwnProperty('emoteId'))
        return;
       if (tBE !== false)
        window.clearTimeout(tBE);
       removeEmoteByID(eList.bttv, 'c', d.data.emoteId);
       tBE = window.setTimeout(loadBTTV, rBE, chID);
       break;
      case 'emote_update':
       if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + chID)
        return;
       if (!d.data.hasOwnProperty('emote'))
        return;
       if (!d.data.emote.hasOwnProperty('id'))
        return;
       if (!d.data.emote.hasOwnProperty('code'))
        return;
       if (tBE !== false)
        window.clearTimeout(tBE);
       removeEmoteByID(eList.bttv, 'c', d.data.emote.id);
       addEmote(eList.bttv, 'c', d.data.emote.code, d.data.emote.id, 'https://cdn.betterttv.net/emote/' + d.data.emote.id + '/3x');
       tBE = window.setTimeout(loadBTTV, rBE, chID);
       break;
     }
    };
   }

   function load7TV_global()
   {
    eList['7tv'] = {};
    if (!eList.hasOwnProperty('zwe'))
     eList.zwe = {};
    if (!eList.zwe.hasOwnProperty('7tv'))
     eList.zwe['7tv'] = {};
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.7tv.app/v2/emotes/global?nocache=' + rnd(0xFFFFFFFF));
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       let j = JSON.parse(x.responseText);
       if (!Array.isArray(j))
       {
        resolve(false);
        return;
       }
       for (let i = 0, l = j.length; i < l; i++)
       {
        if (!j[i].hasOwnProperty('name'))
         continue;
        if (!j[i].hasOwnProperty('urls'))
         continue;
        let t4 = null;
        for (let u = 0, m = j[i].urls.length; u < m; u++)
        {
         if (j[i].urls[u][0] === '1')
         {
          let t1 = j[i].urls[u][1];
          if (t1.slice(-3) === '/1x')
          {
           if (t4 === null)
            t4 = t1.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '2')
         {
          let t2 = j[i].urls[u][1];
          if (t2.slice(-3) === '/2x')
          {
           if (t4 === null)
            t4 = t2.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '3')
         {
          let t3 = j[i].urls[u][1];
          if (t3.slice(-3) === '/3x')
          {
           if (t4 === null)
            t4 = t3.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '4')
          t4 = j[i].urls[u][1];
        }
        if (j[i].hasOwnProperty('visibility') && (j[i].visibility & 0x80) === 0x80) //Zero-Width
        {
         if (cfg.display.extended.useZWE)
          addEmote(eList.zwe['7tv'], 'g', j[i].name, j[i].id, t4, null, true);
         continue;
        }
        addEmote(eList['7tv'], 'g', j[i].name, j[i].id, t4);
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function load7TV_channel(chID)
   {
    if (!eList.hasOwnProperty('zwe'))
     eList.zwe = {};
    if (!eList.zwe.hasOwnProperty('7tv'))
     eList.zwe['7tv'] = {};
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.7tv.app/v2/users/' + chID + '/emotes?nocache=' + rnd(0xFFFFFFFF));
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       if (cfg.display.extended.useZWE)
        removeEmoteByScope(eList.zwe['7tv'], 'c');
       removeEmoteByScope(eList['7tv'], 'c');
       let j = JSON.parse(x.responseText);
       if (!Array.isArray(j))
       {
        resolve(false);
        return;
       }
       for (let i = 0, l = j.length; i < l; i++)
       {
        if (!j[i].hasOwnProperty('name'))
         continue;
        if (!j[i].hasOwnProperty('urls'))
         continue;
        let t4 = null;
        for (let u = 0, m = j[i].urls.length; u < m; u++)
        {
         if (j[i].urls[u][0] === '1')
         {
          let t1 = j[i].urls[u][1];
          if (t1.slice(-3) === '/1x')
          {
           if (t4 === null)
            t4 = t1.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '2')
         {
          let t2 = j[i].urls[u][1];
          if (t2.slice(-3) === '/2x')
          {
           if (t4 === null)
            t4 = t2.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '3')
         {
          let t3 = j[i].urls[u][1];
          if (t3.slice(-3) === '/3x')
          {
           if (t4 === null)
            t4 = t3.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '4')
          t4 = j[i].urls[u][1];
        }
        if (j[i].hasOwnProperty('visibility') && (j[i].visibility & 0x80) === 0x80) //Zero-Width
        {
         if (cfg.display.extended.useZWE)
          addEmote(eList.zwe['7tv'], 'c', j[i].name, j[i].id, t4, null, true);
         continue;
        }
        addEmote(eList['7tv'], 'c', j[i].name, j[i].id, t4);
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function load7TV_channelID(chID)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.7tv.app/v2/users/' + chID + '?nocache=' + rnd(0xFFFFFFFF));
      x.onreadystatechange = function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       let j = JSON.parse(x.responseText);
       if (j.hasOwnProperty('id'))
        resolve(j.id);
       else
        resolve(false);
      };
      x.send();
     }
    );
    return p;
   }

   async function load7TV_ws_channel(chID)
   {
    let wsRetry = 0;
    let accID = await load7TV_channelID(chID);
    if (accID === false)
     return;
    const ws = new WebSocket('wss://events.7tv.io/v3');
    ws.onclose = function()
    {
     ws.onmessage = null;
     ws.onclose = null;
     if (dead)
      return;
     let wsWait = Math.floor((wWS ** (1 + wsRetry)) * 1000);
     if (wsRetry < 2)
      wsRetry += 0.2;
     window.setTimeout(function(){load7TV_ws_channel(chID);}, wsWait);
    };
    ws.onmessage = function(event)
    {
     if (dead)
     {
      ws.close();
      return;
     }
     wsRetry = 0;
     let d = JSON.parse(event.data);
     switch(d.op)
     {
      case 0:
       if (tTE !== false)
        window.clearTimeout(tTE);
       tTE = window.setTimeout(load3rdParty, 500, chID);
       break;
      case 1:
       ws.send(JSON.stringify({"op": 35, "d": {"type":"user.*", "condition": {"object_id": accID}}}));
       ws.send(JSON.stringify({"op": 35, "d": {"type":"emote.*", "condition": {"object_id": accID}}}));
       ws.send(JSON.stringify({"op": 35, "d": {"type":"emote_set.*", "condition": {"object_id": accID}}}));
       break;
      case 2:
       break;
     }
    };
   }

   function doGC()
   {
    if (tGC === false)
     return;
    window.clearTimeout(tGC);
    tGC = false;
    let done = true;
    for (const idx in toGC)
    {
     if (!toGC.hasOwnProperty(idx))
      continue;
     done = false;
     let i = toGC[idx].img;
     let t = toGC[idx].end;
     let d = toGC[idx].dec;
     if (toGC[idx].space)
     {
      let r = i.getBoundingClientRect();
      if ((r.bottom > 0 && r.right > 0 && r.top < window.innerHeight && r.left < window.innerWidth) && t > new Date().getTime())
       continue;
     }
     else
     {
      if (t > new Date().getTime())
       continue;
     }
     delete toGC[idx];
     if (d !== false)
      window.clearTimeout(t);
     document.body.removeChild(i);
     if (d)
      eActive--;
    }
    if (!done)
     tGC = window.setTimeout(doGC, 500);
   }

   function gcEmote(img, space = true, decActive = true, t = false)
   {
    if (t === false)
     t = cfg.emote.time * 1000;
    let x = 0;
    do
    {
     x++;
    } while(toGC.hasOwnProperty(x));
    toGC[x] = {img: img, space: space, dec: decActive, end: new Date().getTime() + t};
    if (tGC === false)
     tGC = window.setTimeout(doGC, 500);
   }

   function styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters)
   {
    let s = '';
    if (aNames.length > 0)
    {
     s += ' animation-name: ' + aNames.join() + ';';
     s += ' animation-delay: ' + aDelays.join() + ';';
     s += ' animation-duration: ' + aDurs.join() + ';';
     s += ' animation-timing-function: ' + aTimings.join() + ';';
     s += ' animation-fill-mode: ' + aFills.join() + ';';
     s += ' animation-iteration-count: ' + aIters.join() + ';';
    }
    return s;
   }

   function styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, fadeIn = true, zoomIn = true, fadeOut = true, zoomOut = true, variationSize = 1)
   {
    if (fadeIn)
    {
     aNames.push('fadeIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('ease-in');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (zoomIn)
    {
     if (variationSize === 0)
      aNames.push('zoomInS');
     else if (variationSize === 2)
      aNames.push('zoomInL');
     else
      aNames.push('zoomIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.in / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (fadeOut)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (zoomOut)
    {
     if (variationSize === 0)
      aNames.push('zoomOutS');
     else if (variationSize === 2)
      aNames.push('zoomOutL');
     else
      aNames.push('zoomOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.zoom.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.out / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    return styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
   }

   function showEmote_Rise(url, zwe, sW, sH, sS, canV = true)
   {
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = rnd(sW) - (sS / 2);
    let v = Math.floor(rnd(0.3) * sH) + Math.floor(0.8 * sH);
    let s = 'left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    if (cfg.emote.out.fade || cfg.emote.out.zoom)
     s += ' offset-path: path("M 0 ' + v + ' L 0 ' + Math.floor(v * 0.05) + '") ;';
    else
     s += ' offset-path: path("M 0 ' + v + ' L 0 -' + sS + '") ;';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (rnd(2) === 1)
     aNames.push('wiggleL');
    else
     aNames.push('wiggleR');
    let d = rnd(600);
    aDelays.push(d + 'ms');
    let w = rnd(3) + 2;
    aDurs.push(w + 's');
    aTimings.push('ease-in-out');
    aFills.push('both');
    aIters.push('infinite');
    aNames.push('offsetPath');
    aDelays.push('0s');
    aDurs.push(cfg.emote.time + 's');
    aTimings.push('linear');
    aFills.push('forwards');
    aIters.push('1');
    s += styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
    f(url);
    for (let i = 0, l = zwe.length; i < l; i++)
    {
     f(zwe[i].url);
    }
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     eActive++;
     document.body.appendChild(img);
     gcEmote(img, false);
    }
   }

   function showEmote_Bounce(url, zwe, sW, sH, sS, canV = true)
   {
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = Math.floor(rnd(sW) - (sS / 2));
    let v = Math.floor(rnd(0.2) * sH);
    let velH = rnd(6) + 3;
    let velV = rnd(3) + 4;
    if (h + (sS / 2) > (sW / 2))
     velH = -1 * velH;
    let s = 'height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
    s += ' transform: translate(' + h + 'px, ' + v + 'px);';
    let bX = h;
    let bY = v;
    let velY = velV;
    let iArr = [];
    iArr.push(f(url));
    for (let i = 0, l = zwe.length; i < l; i++)
    {
     iArr.push(f(zwe[i].url));
    }
    let ms = 20;
    let tmr = window.setTimeout(
     function tLoop()
     {
      window.clearTimeout(tmr);
      tmr = null;
      if (iArr[0].parentElement === null)
       return;
      bX += velH;
      bY += velY;
      velY += 1;
      if (bY + sS >= sH)
      {
       bY = sH - sS;
       velY *= -0.7;
       velY = Math.floor(velY);
      }
      for (let i = 0, l = iArr.length; i < l; i++)
      {
       iArr[i].style.transform = 'translate(' + bX + 'px, ' + bY + 'px)';
      }
      tmr = window.setTimeout(tLoop, ms);
     },
     ms
    );
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     eActive++;
     document.body.appendChild(img);
     gcEmote(img);
     return img;
    }
   }

   function showEmote_Speed(url, zwe, sW, sH, sS, canV = true)
   {
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = rnd(sW) - (sS / 2);
    let v = Math.floor(rnd(0.4) * sH) + Math.floor(0.3 * sH);
    let s = 'top: ' + v + 'px;';
    s += ' left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (h + (sS / 2) > (sW / 2))
    {
     s += ' transform-origin: center right;';
     aNames.push('speedL');
    }
    else
    {
     s += ' transform-origin: center left;';
     aNames.push('speedR');
    }
    aDelays.push('0.5s');
    aDurs.push(cfg.emote.time + 's');
    aTimings.push('ease-in');
    aFills.push('forwards');
    aIters.push('1');
    s += styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
    f(url);
    for (let i = 0, l = zwe.length; i < l; i++)
    {
     f(zwe[i].url);
    }
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     eActive++;
     document.body.appendChild(img);
     gcEmote(img);
    }
   }

   function showEmote_Drop(url, zwe, sW, sH, sS, canV = true)
   {
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = rnd(sW) - (sS / 2);
    let s = 'left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (rnd(2) === 1)
    {
     s += ' transform-origin: top left;';
     aNames.push('dropL');
    }
    else
    {
     s += ' transform-origin: top right;';
     aNames.push('dropR');
    }
    aDelays.push('0s');
    aDurs.push(cfg.emote.time + 's');
    aTimings.push('ease-in');
    aFills.push('forwards');
    aIters.push('1');
    s += styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
    f(url);
    for (let i = 0, l = zwe.length; i < l; i++)
    {
     f(zwe[i].url);
    }
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     eActive++;
     document.body.appendChild(img);
     gcEmote(img, false);
    }
   }

   function showEmote_Confetti(url, zwe, sW, sH, sS, canV = true)
   {
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = rnd(sW) - (sS / 2);
    let s = 'left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += ' transform-origin: center center;';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    switch (rnd(3))
    {
     case 0:
      aNames.push('confettiA');
      break;
     case 1:
      aNames.push('confettiB');
      break;
     case 2:
      aNames.push('confettiC');
      break;
    }
    aDelays.push('0s');
    aDurs.push(cfg.emote.time + 's');
    aTimings.push('linear');
    aFills.push('forwards');
    aIters.push('1');
    s += styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, false, variationSize);
    f(url);
    for (let i = 0, l = zwe.length; i < l; i++)
    {
     f(zwe[i].url);
    }
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     eActive++;
     document.body.appendChild(img);
     gcEmote(img, false);
    }
   }

   function showEmote_Crazy(url, zwe, sW, sH, sS, canV = true)
   {
    /* LAYOUT SHIFTS
     * =============
     * squashes via scale
     * offset-path requires support for offset-anchor/offset-position
     * due to transform-origin changes during squash
     */
    let squashT = 100;
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = rnd(sW - sS - 5) + 10;
    let v = rnd(sH - sS - 5) + 10;
    let s = 'top: ' + v + 'px;';
    s += ' left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    //s += ' transition: all 0.9s linear;';
    let dests = [];
    let traj = {x: 0, y: 0};
    traj.x = rnd() * 11 - 5;
    traj.y = rnd() * 11 - 5;
    let pos = {x: h, y: v, t: 0};
    let lastT = 0;
    let bCt = 0;
    while(pos.t + (bCt * (squashT * 2)) < (cfg.emote.time * 1000))
    {
     pos.x += traj.x;
     pos.y += traj.y;
     pos.t += 5;
     let wall = false;
     if (pos.x < 0)
     {
      pos.x = 0;
      traj.x *= -1;
      wall = 1;
     }
     else if (pos.x > (sW - sS))
     {
      pos.x = sW - sS;
      traj.x *= -1;
      wall = 3;
     }
     if (pos.y < 0)
     {
      pos.y = 0;
      traj.y *= -1;
      wall = 2;
     }
     else if (pos.y > (sH - sS))
     {
      pos.y = sH - sS;
      traj.y *= -1;
      wall = 4;
     }
     if (wall !== false)
     {
      bCt++;
      dests.push({x: Math.floor(pos.x), y: Math.floor(pos.y), t: (pos.t - lastT), w: wall});
      lastT = pos.t;
     }
    }
    dests.push({x: pos.x, y: pos.y, t: (pos.t - lastT), w: 0});
    s += styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
    let iArr = [];
    iArr.push(f(url));
    for (let i = 0, l = zwe.length; i < l; i++)
    {
     iArr.push(f(zwe[i].url));
    }
    let d = 0;
    let lA = iArr.length;
    let lD = dests.length;
    let tmr = window.setTimeout(
     function tLoop()
     {
      if (d >= lD)
       return;
      window.clearTimeout(tmr);
      for (let i = 0; i < lA; i++)
      {
       iArr[i].style.transformOrigin = 'center center';
       iArr[i].style.transform = 'scale(1, 1)';
       iArr[i].style.top = dests[d].y + 'px';
       iArr[i].style.left = dests[d].x + 'px';
       iArr[i].style.transition = 'all ' + dests[d].t + 'ms linear';
      }
      d++;
      tmr = window.setTimeout(
       function tSquash()
       {
        window.clearTimeout(tmr);
        for (let i = 0; i < lA; i++)
        {
         iArr[i].style.transition = 'transform ' + squashT + 'ms linear';
         switch(dests[d-1].w)
         {
          case 1:
           //left
           iArr[i].style.transformOrigin = 'left center';
           iArr[i].style.transform = 'scale(0.7, 2)';
           break;
          case 2:
           //top
           iArr[i].style.transformOrigin = 'center top';
           iArr[i].style.transform = 'scale(2, 0.7)';
           break;
          case 3:
           //right
           iArr[i].style.transformOrigin = 'right center';
           iArr[i].style.transform = 'scale(0.7, 2)';
           break;
          case 4:
           //bottom
           iArr[i].style.transformOrigin = 'center bottom';
           iArr[i].style.transform = 'scale(2, 0.7)';
           break;
         }
        }
        tmr = window.setTimeout(
         function tUnsquash()
         {
          window.clearTimeout(tmr);
          for (let i = 0; i < lA; i++)
          {
           iArr[i].style.transition = 'transform ' + squashT + 'ms linear';
           iArr[i].style.transform = 'scale(1, 1)';
          }
          tmr = window.setTimeout(tLoop, squashT);
         },
         squashT
        );
       }, dests[d - 1].t
      );
     },
     tStart
    );
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     eActive++;
     document.body.appendChild(img);
     gcEmote(img, false);
     return img;
    }
   }

   function showEmote_StraightLine(url, zwe, sW, sH, sS, x = false, y = false, canV = true)
   {
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = x;
    if (h === false)
     h = rnd(sW) - (sS / 2);
    let v = y;
    if (v === false)
     v = rnd(sH) - (sS / 2);
    let r = sW;
    if (sH < r)
     r = sH;
    r = r * (rnd() + 1);
    let th = (rnd() * (Math.PI * 2));
    let hD = Math.floor(h + r * Math.cos(th));
    let vD = Math.floor(v + r * Math.sin(th));
    if (!x && !y)
    {
     while ((h < 0 && hD < 0) || (v < 0 && vD < 0) || (h > (sW - sS) && hD > (sW - sS)) || (v > (sH - sS) && vD > (sH - sS)))
     {
      th = (rnd() * (Math.PI * 2));
      hD = Math.floor(h + r * Math.cos(th));
      vD = Math.floor(v + r * Math.sin(th));
     }
    }
    let s = 'height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += ' transition: transform ' + cfg.emote.time + 's linear;';
    s += ' transform: translate(' + h + 'px, ' + v + 'px);';
    s += styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
    f(url);
    for (let i = 0, l = zwe.length; i < l; i++)
    {
     f(zwe[i].url);
    }
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     eActive++;
     document.body.appendChild(img);
     gcEmote(img);
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
      },
      tStart
     );
    }
   }

   function showEmote_Fountain(url, zwe, sW, sH, sS, fX, fY, canV = true)
   {
    let aT = Math.floor((cfg.emote.time * 1000) / 2);
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = fX;
    if (h === false)
     h = Math.floor((rnd() * ((sW - sS) * 0.33)) + (sW - sS) * 0.33);
    let hD;
    if (rnd(2) === 0)
     hD = h - rnd((sW - sS) * 0.2);
    else
     hD = h + rnd((sW - sS) * 0.2);
    let s = 'height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += ' transition: transform ' + aT + 'ms cubic-bezier(0, 0, 0.58, 1);';
    s += ' transform: translateX(' + h + 'px);';
    s += ' offset-path: path("M 0 ' + sH + ' L 0 ' + Math.floor(fY / 100 * sH + rnd((sH - sS) * 0.5)) + ' L 0 ' + (sH + sS) + '");';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    aNames.push('offsetPath');
    aDelays.push('0s');
    aDurs.push(aT + 'ms');
    aTimings.push('cubic-bezier(0, 0.9, 1, 0.15)');
    aFills.push('forwards');
    aIters.push('1');
    s += styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
    f(url);
    for (let i = 0, l = zwe.length; i < l; i++)
    {
     f(zwe[i].url);
    }
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     eActive++;
     document.body.appendChild(img);
     gcEmote(img, true, true, aT);
     window.setTimeout(
      function()
      {
       img.style.transform = 'translateX(' + hD + 'px)';
      },
      tStart
     );
    }
   }

   function showEmote_Throw(url, zwe, sW, sH, sS, canV = true)
   {
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = (rnd(2) === 1) ? (- 1 * sS) : sW;
    let v = rnd(sH + sS) - sS;
    let hD = Math.floor((rnd() * ((sW - sS) * 0.4)) + (sW - sS) * 0.3);
    let vD = Math.floor((rnd() * ((sH - sS) * 0.4)) + (sH - sS) * 0.3);
    let dH = (rnd() * sS);
    let t1 = cfg.emote.time * 140;
    let t2 = cfg.emote.time * 200;
    let t3 = cfg.emote.time * 800;
    let s = 'height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += ' transition: transform ' + t1 + 'ms cubic-bezier(0.32, 0, 0.67, 0);';
    s += ' transform: translate(' + h + 'px, ' + v + 'px);';
    let s2 = 'height: ' + sS + 'px;';
    s2 += ' width: ' + sS + 'px;';
    s2 += ' transition: transform ' + t3 + 'ms cubic-bezier(0.5, 0, 0.75, 0);';
    let r = '360';
    if (h > 0)
     r = '-360';
    s2 += ' transform: translate(' + hD + 'px, ' + (sH - dH) + 'px) rotate(' + r + 'deg);';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor(t3 - (t3 * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor(t3 * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push((t3 - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomOutS');
     else if (variationSize === 2)
      aNames.push('zoomOutL');
     else
      aNames.push('zoomOut');
     aDelays.push(Math.floor(t3 - (t3 * (tAnim.zoom.out / 100))) + 'ms');
     aDurs.push(Math.floor(t3 * (tAnim.zoom.out / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    s2 += styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
    let iArr = [];
    iArr.push(f(url));
    for (let i = 0, l = zwe.length; i < l; i++)
    {
     iArr.push(f(zwe[i].url));
    }
    let lA = iArr.length;
    window.setTimeout(
     function()
     {
      for (let i = 0, l = lA; i < l; i++)
      {
       iArr[i].style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
      }
     },
     tStart
    );
    window.setTimeout(
     function()
     {
      for (let i = 0, l = lA; i < l; i++)
      {
       iArr[i].setAttribute('style', s2);
      }
     },
     t2
    );
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     eActive++;
     document.body.appendChild(img);
     gcEmote(img, false);
     return img;
    }
   }

   function showEmote_Still(url, zwe, sW, sH, sS, canV = true)
   {
    let variationSize = 1;
    if (canV, cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = rnd(sW) - (sS / 2);
    let v = rnd(sH) - (sS / 2);
    let s = 'top: ' + v + 'px;';
    s += ' left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
    f(url);
    for (let i = 0, l = zwe.length; i < l; i++)
    {
     f(zwe[i].url);
    }
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     eActive++;
     document.body.appendChild(img);
     gcEmote(img, false);
    }
   }

   function showEmote_TheCube(url, zwe, sW, sH, sS, canV = true)
   {
    let scene = document.createElement('div');
    scene.setAttribute('class', 'scene');
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = rnd(cfg.emote.size.variation + 2);
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    scene.setAttribute('width', sS);
    scene.setAttribute('height', sS);
    let cube = document.createElement('div');
    cube.setAttribute('class', 'cube');
    cube.setAttribute('style', 'transform: translateZ(' + (sS * -0.5) + 'px);  transition: transform linear ' + cfg.emote.time + 's;');
    let f = 'height: ' + sS + 'px;';
    f += ' width: ' + sS + 'px;';
    let lZ = zwe.length;
    if (zwe.length === 0)
    {
     let cubeF = document.createElement('img');
     cubeF.setAttribute('src', url);
     cubeF.setAttribute('alt', '');
     cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
     cubeF.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeF);
     let cubeB = document.createElement('img');
     cubeB.setAttribute('src', url);
     cubeB.setAttribute('alt', '');
     cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
     cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeB);
     let cubeR = document.createElement('img');
     cubeR.setAttribute('src', url);
     cubeR.setAttribute('alt', '');
     cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
     cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeR);
     let cubeL = document.createElement('img');
     cubeL.setAttribute('src', url);
     cubeL.setAttribute('alt', '');
     cubeL.setAttribute('class', 'cubeFace cubeFaceLeft');
     cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeL);
     let cubeT = document.createElement('img');
     cubeT.setAttribute('src', url);
     cubeT.setAttribute('alt', '');
     cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
     cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeT);
     let cubeU = document.createElement('img');
     cubeU.setAttribute('src', url);
     cubeU.setAttribute('alt', '');
     cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
     cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeU);
    }
    else
    {
     let cubeF = document.createElement('div');
     cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
     cubeF.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px);');
     let pctF = document.createElement('img');
     pctF.setAttribute('src', url);
     pctF.setAttribute('alt', '');
     pctF.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeF.appendChild(pctF);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeF.appendChild(pctZ);
     }
     cube.appendChild(cubeF);
     let cubeB = document.createElement('div');
     cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
     cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + (sS * 0.5) + 'px);');
     let pctB = document.createElement('img');
     pctB.setAttribute('src', url);
     pctB.setAttribute('alt', '');
     pctB.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeB.appendChild(pctB);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeB.appendChild(pctZ);
     }
     cube.appendChild(cubeB);
     let cubeR = document.createElement('div');
     cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
     cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + (sS * 0.5) + 'px);');
     let pctR = document.createElement('img');
     pctR.setAttribute('src', url);
     pctR.setAttribute('alt', '');
     pctR.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeR.appendChild(pctR);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeR.appendChild(pctZ);
     }
     cube.appendChild(cubeR);
     let cubeL = document.createElement('div');
     cubeL.setAttribute('class', 'cubeFace cubeFaceLight');
     cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + (sS * 0.5) + 'px);');
     let pctL = document.createElement('img');
     pctL.setAttribute('src', url);
     pctL.setAttribute('alt', '');
     pctL.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeL.appendChild(pctL);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeL.appendChild(pctZ);
     }
     cube.appendChild(cubeL);
     let cubeT = document.createElement('div');
     cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
     cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + (sS * 0.5) + 'px);');
     let pctT = document.createElement('img');
     pctT.setAttribute('src', url);
     pctT.setAttribute('alt', '');
     pctT.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeT.appendChild(pctT);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeT.appendChild(pctZ);
     }
     cube.appendChild(cubeT);
     let cubeU = document.createElement('div');
     cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
     cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + (sS * 0.5) + 'px);');
     let pctU = document.createElement('img');
     pctU.setAttribute('src', url);
     pctU.setAttribute('alt', '');
     pctU.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeU.appendChild(pctU);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeU.appendChild(pctZ);
     }
     cube.appendChild(cubeU);
    }
    scene.appendChild(cube);
    let h = rnd(sW) - (sS / 2);
    let v = rnd(sH) - (sS / 2);
    let r = sW;
    if (sH < r)
     r = sH;
    r = r * (rnd() + 1);
    let th = (rnd() * (Math.PI * 2));
    let hD = Math.floor(h + r * Math.cos(th));
    let vD = Math.floor(v + r * Math.sin(th));
    while ((h < 0 && hD < 0) || (v < 0 && vD < 0) || (h > (sW - sS) && hD > (sW - sS)) || (v > (sH - sS) && vD > (sH - sS)))
    {
     th = (rnd() * (Math.PI * 2));
     hD = Math.floor(h + r * Math.cos(th));
     vD = Math.floor(v + r * Math.sin(th));
    }
    let s = 'width: ' + sS + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' perspective: ' + (sS * 3)  + 'px;';
    s += ' transition: all ' + cfg.emote.time + 's linear;';
    s += ' transform: translate(' + h + 'px, ' + v + 'px);';
    s += styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false, variationSize);
    scene.setAttribute('style', s);
    eActive++;
    document.body.appendChild(scene);
    gcEmote(scene);
    window.setTimeout(
     function()
     {
      let rX = 0;
      let rY = 0;
      while ((Math.abs(rX) + Math.abs(rY)) < 45)
      {
       rX = (360 - (rnd() * 720)) * cfg.emote.cube.rotations;
       rY = (360 - (rnd() * 720)) * cfg.emote.cube.rotations;
      }
      cube.style.transform = 'translateZ(' + (sS * -0.5) + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
      scene.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
     },
     tStart
    );
   }

   function showKappa_TheCube(url, zwe, sW, sH, sS, bC, iR)
   {
    let scene = document.createElement('div');
    scene.setAttribute('class', 'scene');
    scene.setAttribute('width', sS);
    scene.setAttribute('height', sS);
    let cube = document.createElement('div');
    cube.setAttribute('class', 'cube');
    cube.setAttribute('style', 'transform: translateZ(' + (sS * -0.5) + 'px);  transition: transform linear ' + cfg.emote.time + 's;');
    let f = 'height: ' + sS + 'px;';
    f += ' width: ' + sS + 'px;';
    let lZ = zwe.length;
    if (lZ === 0)
    {
     let cubeF = document.createElement('img');
     cubeF.setAttribute('src', url);
     cubeF.setAttribute('alt', '');
     cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
     cubeF.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeF);
     let cubeB = document.createElement('img');
     cubeB.setAttribute('src', url);
     cubeB.setAttribute('alt', '');
     cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
     cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeB);
     let cubeR = document.createElement('img');
     cubeR.setAttribute('src', url);
     cubeR.setAttribute('alt', '');
     cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
     cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeR);
     let cubeL = document.createElement('img');
     cubeL.setAttribute('src', url);
     cubeL.setAttribute('alt', '');
     cubeL.setAttribute('class', 'cubeFace cubeFaceLeft');
     cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeL);
     let cubeT = document.createElement('img');
     cubeT.setAttribute('src', url);
     cubeT.setAttribute('alt', '');
     cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
     cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeT);
     let cubeU = document.createElement('img');
     cubeU.setAttribute('src', url);
     cubeU.setAttribute('alt', '');
     cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
     cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + (sS * 0.5) + 'px);');
     cube.appendChild(cubeU);
    }
    else
    {
     let cubeF = document.createElement('div');
     cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
     cubeF.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px);');
     let pctF = document.createElement('img');
     pctF.setAttribute('src', url);
     pctF.setAttribute('alt', '');
     pctF.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeF.appendChild(pctF);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeF.appendChild(pctZ);
     }
     cube.appendChild(cubeF);
     let cubeB = document.createElement('div');
     cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
     cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + (sS * 0.5) + 'px);');
     let pctB = document.createElement('img');
     pctB.setAttribute('src', url);
     pctB.setAttribute('alt', '');
     pctB.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeB.appendChild(pctB);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeB.appendChild(pctZ);
     }
     cube.appendChild(cubeB);
     let cubeR = document.createElement('div');
     cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
     cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + (sS * 0.5) + 'px);');
     let pctR = document.createElement('img');
     pctR.setAttribute('src', url);
     pctR.setAttribute('alt', '');
     pctR.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeR.appendChild(pctR);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeR.appendChild(pctZ);
     }
     cube.appendChild(cubeR);
     let cubeL = document.createElement('div');
     cubeL.setAttribute('class', 'cubeFace cubeFaceLight');
     cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + (sS * 0.5) + 'px);');
     let pctL = document.createElement('img');
     pctL.setAttribute('src', url);
     pctL.setAttribute('alt', '');
     pctL.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeL.appendChild(pctL);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeL.appendChild(pctZ);
     }
     cube.appendChild(cubeL);
     let cubeT = document.createElement('div');
     cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
     cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + (sS * 0.5) + 'px);');
     let pctT = document.createElement('img');
     pctT.setAttribute('src', url);
     pctT.setAttribute('alt', '');
     pctT.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeT.appendChild(pctT);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeT.appendChild(pctZ);
     }
     cube.appendChild(cubeT);
     let cubeU = document.createElement('div');
     cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
     cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + (sS * 0.5) + 'px);');
     let pctU = document.createElement('img');
     pctU.setAttribute('src', url);
     pctU.setAttribute('alt', '');
     pctU.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
     cubeU.appendChild(pctU);
     for (let i = 0; i < lZ; i++)
     {
      let pctZ = document.createElement('img');
      pctZ.setAttribute('src', zwe[i].url);
      pctZ.setAttribute('alt', '');
      pctZ.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px); position: absolute;');
      cubeU.appendChild(pctZ);
     }
     cube.appendChild(cubeU);
    }
    scene.appendChild(cube);
    let h = rnd(sW - sS);
    let v = rnd(sH - sS);
    if (bC)
    {
     h = Math.floor((sW / 2) - (sS / 2));
     v = Math.floor((sH / 2) - (sS / 2));
    }
    let s = 'width: ' + sS + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' perspective: ' + (sS * 3)  + 'px;';
    s += ' transition: all ' + cfg.emote.time + 's linear;';
    s += ' transform: translate(' + h + 'px, ' + v + 'px);';
    s += styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false);
    scene.setAttribute('style', s);
    eActive++;
    document.body.appendChild(scene);
    gcEmote(scene, false);
    window.setTimeout(
     function()
     {
      let rX = 0;
      let rY = 0;
      while ((Math.abs(rX) + Math.abs(rY)) < 45)
      {
       rX = (360 - (rnd() * 720)) * iR;
       rY = (360 - (rnd() * 720)) * iR;
      }
      cube.style.transform = 'translateZ(' + (sS * -0.5) + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
     },
     tStart
    );
   }

   function showKappa_Fireworks(kList, sW, sH, sS, iKC)
   {
    let sendUp = 2;
    let oX = (sW * 0.5) - (sS * 0.5);
    let oY = sH;
    let cX = oX;
    switch(rnd(3))
    {
     case 0:
      cX = Math.floor(cX * 0.5);
      break;
     case 2:
      cX = Math.floor(cX * 1.5);
      break;
    }
    let cY = oY * 0.33;
    let lK = kList.length;
    function sparkler(url, r, d, a)
    {
     let simg = document.createElement('img');
     simg.setAttribute('class', 'emote');
     simg.setAttribute('src', url);
     simg.setAttribute('alt', '');
     let th = (a * (Math.PI * 2));
     let hD = Math.floor(cX + r * Math.cos(th));
     let vD = Math.floor(cY + r * Math.sin(th));
     let s2 = 'height: ' + sS + 'px;';
     s2 += ' width: ' + sS + 'px;';
     s2 += ' transition: transform ' + cfg.emote.time + 's ease-out;';
     s2 += ' transform: translate(' + cX + 'px, ' + cY + 'px);';
     let aNames = [];
     let aDelays = [];
     let aDurs = [];
     let aTimings = [];
     let aFills = [];
     let aIters = [];
     aNames.push('fadeIn');
     aDelays.push((d * 1000) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
     aNames.push('fadeOut');
     aDelays.push((d * 1000) + Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
     s2 += styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
     simg.setAttribute('style', s2);
     document.body.appendChild(simg);
     gcEmote(simg, true, true, (d + cfg.emote.time) * 1000);
     window.setTimeout(
      function()
      {
       simg.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
      },
      (d * 1000) + tStart
     );
    }
    let s = 'height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += ' transition: transform ' + sendUp + 's linear;';
    s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
    let oK = kList[rnd(lK)];
    let iArr = [];
    iArr.push(f(oK.url));
    if (oK.hasOwnProperty('zwe'))
    {
     for (let i = 0, l = oK.zwe.length; i < l; i++)
     {
      eActive++;
      iArr.push(f(oK.zwe[i].url));
     }
    }
    function f(uri)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', uri);
     img.setAttribute('alt', '');
     img.setAttribute('style', s);
     document.body.appendChild(img);
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + cX + 'px, ' + cY + 'px)';
      },
      tStart
     );
     return img;
    }
    window.setTimeout(
     async function()
     {
      for (let i = 0, l = iArr.length; i < l; i++)
      {
       document.body.removeChild(iArr[i]);
       eActive--;
      }
      let r = sW;
      if (sH < r)
       r = sH;
      r *= 0.66;
      let inner = Math.floor(iKC / 8);
      let outer = inner;
      let core = iKC - (inner + outer);
      let t = 0;
      for (let v = 0; v < inner; v++)
      {
       let sK = kList[rnd(lK)];
       let sA = rnd();
       sparkler(sK.url, r * 0.5, t, sA);
       if (sK.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = sK.zwe.length; i < l; i++)
        {
         sparkler(sK.zwe[i].url, r * 0.5, t, sA);
        }
       }
       if (v % Math.floor(outer / 3) === 0)
        await sleep(1);
      }
      t += 0.5;
      for (let v = 0; v < core; v++)
      {
       let sK = kList[rnd(lK)];
       let sA = rnd();
       sparkler(sK.url, r, t, sA);
       if (sK.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = sK.zwe.length; i < l; i++)
        {
         sparkler(sK.zwe[i].url, r, t, sA);
        }
       }
       t += 0.005;
       if (v % Math.floor(outer / 9) === 0)
        await sleep(1);
      }
      t += 0.25;
      for (let v = 0; v < outer; v++)
      {
       let sK = kList[rnd(lK)];
       let sA = rnd();
       sparkler(sK.url, r * 1.5, t, sA);
       if (sK.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = sK.zwe.length; i < l; i++)
        {
         sparkler(sK.zwe[i].url, r * 1.5, t, sA);
        }
       }
       if (v % Math.floor(outer / 3) === 0)
        await sleep(1);
      }
     },
     sendUp * 1000
    );
   }

   function showKappa_Spiral(kList, sW, sH, sS, iKC)
   {
    let oX = rnd(sW - sS);
    let oY = rnd(sH - sS);
    function sparkler(url, r, th)
    {
     let simg = document.createElement('img');
     simg.setAttribute('class', 'emote');
     simg.setAttribute('src', url);
     simg.setAttribute('alt', '');
     let hD = Math.floor(oX + r * Math.cos(th));
     let vD = Math.floor(oY + r * Math.sin(th));
     let s = 'height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: transform ' + cfg.emote.time + 's ease-out;';
     s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
     s += styleEmote([], [], [], [], [], [], true, false, true, false);
     simg.setAttribute('style', s);
     document.body.appendChild(simg);
     gcEmote(simg, true, true);
     window.setTimeout(
      function()
      {
       simg.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
      },
      tStart
     );
    }
    window.setTimeout(
     async function()
     {
      let r = sW;
      if (sH < r)
       r = sH;
      let l = iKC / 25 + 2;
      l = l + (rnd() * 4 - 2);
      if (l < 0.1)
       l = 0.1;
      let c = (Math.PI * l) / iKC;
      let th = (rnd() * (Math.PI * 2));
      let o = (rnd(2) === 0);
      for (let i = 0; i < iKC; i++)
      {
       if (o)
       {
        th-= c;
        if (th <= 0)
         th+= Math.PI * 2;
       }
       else
       {
        th+= c;
        if (th >= Math.PI * 2)
         th+= Math.PI * 2;
       }
       let oK = kList[rnd(kList.length)];
       sparkler(oK.url, r, th);
       if (oK.hasOwnProperty('zwe'))
       {
        for (let j = 0, m = oK.zwe.length; j < m; j++)
        {
         eActive++;
         sparkler(oK.zwe[j].url, r, th);
        }
       }
       await sleep(10);
      }
     },
     tStart
    );
   }

   function showKappa_Pyramid(kList, sW, sH)
   {
    let sS = sW / 19;
    let drawn = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    let ct = 0;
    let lP = pyramidDist.length;
    for (let i = 0; i < lP; i++)
     ct += pyramidDist[i];
    let eT = (cfg.emote.time * 1000) * 0.8;
    let tPerB = Math.floor(eT / ct);
    if (tPerB < 50)
     tPerB = 50;
    eT = tPerB * ct;
    let dT = (cfg.emote.time * 1000) * 0.2;
    function block(url, x, t)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', url);
     img.setAttribute('alt', '');
     let h = sS * x;
     let v = -1 * sS;
     let vD = sH - (sS * (drawn[x] + 1));
     let s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: all ' + tPerB + 'ms ease-in;';
     s += ' transform: translate(' + h + 'px, ' + v + 'px);';
     img.setAttribute('style', s);
     document.body.appendChild(img);
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
       img.style.transitionTime = '500ms';
       gcEmote(img, false, true, 500);
      },
      Math.floor(eT + dT + (t / 10))
     );
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
      },
      t
     );
    }
    let t = 0;
    for (let i = 0; i < ct; i++)
    {
     let x;
     do
      x = rnd(lP);
     while(drawn[x] >= pyramidDist[x]);
     let oK = kList[rnd(kList.length)];
     block(oK.url, x, t);
     if (oK.hasOwnProperty('zwe'))
     {
      for (let j = 0, l = oK.zwe.length; j < l; j++)
      {
       eActive++;
       block(oK.zwe[j].url, x, t);
      }
     }
     drawn[x]++;
     t += tPerB;
    }
   }

   function showKappa_SmallPyramid(kList, sW, sH)
   {
    let sS = sW / 19;
    if (sS > Math.floor(sW * cfg.emote.size.ratio.small))
     sS = Math.floor(sW * cfg.emote.size.ratio.small);
    if (sS > Math.floor(sH * cfg.emote.size.ratio.small))
     sS = Math.floor(sH * cfg.emote.size.ratio.small);
    let drawn = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    let ct = 0;
    let lP = pyramidDist.length;
    for (let i = 0; i < lP; i++)
     ct += pyramidDist[i];
    let eT = (cfg.emote.time * 1000) * 0.8;
    let tPerB = Math.floor(eT / ct);
    if (tPerB < 75)
     tPerB = 75;
    eT = tPerB * ct;
    let dT = (cfg.emote.time * 1000) * 0.2;
    function block(url, oX, x, t)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', url);
     img.setAttribute('alt', '');
     let h = oX + sS * x;
     let v = -1 * sS;
     let vD = sH - (sS * (drawn[x] + 1));
     let s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: all ' + tPerB + 'ms ease-in;';
     s += ' transform: translate(' + h + 'px, ' + v + 'px);';
     img.setAttribute('style', s);
     document.body.appendChild(img);
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
       img.style.transitionTime = '500ms';
       gcEmote(img, false, true, 500);
      },
      Math.floor(eT + dT + (t / 10))
     );
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
      },
      t
     );
    }
    let oX = rnd(sW - (sS * lP));
    let t = 0;
    for (let i = 0; i < ct; i++)
    {
     let x;
     do
      x = rnd(lP);
     while(drawn[x] >= pyramidDist[x]);
     let oK = kList[rnd(kList.length)];
     block(oK.url, oX, x, t);
     if (oK.hasOwnProperty('zwe'))
     {
      for (let j = 0, l = oK.zwe.length; j < l; j++)
      {
       eActive++;
       block(oK.zwe[j].url, oX, x, t);
      }
     }
     drawn[x]++;
     t += tPerB;
    }
   }

   async function showKappa_Stampede(kList, sW, sH, sS, iKC)
   {
    let speed = 2000;
    let bandHeight = sS * 3;
    let d = (rnd(2) === 1);
    let bandTop = rnd(sH - (sS * 2.5));
    function run(url, y)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', url);
     img.setAttribute('alt', '');
     let h = -2 * sS;
     let v = y + bandTop;
     let s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: all ' + (speed / 1000) + 's linear;';
     if (d)
      s += ' transform: translate(' + sW + 'px, ' + v + 'px);';
     else
      s += ' transform: translate(' + h + 'px, ' + v + 'px);';
     img.setAttribute('style', s);
     document.body.appendChild(img);
     window.setTimeout(
      function()
      {
       document.body.removeChild(img);
       img.setAttribute('deleted', true);
      },
      speed
     );
     window.setTimeout(
      function()
      {
       if (d)
        img.style.transform = 'translate(' + h + 'px, ' + v + 'px)';
       else
        img.style.transform = 'translate(' + (sW + sS) + 'px, ' + v + 'px)';
      },
      tStart
     );
     return img;
    }
    async function stampede(ct, pause)
    {
     let imgs = [];
     for (let i = 0; i < ct; i++)
     {
      let oK = kList[rnd(kList.length)];
      let y = rnd(bandHeight);
      imgs.push(run(oK.url, y));
      if (oK.hasOwnProperty('zwe'))
      {
       for (let j = 0, l = oK.zwe.length; j < l; j++)
       {
        run(oK.zwe[j].url, y);
       }
      }
      await sleep(rnd(90) + 10);
     }
     if (pause === false)
      return;
     if (pause !== true)
     {
      await sleep(pause);
      return;
     }
     do
     {
      await sleep(100);
      for (let i = imgs.length - 1; i >= 0; i--)
      {
       if (imgs[i] === null || imgs[i].hasAttribute('deleted'))
        imgs.splice(i, 1);
      }
     } while (imgs.length > 0);
    }
    let b1 = rnd(4) + 1;
    let b2 = rnd(8 - b1) + b1;
    let b4 = rnd(4);
    await stampede(b1, speed * 0.8);
    await stampede(b2, speed * 0.4);
    await stampede(iKC, (b4 > 0));
    if (b4 > 0)
     await stampede(b4, false);
   }

   async function showKappa_Conga(kList, sW, sH, sS, nM)
   {
    let v = 0;
    let unique = false;
    let bS = Math.ceil(sS * (5/3));
    let seg = Math.floor(bS / 2);
    let sht = Math.floor(sH / seg);
    let longWait = cfg.emote.time * 2;
    let lns = sht;
    if (nM)
     lns = 6;
    while (conga.length >= lns)
    {
     await sleep(250);
    }
    while (!unique)
    {
     v = rnd(sht) * seg;
     if (nM)
     {
      v = rnd(6);
      if (v > 2)
       v = (sht - 1) - (v - 3);
      v *= seg;
     }
     let found = false;
     for (let i = 0, l = conga.length; i < l; i++)
     {
      if (conga[i].row === v)
      {
       found = true;
       break;
      }
     }
     if (!found)
      unique = true;
    }
    conga.push({row: v, done: false});
    let urls = [];
    let zurls = [];
    let ct = Math.floor(sW / bS);
    for (let i = 0; i < ct; i++)
    {
     let oK = kList[rnd(kList.length)];
     urls.push(oK.url);
     let oZ = [];
     if (oK.hasOwnProperty('zwe'))
     {
      for (let j = 0, l = oK.zwe.length; j < l; j++)
      {
       oZ.push(oK.zwe[j].url);
      }
     }
     zurls.push(oZ);
    }
    let d = ((v / seg) % 2 === 1);
    let xtra = Math.floor((sW - (ct * bS)) / 2);
    function dance(url, col)
    {
     let box = document.createElement('div');
     box.setAttribute('class', 'scene');
     let img = document.createElement('img');
     img.setAttribute('class', 'dancer');
     img.setAttribute('src', url);
     img.setAttribute('alt', '');
     let s = 'width: ' + sS + 'px;';
     s += ' height: ' + sS + 'px;';
     img.setAttribute('style', s);
     let sE = bS * col + xtra;
     let sB = sE - sW;
     if (d)
     {
      sE = bS * ((ct - 1) - col) + xtra;
      sB = sE + sW;
      img.setAttribute('title', 'd is true');
     }
     s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' width: ' + bS + 'px;';
     s += ' height: ' + bS + 'px;';
     s += ' z-index: ' + v + ';';
     s += ' transition: all ' + longWait + 's linear;';
     s += ' transform: translate(' + sB + 'px, ' + v + 'px);';
     box.setAttribute('style', s);
     eActive++;
     box.appendChild(img);
     document.body.appendChild(box);
     window.setTimeout(
      function()
      {
       box.style.transform = 'translate(' + sE + 'px, ' + v + 'px)';
      },
      tStart
     );
     return box;
    }
    function endDance(box, col)
    {
     let sB = bS * col + xtra;
     let sE = sB + sW;
     if (d)
     {
      sB = bS * ((ct - 1) - col) + xtra;
      sE = sB - sW;
     }
     let s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' width: ' + bS + 'px;';
     s += ' height: ' + bS + 'px;';
     s += ' z-index: ' + v + ';';
     s += ' transition: all ' + longWait + 's ease-in;';
     s += ' transform: translate(' + sB + 'px, ' + v + 'px);';
     box.setAttribute('style', s);
     gcEmote(box, true, true, longWait * 1000 * 1.25);
     window.setTimeout(
      function()
      {
       box.style.transform = 'translate(' + sE + 'px, ' + v + 'px)';
      },
      tStart
     );
    }
    let imgs = [];
    let zimgs = [];
    for (let i = 0; i < ct; i++)
    {
     imgs.push(dance(urls[i], i));
     let oZ = [];
     for (let j = 0, l = zurls[i].length; j < l; j++)
     {
      oZ.push(dance(zurls[i][j], i));
     }
     zimgs.push(oZ);
    }
    await sleep(longWait * 1000);
    let full = false;
    if (conga.length === sht)
     full = true;
    await sleep(cfg.display.kappa.conga.time * 1000);
    if (cfg.display.kappa.conga.contagious)
    {
     let ex = false;
     let lC = conga.length;
     if (lC > 1)
      ex = true;
     for (let i = 0; i < lC; i++)
     {
      if (conga[i].row !== v)
       continue;
      conga[i].done = true;
      break;
     }
     let done = false;
     while (!done)
     {
      lC = conga.length;
      if (!ex && lC > 1)
       ex = true;
      let notDone = false;
      for (let i = 0; i < lC; i++)
      {
       if (conga[i].done === false)
       {
        notDone = true;
        break;
       }
      }
      if (notDone === false)
       done = true;
      await sleep(100);
     }
    }
    for (let i = 0, l = imgs.length; i < l; i++)
    {
     endDance(imgs[i], i);
     for (let j = 0, m = zimgs[i].length; j < m; j++)
     {
      endDance(zimgs[i][j], i);
     }
    }
    await sleep(longWait * 1000);
    for (let i = 0, l = conga.length; i < l; i++)
    {
     if (conga[i].row !== v)
      continue;
     conga.splice(i, 1);
     break;
    }
   }

   function showKappa_Text(kList, sW, sH, sMsg, iTime)
   {
    function buildMsgArr(s)
    {
     let o = [];
     let spc = [];
     for (let y = 0, l = alnumDist['A'][0].length; y < l; y++)
     {
      spc.push(0);
     }
     for (let i = 0, l = s.length; i < l; i++)
     {
      if (i > 0)
       o.push(spc);
      if (s[i] === ' ')
      {
       o.push(spc);
       o.push(spc);
       continue;
      }
      let v = s[i];
      if (!alnumDist.hasOwnProperty(v))
       continue;
      let c = alnumDist[v];
      for (let x = 0, m = c.length; x < m; x++)
      {
       o.push(c[x]);
      }
     }
     return o;
    }
    let msgDist = buildMsgArr(sMsg);
    let ct = 0;
    let ctT = 0;
    let drawn = [];
    let lM = msgDist.length;
    for (let x = 0; x < lM; x++)
    {
     let lX = msgDist[x].length;
     for (let y = 0; y < lX; y++)
     {
      if (msgDist[x][y] !== 0)
       ctT += 1;
     }
     ct += lX;
     drawn.push(0);
    }
    let sS = Math.floor(sW / (lM + 2));
    if (sS > Math.floor(sW * cfg.emote.size.ratio.small))
     sS = Math.floor(sW * cfg.emote.size.ratio.small);
    if (sS > Math.floor(sH * cfg.emote.size.ratio.small))
     sS = Math.floor(sH * cfg.emote.size.ratio.small);
    let eT = cfg.emote.time * 1000;
    let tPerB = Math.floor(eT / ctT);
    if (tPerB < 24)
     tPerB = 24;
    eT = tPerB * ctT;
    let lF = msgDist[0].length;
    let vH = rnd(sH - (sS * lF)) + (sS * lF);
    function block(url, oX, x, t)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', url);
     img.setAttribute('alt', '');
     let h = oX + sS * x;
     let v = -1 * sS;
     let vD = vH - (sS * (drawn[x] + 1));
     let s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: all ' + tPerB + 'ms ease-in;';
     s += ' transform: translate(' + h + 'px, ' + v + 'px);';
     img.setAttribute('style', s);
     document.body.appendChild(img);
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
       img.style.transitionTime = '500ms';
       gcEmote(img, false, true, 500);
      },
      Math.floor(eT + (iTime * 1000) + (t / 10))
     );
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
      },
      t
     );
    }
    let oX = rnd(sW - (sS * lM));
    let t = 0;
    for (let i = 0; i < ct; i++)
    {
     let x;
     do
      x = rnd(lM);
     while(drawn[x] >= msgDist[x].length);
     if (msgDist[x][drawn[x]] !== 0)
     {
      let oK = kList[rnd(kList.length)];
      block(oK.url, oX, x, t);
      if (oK.hasOwnProperty('zwe'))
      {
       for (let j = 0, l = oK.zwe.length; j < l; j++)
       {
        eActive++;
        block(oK.zwe[j].url, oX, x, t);
       }
      }
      t += tPerB;
     }
     drawn[x]++;
    }
   }

   function showEmote(url, zwe)
   {
    let sW = window.innerWidth;
    let sH = window.innerHeight;
    let sS = cfg.emote.size.max;
    if (sW < sH)
     sS = Math.floor(sW * cfg.emote.size.ratio.normal);
    else
     sS = Math.floor(sH * cfg.emote.size.ratio.normal);
    if (sS > cfg.emote.size.max)
     sS = cfg.emote.size.max;
    if (sS < cfg.emote.size.min)
     sS = cfg.emote.size.min;
    document.documentElement.style.setProperty('--height', sH + 'px');
    document.documentElement.style.setProperty('--width', sW + 'px');
    document.documentElement.style.setProperty('--emote-height', sS + 'px');
    document.documentElement.style.setProperty('--emote-height-s', Math.ceil(sS * 0.5) + 'px');
    document.documentElement.style.setProperty('--emote-height-l', (sS * 2) + 'px');
    let style = cfg.display.styles[rnd(cfg.display.styles.length)];
    if (style === undefined)
     return;
    window['showEmote_' + style](url, zwe, sW, sH, sS);
   }

   function showEmotes()
   {
    if (tEmote !== false)
    {
     window.clearTimeout(tEmote);
     tEmote = false;
    }
    if (cfg.emote.max > 0 && eActive >= cfg.emote.max)
    {
     tEmote = window.setTimeout(showEmotes, 500);
     return;
    }
    let e = null;
    while ((e =  toShow.shift()) !== undefined)
    {
     showEmote(e.url, e.zwe ?? []);
     if (cfg.emote.max > 0 && eActive > cfg.emote.max)
     {
      if (cfg.emote.queue > 0 && toShow.length > cfg.emote.queue)
       toShow.splice(0, toShow.length - cfg.emote.queue);
      tEmote = window.setTimeout(showEmotes, 500);
      return;
     }
    }
   }

   function canShowKappa(k)
   {
    if (cfg.emote.max < 1)
     return true;
    if (eActive < 1)
     return true;
    let tC = cfg.display.kappa.count;
    if (k !== false)
     tC = getKappaCountEstimate(k);
    let cM = cfg.emote.max;
    if (tC > cM)
     cM = tC;
    return (eActive + tC < cM);
   }

   function showKappas()
   {
    if (tKappa !== false)
    {
     window.clearTimeout(tKappa);
     tKappa = false;
    }
    if (toKappa.length < 1)
     return;
    let nK = getNextKappa(toKappa[0]);
    if (nK === false)
     return;
    if (!canShowKappa(nK))
    {
     tKappa = window.setTimeout(showKappas, 500);
     return;
    }
    let e = null;
    while ((e = toKappa.shift()) !== undefined)
    {
     nK = false;
     let a = {};
     a[e.style] = e.prefs;
     showKappa(e.list, a, e.params);
     if (toKappa.length < 1)
      return;
     nK = getNextKappa(toKappa[0]);
     if (nK === false)
      return;
     if (!canShowKappa(nK))
     {
      if (cfg.emote.queue > 0 && toKappa.length > cfg.emote.queue)
       toKappa.splice(0, toKappa.length - cfg.emote.queue);
      tKappa = window.setTimeout(showKappas, 500);
      return;
     }
    }
   }

   function getNextKappa(k)
   {
    let a = [];
    a[k.style] = k.prefs;
    return getNextKappaEx(a, k.params);
   }

   function getNextKappaEx(kS = false, kP = false)
   {
    if (typeof kS !== 'object')
    {
     if (cfg.display.kappa.styles.length < 1)
      return false;
     kS = cfg.display.kappa.styles;
    }
    let s, p;
    let keys = Object.keys(kS);
    if (cfg.display.kappa.conga.contagious && conga.length > 0)
    {
     s = 'Conga';
     p = {};
     if (keys.includes('Conga'))
      p = kS['Conga'];
    }
    else
    {
     s = keys[rnd(keys.length)];
     p = kS[s];
    }
    if (s === undefined)
     return false;
    let iKC = cfg.display.kappa.count;
    if (cfg.display.kappa.styles.hasOwnProperty(s) && cfg.display.kappa.styles[s].hasOwnProperty('count') && cfg.display.kappa.styles[s].count > 0)
     iKC = cfg.display.kappa.styles[s].count;
    if (p === undefined)
     p = {};
    if (p.hasOwnProperty('count'))
    {
     let tKC = p.count;
     if (tKC === -1 && kP !== false && kP.hasOwnProperty('%AMOUNT%') && Math.ceil(kP['%AMOUNT%']) > 0)
      tKC = Math.ceil(kP['%AMOUNT%']);
     if (tKC > 0)
      iKC = tKC;
    }
    if ((cfg.emote.max > 0) && (iKC > cfg.emote.max))
     iKC = cfg.emote.max;
    return {style: s, prefs: p, count: iKC};
   }

   function getKappaCountEstimate(k)
   {
    switch (k.style)
    {
     case 'Pyramid':
     case 'SmallPyramid':
      let c = 0;
      for (let i = 0, l = pyramidDist.length; i < l; i++)
       c += pyramidDist[i];
      return c;
     case 'Fireworks':
      let inner = Math.floor(k.count / 8);
      let outer = inner;
      let core = k.count - (inner + outer);
      return 1 + inner + core + outer;
     case 'Conga':
      let sW = window.innerWidth;
      let sH = window.innerHeight;
      let sS = cfg.emote.size.max;
      if (sW < sH)
       sS = Math.floor(sW * cfg.emote.size.ratio.normal);
      else
       sS = Math.floor(sH * cfg.emote.size.ratio.normal);
      if (sS > cfg.emote.size.max)
       sS = cfg.emote.size.max;
      if (sS < cfg.emote.size.min)
       sS = cfg.emote.size.min;
      let bS = Math.ceil(sS * (5/3));
      return Math.floor(sW / bS);
    }
    return k.count;
   }

   async function showKappa(kList, kStyles = false, kParams = false)
   {
    let kStyle = getNextKappaEx(kStyles, kParams);
    if (kStyle === false)
     return;
    if (kStyle.style === undefined)
     return;
    if (!Array.isArray(kList) || kList.length < 1)
     kList = cList;
    if (!Array.isArray(kList) || kList.length < 1)
     kList = bareList;
    let sW = window.innerWidth;
    let sH = window.innerHeight;
    let sS = cfg.emote.size.max;
    let sSm = Math.floor(sS / 2);
    if (sW < sH)
    {
     sS = Math.floor(sW * cfg.emote.size.ratio.normal);
     sSm = Math.floor(sW * cfg.emote.size.ratio.small);
    }
    else
    {
     sS = Math.floor(sH * cfg.emote.size.ratio.normal);
     sSm = Math.floor(sH * cfg.emote.size.ratio.small);
    }
    if (sS > cfg.emote.size.max)
     sS = cfg.emote.size.max;
    if (sS < cfg.emote.size.min)
     sS = cfg.emote.size.min;
    if (sSm > cfg.emote.size.max)
     sSm = cfg.emote.size.max;
    if (sSm < cfg.emote.size.min)
     sSm = cfg.emote.size.min;
    document.documentElement.style.setProperty('--height', sH + 'px');
    document.documentElement.style.setProperty('--width', sW + 'px');
    document.documentElement.style.setProperty('--emote-height', sS + 'px');
    document.documentElement.style.setProperty('--emote-height-s', Math.ceil(sS * 0.5) + 'px');
    document.documentElement.style.setProperty('--emote-height-l', (sS * 2) + 'px');
    let waitFor = getKappaCountEstimate(kStyle);
    if (!canShowKappa(kStyle))
    {
     toKappa.push({list: kList, style: kStyle.style, prefs: kStyle.prefs, params: kParams});
     if (tKappa !== false)
     {
      window.clearTimeout(tKappa);
      tKappa = false;
     }
     tKappa = window.setTimeout(showKappas, 500);
     return;
    }
    eActive += waitFor;
    let lK = kList.length;
    switch(kStyle.style)
    {
     case 'Stampede':
      await showKappa_Stampede(kList, sW, sH, sS, kStyle.count);
      eActive -= kStyle.count;
      break;
     case 'Fireworks':
      showKappa_Fireworks(kList, sW, sH, sSm, kStyle.count);
      break;
     case 'Spiral':
      showKappa_Spiral(kList, sW, sH, sSm, kStyle.count);
      break;
     case 'Pyramid':
      showKappa_Pyramid(kList, sW, sH);
      break;
     case 'SmallPyramid':
      showKappa_SmallPyramid(kList, sW, sH);
      break;
     case 'Conga':
      eActive -= waitFor;
      let avoidMiddle = false;
      if (cfg.display.kappa.conga.hasOwnProperty('avoidMiddle') && cfg.display.kappa.conga.avoidMiddle === true)
       avoidMiddle = true;
      if (kStyle.prefs.hasOwnProperty('avoidMiddle') && kStyle.prefs.avoidMiddle === true)
       avoidMiddle = true;
      showKappa_Conga(kList, sW, sH, sS, avoidMiddle);
      break;
     case 'Text':
      eActive -= waitFor;
      let sTM = 'HYPE!';
      if (cfg.display.kappa.styles.hasOwnProperty('Text') && cfg.display.kappa.styles['Text'].hasOwnProperty('message'))
       sTM = cfg.display.kappa.styles['Text'].message[rnd(cfg.display.kappa.styles['Text'].message.length)];
      if (kStyle.prefs.hasOwnProperty('message'))
       sTM = kStyle.prefs.message[rnd(kStyle.prefs.message.length)];
      let sTT = cfg.emote.time;
      if (cfg.display.kappa.styles.hasOwnProperty('Text') && cfg.display.kappa.styles['Text'].hasOwnProperty('time'))
       sTT = cfg.display.kappa.styles['Text'].time;
      if (kStyle.prefs.hasOwnProperty('time'))
       sTT = kStyle.prefs.time;
      if (kParams !== false)
      {
       let pK = Object.keys(kParams);
       for (let i = 0, l = pK.length; i < l; i++)
       {
        sTM = sTM.replaceAll(pK[i], kParams[pK[i]]);
       }
      }
      showKappa_Text(kList, sW, sH, sTM, sTT);
      break;
     case 'TheCube':
      eActive -= waitFor;
      let cS = sW;
      if (sW > sH)
       cS = sH;
      let r = rnd(lK);
      let sCS = cfg.display.kappa.styles['TheCube'].size;
      if (kStyle.prefs.hasOwnProperty('size'))
       sCS = kStyle.prefs.size;
      let sCC = cfg.display.kappa.styles['TheCube'].center;
      if (kStyle.prefs.hasOwnProperty('center'))
       sCC = kStyle.prefs.center;
      let sCR = cfg.display.kappa.styles['TheCube'].rotations;
      if (kStyle.prefs.hasOwnProperty('rotations'))
       sCR = kStyle.prefs.rotations;
      showKappa_TheCube(kList[r].url, kList[r].zwe ?? [], sW, sH, Math.floor(cS * sCS), sCC, sCR);
      break;
     case 'Burst':
      let oH = Math.floor((rnd() * ((sW - sS) * 0.33)) + (sW - sS) * 0.33);
      let oV = Math.floor((rnd() * ((sH - sS) * 0.33)) + (sH - sS) * 0.33);
      for (let i = 0; i < kStyle.count; i++)
      {
       let r = rnd(lK);
       eActive--;
       showEmote_StraightLine(kList[r].url, kList[r].zwe ?? [], sW, sH, sS, oH, oV, false);
       await sleep(50);
      }
      break;
     case 'Fountain':
      let fX = Math.floor((rnd() * ((sW - sS) * 0.33)) + (sW - sS) * 0.33);
      let fY = rnd(25) + 15;
      for (let i = 0; i < kStyle.count; i++)
      {
       let r = rnd(lK);
       eActive--;
       showEmote_Fountain(kList[r].url, kList[r].zwe ?? [], sW, sH, sS, fX, fY, false);
       await sleep(50);
      }
      break;
     case 'Confetti':
      for (let i = 0; i < kStyle.count; i++)
      {
       let r = rnd(lK);
       eActive--;
       showEmote_Confetti(kList[r].url, kList[r].zwe ?? [], sW, sH, sSm, false);
       await sleep(25);
      }
      break;
     default:
      if (typeof window['showEmote_' + kStyle.style] === 'undefined')
       return false;
      for (let i = 0; i < kStyle.count; i++)
      {
       let r = rnd(lK);
       eActive--;
       if (kStyle.style === 'StraightLine')
        showEmote_StraightLine(kList[r].url, kList[r].zwe ?? [], sW, sH, sS, false, false, false);
       else
        window['showEmote_' + kStyle.style](kList[r].url, kList[r].zwe ?? [], sW, sH, sS, false);
       await sleep(100);
      }
    }
   }

   async function parseEmoji(cmd, set, dup = null)
   {
    if (cmd.params.length < 2)
     return [];
    let msg = cmd.params[1];
    let emSeg = /((?:[\p{EPres}\p{ExtPict}]\ufe0f?\u200d?)+)+/gu;
    let emList = [];
    let match = '';
    while ((match = emSeg.exec(msg)) != null)
    {
     emList.push(match);
    }
    if (emList.length === 0)
     return [];
    if (dup === null)
     dup = cfg.display.duplicates;
    if (set === true)
     set = 'twemoji';
    let ret = [];
    let uri = 'https://cdn.frankerfacez.com/static/emoji/images/' + set + '/';
    let addList = {};
    function showEmoji(c, p)
    {
     if (c.slice(-5) === '-fe0f' && !c.match(/-200d-264[0|2]-/) && !c.match(/-200d-26a7/) && !c.match(/-200d-2620/))
      c = c.slice(0, -5);
     if (!addList.hasOwnProperty(c))
      addList[c] = 0;
     else
     {
      if (dup === false)
       return false;
      if (dup !== true && addList[c] >= dup)
       return false;
     }
     addList[c]++;
     ret.push({svc: 'e', url: uri + c + '.png', str: c, pos: p});
     return true;
    }
    for (let i = 0, l = emList.length; i < l; i++)
    {
     let cpList = [];
     for (const c of emList[i][0])
     {
      let p = c.codePointAt(0).toString(16);
      if (cpList.length === 0)
      {
       cpList.push(p);
       continue;
      }
      let lL = cpList.length - 1;
      if (p === 'fe0f') //emoji variation
       cpList[lL] += '-' + p;
      else if (p === '200d') //zwj
       cpList[lL] += '-' + p;
      else if (p.match(/1f3f[b-f]/)) //skin tone
       cpList[lL] += '-' + p;
      else if (p.match(/1f9b[0-3]/)) //hair
      {
       if (cpList[lL].slice(-5) === '-200d')
        cpList[lL] += '-' + p;
       else
        cpList[lL] += '-200d-' + p;
      }
      else if (p.match(/264[0|2]/) || p.match(/26a7/)) //gender
      {
       if (cpList[lL].slice(-5) === '-200d')
        cpList[lL] += '-' + p;
       else
        cpList[lL] += '-200d-' + p;
      }
      else if (p.match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].length < 11) //country code (2 chars max)
       cpList[lL] += '-' + p;
      else if (p === '1f308' && cpList[lL] === '1f3f3-fe0f') //rainbow flag
       cpList[lL] += '-200d-' + p;
      else if (p === '2620' && cpList[lL] === '1f3f4') //pirate flag
       cpList[lL] += '-200d-' + p;
      else if (cpList[lL].slice(-5) === '-200d') //post-zwj
       cpList[lL] += '-' + p;
      else
       cpList.push(p);
     }
     let found = false;
     let lP = cpList.length;
     if (lP === 1)
     {
      let s = cpList[0];
      let tU;
      if (s.slice(-5) === '-fe0f')
      {
       if (s.match(/-200d-264[0|2]-/) || s.match(/-200d-26a7/) || s.match(/-200d-2620/))
        tU = uri + s + '.png';
       else
        tU = uri + s.slice(0, -5) + '.png';
      }
      else
       tU = uri + s + '.png';
      found = await checkURL(tU);
      if (found)
      {
       showEmoji(s, emList[i].index);
       continue;
      }
      while (s.includes('-'))
      {
       s = s.slice(0, s.lastIndexOf('-'));
       if (s.slice(-5) === '-fe0f')
        tU = uri + s.slice(0, -5) + '.png';
       else
        tU = uri + s + '.png';
       found = await checkURL(tU);
       if (found)
       {
        showEmoji(s, emList[i].index);
        break;
       }
      }
      continue;
     }
     let p = emList[i].index;
     for (let j = 0; j < lP; j++)
     {
      p += cpList[j].replaceAll(/[^\-]/g, '').length + 1;
      found = await checkURL(uri + cpList[j] + '.png');
      if (found)
       showEmoji(cpList[j], p);
     }
    }
    return ret;
   }

   function parseT(cmd, dup = null)
   {
    if (!cmd.hasOwnProperty('tags'))
     return [];
    if (!cmd.tags.hasOwnProperty('emotes'))
     return [];
    if (cmd.tags.emotes === '')
     return [];
    let f = 'default';
    let t = 'dark';
    let r = '3.0';
    if (cmd.params.length < 2)
     return [];
    let m = cmd.params[1];
    let e = cmd.tags.emotes.split('/');
    if (dup === null)
     dup = cfg.display.duplicates;
    let ret = [];
    for (let i = 0, n = e.length; i < n; i++)
    {
     let eID = e[i].slice(0, e[i].indexOf(':'));
     let u = 'https://static-cdn.jtvnw.net/emoticons/v2/' + eID + '/' + f + '/' + t + '/' + r;
     let eVals = e[i].slice(e[i].indexOf(':') + 1).split(',');
     let eStart = parseInt(eVals[0].split('-')[0], 10);
     let eEnd = parseInt(eVals[0].split('-')[1], 10);
     let sName = m.slice(eStart, (eEnd + 1));
     let l = eVals.length;
     if (dup === false)
      l = 1;
     else if (dup !== true && l > dup)
      l = dup;
     for (let c = 0; c < l; c++)
     {
      let p = parseInt(eVals[c].split('-')[0], 10);
      ret.push({svc: 't', url: u, str: sName, pos: p});
     }
    }
    return ret;
   }

   function parseFFZ(cmd, dup = null)
   {
    if (!eList.hasOwnProperty('ffz'))
     return [];
    if (cmd.params.length < 2)
     return [];
    let m = cmd.params[1].split(' ');
    if (dup === null)
     dup = cfg.display.duplicates;
    let ret = [];
    let addList = {};
    for (let i = 0, l = m.length; i < l; i++)
    {
     if (!eList.ffz.hasOwnProperty(m[i]))
      continue;
     if (eList.ffz[m[i]].users !== null)
     {
      let u = parseUser(cmd);
      if (!eList.ffz[m[i]].users.includes(u.host))
       continue;
     }
     if (!addList.hasOwnProperty(m[i]))
      addList[m[i]] = 0;
     else
     {
      if (dup === false)
       continue;
      if (dup !== true && addList[m[i]] >= dup)
       continue;
     }
     addList[m[i]]++;
     let p = 0;
     for (let j = 0; j < i; j++)
     {
      p+= m[j].length + 1;
     }
     ret.push({svc: 'f', url: eList.ffz[m[i]].url, str: m[i], pos: p, scope: eList.ffz[m[i]].scope});
    }
    return ret;
   }

   function parseBTTV(cmd, dup = null)
   {
    if (!eList.hasOwnProperty('bttv'))
     return [];
    if (cmd.params.length < 2)
     return [];
    let m = cmd.params[1].split(' ');
    if (dup === null)
     dup = cfg.display.duplicates;
    let ret = [];
    let addList = {};
    for (let i = 0, l = m.length; i < l; i++)
    {
     if (!eList.bttv.hasOwnProperty(m[i]))
      continue;
     if (!addList.hasOwnProperty(m[i]))
      addList[m[i]] = 0;
     else
     {
      if (dup === false)
       continue;
      if (dup !== true && addList[m[i]] >= dup)
       continue;
     }
     addList[m[i]]++;
     let p = 0;
     for (let j = 0; j < i; j++)
     {
      p+= m[j].length + 1;
     }
     ret.push({svc: 'b', url: eList.bttv[m[i]].url, str: m[i], pos: p, scope: eList.bttv[m[i]].scope});
    }
    return ret;
   }

   function parseBTTVZWE(l, cmd, pass, dup = null)
   {
    if (!cfg.display.extended.useZWE)
     return;
    if (!eList.hasOwnProperty('zwe'))
     return;
    if (!eList.zwe.hasOwnProperty('bttv'))
     return;
    if (cmd.params.length < 2)
     return;
    l.sort(function(a, b){return a.pos - b.pos;});
    let m = cmd.params[1].split(' ');
    if (dup === null)
     dup = cfg.display.duplicates;
    let addList = {};
    for (let i = 0, n = m.length; i < n; i++)
    {
     if (!eList.zwe.bttv.hasOwnProperty(m[i]))
      continue;
     if (!addList.hasOwnProperty(m[i]))
      addList[m[i]] = 0;
     else
     {
      if (dup === false)
       continue;
      if (dup !== true && addList[m[i]] >= dup)
       continue;
     }
     addList[m[i]]++;
     let p = 0;
     for (let j = 0; j < i; j++)
     {
      p+= m[j].length + 1;
     }
     let f = -1;
     let h = -1;
     for (let j = 0, o = l.length; j < o; j++)
     {
      if (l[j].pos > h)
       h = l[j].pos;
      else
       continue;
      if (l[j].pos < p)
       f = j;
     }
     if (f === -1)
     {
      if (pass === 1)
       l.push({svc: 'b', url: eList.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: eList.zwe.bttv[m[i]].scope});
     }
     else
     {
      let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
      let b = Object.keys(eList.zwe.bttv);
      for (let j = 0, o = b.length; j < o; j++)
      {
       t = t.replaceAll(b[j], '');
      }
      if (eList.zwe.hasOwnProperty('7tv'))
      {
       b = Object.keys(eList.zwe['7tv']);
       for (let j = 0, o = b.length; j < o; j++)
       {
        t = t.replaceAll(b[j], '');
       }
      }
      t = t.trim();
      if (t.length > 0)
      {
       if (pass === 1)
        l.push({svc: 'b', url: eList.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: eList.zwe.bttv[m[i]].scope});
      }
      else if (pass === 2)
      {
       if (!l[f].hasOwnProperty('zwe'))
        l[f].zwe = [];
       l[f].zwe.push({svc: 'b', url: eList.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: eList.zwe.bttv[m[i]].scope});
       l[f].zwe.sort(function(a, b){return a.pos - b.pos;});
       for (let j = 0, o = l.length; j < o; j++)
       {
        if (l[j].svc !== 'b')
         continue;
        if (l[j].pos !== p)
         continue;
        l.splice(j, 1);
        break;
       }
      }
     }
    }
   }

   function parseBTTVU(cmd, dup = null)
   {
    if (!eList.hasOwnProperty('bttvU'))
     return [];
    if (cmd.params.length < 2)
     return [];
    let u = parseUser(cmd);
    if (!eList.bttvU.hasOwnProperty(u.host))
     return [];
    let m = cmd.params[1].split(' ');
    if (dup === null)
     dup = cfg.display.duplicates;
    let ret = [];
    let addList = {};
    for (let i = 0, l = m.length; i < l; i++)
    {
     if (!eList.bttvU[u.host].hasOwnProperty(m[i]))
      continue;
     if (!addList.hasOwnProperty(m[i]))
      addList[m[i]] = 0;
     else
     {
      if (dup === false)
       continue;
      if (dup !== true && addList[m[i]] >= dup)
       continue;
     }
     addList[m[i]]++;
     let p = 0;
     for (let j = 0; j < i; j++)
     {
      p+= m[j].length + 1;
     }
     ret.push({svc: 'b', url: eList.bttvU[u.host][m[i]].url, str: m[i], pos: p, scope: eList.bttvU[u.host][m[i]].scope});
    }
    return ret;
   }

   function parse7TV(cmd, dup = null)
   {
    if (!eList.hasOwnProperty('7tv'))
     return [];
    if (cmd.params.length < 2)
     return [];
    let m = cmd.params[1].split(' ');
    if (dup === null)
     dup = cfg.display.duplicates;
    let ret = [];
    let addList = {};
    for (let i = 0, l = m.length; i < l; i++)
    {
     if (!eList['7tv'].hasOwnProperty(m[i]))
      continue;
     if (!addList.hasOwnProperty(m[i]))
      addList[m[i]] = 0;
     else
     {
      if (dup === false)
       continue;
      if (dup !== true && addList[m[i]] >= dup)
       continue;
     }
     addList[m[i]]++;
     let p = 0;
     for (let j = 0; j < i; j++)
     {
      p+= m[j].length + 1;
     }
     ret.push({svc: '7', url: eList['7tv'][m[i]].url, str: m[i], pos: p, scope: eList['7tv'][m[i]].scope});
    }
    return ret;
   }

   function parse7TVZWE(l, cmd, pass, dup = null)
   {
    if (!cfg.display.extended.useZWE)
     return;
    if (!eList.hasOwnProperty('zwe'))
     return;
    if (!eList.zwe.hasOwnProperty('7tv'))
     return;
    if (cmd.params.length < 2)
     return;
    l.sort(function(a, b){return a.pos - b.pos;});
    let m = cmd.params[1].split(' ');
    if (dup === null)
     dup = cfg.display.duplicates;
    let addList = {};
    for (let i = 0, n = m.length; i < n; i++)
    {
     if (!eList.zwe['7tv'].hasOwnProperty(m[i]))
      continue;
     if (!addList.hasOwnProperty(m[i]))
      addList[m[i]] = 0;
     else
     {
      if (dup === false)
       continue;
      if (dup !== true && addList[m[i]] >= dup)
       continue;
     }
     addList[m[i]]++;
     let p = 0;
     for (let j = 0; j < i; j++)
     {
      p+= m[j].length + 1;
     }
     let f = -1;
     let h = -1;
     for (let j = 0, o = l.length; j < o; j++)
     {
      if (l[j].pos > h)
       h = l[j].pos;
      else
       continue;
      if (l[j].pos < p)
       f = j;
     }
     if (f === -1)
     {
      if (pass === 1)
       l.push({svc: '7', url: eList.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: eList.zwe['7tv'][m[i]].scope});
     }
     else
     {
      let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
      let b = Object.keys(eList.zwe['7tv']);
      for (let j = 0, o = b.length; j < o; j++)
      {
       t = t.replaceAll(b[j], '');
      }
      if (eList.zwe.hasOwnProperty('bttv'))
      {
       b = Object.keys(eList.zwe.bttv);
       for (let j = 0, o = b.length; j < o; j++)
       {
        t = t.replaceAll(b[j], '');
       }
      }
      t = t.trim();
      if (t.length > 0)
      {
       if (pass === 1)
        l.push({svc: '7', url: eList.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: eList.zwe['7tv'][m[i]].scope});
      }
      else if (pass === 2)
      {
       if (!l[f].hasOwnProperty('zwe'))
        l[f].zwe = [];
       l[f].zwe.push({svc: '7', url: eList.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: eList.zwe['7tv'][m[i]].scope});
       l[f].zwe.sort(function(a, b){return a.pos - b.pos;});
       for (let j = 0, o = l.length; j < o; j++)
       {
        if (l[j].svc !== '7')
         continue;
        if (l[j].pos !== p)
         continue;
        l.splice(j, 1);
        break;
       }
      }
     }
    }
   }

   function streamlabsWS()
   {
    let wsRetry = 0;
    let p = 0;
    const ws = new WebSocket('wss://sockets.streamlabs.com/socket.io/?token=' + cfg.streamlabs.token + '&transport=websocket');
    ws.onclose = function(event)
    {
     if (p !== 0)
     {
      window.clearInterval(p);
      p = 0;
     }
     ws.onmessage = null;
     ws.onclose = null;
     if (dead)
      return;
     let wsWait = Math.floor((wWS ** (1 + wsRetry)) * 1000);
     if (wsRetry < 2)
      wsRetry += 0.2;
     window.setTimeout(function(){streamlabsWS();}, wsWait);
    };
    ws.onmessage = async function(event)
    {
     if (dead)
     {
      ws.close();
      return;
     }
     wsRetry = 0;
     let d = event.data;
     if (d.length < 1)
      return;
     switch (d.slice(0, 1))
     {
      case '0':
       let t = 20000;
       if (d.length > 1)
       {
        let c = JSON.parse(d.slice(1));
        if (c.hasOwnProperty('pingInterval'))
         t = c.pingInterval;
       }
       if (p !== 0)
       {
        window.clearInterval(p);
        p = 0;
       }
       p = window.setInterval(function(){ws.send('2');}, t);
       break;
      case '4':
       if (document.visibilityState === 'hidden')
        return;
       if (d.slice(1, 2) !== '2')
        return;
       if (d.length < 2)
        return;
       let o = JSON.parse(d.slice(2));
       if (o.length < 2)
        return;
       if (o[0] !== 'event')
        return;
       if (!o[1].hasOwnProperty('message'))
        return;
       let rD = [];
       let rP = [];
       for (let i = 0, l = o[1].message.length; i < l; i++)
       {
        if (!o[1].message[i].hasOwnProperty('amount'))
         continue;
        if (!o[1].message[i].hasOwnProperty('type'))
         continue;
        if (o[1].message[i].type === 'donation')
        {
         let n = false;
         if (o[1].message[i].hasOwnProperty('name'))
          n = o[1].message[i].name;
         rD.push({amt: o[1].message[i].amount, name: n});
        }
        if (o[1].message[i].type === 'pledge')
        {
         let n = false;
         if (o[1].message[i].hasOwnProperty('name'))
          n = o[1].message[i].name;
         rP.push({amt: o[1].message[i].amount, name: n});
        }
       }
       if (rD.length > 0)
        await showStreamlabsDonations(rD);
       if (rP.length > 0)
        await showStreamlabsPledges(rP);
       break;
     }
    };
   }

   async function showStreamlabsDonations(dRet)
   {
    for (let i = 0, l = dRet.length; i < l; i++)
    {
     let n = dRet[i].name;
     let a = dRet[i].amt;
     let v = Math.floor(a * cfg.streamlabs.curMul);
     let r = findInMaybeRange(cfg.event.tip.streamlabs.donation, v);
     if (r === false)
      continue;
     let p = false;
     if (cfg.event.tip.useProfileImage && n !== false)
     {
      let u = false;
      if (!(/[^A-Za-z0-9_]/).test(n))
       u = await getUserInfo(n);
      if (u !== false)
      {
       if (u.hasOwnProperty('profile_image_url'))
        p = [
         {url: u['profile_image_url']}
        ];
      }
     }
     let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
     if (cfg.streamlabs.dispDec > 0)
      s = s.toFixed(cfg.streamlabs.dispDec);
     else
      s = Math.floor(s);
     if (cfg.streamlabs.dispPre !== false)
      s = cfg.streamlabs.dispPre + s;
     if (cfg.streamlabs.dispSuf !== false)
      s += cfg.streamlabs.dispSuf;
     showKappa(p, r, {'%USER%': n, '%AMOUNT%': s});
    }
   }

   async function showStreamlabsPledges(pRet)
   {
    for (let i = 0, l = pRet.length; i < l; i++)
    {
     let n = pRet[i].name;
     let a = pRet[i].amt;
     let v = Math.floor(a * cfg.streamlabs.curMul);
     let r = findInMaybeRange(cfg.event.tip.streamlabs.pledge, v);
     if (r === false)
      continue;
     let p = false;
     if (cfg.event.tip.useProfileImage && n !== false)
     {
      let u = false;
      if (!(/[^A-Za-z0-9_]/).test(n))
       u = await getUserInfo(n);
      if (u !== false)
      {
       if (u.hasOwnProperty('profile_image_url'))
        p = [
         {url: u['profile_image_url']}
        ];
      }
     }
     let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
     if (cfg.streamlabs.dispDec > 0)
      s = s.toFixed(cfg.streamlabs.dispDec);
     else
      s = Math.floor(s);
     if (cfg.streamlabs.dispPre !== false)
      s = cfg.streamlabs.dispPre + s;
     if (cfg.streamlabs.dispSuf !== false)
      s += cfg.streamlabs.dispSuf;
     showKappa(p, r, {'%USER%': n, '%AMOUNT%': s});
    }
   }

   function streamelementsWS()
   {
    let wsRetry = 0;
    let p = 0;
    const ws = new WebSocket('wss://realtime.streamelements.com/socket.io/?transport=websocket');
    ws.onclose = function(event)
    {
     if (p !== 0)
     {
      window.clearInterval(p);
      p = 0;
     }
     ws.onmessage = null;
     ws.onclose = null;
     if (dead)
      return;
     let wsWait = Math.floor((wWS ** (1 + wsRetry)) * 1000);
     if (wsRetry < 2)
      wsRetry += 0.2;
     window.setTimeout(function(){streamelementsWS();}, wsWait);
    };
    ws.onmessage = async function(event)
    {
     if (dead)
     {
      ws.close();
      return;
     }
     wsRetry = 0;
     let d = event.data;
     if (d.length < 1)
      return;
     switch (d.slice(0, 1))
     {
      case '0':
       let t = 20000;
       if (d.length > 1)
       {
        let c = JSON.parse(d.slice(1));
        if (c.hasOwnProperty('pingInterval'))
         t = c.pingInterval;
       }
       if (p !== 0)
       {
        window.clearInterval(p);
        p = 0;
       }
       p = window.setInterval(function(){ws.send('2');}, t);
       break;
      case '4':
       if (document.visibilityState === 'hidden')
        return;
       if (d.slice(1, 2) === '0')
       {
        let a = '';
        if (cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== 'OAUTH_ID')
         a = '["authenticate",{"method":"oauth2","token":"' + cfg.streamelements.oauth + '"}]';
        else if (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== 'JWT_TOKEN')
         a = '["authenticate",{"method":"jwt","token":"' + cfg.streamelements.token + '"}]';
        ws.send('42' + a);
        return;
       }
       if (d.slice(1, 2) !== '2')
        return;
       if (d.length < 2)
        return;
       let o = JSON.parse(d.slice(2));
       if (o.length < 2)
        return;
       if (o[0] !== 'event:update')
        return;
       if (!o[1].hasOwnProperty('name'))
        return;
       if (o[1].name !== 'tip-latest')
        return;
       if (!o[1].hasOwnProperty('data'))
        return;
       if (!o[1].data.hasOwnProperty('amount'))
        return;
       let n = false;
       if (o[1].data.hasOwnProperty('name'))
        n = o[1].data.name;
       await showStreamElementsTip(o[1].data.amount, n);
       break;
     }
    };
   }

   async function showStreamElementsTip(dAmt, dName)
   {
    let v = Math.floor(dAmt * cfg.streamelements.curMul);
    if (v < 1)
     return;
    let r = findInMaybeRange(cfg.event.tip.streamelements, v);
    if (r === false)
     return;
    let p = false;
    if (cfg.event.tip.useProfileImage && dName !== false)
    {
     let u = false;
     if (!(/[^A-Za-z0-9_]/).test(dName))
      u = await getUserInfo(dName);
     if (u !== false)
     {
      if (u.hasOwnProperty('profile_image_url'))
       p = [
        {url: u['profile_image_url']}
       ];
     }
    }
    let s = Number.parseFloat(dAmt * cfg.streamelements.dispMul);
    if (cfg.streamelements.dispDec > 0)
     s = s.toFixed(cfg.streamelements.dispDec);
    else
     s = Math.floor(s);
    if (cfg.streamelements.dispPre !== false)
     s = cfg.streamelements.dispPre + s;
    if (cfg.streamelements.dispSuf !== false)
     s += cfg.streamelements.dispSuf;
    showKappa(p, r, {'%USER%': dName, '%AMOUNT%': s});
   }

   async function detectFollowers(chID)
   {
    if (tFC === false)
     return;
    window.clearTimeout(tFC);
    tFC = false;
    let fRet = await getFollowerChange(chID);
    if (document.visibilityState !== 'hidden' && fRet !== false && fRet.length > 0)
    {
     for (let i = 0, l = fRet.length; i < l; i++)
      showKappa(false, cfg.event.follow, {'%USER%': fRet[i]});
    }
    tFC = window.setTimeout(detectFollowers, rFC, chID);
   }

   function getFollowerChange(chID)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.twitch.tv/helix/users/follows?to_id=' + chID + '&first=100&nocache=' + rnd(0xFFFFFFFF));
      x.setRequestHeader('Authorization', 'Bearer ' + cfg.login.oauth);
      x.setRequestHeader('Client-Id', cfg.login.client);
      x.onreadystatechange = async function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('total') || j.total < 1)
       {
        resolve(false);
        return;
       }
       if (!j.hasOwnProperty('data') || !Array.isArray(j.data) || j.data.length < 1)
       {
        resolve(false);
        return;
       }
       let findU = uLF;
       uLF = j.data[0].from_id;
       if (findU === false)
       {
        resolve(false);
        return;
       }
       let s = [];
       for (let i = 0, l = j.data.length; i < l; i++)
       {
        if (j.data[i].from_id === findU)
        {
         resolve(s);
         return;
        }
        fList[j.data[i].from_id] = {value: true, t: new Date().getTime()};
        s.push(j.data[i].from_name);
       }
       resolve([]);
      };
      x.send();
     }
    );
    return p;
   }

   function checkFollower(cmd)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let uID = cmd.tags['user-id'];
      if (fList.hasOwnProperty(uID))
      {
       let tDif = new Date().getTime() - fList[uID].t;
       if (tDif < rFH)
       {
        resolve(fList[uID].value);
        return;
       }
      }
      let chID = cmd.tags['room-id'];
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.twitch.tv/helix/users/follows?from_id=' + uID + '&to_id=' + chID + '&nocache=' + rnd(0xFFFFFFFF));
      x.setRequestHeader('Authorization', 'Bearer ' + cfg.login.oauth);
      x.setRequestHeader('Client-Id', cfg.login.client);
      x.onreadystatechange = async function()
      {
       if (x.readyState < 2)
        return;
       if (x.status !== 200)
       {
        x.onreadystatechange = null;
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       x.onreadystatechange = null;
       if (x.responseText === null)
       {
        resolve(false);
        return;
       }
       let j = JSON.parse(x.responseText);
       if (j.hasOwnProperty('total') && j.total > 0)
       {
        fList[uID] = {value: true, t: new Date().getTime()};
        resolve(true);
        return;
       }
       fList[uID] = {value: false, t: new Date().getTime()};
       resolve(false);
      };
      x.send();
     }
    );
    return p;
   }

   async function parseLevel(cmd)
   {
    let level = 0x001;
    if (cmd.tags.hasOwnProperty('mod') && cmd.tags.mod === '1')
     level |= 0x400;
    if (cmd.tags.hasOwnProperty('vip') && cmd.tags.vip === '1')
     level |= 0x100;
    if (cmd.tags.hasOwnProperty('badges'))
    {
     let badges = cmd.tags.badges.split(',');
     for (let i = 0, l = badges.length; i < l; i++)
     {
      let bData = jSplit(badges[i], '/', 2);
      switch (bData[0])
      {
       case 'broadcaster':
        level |= 0x800;
        break;
       case 'moderator':
        level |= 0x400;
        break;
       case 'vip':
        level |= 0x100;
        break;
       case 'artist-badge':
        level |= 0x080;
        break;
       case 'founder':
        level |= 0x200;
        break;
       case 'bits':
        level |= 0x004;
        break;
       case 'subscriber':
        let badge = parseInt(bData[1], 10);
        if (badge < 2000)
         level |= 0x010;
        else if (badge < 3000)
         level |= 0x020;
        else
         level |= 0x040;
        break;
      }
     }
    }
    /* api-heavy, only check if follower access is allowed and there's a chance it matters */
    let needF = false;
    if ((cfg.display.access & 0x002) === 0x002 && (cfg.display.access & 0x001) !== 0x001)
     needF = true;
    else if ((cfg.display.kappa.access & 0x002) === 0x002 && (cfg.display.kappa.access & 0x001) !== 0x001)
     needF = true;
    else
    {
     for (const k in cfg.display.kappa.styles)
     {
      if (!cfg.display.kappa.styles.hasOwnProperty(k))
       continue;
      if (!cfg.display.kappa.styles[k].hasOwnProperty('command'))
       continue;
      if (!cfg.display.kappa.styles[k].command.hasOwnProperty('access'))
       continue;
      if ((cfg.display.kappa.styles[k].command.access & 0x002) === 0x002 && (cfg.display.kappa.styles[k].command.access & 0x001) !== 0x001)
      {
       needF = true;
       break;
      }
     }
    }
    if (needF)
    {
     let f = await checkFollower(cmd);
     if (f)
      level |= 0x002;
    }
    return level;
   }

   function handleDuplicates(a)
   {
    let lA = a.length;
    if (lA < 1)
     return a;
    let r = [];
    for (let i = 0; i < lA; i++)
    {
     if (a[i].scope === 'u')
      r.push(a[i]);
    }
    for (let i = 0; i < lA; i++)
    {
     if (a[i].svc === 't' || a[i].svc === 'c' || a[i].svc === 'e')
      r.push(a[i]);
    }
    for (let i = 0; i < lA; i++)
    {
     if ((a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7') && (a[i].scope === 'c'))
     {
      let f = false;
      for (let j = 0, l = r.length; j < l; j++)
      {
       if (r[j].str === a[i].str)
       {
        f = true;
        if (r[j].svc === a[i].svc)
         r.push(a[i]);
        break;
       }
      }
      if (!f)
       r.push(a[i]);
     }
    }
    for (let i = 0; i < lA; i++)
    {
     if ((a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7') && (a[i].scope !== 'c'))
     {
      let f = false;
      for (let j = 0, l = r.length; j < l; j++)
      {
       if (r[j].str === a[i].str)
       {
        f = true;
        if (r[j].svc === a[i].svc)
         r.push(a[i]);
        break;
       }
      }
      if (!f)
       r.push(a[i]);
     }
    }
    return r;
   }

   async function parseCheer(cmd)
   {
    if (!eList.hasOwnProperty('cheer'))
     return false;
    if (!cmd.hasOwnProperty('tags'))
     return false;
    if (!cmd.tags.hasOwnProperty('bits'))
     return false;
    if (cmd.tags.bits < 1)
     return false;
    let p = [];
    let msg = cmd.params[1].split(' ');
    for (let m = 0, l = msg.length; m < l; m++)
    {
     for (const prefix in eList.cheer)
     {
      if (!eList.cheer.hasOwnProperty(prefix))
       continue;
      let firstChars = prefix.length;
      if (msg[m].slice(0, firstChars).toLowerCase() !== prefix.toLowerCase())
       continue;
      let amt = msg[m].slice(firstChars);
      if (isNaN(amt))
       continue;
      for (let i = 0, n = eList.cheer[prefix].length; i < n; i++)
      {
       if (parseInt(amt, 10) < eList.cheer[prefix][i].min)
        continue;
       let sName = prefix + eList.cheer[prefix][i].min;
       p.push({svc: 'c', url: eList.cheer[prefix][i].img, str: sName});
       break;
      }
     }
    }
    if (cfg.event.cheer.useMsg)
    {
     p = p.concat(parseT(cmd));
     if (cfg.display.useEmoji)
      p = p.concat(await parseEmoji(cmd, cfg.display.useEmoji));
     if (cfg.display.extended.useFFZ)
      p = p.concat(parseFFZ(cmd));
     if (cfg.display.extended.useBTTV)
     {
      p = p.concat(parseBTTV(cmd));
      p = p.concat(parseBTTVU(cmd));
     }
     if (cfg.display.extended.use7TV)
      p = p.concat(parse7TV(cmd));
     if (cfg.display.extended.useBTTV)
      parseBTTVZWE(p, cmd, 1);
     if (cfg.display.extended.use7TV)
      parse7TVZWE(p, cmd, 1);
     if (cfg.display.extended.useBTTV)
      parseBTTVZWE(p, cmd, 2);
     if (cfg.display.extended.use7TV)
      parse7TVZWE(p, cmd, 2);
    }
    else
     await parseLine(cmd);
    p = handleDuplicates(p);
    if (p.length === 0)
     return false;
    let r = findInMaybeRange(cfg.event.cheer.bits, cmd.tags.bits);
    if (r === false)
    {
     toShow = toShow.concat(p);
     showEmotes();
     return true;
    }
    let u = parseUser(cmd, true);
    let dn = 'Anonymous';
    if (u.hasOwnProperty('display-name'))
     dn = u['display-name'];
    showKappa(p, r, {'%USER%': dn, '%AMOUNT%': cmd.tags.bits});
    return true;
   }

   async function parseLine(cmd)
   {
    let level = -1;
    let kNow = new Date().getTime();
    if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('custom-reward-id'))
    {
     let lnID = cmd.tags['custom-reward-id'];
     if (!rList.hasOwnProperty(lnID))
     {
      rList[lnID] = {name: false, cmds: [cmd]};
      return;
     }
     rList[lnID].cmds.push(cmd);
     if (rList[lnID].name === false)
      return;
     while (rList[lnID].cmds.length > 0)
     {
      await parseRedeem(rList[lnID].name, rList[lnID].cmds.shift());
     }
     return;
    }
    if (cmd.params.length > 1 && (cfg.display.kappa.cooldown === 0 || (kNow - kLast) > (cfg.display.kappa.cooldown * 1000)))
    {
     let m = cmd.params[1].toLowerCase();
     for (const k in cfg.display.kappa.styles)
     {
      if (!cfg.display.kappa.styles.hasOwnProperty(k))
       continue;
      if (!cfg.display.kappa.styles[k].hasOwnProperty('command'))
       continue;
      if (!cfg.display.kappa.styles[k].command.hasOwnProperty('aliases'))
       continue;
      let kAccess = cfg.display.kappa.access;
      if (cfg.display.kappa.styles[k].command.hasOwnProperty('access'))
       kAccess = cfg.display.kappa.styles[k].command.access;
      let kC = {};
      kC[k] = cfg.display.kappa.styles[k];
      if (cfg.display.kappa.styles[k].command.aliases.includes(m))
      {
       if (level === -1)
        level = await parseLevel(cmd);
       if ((level & kAccess) !== 0)
       {
        kLast = kNow;
        showKappa(false, kC);
        return;
       }
      }
      let foundKCmd = false;
      for (let i = 0, l = cfg.display.kappa.styles[k].command.aliases.length; i < l; i++)
      {
       if (m.slice(0, cfg.display.kappa.styles[k].command.aliases[i].length + 1) === cfg.display.kappa.styles[k].command.aliases[i] + ' ')
       {
        foundKCmd = true;
        break;
       }
      }
      if (foundKCmd)
      {
       if (level === -1)
        level = await parseLevel(cmd);
       if ((level & kAccess) !== 0)
       {
        let a = [];
        a = a.concat(parseT(cmd, true));
        if (cfg.display.useEmoji)
         a = a.concat(await parseEmoji(cmd, cfg.display.useEmoji, true));
        if (cfg.display.extended.useFFZ)
         a = a.concat(parseFFZ(cmd, true));
        if (cfg.display.extended.useBTTV)
        {
         a = a.concat(parseBTTV(cmd, true));
         a = a.concat(parseBTTVU(cmd, true));
        }
        if (cfg.display.extended.use7TV)
         a = a.concat(parse7TV(cmd, true));
        if (cfg.display.extended.useBTTV)
         parseBTTVZWE(a, cmd, 1, true);
        if (cfg.display.extended.use7TV)
         parse7TVZWE(a, cmd, 1, true);
        if (cfg.display.extended.useBTTV)
         parseBTTVZWE(a, cmd, 2, true);
        if (cfg.display.extended.use7TV)
         parse7TVZWE(a, cmd, 2, true);
        a = handleDuplicates(a);
        kLast = kNow;
        showKappa(a, kC);
        return;
       }
      }
     }
     if (cfg.display.kappa.aliases.includes(m))
     {
      if (level === -1)
       level = await parseLevel(cmd);
      if ((level & cfg.display.kappa.access) !== 0)
      {
       kLast = kNow;
       showKappa(false);
       return;
      }
     }
     let foundCmd = false;
     for (let i = 0, l = cfg.display.kappa.aliases.length; i < l; i++)
     {
      if (m.slice(0, cfg.display.kappa.aliases[i].length + 1) === cfg.display.kappa.aliases[i] + ' ')
      {
       foundCmd = true;
       break;
      }
     }
     if (foundCmd)
     {
      if (level === -1)
       level = await parseLevel(cmd);
      if ((level & cfg.display.kappa.access) !== 0)
      {
       let a = [];
       a = a.concat(parseT(cmd, true));
       if (cfg.display.useEmoji)
        a = a.concat(await parseEmoji(cmd, cfg.display.useEmoji, true));
       if (cfg.display.extended.useFFZ)
        a = a.concat(parseFFZ(cmd, true));
       if (cfg.display.extended.useBTTV)
       {
        a = a.concat(parseBTTV(cmd, true));
        a = a.concat(parseBTTVU(cmd, true));
       }
       if (cfg.display.extended.use7TV)
        a = a.concat(parse7TV(cmd, true));
       if (cfg.display.extended.useBTTV)
        parseBTTVZWE(a, cmd, 1, true);
       if (cfg.display.extended.use7TV)
        parse7TVZWE(a, cmd, 1, true);
       if (cfg.display.extended.useBTTV)
        parseBTTVZWE(a, cmd, 2, true);
       if (cfg.display.extended.use7TV)
        parse7TVZWE(a, cmd, 2, true);
       a = handleDuplicates(a);
       kLast = kNow;
       showKappa(a);
       return;
      }
     }
    }
    let p = [];
    p = p.concat(parseT(cmd));
    if (cfg.display.useEmoji)
     p = p.concat(await parseEmoji(cmd, cfg.display.useEmoji));
    if (cfg.display.extended.useFFZ)
     p = p.concat(parseFFZ(cmd));
    if (cfg.display.extended.useBTTV)
    {
     p = p.concat(parseBTTV(cmd));
     p = p.concat(parseBTTVU(cmd));
    }
    if (cfg.display.extended.use7TV)
     p = p.concat(parse7TV(cmd));
    if (cfg.display.extended.useBTTV)
     parseBTTVZWE(p, cmd, 1);
    if (cfg.display.extended.use7TV)
     parse7TVZWE(p, cmd, 1);
    if (cfg.display.extended.useBTTV)
     parseBTTVZWE(p, cmd, 2);
    if (cfg.display.extended.use7TV)
     parse7TVZWE(p, cmd, 2);
    p = handleDuplicates(p);
    if (p.length === 0)
     return;
    if (level === -1)
     level = await parseLevel(cmd);
    if ((level & cfg.display.access) === 0)
     return;
    toShow = toShow.concat(p);
    showEmotes();
   }

   async function parseRaid(cmd)
   {
    if (!cmd.tags.hasOwnProperty('msg-param-viewerCount'))
     return;
    let c = cmd.tags['msg-param-viewerCount'];
    let r = findInMaybeRange(cfg.event.raid.raiders, c);
    if (r === false)
     return;
    let u = parseUser(cmd, true);
    let dn = 'Anonymous';
    if (u.hasOwnProperty('display-name'))
     dn = u['display-name'];
    if (!cfg.event.raid.originEmotes)
    {
     showKappa(false, r, {'%USER%': dn, '%AMOUNT%': c});
     return;
    }
    let d = cmd.tags['user-id'];
    let e = await findEmote_channel(d);
    showKappa(e, r, {'%USER%': dn, '%AMOUNT%': c});
   }

   async function parseSub(cmd)
   {
    function parsePlan(c)
    {
     if (!c.tags.hasOwnProperty('msg-param-sub-plan'))
      return false;
     let p = c.tags['msg-param-sub-plan'];
     switch (p)
     {
      case '1000': return 't1';
      case '2000': return 't2';
      case '3000': return 't3';
      case 'Prime': return 'prime';
      default:
     }
     console.log('Unknown Sub Plan: ', p, c);
     return false;
    }
    if (!cmd.tags.hasOwnProperty('msg-id'))
     return;
    let subPlan = parsePlan(cmd);
    if (subPlan === false)
     return;
    let mpoi = false;
    if (cmd.tags.hasOwnProperty('msg-param-origin-id'))
     mpoi = cmd.tags['msg-param-origin-id'];
    if (mpoi !== false && bList.includes(mpoi))
     return;
    let a = [];
    if (cmd.params.length > 1)
    {
     if (cfg.event.sub.useMsg)
     {
      a = a.concat(parseT(cmd, true));
      if (cfg.display.useEmoji)
       a = a.concat(await parseEmoji(cmd, cfg.display.useEmoji, true));
      if (cfg.display.extended.useFFZ)
       a = a.concat(parseFFZ(cmd, true));
      if (cfg.display.extended.useBTTV)
      {
       a = a.concat(parseBTTV(cmd, true));
       a = a.concat(parseBTTVU(cmd, true));
      }
      if (cfg.display.extended.use7TV)
       a = a.concat(parse7TV(cmd, true));
      if (cfg.display.extended.useBTTV)
       parseBTTVZWE(a, cmd, 1, true);
      if (cfg.display.extended.use7TV)
       parse7TVZWE(a, cmd, 1, true);
      if (cfg.display.extended.useBTTV)
       parseBTTVZWE(a, cmd, 2, true);
      if (cfg.display.extended.use7TV)
       parse7TVZWE(a, cmd, 2, true);
     }
     else
      await parseLine(cmd);
    }
    let mpm = 1;
    if (cmd.tags.hasOwnProperty('msg-param-months'))
     mpm = parseInt(cmd.tags['msg-param-months'], 10);
    let mpcm = 1;
    if (cmd.tags.hasOwnProperty('msg-param-cumulative-months'))
     mpcm = parseInt(cmd.tags['msg-param-cumulative-months'], 10);
    let mpmgc = 1;
    if (cmd.tags.hasOwnProperty('msg-param-mass-gift-count'))
     mpmgc = parseInt(cmd.tags['msg-param-mass-gift-count'], 10);
    let u = parseUser(cmd, true);
    let dn = 'Anonymous';
    if (u.hasOwnProperty('display-name'))
     dn = u['display-name'];
    let mprdn = 'Anonymous';
    if (cmd.tags.hasOwnProperty('msg-param-recipient-display-name'))
     mprdn = cmd.tags['msg-param-recipient-display-name'];
    switch (cmd.tags['msg-id'])
    {
     case 'sub':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('first'))
       return;
      if (cfg.event.sub[subPlan].first === false)
       return;
      showKappa(a, cfg.event.sub[subPlan].first, {'%USER%': dn});
      break;
     case 'resub':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('resub'))
       return;
      let rs = findInMaybeRange(cfg.event.sub[subPlan].resub, mpcm);
      if (rs === false)
       return;
      showKappa(a, rs, {'%USER%': dn, '%AMOUNT%': mpcm});
      break;
     case 'primepaidupgrade':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('upgrade'))
       return;
      if (!cfg.event.sub[subPlan].upgrade.hasOwnProperty('prime'))
       return;
      showKappa(a, cfg.event.sub[subPlan].upgrade.prime, {'%USER%': dn});
      break;
     case 'giftpaidupgrade':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('upgrade'))
       return;
      if (!cfg.event.sub[subPlan].upgrade.hasOwnProperty('gift'))
       return;
      showKappa(a, cfg.event.sub[subPlan].upgrade.gift, {'%USER%': dn});
      break;
     case 'subgift':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('gift'))
       return;
      if (mpm === 1)
      {
       if (!cfg.event.sub[subPlan].gift.hasOwnProperty('first'))
        return;
       if (cfg.event.sub[subPlan].gift.first === false)
        return;
       showKappa(a, cfg.event.sub[subPlan].gift.first, {'%SENDER%': dn, '%USER%': mprdn});
       return;
      }
      if (!cfg.event.sub[subPlan].gift.hasOwnProperty('resub'))
       return;
      let gpr = findInMaybeRange(cfg.event.sub[subPlan].gift.resub, mpm);
      if (gpr === false)
       return;
      showKappa(a, gpr, {'%SENDER%': dn, '%USER%': mprdn, '%AMOUNT%': mpm});
      break;
     case 'submysterygift':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('gift'))
       return;
      if (!cfg.event.sub[subPlan].gift.hasOwnProperty('bomb'))
       return;
      if (cfg.event.sub[subPlan].gift.bomb === false)
       return;
      if (mpoi !== false)
       bList.push(mpoi);
      let gpb = findInMaybeRange(cfg.event.sub[subPlan].gift.bomb, mpmgc);
      if (gpb === false)
       return;
      showKappa(a, gpb, {'%SENDER%': dn, '%AMOUNT%': mpmgc});
      break;
     default:
      console.log('Unknown Sub Type: ', cmd);
    }
   }

   async function parseRedeem(title, cmd)
   {
    let kNow = new Date().getTime();
    for (const k in cfg.display.kappa.styles)
    {
     if (!cfg.display.kappa.styles.hasOwnProperty(k))
      continue;
     if (!cfg.display.kappa.styles[k].hasOwnProperty('redeem'))
      continue;
     if (!cfg.display.kappa.styles[k].redeem.includes(title))
      continue;
     let kC = {};
     kC[k] = cfg.display.kappa.styles[k];
     if (cmd === false)
     {
      kLast = kNow;
      showKappa(false, kC);
      return;
     }
     let a = [];
     a = a.concat(parseT(cmd, true));
     if (cfg.display.useEmoji)
      a = a.concat(await parseEmoji(cmd, cfg.display.useEmoji, true));
     if (cfg.display.extended.useFFZ)
      a = a.concat(parseFFZ(cmd, true));
     if (cfg.display.extended.useBTTV)
     {
      a = a.concat(parseBTTV(cmd, true));
      a = a.concat(parseBTTVU(cmd, true));
     }
     if (cfg.display.extended.use7TV)
      a = a.concat(parse7TV(cmd, true));
     if (cfg.display.extended.useBTTV)
      parseBTTVZWE(a, cmd, 1, true);
     if (cfg.display.extended.use7TV)
      parse7TVZWE(a, cmd, 1, true);
     if (cfg.display.extended.useBTTV)
      parseBTTVZWE(a, cmd, 2, true);
     if (cfg.display.extended.use7TV)
      parse7TVZWE(a, cmd, 2, true);
     a = handleDuplicates(a);
     kLast = kNow;
     showKappa(a, kC);
     return;
    }
   }

   function parseBadge(cmd)
   {
    if (!cmd.tags.hasOwnProperty('msg-param-threshold'))
     return;
    let c = cmd.tags['msg-param-threshold'];
    let u = parseUser(cmd, true);
    let dn = 'Anonymous';
    if (u.hasOwnProperty('display-name'))
     dn = u['display-name'];
    if (cfg.event.badge.hasOwnProperty(c) && cfg.event.badge[c] !== false)
    {
     showKappa(false, cfg.event.badge[c], {'%USER%': dn, '%AMOUNT%': c});
     return;
    }
    let closest = null;
    for (const b in cfg.event.badge)
    {
     if (!cfg.event.badge.hasOwnProperty(b))
      continue;
     if (closest === null)
     {
      closest = b;
      continue;
     }
     if (Math.abs(parseInt(closest, 10) - parseInt(c, 10)) > Math.abs(parseInt(b, 10) - parseInt(c, 10)))
      closest = b;
    }
    if (closest === null)
     return;
    if (cfg.event.badge[closest] === false)
     return;
    showKappa(false, cfg.event.badge[closest], {'%USER%': dn, '%AMOUNT%': c});
   }

   function irc()
   {
    let wsRetry = 0;
    let firstRoomstate = true;
    const ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
    ws.onopen = function(event)
    {
     ws.onopen = null;
     tIRC = setTimeout(
      function()
      {
       if (dead === true)
        return;
       dead = true;
       if (tIRC !== false)
       {
        clearTimeout(tIRC);
        tIRC = false;
       }
       ws.close();
       blargIAmDead(5);
      },
      5000);
     ws.send('CAP REQ :twitch.tv/commands twitch.tv/tags');
     ws.send('PASS oauth:' + cfg.login.oauth);
     ws.send('NICK ' + cfg.channel);
     ws.send('JOIN #' + cfg.channel);
    };
    ws.onclose = function()
    {
     if (tIRC !== false)
     {
      clearTimeout(tIRC);
      tIRC = false;
     }
     ws.onopen = null;
     ws.onmessage = null;
     ws.onclose = null;
     if (dead)
      return;
     let wsWait = Math.floor((wWS ** (1 + wsRetry)) * 1000);
     if (wsRetry < 2)
      wsRetry += 0.2;
     window.setTimeout(function(){irc();}, wsWait);
    };
    ws.onmessage = async function(event)
    {
     if (dead)
     {
      ws.close();
      return;
     }
     wsRetry = 0;
     let data = event.data.split('\r\n');
     for (let i = 0, l = data.length; i < l; i++)
     {
      if (data[i].length === 0)
       continue;
      let cmd = parseMsg(data[i]);
      if (cmd === false)
      {
       console.log('Unparsed IRC Command: ', data[i]);
       continue;
      }
      switch(cmd.command)
      {
       case '001':
       case '002':
       case '003':
       case '004':
       case '353':
       case '366':
       case '372':
       case '375':
       case '376':
       case 'CAP':
       case 'JOIN':
       case 'PART':
       case 'WHISPER':
       case 'CLEARCHAT':
       case 'CLEARMSG':
       case 'USERSTATE':
       case 'GLOBALUSERSTATE':
        break;
       case 'PING':
        ws.send('PONG ' + cmd.params[0]);
        break;
       case 'PRIVMSG':
        if (document.visibilityState === 'hidden')
         return;
        if (cmd.params.length > 1)
        {
         // https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f
         cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d'); //zwj alternate
        }
        if (!await parseCheer(cmd))
         parseLine(cmd);
        break;
       case 'NOTICE':
        if (cmd.params.length > 1 && cmd.params[1] === 'Login authentication failed')
        {
         dead = true;
         blargIAmDead(1);
        }
        else
         console.log('Unhandled IRC NOTICE: ', cmd);
        break;
       case 'ROOMSTATE':
        if (!cmd.hasOwnProperty('tags'))
         continue;
        if (!cmd.tags.hasOwnProperty('room-id'))
         continue;
        channelID = cmd.tags['room-id'];
        if (firstRoomstate)
        {
         if (tIRC !== false)
         {
          clearTimeout(tIRC);
          tIRC = false;
         }
         firstRoomstate = false;
         await loadEmote_channel(channelID);
         loadCheer_channel(channelID);
         if (cfg.display.extended.useFFZ)
          loadFFZ_channel(channelID);
         if (cfg.display.extended.useBTTV)
         {
          loadBTTV_channel(channelID);
          loadBTTV_ws_channel(channelID);
         }
         if (cfg.display.extended.use7TV)
         {
          load7TV_channel(channelID);
          load7TV_ws_channel(channelID);
         }
         if (cfg.display.extended.useFFZ | cfg.display.extended.use7TV)
          tTE = window.setTimeout(load3rdParty, rTE, channelID);
         if (cfg.display.extended.useBTTV)
          tBE = window.setTimeout(loadBTTV, rTE, channelID);
         if (cfg.event.follow !== false)
          tFC = window.setTimeout(detectFollowers, tStart, channelID);
         pubSub();
        }
        break;
       case 'USERNOTICE':
        if (document.visibilityState === 'hidden')
         return;
        if (!cmd.hasOwnProperty('tags'))
         continue;
        if (!cmd.tags.hasOwnProperty('msg-id'))
         continue;
        if (cmd.params.length > 1)
        {
         // https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f
         cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d'); //zwj alternate
        }
        switch (cmd.tags['msg-id'])
        {
         case 'raid':
          parseRaid(cmd);
          break;
         case 'sub':
         case 'resub':
         case 'subgift':
         case 'submysterygift':
         case 'giftpaidupgrade':
         case 'primepaidupgrade':
          parseSub(cmd);
          break;
         case 'bitsbadgetier':
          parseBadge(cmd);
          break;
         default:
          if (cmd.params.length > 1)
           parseLine(cmd);
          console.log('Unhandled IRC USERNOTICE: ', cmd.tags['msg-id'], cmd);
        }
        break;
       default:
        console.log('Unhandled IRC Command: ', cmd.command, cmd);
      }
     }
    };
   }

   function pubSub()
   {
    let wsRetry = 0;
    const ws = new WebSocket('wss://pubsub-edge.twitch.tv:443');
    let tmrPing = null;
    ws.onopen = function(event)
    {
     ws.onopen = null;
     tmrPing = window.setInterval(function(){ws.send('{"type": "PING"}');}, 4 * 60 * 1000);
     let req = {};
     req.type = 'LISTEN';
     req.nonce = 'init';
     req.data = {};
     req.data.topics = [];
     req.data.topics.push('channel-points-channel-v1.' + channelID);
     req.data.auth_token = cfg.login.oauth;
     ws.send(JSON.stringify(req));
    };
    ws.onclose = function()
    {
     if (tmrPing !== null)
     {
      window.clearInterval(tmrPing);
      tmrPing = null;
     }
     ws.onopen = null;
     ws.onmessage = null;
     ws.onclose = null;
     if (dead)
      return;
     let wsWait = Math.floor((wWS ** (1 + wsRetry)) * 1000);
     if (wsRetry < 2)
      wsRetry += 0.2;
     window.setTimeout(function(){pubSub();}, wsWait);
    };
    ws.onmessage = async function(event)
    {
     if (dead)
     {
      ws.close();
      return;
     }
     wsRetry = 0;
     let r = JSON.parse(event.data);
     if (!r.hasOwnProperty('type'))
      return;
     switch (r.type)
     {
      case 'RESPONSE':
       if (r.hasOwnProperty('error') && r.error !== '')
       {
        ws.close();
        if (r.error === 'ERR_BADAUTH')
        {
         dead = true;
         blargIAmDead(6);
         return;
        }
        alert('Error Connecting to Twitch PubSub: ' + r.error);
        return;
       }
       break;
      case 'MESSAGE':
       if (document.visibilityState === 'hidden')
        return;
       if (!r.hasOwnProperty('data'))
        return;
       if (!r.data.hasOwnProperty('topic'))
        return;
       if (r.data.topic !== 'channel-points-channel-v1.' + channelID)
        return;
       if (!r.data.hasOwnProperty('message'))
        return;
       let d = JSON.parse(r.data.message);
       if (!d.hasOwnProperty('type'))
        return;
       if (d.type !== 'reward-redeemed')
        return;
       if (!d.hasOwnProperty('data'))
        return;
       if (!d.data.hasOwnProperty('redemption'))
        return;
       if (!d.data.redemption.hasOwnProperty('reward'))
        return;
       if (!d.data.redemption.reward.hasOwnProperty('title'))
        return;
       let n = d.data.redemption.reward.title;
       if (!d.data.redemption.hasOwnProperty('user_input'))
       {
        await parseRedeem(n, false);
        return;
       }
       let lnID = d.data.redemption.reward.id;
       if (!rList.hasOwnProperty(lnID))
       {
        rList[lnID] = {name: n, cmds: []};
        return;
       }
       if (rList[lnID].name === false)
        rList[lnID].name = n;
       while (rList[lnID].cmds.length > 0)
       {
        await parseRedeem(n, rList[lnID].cmds.shift());
       }
       break;
     }
    };
   }

   function shouldUseLogin()
   {
    useL = false;
    if (cfg.hasOwnProperty('channel') && cfg.channel !== false && cfg.channel !== 'CHANNEL_NAME' && cfg.hasOwnProperty('login') && cfg.login.hasOwnProperty('oauth') && cfg.login.oauth !== false && cfg.login.oauth !== 'OAUTH_ID')
     return false;
    useL = true;
    if (window.localStorage.getItem('rrew.channel') !== null)
    {
     window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.channel', window.localStorage.getItem('rrew.channel'));
     window.localStorage.removeItem('rrew.channel');
    }
    if (window.localStorage.getItem('rrew.client') !== null)
    {
     window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.client', window.localStorage.getItem('rrew.client'));
     window.localStorage.removeItem('rrew.client');
    }
    if (window.localStorage.getItem('rrew.oauth') !== null)
    {
     window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.oauth', window.localStorage.getItem('rrew.oauth'));
     window.localStorage.removeItem('rrew.oauth');
    }
    if (window.localStorage.getItem('rrew.expires') !== null)
    {
     window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.expires', window.localStorage.getItem('rrew.expires'));
     window.localStorage.removeItem('rrew.expires');
    }
    let lsChannel = window.localStorage.getItem('twitch.chat:read+channel:read:redemptions.channel');
    let lsClient  = window.localStorage.getItem('twitch.chat:read+channel:read:redemptions.client');
    let lsOAuth   = window.localStorage.getItem('twitch.chat:read+channel:read:redemptions.oauth');
    let lsExpires = window.localStorage.getItem('twitch.chat:read+channel:read:redemptions.expires');
    if (lsChannel === null || lsOAuth === null)
    {
     let h = getHashParams();
     if (!h.hasOwnProperty('channel') || !h.hasOwnProperty('client') || !h.hasOwnProperty('oauth') || !h.hasOwnProperty('expires'))
     {
      showLoginButton();
      return true;
     }
     lsChannel = h.channel;
     lsClient = h.client;
     lsOAuth = h.oauth;
     lsExpires = h.expires;
     window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.channel', lsChannel);
     window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.oauth', lsOAuth);
     window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.client', lsClient);
     window.localStorage.setItem('twitch.chat:read+channel:read:redemptions.expires', lsExpires);
    }
    cfg.channel = lsChannel;
    cfg.login.oauth = lsOAuth;
    cfg.login.client = lsClient;
    cfg.login.expires = lsExpires;
    document.title = cfg.channel + ' Emote Wall';
    showLogoutButton();
    return false;
   }

   function getHashParams()
   {
    let d = function(s) {
     let a = /\+/g;
     return decodeURIComponent(s.replace(a, " "));
    };
    let hashParams = {};
    let r = /([^&;=]+)=?([^&;]*)/g;
    let q = window.location.hash.substring(1);
    let e;
    while ((e = r.exec(q)))
    {
     hashParams[d(e[1])] = d(e[2]);
    }
    return hashParams;
   }

   function doLogin()
   {
    window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.channel');
    window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.oauth');
    window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.client');
    window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.expires');
    let o = encodeURIComponent(btoa(window.location));
    let c = encodeURIComponent('4umzcpmjkg6ar78b81s7302jlj33t8');
    let r = encodeURIComponent('https://realityripple.com/Tools/Twitch/EmoteWall/wizard.php');
    let s = encodeURIComponent('chat:read channel:read:redemptions');
    let u = 'https://id.twitch.tv/oauth2/authorize?client_id=' + c + '&redirect_uri=' + r + '&response_type=token&scope=' + s + '&state=redirto_' + o + '&force_verify=true';
    if (u.length > 1500)
     u = 'https://realityripple.com/Tools/Twitch/tempRedir.php?c=' + c + '&r=' + r + '&s=' + s + '&u=' + encodeURIComponent(window.location);
    window.location = u;
   }

   function showLoginButton()
   {
    document.title = 'Log In to Access Emote Wall';
    if (document.getElementById('cmdLogout'))
     document.body.removeChild(document.getElementById('cmdLogout'));
    window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.channel');
    window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.oauth');
    window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.client');
    window.localStorage.removeItem('twitch.chat:read+channel:read:redemptions.expires');
    let cmdLogin = document.createElement('button');
    cmdLogin.setAttribute('id', 'cmdLogin');
    cmdLogin.setAttribute('type', 'button');
    cmdLogin.setAttribute('onclick', 'doLogin();');
    let sStyle = 'z-index: 1000;';
    sStyle += ' position: absolute;';
    sStyle += ' top: 45%;';
    sStyle += ' left: calc(50% - 6.5em);';
    sStyle += ' width: 13em;';
    sStyle += ' font-size: 3vw;';
    sStyle += ' padding: 0.5em;';
    cmdLogin.setAttribute('style', sStyle);
    cmdLogin.innerHTML = 'Authenticate Emote Wall';
    document.body.appendChild(cmdLogin);
   }

   function showLogoutButton(v = false)
   {
    let visTime = 5000;
    if (document.getElementById('cmdLogout'))
     document.body.removeChild(document.getElementById('cmdLogout'));
    let cmdLogout = document.createElement('button');
    if (tL !== false)
    {
     window.clearTimeout(tL);
     tL = false;
    }
    cmdLogout.setAttribute('id', 'cmdLogout');
    cmdLogout.setAttribute('type', 'button');
    let sStyle = 'z-index: 1000;';
    sStyle += ' transition: opacity 0.5s;';
    sStyle += ' position: absolute;';
    sStyle += ' top: 1em;';
    sStyle += ' right: 1em;';
    sStyle += ' width: 5em;';
    sStyle += ' font-size: 1vw;';
    sStyle += ' padding: 0.5em;';
    document.addEventListener(
     'mouseover',
     function()
     {
      cmdLogout.style.opacity = '1';
      if (tL !== false)
      {
       window.clearTimeout(tL);
       tL = false;
      }
      tL = window.setTimeout(
       function()
       {
        if (tL !== false)
        {
         window.clearTimeout(tL);
         tL = false;
        }
        cmdLogout.style.opacity = '0';
       },
       visTime
      );
     }
    );
    if (v)
    {
     cmdLogout.setAttribute('onclick', 'doLogin();');
     cmdLogout.innerHTML = 'Re-Auth';
     sStyle += ' opacity: 1;';
     tL = window.setTimeout(
      function()
      {
       if (tL !== false)
       {
        window.clearTimeout(tL);
        tL = false;
       }
       cmdLogout.style.opacity = '0';
      },
      visTime
     );
    }
    else
    {
     cmdLogout.setAttribute('onclick', 'showLoginButton();');
     cmdLogout.innerHTML = 'Log Out';
     sStyle += ' opacity: 0;';
    }
    cmdLogout.setAttribute('style', sStyle);
    document.body.appendChild(cmdLogout);
   }

   function blargIAmDead(e)
   {
    let showButton = false;
    switch (e)
    {
     case 1:
      if (useL)
      {
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Connect to Twitch<br><br>Please Log In Again</div>';
       showButton = true;
       showLogoutButton(true);
      }
      else
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Connect to Twitch<br><br>Please Update Your OAuth Token</div>';
      break;
     case 2:
      document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Corrupted Configuration<br><br>Please Check Your Browser\'s Error Console</div>';
      break;
     case 3:
      if (useL)
      {
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Emotes<br><br>Please Log In Again</div>';
       showButton = true;
       showLoginButton();
      }
      else
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Emotes<br><br>Please Check Your Client ID and OAuth Token</div>';
      break;
     case 4:
      document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Warning:<br><br>Your Credentials Will Expire Soon<br><br>Please Update Your OAuth Token</div>';
      if (useL)
      {
       showLogoutButton(true);
       window.setTimeout(function(){document.body.innerHTML = ''; showLogoutButton(true);}, 15000);
       return;
      }
      break;
     case 5:
      document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>The connection to the IRC channel was incomplete.<br><br>Please check your Channel</div>';
      break;
     case 6:
      if (useL)
      {
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Point Redeems<br><br>Please Log In Again</div>';
       showButton = true;
       showLoginButton();
      }
      else
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Point Redeems<br><br>Please Check Your Client ID and OAuth Token</div>';
      break;
    }
    window.setTimeout(function(){document.body.innerHTML = ''; if (showButton) showLoginButton();}, 15000);
   }

   async function startup()
   {
    if (typeof cfg === 'undefined')
    {
     blargIAmDead(2);
     return;
    }
    if (shouldUseLogin() === true)
     return;
    if (cfg.login.hasOwnProperty('expires') && cfg.login.expires > 0)
    {
     let expTime = cfg.login.expires - new Date().getTime();
     if (expTime > 0)
     {
      let expDays = Math.floor(expTime / 1000 / 60 / 60 / 24);
      if (expDays < 7)
      {
       blargIAmDead(4);
      }
     }
    }
    if (cfg.hasOwnProperty('streamlabs') && cfg.streamlabs.hasOwnProperty('token') && cfg.streamlabs.token !== false && cfg.streamlabs.token !== 'SOCKET_TOKEN')
     streamlabsWS();
    if (cfg.hasOwnProperty('streamelements') && ((cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== 'OAUTH_ID') || (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== 'JWT_TOKEN')))
     streamelementsWS();
    if (cfg.display.extended.useFFZ)
     await loadFFZ_global();
    if (cfg.display.extended.useBTTV)
     await loadBTTV_global();
    if (cfg.display.extended.use7TV)
     await load7TV_global();
    irc();
   }

   window.addEventListener('load', startup);
  </script>
 </head>
</html>