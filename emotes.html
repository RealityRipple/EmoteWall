<!doctype html>
<html lang="en">
 <head>
  <meta charset="utf-8" />
  <title>Loading Emote Wall...</title>
  <script>
   'use strict';
   /* RealityRipple's Home-Made Emote Wall
    * ====================================
    *
    * v1.5
    *
    *  <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *
    *
    * Help
    * ----
    *
    *  For information on how the Emote Wall works, including details about
    *  kappagens, emote priorities, cheers, the Twitch and YouTube APIs, OBS,
    *  and various known inefficiencies, please see the README file at
    *
    *   <https://github.com/RealityRipple/EmoteWall/blob/master/README.md>
    *
    *
    *  Please contact RealityRipple for assistance, bug reports, or questions.
    *
    *   <https://realityripple.com>
    *   <https://twitch.tv/realityripple>
    *   <https://discord.gg/fcxJ9tq3XS>
    *
    *
    * Configuration Information
    * -------------------------
    *
    *  For documentation on the configuration, please see
    *
    *   <https://github.com/RealityRipple/EmoteWall/blob/master/CONFIG.md>
    *
    *
    * Update Procedure
    * ----------------
    *
    *  To update this emote wall, simply use the Wizard to import and download it.
    *   1) Visit the official page <https://realityripple.com/Tools/Twitch/EmoteWall/>.
    *   2) Click "Download Emote Wall" and choose "Use the Wizard".
    *   3) Import your previous HTML file by clicking "Import from File".
    *   4) Make any changes you need to make on each page.
    *   5) At the end of your configuration, hit "Download".
    *  You will receive a new version of this HTML file with your previous settings.
    *
    */

   /* jshint esversion: 11, bitwise: false, eqeqeq: true, loopfunc: true, forin: true, freeze: true, futurehostile: true, leanswitch: true, noarg: true, nocomma: true, nonbsp: true, nonew: true, noreturnawait: true, quotmark: single, shadow: outer, singleGroups: false, strict: global, trailingcomma: false, undef: true, unused: true, varstmt: true */

   var cfg = {
    twitch: {
     oauth_refresh: 'OAUTH_REFRESH',
     share: false,
     sharedChat: false
    },
    youtube: {
     oauth_refresh: 'OAUTH_REFRESH',
     connect_to: {
      title: false,
      list: [
       'liveStarting',
       'live',
       'testStarting',
       'testing'
      ],
      max: 1,
      sort: {
       'actualStartTime': 'desc',
       'publishedAt': 'desc'
      },
      recheck: false
     },
     cdn: 'yt4',
     share: false
    },
    kick: {
     channel: 'CHANNEL_NAME'
    },
    lfg: {
     channel: 'CHANNEL_NAME',
     sharedChat: false
    },
    streamlabs: {
     token: 'JWT_TOKEN', //Requires socket.token
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    streamelements: {
     oauth_refresh: 'OAUTH_REFRESH', //Requires tips:read
     token: 'JWT_TOKEN',
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    display: {
     styles: [
    //'Still',        // No movement
      'StraightLine', // Gentle movement in a random straight line
      'Rise',         // Slowly rise to top while wobbling back and forth
      'Bounce',       // Fall from the top at an angle and bounce along the bottom (Windows Solitaire style)
      'Speed',        // Zoom across the screen
      'Drop',         // Get stuck at the top and tumble down (no fade/zoom in, only out)
      'Crazy',        // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
      'Confetti',     // Fall like confetti                   (no zoom, no fade in, only fade out)
      'Throw',        // Toss at the middle and tumble down   (no fade/zoom in, only out)
      'Pop',          // Jump from the bottom                 (no fade/zoom in, only out)
      'TheCube'       // Rotate a 3D cube of an emote         (no zoom, only fade)
     ],
     access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x008 | 0x004 | 0x002 | 0x001,
     duplicates: true,
     useEmoji: true,
     extended: {
      useFFZ: true,
      useBTTV: true,
      use7TV: true,
      useZWE: true,
      fillZWE: false,
      holidayZWE: true,
      priority: ['ffz', 'bttv', '7tv']
     },
     toroidal: false,
     hue: false,
     shadow: false,
     kappa: {
      count: 150,
      styles: {
       'Rise': {},        // Slowly rise to top while wobbling back and forth
       'Speed': {},       // Zoom across the screen
       'Crazy': {},       // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
       'Burst': {},       // Expand from a center point
       'Fireworks': {},   // Burst out from a single emote (no fade/zoom; small emotes)
       'Spiral': {},      // Burst out from a single emote in a spiral (no fade/zoom; small emotes)
       'Pyramid': {},     // Build a pyramid        (no fade/zoom; specific-size emotes)
       'SmallPyramid': {},// Build a small pyramid  (no fade/zoom; small emotes)
       'CodeLines': {},   // "Matrix" code columns  (no fade/zoom; small emotes)
       'Fountain': {},    // Spout from a fountain  (no fade/zoom)
       'Stampede': {},    // Stampede of emotes     (no fade/zoom)
       'Confetti': {},    // Fall like confetti     (no zoom, no fade in, only fade out; small emotes)
       'Conga': {},       // Start a conga line     (no fade/zoom)
       'Coaster': {},     // Rollercoaster ride     (no fade/zoom)
       'TheCube': {       // Rotate a 3D cube of an emote (no zoom, only fade)
        size: 8/10,
        center: true,
        rotations: 5,
        faces: false
       },
       'Text': {          // Show a message         (no fade/zoom; specific-size emotes)
        message: ['HYPE!'],
        time: 3
       }
      },
      access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x008 | 0x004 | 0x002,
      aliases: [      // !kappagen command aliases (must be lower-case)
       '!kappagen',
       '-kappagen'
      ],
      cooldown: 0,
      conga: {
       contagious: false,
       time: 5,
       avoidMiddle: false
      }
     },
     statuses: true
    },
    emote: {
     time: 5,
     max: 0,
     queue: 0,
     threshold: {
      emotes: 0,
      seconds: 0
     },
     size: {
      ratio: {
       normal: 1/12,
       small: 1/24
      },
      min: 16,
      max: 256,
      variation: false
     },
     cube: {
      rotations: 5
     },
     in: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     },
     out: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     }
    },
    event: {
     twitch: {
      clear: true,
      raid: {
       raiders: 2,
       originEmotes: true,
       originExtendedEmotes: false
      },
      follow: true,
      shoutout: {
       create: {
        styles: false,
        targetEmotes: true,
        targetExtendedEmotes: false
       },
       receive: {
        styles: false,
        originEmotes: true,
        originExtendedEmotes: false
       }
      },
      tag: {
       styles: true,
       access: -1,
       onReply: false,
       targetEmotes: true,
       targetExtendedEmotes: false
      },
      sub: {
       useMsg: true,
       t1: {
        first: true,
        resub: true,
        upgrade: {
         gift: false,
         prime: false
        },
        gift: {
         first: true,
         resub: true,
         bomb: 1
        }
       },
       t2: {
        first: true,
        resub: true,
        upgrade: {
         gift: false,
         prime: false
        },
        gift: {
         first: true,
         resub: true,
         bomb: 1
        }
       },
       t3: {
        first: true,
        resub: true,
        upgrade: {
         gift: false,
         prime: false
        },
        gift: {
         first: true,
         resub: true,
         bomb: 1
        }
       },
       prime: {
        first: true,
        resub: true
       }
      },
      cheer: {
       useMsg: true,
       bits: 50
      },
      badge: {
       '1': false,
       '100': true
      },
      hypetrain: {
       begin: false,
       success: false
      },
      kappatrain: {
       begin: false,
       success: false
      },
      treasuretrain: {
       begin: false,
       success: false
      },
      poll: {
       begin: false,
       end: false
      },
      prediction: {
       begin: false,
       resolved: false
      },
      goal: {
       begin: false,
       achieved: false
      },
      charity: false,
      powerup: {
       message: {
        simmer: false,
        eclipse: false,
        abyss: false
       },
       emote: false
      },
      redeem: {
       highlight: false,
       random_emote: false,
       chosen_emote: false,
       modified_emote: false
      },
      timeout: false,
      ban: false
     },
     youtube: {
      sub: true,
      member: {
       useMsg: true,
       first: true,
       milestone: true,
       giftbomb: 5
      },
      superchat: {
       useMsg: true,
       level: 1
      },
      supersticker: 1,
      timeout: false,
      ban: false
     },
     kick: {
      clear: true,
      raid: {
       raiders: 2,
       originEmotes: true,
       originExtendedEmotes: false
      },
      follow: true,
      sub: {
       first: true,
       resub: true,
       gift: true,
       giftbomb: 1
      },
      cheer: {
       useMsg: true,
       kicks: 50
      },
      poll: {
       begin: false,
       end: false
      },
      prediction: {
       begin: false,
       resolved: false
      },
      timeout: false,
      ban: false
     },
     lfg: {
      raid: {
       raiders: 2,
       originEmotes: true
      },
      follow: true,
      shoutout: {
       create: {
        styles: false,
        targetEmotes: true
       }
      },
      sub: {
       pass: true,
       gift: true,
       giftpack: 1
      },
      cheer: {
       useMsg: true,
       coins: 50
      },
      hypetrain: {
       begin: false,
       success: false
      },
      timeout: false,
      ban: false
     },
     tip: {
      useProfileImage: false,
      useMsgEmotes: true,
      streamlabs: {
       donation: false,
       pledge: false
      },
      streamelements: false
     }
    },
    commands: [],
    ignore: {
     users: false,
     emotes: false
    }
   };

   /* fractions (or decimal percentages) of the emote time configuration value */

   const timing = {
    display: {
     'Still': {
      time: 1
     },
     'StraightLine': {
      time: 1
     },
     'Rise': {
      origin: {      /* percentages of the screen height */
       min: 0.8,
       max: 1.1
      },
      dest: {        /* percentages of the screen height */
       min: 4/100,   /* only used if fade or zoom transitions are enabled */
       max: 6/100    /* otherwise, the emote will simply go off-screen */
      },
      time: 1,
      wiggle: {      /* percentages of the above time percentage */
       delay: {
        min: 0,
        max: 3/25
       },
       min: 2/5,
       max: 1
      }
     },
     'Bounce': {
      origin: {      /* percentages of the screen height */
       min: 0,
       max: 0.2
      },
      time: 1,
      velocity: {    /* pixels per 300th of display time */
       h: {
        min: 3,
        max: 9
       },
       v: {
        min: 4,
        max: 7
       },
       loss: 0.3     /* velocity percentage lost per bounce */
      },
      gravity: 1     /* pixels added to vertical velocity per increment */
     },
     'Speed': {
      origin: {      /* percentages of the screen height */
       min: 0.3,
       max: 0.7
      },
      time: 1,
      delay: 0.1
     },
     'Drop': {
      time: 1
     },
     'Crazy': {
      time: 1,
      distance: 7000,  /* max pixels to travel */
      squash: {
       width: 2,     /* squashed wide dimension */
       height: 0.7,  /* squashed tall dimension */
       time: 1/50
      }
     },
     'Confetti': {
      time: 1
     },
     'Throw': {
      time: 1,
      twist: 7/50,
      toss: 1/5,
      drop: 4/5,
      dest: {
       h: {          /* percentages of the screen width */
        min: 0.3,
        max: 0.7
       },
       v: {          /* percentages of the screen height */
        min: 0.3,
        max: 0.7
       }
      }
     },
     'Pop': {
      time: 1,
      peek: {        /* percentages of the above time percentage */
       up: 1/10,
       pause: 1/10,
       'down': 1/10
      },
      pause: 0,
      jump: {
       up: 1/5,
       pause: 0,
       'down': 1/2
      },
      top: {         /* percentages of the screen height */
       min: 1/10,
       max: 2/5
      },
      bottom: {
       min: 4/5,
       max: 19/20
      }
     },
     'TheCube': {
      time: 1
     },
     'Fountain': {
      time: 1/2
     }
    },
    kappa: {
     'Rise': {
      time: 2
     },
     'Speed': {
      time: 2
     },
     'Crazy': {
      time: 2
     },
     'Burst': {
      time: 1.5,
      top: {         /* top and bottom margin of the origin point */
       min: 1/4,
       max: 3/4
      },             /* left and right margin of the origin point */
      left: {
       min: 1/4,
       max: 3/4
      }
     },
     'Fireworks': {
      time: 1,
      origin: {      /* origin point(s) of the firework's rocket */
       x: [1/2],
       y: [1]
      },
      dest: {        /* destination point(s) of the firework's rocket */
       x: [1/4, 1/2, 3/4],
       y: [1/3]
      },
      speed: {
       rocket: 2/5,  /* speed of rocket */
       burst: 1/50   /* speed of initial burst */
      },
      quantity: {    /* number of emotes per burst */
       small: 1/8,
       medium: 3/4,
       large: 1/8
      },
      radius: {      /* firework burst radii */
       base: 2/3,    /* screen's smaller dimension */
       small: 1/3,
       medium: 2/3,
       large: 1
      },
      spread: 12,    /* how much more frequently to pause during medium burst */
      delays: {      /* pause between bursts */
       small: 2/25,
       large: 1/10
      }
     },
     'Spiral': {
      time: 1/4,
      bulk: 8,       /* max number of emotes to send in bulk (>1 can end up looking chunked) */
      vectors: {     /* number of emote vectors per circle */
       min: 40,
       max: 60
      }
     },
     'Pyramid': {
      time: 1,
      show: {
       total: 0.8,   /* percentage of time to spend showing the pyramid */
       min: 75       /* minimum animation speed per block (in ms) */
      },
      pause: 0.2,
      hide: 0.01
     },
     'SmallPyramid': {
      time: 1,
      show: {
       total: 0.8,   /* percentage of time to spend showing the pyramid */
       min: 100      /* minimum animation speed per block (in ms) */
      },
      pause: 0.2,
      hide: 0.01
     },
     'CodeLines': {
      time: 1,
      fade: 1/6,     /* percentage of time to spend fading out each emote */
      overlap: 3,    /* simultaneous columns to show */
      opacity: 1/5   /* opacity of emotes to fade-out to after showing */
     },
     'Fountain': {
      time: 1.5,
      top: {         /* peak of the fountain, as a percent of the screen height */
       min: 3/20,
       max: 2/5
      },             /* left and right margin of the origin point */
      left: {
       min: 1/3,
       max: 2/3
      }
     },
     'Stampede': {
      time: 1,
      speed: 2/5,     /* travel time across the screen for each emote */
      maxdensity: 6,  /* maximum emotes to show at once */
      top: {
       min: 0.5,      /* top of stampede relative to top of screen, in emote heights */
       max: 0.5       /* bottom of stampede relative to bottom of screen, in emote heights */
      },
      height: 3,      /* height of stampede in emote heights */
      bunch: {
       '1': {
        min: 1,
        max: 5
       },
       '2': 8,        /* this number minus the value of 1 */
       '4': {
        min: 0,
        max: 3
       }
      },
      pause: {
       '1': 4/5,
       '2': 2/5
      },
      smallSleep: {
       min: 90,
       max: 100
      }
     },
     'Confetti': {
      time: 1
     },
     'Conga': {
      time: {
       show: 2,
       hide: 2
      },
      size: 5/3,      /* height of animation space for row in emote heights */
      height: 5/6,    /* height of each row of dancers in emote heights (padding) */
      avoidMiddle: 6  /* rows to use when avoiding the middle (half top, half bottom; please use even numbers) */
     },
     'Coaster': {
      time: 1/4,
      bottom: {       /* starting location of rollercoaster */
       min: 7/10,     /*  percentages of the screen height */
       max: 9/10
      },
      top: {          /* apex of rollercoaster */
       min: 2/10,     /*  percentages of the screen height */
       max: 4/10
      },
      at: {           /* initiation of loop */
       min: 1/5,      /*  percentages of the screen width (from either side) */
       max: 1/3
      }
     },
     'TheCube': {
      time: 1
     },
     'Text': {
      time: 1,
      show: {
       total: 0.8,   /* percentage of time to spend showing the pyramid */
       min: 75       /* minimum animation speed per block (in ms) */
      },
      hide: 0.01
     }
    }
   };

   /* potentially alterable arrays */

   // list of default images to use if your channel has no emotes
   const bareList = [
    {url: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAHv0lEQVRIx52Xa6xdRRXHf2vN7L3Puff29ra37yfQaCPGkPIwoCLVhEQEDaCngaAGo8FErZCI1gTweD6QKIiBEkyKhoBSwXtDwEaKhkQKJmKLgIRCebbIoy19nnse9+zHPPzQNBSwIbjm02Stmd9kzays/wjHsQgiEO+84YoVRcyWTHUPLo7en7Hn9d033Lzx73tiRESIfEjT4zkmGw0F6HTanyh7B7dU/emNVsJVs+bOu/eW5mWja9Y0tNlsagT5MED5AF9srv3CaNUfXOyD+eycRfO/MWfuAtPrTl+79qcbrj8a2Gw2FbYorA6tViv8v0AAaTabptVquesuP/2MkdkLtg7NXhBdOXi12L39osolnVQXtdfdsan7DhyFJscDHw8oExMNXbNm0h+dX3vpqptr1v/A1lI/OjZmYrRtlZpIUj8coj5RVINHyqr/t3W3/PVFgEajYSYmJ4Pw7nt+H7DZbOrR023YsCEx+5+6rMx738q7Bz4diq6kSUY2YzyabEQEQQVwJSE6Bnk5IPjNkNz4/Zvu2/re/d4HPOpsNpvp4uzgV9T7q+qZ/WReDBj0exByYvCEqkAkRqInEWJEYlSDijEKDArnPOY2V0+vW3fjpu6xUHkvbP013z7RSnF3lphPeVeSD6ZDWQwioTTiSkIxQDRijCAmJbGGrJYRAkznVQw+hBiCSW2Kk/RpOzr7krU//+NLR/eXd14ZzMkOzDKDzqM18R+f6rS9K3MJZaExBvAFKhCrkqRex0gkhIhNE9IsJQbPdKdHnjti8DFGfH1k1Gpt1i4dqp975S8feLXZbKoAxGZTpdUK6398ye+GEv/1TrdbRV8mrsiJVUHwnsREgnfEqkSzYWr1FOcqVBQ1hhADMrScUJ9HXnm06BP6b7skdq1kM5+gPvOczuhkIRONhlkzOelvW3f5l6Kb2pRPt31wTkNVSAweO3M5YXgJQRLU9Um6O/G93ST1YQieGCMiEbPkcwxGV1J5jw+RsshJ80PY/U+7WjhsQ33mD6++7aFfydFaG+88uw0/WDXdPeQlOCOSYJaeTTW0hLRWx3tP5Rwz6inujX/C1AvYJCV4j5m9gmL8TLpFiarBZgndTg8rih56JWbt5zCm3Lv0rHNWKRAXFS+vTjSsKnpTIVbO4D31E84mH17KvLkZr778DK+99gpWhW4/p5x1CmZ0OWmWktWGiPVllN5TGxqiDCV/uHMD9917B/94/BGKoXniagshxIWHdz5/lgK4qrzQ+AJX5pEqx44s5LCO85cH72Fy8m42P/Qn7r9/I/9+5kmSJGVs3nx05knYbBg1lsGgwBrlwP79PLjpPt54fSeHD+3n8cce5l9PPYEdWxSNSaj6vfMVILr8hKoYQAhI8ITaHJ58eht552127XoTH47Uz7ZtjzHVbVNVJWXMqFwgEul326hJeev1nex88XlUFR8CWVbjhR3b6RVObGKJMZ6hExPNNPq4ILoSE5wokW63x7639+Ax1LIUawVjDVVZ0p1qUwwGFNN9Ovvfoju1j+rQfyA4EqOIRIL3BOfwztHvdfFugOIBRrX/XHtIcKORgEhEgkPKNmoMg8LRy3NAjgwxZFl2pBH295J3DpBP96kO7KDzxvOsWLGS8bExfDiSEmst8+YvoB7auGIKCRQ6zNi0TbSfWINai1dDVh5gzoyMaFJUDd57ut0OH/3IShYvWkwYdHDt7ZAIqGNoCDrPbSarpjjv/Is56cQTmTtvPguXLef0lQuYUe6KagRR7QjA7T+6cJN17Qum2p1QDXLjfUFX5/DkoWH27DtACBXLlp7E6tXnYQn0Xvoz9HagmqAGEEsxqJguhBlLzySPNQ4c3EtNpliYTmHwYWR4ljozdLsA/HbdV9da311/uH3QV4PChBjwxTSuvoCpZCn1WUsZHx+nnNpLvnsr6vZiswwJDrUGxEBUnHPk/QKT1KgN10mtx1cOIY1JUkeTkfME4NfNi+ZxqLMjuulZea8fXai0Kkq8c2AMPiZ4PInkpImgWR2xigaPGIMYS3AeNQbBEqNDjYVoCJXzNZsap7WttfCxs3Wi0TDfbd2/z1X+plqSCqJBRTFqscagGkniNMOppz5Ux6Y1VARrDUYVjWCNYo2gRlAFq4qiiA+RKsYYFbG11nduv72SCPKzZlN4bUs6XgsPJ7H8TK/XcYhYV5SgEQFEFbGgakBBU4uEAD5gspToPRgDGHAeURt8XvnMDiXTpvaLq3/z6E8ajYbRoxKgddejeWHs14pod9VrIxaxTkwSBIOogSgQDTFAqCAWgRjAOwiVJ4RIqAKUPgQnXoLRWjqcDKjfs+zc713TbKKTRyTHuxvw9d/8/MnDkv9ecae6qqIoyigaQqyCSGJEjYD3ICAWYhmipvZIGkLURFNRW6fw+mYgual/wpb1rZbEeKTbx/dIDLTVIjQvOG1odIxLQ2Stip5iTcSVBa7yaGII3kMI2FSJHowx2EQpKsGRbMekGwc6887WXZv3His5jyOijkABmo1zRkbq8YsR/+UY3Mm+KBcgMiwabXAxGkMeQjwUot1rUvNsCMkDI3NPfezKW28tAI722g+UiRFkstHQY4OvuOK0ZFl/zpxAOWqMZD4vRGxou2rJwdbkZO/Y9RONhmlMTIb/9RX4Ly/EQPT2tQstAAAAAElFTkSuQmCC'}
   ];

   // list of images that are shown when an emote is removed prematurely
   const dieList = [
    {time: 700, url: 'data:image/gif;base64,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'}
   ];

   // distribution of emotes for Pyramid and SmallPyramid kappagen
   const pyramidDist = [1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1];

   // treat these BTTV emotes as zero-width (overlapping) emotes
   const bttvZWE = Object.freeze({
    '567b5b520e984428652809b6': [],                    //SoSnowy
    '5849c9a4f52be01a7ee5f79d': ['zweFramed'],         //IceCold
    '58487cc6f52be01a7ee5f205': ['zweHat', 'zweLPad'], //SantaHat
    '5849c9c8f52be01a7ee5f79e': ['zweHat'],            //TopHat
    '567b5dc00e984428652809bd': ['zweHat'],            //ReinDeer
    '567b5c080e984428652809ba': ['zweHat'],            //CandyCane
    '5e76d399d6581c3724c0f0b8': [],                    //cvMask
    '5e76d338d6581c3724c0f0b2': ['zweFramed'],         //cvHazmat
    '58017bcc8faabf4b3d008456': ['zweHat'],            //HalloHalo
    '58017be38faabf4b3d00845a': ['zweHat'],            //HalloKKona
    '58017bf38faabf4b3d00845d': ['zweHat'],            //HalloHorns
    '58017c088faabf4b3d008460': ['zweHat'],            //HalloFedora
    '5801777f8faabf4b3d008434': ['zweHat'],            //HalloWitch
    '5802e7a5d336345f3d4e1ed5': ['zweHat']             //HalloPirate
   });

   // force-append these zero-width emotes on holidays
   const bttvHoliday = Object.freeze({
    '5802e7a5d336345f3d4e1ed5': Object.freeze({min: Object.freeze({month:  9, day: 19}), max: Object.freeze({month:  9, day: 19}), code: 'HalloPirate', width: 30, height: 38}),
    '5801777f8faabf4b3d008434': Object.freeze({min: Object.freeze({month: 10, day: 31}), max: Object.freeze({month: 10, day: 31}), code: 'HalloWitch',  width: 30, height: 38}),
    '58487cc6f52be01a7ee5f205': Object.freeze({min: Object.freeze({month: 12, day: 24}), max: Object.freeze({month: 12, day: 25}), code: 'SantaHat',    width: 31, height: 38}),
    '5849c9c8f52be01a7ee5f79e': Object.freeze({min: Object.freeze({month: 12, day: 31}), max: Object.freeze({month: 12, day: 31}), code: 'TopHat',      width: 30, height: 38})
   });

   // distribution of emotes for letters in message kappagens
   const alnumDist = {
    'A': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'a': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'B': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    'b': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'C': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0]
    ],
    'c': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'D': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'd': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'E': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'e': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'F': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'f': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    'G': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 1, 0, 0]
    ],
    'g': [
     [1, 0, 0, 1, 1, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'H': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'h': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0]
    ],
    'I': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'i': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'J': [
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'j': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0]
    ],
    'K': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'k': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'L': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'l': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'M': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'm': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'N': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'n': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'O': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'o': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'P': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    'p': [
     [1, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 1, 0, 0, 0, 0]
    ],
    'Q': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [1, 1, 0, 1, 1, 1, 1, 0, 0]
    ],
    'q': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'R': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 1, 0, 0]
    ],
    'r': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'S': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    's': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    'T': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    't': [
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0]
    ],
    'U': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'u': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'V': [
     [0, 0, 0, 0, 1, 1, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 1, 1, 0]
    ],
    'v': [
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0]
    ],
    'W': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'w': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 0, 0, 0]
    ],
    'X': [
     [0, 1, 1, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 0, 1, 1, 0]
    ],
    'x': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'Y': [
     [0, 0, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    'y': [
     [1, 0, 0, 1, 1, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'Z': [
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0]
    ],
    'z': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '1': [
     [0, 1, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '2': [
     [0, 1, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '3': [
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '4': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0]
    ],
    '5': [
     [0, 0, 1, 0, 0, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 0, 1, 0]
    ],
    '6': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0]
    ],
    '7': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    '8': [
     [0, 0, 1, 1, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '9': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 1, 1, 0, 0]
    ],
    '0': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    '>': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '<': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    ':': [
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    '.': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    ',': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '\'': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 1]
    ],
    '-': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '_': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '+': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '=': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0]
    ],
    '!': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    '@': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 1, 1, 0, 0]
    ],
    '#': [
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    '$': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [1, 1, 1, 1, 1, 1, 1, 1, 1],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    '\u00a2': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '\u20ac': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    '\u00a3': [
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '\u00a5': [
     [0, 0, 0, 0, 1, 0, 1, 1, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 1, 0]
    ],
    '%': [
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0]
    ],
    '?': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ]
   };

   // name used in text kappagens when the user isn't known
   const anonName = 'Anonymous';

   //////////////////////////////////////////////////////////////////////////////
   // don't mess with things below this line without knowing what you're doing //
   //////////////////////////////////////////////////////////////////////////////

   const wsRetryBase = 5;
   const oauthClient = Object.freeze({
    t: '4umzcpmjkg6ar78b81s7302jlj33t8',
    yt: '71876675824-aepsnb3onligbj62r1i2qakfjh9sr8kg.apps.googleusercontent.com'
   });
   const cVARs = Object.freeze({
    crew: Object.freeze({
     st1: '#%ST1%',
     st3: '#%ST3%'
    }),
    css: Object.freeze({
     x: '%X%',
     y: '%Y%'
    }),
    evt: Object.freeze({
     amount: '%AMOUNT%',
     result: '%RESULT%',
     sender: '%SENDER%',
     sticker: '%STICKER%',
     title: '%TITLE%',
     type: '%TYPE%',
     user: '%USER%'
    }),
    notice: Object.freeze({
     desc: '%DESC%'
    }),
    url: Object.freeze({
     channelID: '%CHANNEL_ID%',
     channelName: '%CHANNEL_NAME%',
     chatID: '%CHAT_ID%',
     streamID: '%STREAM_ID%',
     clientID: '%CLIENT_ID%',
     emojiID: '%EMOJI_ID%',
     emoteID: '%EMOTE_ID%',
     eventID: '%EVENT_ID%',
     origin: '%ORIGIN%',
     page: '%PAGE%',
     part: '%PART%',
     scope: '%SCOPE%',
     setID: '%SET_ID%',
     stickerID: '%STICKER_ID%',
     token: '%TOKEN%',
     user: '%USER%',
     userID: '%USER_ID%',
     uri: '%URI%'
    })
   });
   const cURLs = Object.freeze({
    ws: Object.freeze({
     twitch: Object.freeze({
      irc: 'wss://irc-ws.chat.twitch.tv',
      eventSub: 'wss://eventsub.wss.twitch.tv/ws'
     }),
     kick: 'wss://ws-us2.pusher.com/app/' + cVARs.url.chatID + '?protocol=7&client=js&version=7.6.0&flash=false',
     lfg: 'wss://chat.lfg.tv/socket.io/?EIO=4&transport=websocket',
     streamlabs: 'wss://sockets.streamlabs.com/socket.io/?transport=websocket&token=' + cVARs.url.token,
     streamelements: 'wss://realtime.streamelements.com/socket.io/?transport=websocket',
     bttv: 'wss://sockets.betterttv.net/ws',
     '7tv': 'wss://events.7tv.io/v3'
    }),
    sse: Object.freeze({
     '7tv': 'https://events.7tv.io/v3'
    }),
    api: Object.freeze({
     twitch: Object.freeze({
      users: Object.freeze({
       name: 'https://api.twitch.tv/helix/users?login=' + cVARs.url.user,
       id: 'https://api.twitch.tv/helix/users?id=' + cVARs.url.userID
      }),
      bits: Object.freeze({
       cheermotes: 'https://api.twitch.tv/helix/bits/cheermotes?broadcaster_id=' + cVARs.url.channelID
      }),
      channels: Object.freeze({
       root: 'https://api.twitch.tv/helix/channels?broadcaster_id=' + cVARs.url.channelID,
       followers: 'https://api.twitch.tv/helix/channels/followers?user_id=' + cVARs.url.userID + '&broadcaster_id=' + cVARs.url.channelID
      }),
      chat: Object.freeze({
       emotes: Object.freeze({
        root: 'https://api.twitch.tv/helix/chat/emotes?broadcaster_id=' + cVARs.url.channelID,
        global: 'https://api.twitch.tv/helix/chat/emotes/global'
       })
      }),
      eventSub: Object.freeze({
       get: 'https://api.twitch.tv/helix/eventsub/subscriptions',
       delete: 'https://api.twitch.tv/helix/eventsub/subscriptions?id=' + cVARs.url.eventID
      }),
      validate: 'https://id.twitch.tv/oauth2/validate'
     }),
     youtube: Object.freeze({
      broadcasts: 'https://youtube.googleapis.com/youtube/v3/liveBroadcasts?part=snippet,status&broadcastStatus=all&broadcastType=all&maxResults=50',
      livechat: Object.freeze({
       messages: Object.freeze({
        init: 'https://youtube.googleapis.com/youtube/v3/liveChat/messages?liveChatId=' + cVARs.url.chatID + '&part=' + cVARs.url.part + '&maxResults=2000',
        page: 'https://youtube.googleapis.com/youtube/v3/liveChat/messages?liveChatId=' + cVARs.url.chatID + '&part=' + cVARs.url.part + '&pageToken=' + cVARs.url.page + '&maxResults=2000'
       }),
       emojis: 'https://realityripple.com/Tools/ytEmojiDB/read.php',
       superstickers: 'https://cdn.jsdelivr.net/gh/realityripple/yt-super-stickers/list.json'
      }),
      subscriptions: Object.freeze({
       recent: 'https://www.googleapis.com/youtube/v3/subscriptions?part=' + cVARs.url.part + '&myRecentSubscribers=true&maxResults=50',
       match: 'https://www.googleapis.com/youtube/v3/subscriptions?part=' + cVARs.url.part + '&channelId=' + cVARs.url.user + '&forChannelId=' + cVARs.url.channelID
      }),
      tokeninfo: 'https://www.googleapis.com/oauth2/v3/tokeninfo?access_token=' + cVARs.url.token
     }),
     kick: Object.freeze({
      users: 'https://kick.com/api/v2/channels/' + cVARs.url.channelName + '/users/' + cVARs.url.user,
      channels: 'https://kick.com/api/v2/channels/' + cVARs.url.channelName,
      followers: 'https://kick.com/api/internal/v1/channels/' + cVARs.url.channelName + '/followers-count',
      emotes: 'https://kick.com/emotes/' + cVARs.url.channelName
     }),
     lfg: Object.freeze({
      users: 'https://api.lfg.tv/v1/users/' + cVARs.url.user,
      emotes: 'https://ew.realityripple.com/lfg/emotes',
      followers: 'https://api.lfg.tv/v1/users/' + cVARs.url.channelName + '/followers?start=' + cVARs.url.page,
      subscribed: 'https://api.lfg.tv/v1/users/' + cVARs.url.user + '/subscribed/' + cVARs.url.channelName,
      hypetrains: 'https://api.lfg.tv/v1/streams/' + cVARs.url.streamID + '/hype-train'
     }),
     ffz: Object.freeze({
      set: Object.freeze({
       global: 'https://api.frankerfacez.com/v1/set/global'
      }),
      room: Object.freeze({
       twitch: 'https://api.frankerfacez.com/v1/room/id/' + cVARs.url.channelID,
       youtube: 'https://api.frankerfacez.com/v1/room/yt/' + cVARs.url.channelID
      })
     }),
     bttv: Object.freeze({
      emotes: Object.freeze({
       global: 'https://api.betterttv.net/3/cached/emotes/global'
      }),
      users: Object.freeze({
       twitch: 'https://api.betterttv.net/3/cached/users/twitch/' + cVARs.url.channelID,
       youtube: 'https://api.betterttv.net/3/cached/users/youtube/' + cVARs.url.channelID
      })
     }),
     '7tv': Object.freeze({
      emotes: Object.freeze({
       global: 'https://7tv.io/v3/emote-sets/global',
       set: 'https://7tv.io/v3/emote-sets/' + cVARs.url.setID
      }),
      users: Object.freeze({
       twitch: 'https://7tv.io/v3/users/twitch/' + cVARs.url.channelID,
       youtube: 'https://7tv.io/v3/users/youtube/' + cVARs.url.channelID,
       kick: 'https://7tv.io/v3/users/kick/' + cVARs.url.channelID
      })
     }),
     streamelements: Object.freeze({
      validate: 'https://api.streamelements.com/oauth2/validate'
     }),
     rr: Object.freeze({
      refresh: Object.freeze({
       t: 'https://ew.realityripple.com/t/auth',
       yt: 'https://ew.realityripple.com/yt/auth',
       se: 'https://ew.realityripple.com/se/auth'
      })
     })
    }),
    cdn: Object.freeze({
     twitch: Object.freeze({
      emote: 'https://static-cdn.jtvnw.net/emoticons/v2/' + cVARs.url.emoteID + '/default/dark/3.0'
     }),
     youtube: Object.freeze({
      subdomain: [
       'ap1', 'ap2',
       'cp3', 'cp4', 'cp5', 'cp6',
       'gm1', 'gm2', 'gm3', 'gm4',
       'gp3', 'gp4', 'gp5', 'gp6',
       'mua3', 'mua4', 'mua5', 'mua6',
       'sp1', 'sp3',
       'yt3', 'yt4'
      ],
      emoji: 'https://yt3.ggpht.com/' + cVARs.url.emojiID + '=w112-h112-c-k-nd',
      sticker: 'https://yt3.ggpht.com/' + cVARs.url.stickerID + '=s256-rwa'
     }),
     kick: Object.freeze({
      appid: 'https://cdn.jsdelivr.net/gh/realityripple/kick-appid/app.json',
      emote: 'https://files.kick.com/emotes/' + cVARs.url.emoteID + '/fullsize',
      cheer: 'https://files.kick.com/kicks/gifts/' + cVARs.url.emoteID + '.webp'
     }),
     lfg: Object.freeze({
      coin: 'https://lfg.tv/coins/Coin-' + cVARs.url.emoteID + '.png',
      emote: Object.freeze({
       png: 'https://lfgtv-storage.nyc3.cdn.digitaloceanspaces.com/users/' + cVARs.url.userID + '/emotes/' + cVARs.url.emoteID + '-static.png',
       gif: 'https://lfgtv-storage.nyc3.cdn.digitaloceanspaces.com/users/' + cVARs.url.userID + '/emotes/' + cVARs.url.emoteID + '-animated.gif'
      })
     }),
     emoji: Object.freeze({
      fonts: 'https://cdn.jsdelivr.net/gh/realityripple/emoji/fonts.min.json',
      list: 'https://cdn.jsdelivr.net/gh/realityripple/emoji/list.min.json',
      image: 'https://cdn.jsdelivr.net/gh/realityripple/emoji/' + cVARs.url.setID + '/' + cVARs.url.emojiID + '.png'
     }),
     bttv: Object.freeze({
      emote: 'https://cdn.betterttv.net/emote/' + cVARs.url.emoteID + '/3x'
     })
    }),
    html: Object.freeze({
     rr: Object.freeze({
      auth: Object.freeze({
       t: 'https://ew.realityripple.com/t/login',
       yt: 'https://ew.realityripple.com/yt/login'
      }),
      redir: 'https://realityripple.com/Tools/Twitch/tempRedir.php'
     }),
     twitch: 'https://id.twitch.tv/oauth2/authorize?client_id=' + cVARs.url.clientID + '&redirect_uri=' + cVARs.url.uri + '&response_type=code&scope=' + cVARs.url.scope + '&state=redirto_' + cVARs.url.origin + '&force_verify=true',
     youtube: 'https://accounts.google.com/o/oauth2/v2/auth?client_id=' + cVARs.url.clientID + '&redirect_uri=' + cVARs.url.uri + '&response_type=code&access_type=offline&scope=' + cVARs.url.scope + '&state=redirto_' + cVARs.url.origin + '&prompt=consent%20select_account&include_granted_scopes=false'
    })
   });
   const cScopes = Object.freeze({
    twitch: Object.freeze({
     read: 'chat:read',
     followers: 'moderator:read:followers',
     shoutouts: 'moderator:read:shoutouts',
     redemptions: 'channel:read:redemptions',
     hypetrains: 'channel:read:hype_train',
     polls: 'channel:read:polls',
     predictions: 'channel:read:predictions',
     goals: 'channel:read:goals',
     charity: 'channel:read:charity'
    }),
    youtube: Object.freeze({
     readonly: 'https://www.googleapis.com/auth/youtube.readonly',
     memberships: 'https://www.googleapis.com/auth/youtube.channel-memberships.creator'
    })
   });
   const cSources = Object.freeze({
    service: Object.freeze({
     url: Symbol(),
     cheer: Symbol(),
     twitch: Symbol(),
     youtube: Symbol(),
     kick: Symbol(),
     lfg: Symbol(),
     ffz: Symbol(),
     bttv: Symbol(),
     '7tv': Symbol(),
     emoji: Symbol()
    }),
    scope: Object.freeze({
     user: Symbol(),
     global: Symbol(),
     channel: Symbol()
    })
   });
   const cCrew = Object.freeze({
    id: '0d9e',
    prefix: 'data:image/svg+xml,',
    svg: Object.freeze({
     tag: Object.freeze({
      open: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000">',
      close: '</svg>'
     }),
     body: '<ellipse cx="533.9" cy="929.8" rx="295.8" ry="39.4" class="st0"/><path d="M812 403c25-28 39-63 36-98-3-41-29-80-72-111l-16-11a193 193 0 0 0-77-105c-34-21-70-31-102-39-18-5-33-4-46-3h-24c-37-5-74 3-108 24-31 19-58 47-76 79-25 44-35 93-41 140l-25 1c-27 0-60 0-84 26-20 23-21 53-22 73-3 73-5 150-3 225 1 44 6 89 39 120 26 24 59 30 89 30l10-1 6 60c4 25 8 49 21 71a113 113 0 0 0 116 51c46-8 84-45 94-90 5-22 3-43 2-62l-1-24h33c-8 44 7 91 40 120a115 115 0 0 0 87 27c31-3 57-17 75-39 19-24 26-54 31-82 21-126 28-254 18-382z"/><path d="m760 495-1-52c-20 10-44 18-72 24-26 6-50 9-73 9a184 184 0 0 1-179-123c-14-42-12-91 7-133 20-45 69-58 99-66 46-13 94-13 140-3-9-10-19-20-29-25-26-17-57-26-85-33-9-2-17-1-28-1-11 1-22 2-37 0-53-8-103 33-126 75l-4 6c-25 50-31 109-35 165-9 156-4 313 15 468 3 19 5 37 13 50 11 18 36 28 58 24 23-4 44-24 49-47 4-14 2-29 1-46-1-19-3-40 2-62 3-12 13-21 26-22h2c23 0 135-1 190-5 0 0-28 52-74 59-9 28-2 62 19 80 11 10 28 15 45 13 15-1 28-8 36-18 11-14 15-34 19-56 16-93 24-187 22-281zm-482-99 3-60h-20c-22 0-36 1-43 8-6 8-7 25-7 37l-1 18c-2 68-4 137-3 204 1 32 5 63 22 80 14 12 34 15 56 15-8-101-10-201-7-302z" class="st1"/><path d="M792 322c-3 20-15 40-33 55-20 16-47 27-84 36-42 9-75 10-103 2-38-12-70-42-83-80-11-29-9-63 4-92l6-9c7-8 21-17 57-26a230 230 0 0 1 188 32c39 28 47 55 48 69v13z" class="st2"/><path d="M285 698c-22 0-42-3-56-15-17-17-21-48-21-80-2-67 0-136 2-204 20-8 45-7 68-3-3 101-1 201 7 302zm475-203c-15 58-56 109-111 133-73 32-165 11-215-49-32-39-45-90-54-140-15-87-18-177-8-266-25 50-31 109-35 165-9 156-4 313 15 468 3 19 5 37 13 50 11 18 36 28 58 24 23-4 44-24 49-47 4-14 2-29 1-46-1-19-3-40 2-62 3-12 13-21 26-22h2c23 0 135-1 190-5 0 0-28 52-74 59-9 28-2 62 19 80 11 10 28 15 45 13 15-1 28-8 36-18 11-14 15-34 19-56 16-93 24-187 22-281z" class="st3"/><path d="M792 322c-3 20-15 40-33 55-20 16-47 27-84 36-42 9-75 10-103 2-38-12-70-42-83-80-11-29-9-63 4-92l6-9c7 11 13 40 18 49 10 17 26 33 44 44 38 23 84 28 128 22 35-4 69-15 103-27z" class="st4"/><path d="M614 274c-7-3-13-9-13-17-1-11 11-18 21-22 30-10 63-8 91 3 9 4 17 9 18 18 1 10-9 18-19 19s-20-3-29-4c-23-4-45 11-69 3z" class="st5"/>'
    }),
    css: Object.freeze({
     tag: Object.freeze({
      open: '<style type="text/css">',
      close: '</style>'
     }),
     body: '.st0{fill:#484C4D;}.st1{fill:#' + cVARs.crew.st1 + ';}.st2{fill:#A3D3E3;}.st3{opacity:0.5;fill:#' + cVARs.crew.st3 + ';}.st4{opacity:0.45;fill:#5B7882;}.st5{fill:#FFFFFF;}',
     flip: 'svg{transform: scaleX(-1);}'
    }),
    colors: [['C51111', '300060'], ['132FD2', '00004A'], ['10802D', '021B2E'], ['ED53B9', '6B05A1'], ['EF7D0E', '730020'], ['F5F558', '8E1800'], ['3F484E', '000000'], ['D5E0EF', '2E4A8D'], ['6B30BC', '0E003C'], ['72491E', '4A040A'], ['39FEDB', '1054A1'], ['50EF3A', '006144'], ['938877', '14000A'], ['E27060', '983262'], ['F5E4A5', 'B89268'], ['F1C6D0', 'DA749C'], ['738593', '162638'], ['761E1C', '4A102C']]
   });

   const notice = function()
   {
    const _visTime = 5000;
    const _errTime = 15000;
    let _tHide = false;
    const _iHide = 5000;
    const _states = {};
    const _timers = {};
    const _sTypes = Object.freeze({
     info: Symbol(),
     warning: Symbol(),
     error: Symbol()
    });
    const _nC = Object.freeze({
     t: Object.freeze({
      i: 'noticeInfo',
      w: 'noticeWarning',
      e: 'noticeError'
     }),
     s: Object.freeze({
      g: 'global',
      t: 'sTwitch',
      y: 'sYouTube',
      k: 'sKick',
      l: 'sLFG',
      se: 'tStreamElements',
      sl: 'tStreamlabs',
      b: 'eBTTV',
      '7': 'e7TV'
     })
    });
    const idNoticeLine = 'noticeLine';
    const idNotices = 'notices';
    const idNotice = 'notice' + cVARs.notice.desc;
    const idBadge = 'badge';
    const cFader = 'fader';
    const cFaded = 'faded';
    const cFade = 'fade';
    const cHide = 'hide';
    const evMove = 'mousemove';

    function $info(i)
    {
     if (_states.hasOwnProperty(i) && _states[i] === _sTypes.info)
      return;
     _states[i] = _sTypes.info;
     if (!_timers.hasOwnProperty(i))
      _timers[i] = false;
     _buildNotices();
     const tInfo = 5;
     switch (i)
     {
      case notice.Type.GLOBAL_NET:
       _setNotice(i, [_nC.t.i, _nC.s.g], 'Online', 1);
       break;
      case notice.Type.TWITCH_IRC:
       _setNotice(i, [_nC.t.i, _nC.s.t], 'IRC Connected', tInfo);
       break;
      case notice.Type.TWITCH_EVENTSUB:
       _setNotice(i, [_nC.t.i, _nC.s.t], 'EventSub Connected', tInfo);
       break;
      case notice.Type.YOUTUBE_NETWORK:
       _setNotice(i, [_nC.t.i, _nC.s.y], 'Connected', tInfo);
       break;
      case notice.Type.KICK_NETWORK:
       _setNotice(i, [_nC.t.i, _nC.s.k], 'Connected', tInfo);
       break;
      case notice.Type.LFG_NETWORK:
       _setNotice(i, [_nC.t.i, _nC.s.l], 'Connected', tInfo);
       break;
      case notice.Type.STREAMELEMENTS_NETWORK:
       _setNotice(i, [_nC.t.i, _nC.s.se], 'Connected', tInfo);
       break;
      case notice.Type.STREAMLABS_NETWORK:
       _setNotice(i, [_nC.t.i, _nC.s.sl], 'Connected', tInfo);
       break;
      case notice.Type.BTTV_NETWORK:
       _setNotice(i, [_nC.t.i, _nC.s.b], 'Connected', tInfo);
       break;
      case notice.Type['7TV_NETWORK']:
       _setNotice(i, [_nC.t.i, _nC.s['7']], 'Connected', tInfo);
       break;
     }
    }

    function $warning(w)
    {
     if (_states.hasOwnProperty(w) && _states[w] === _sTypes.warning)
      return;
     _states[w] = _sTypes.warning;
     if (!_timers.hasOwnProperty(w))
      _timers[w] = false;
     _buildNotices();
     const tWarn = 20;
     switch (w)
     {
      case notice.Type.TWITCH_EVENTSUB:
       _setNotice(w, [_nC.t.w, _nC.s.t], 'Too Many Instances<br>Please use existing (reference) copies wherever possible.', tWarn);
       break;
     }
    }

    function $error(e, sMsg = false)
    {
     if (_states.hasOwnProperty(e) && _states[e] === _sTypes.error)
      return;
     _states[e] = _sTypes.error;
     if (!_timers.hasOwnProperty(e))
      _timers[e] = false;
     _buildNotices();
     const tRetry = 15500;
     let sDecErr = 'Decryption Error<br>Please check the &quot;#key=&quot; value of your URL.';
     switch (sMsg)
     {
      case notice.DecryptType.KEY_MISSING:
       sDecErr = 'Decryption Key Missing<br>Please include the &quot;#key=&quot; portion of your URL.';
       break;
      case notice.DecryptType.KEY_INVALID:
       sDecErr = 'Decryption Key Invalid<br>Please check the &quot;#key=&quot; value of your URL.';
       break;
     }
     switch (e)
     {
      case notice.Type.GLOBAL_NET:
       _setNotice(e, [_nC.t.e, _nC.s.g], 'No Internet');
       break;
      case notice.Type.GLOBAL_CFG:
       _setNotice(e, [_nC.t.e, _nC.s.g], 'Corrupted Configuration');
       break;
      case notice.Type.GLOBAL_OBS:
       _setNotice(e, [_nC.t.e, _nC.s.g], 'OBS Not Detected<br>Please see <a href="https://www.youtube.com/watch?v=1hnsN4RZ3ng" target="_blank" title="Adding Emote Wall to OBS" onclick="notice.copyAndOpen(this.href); return false;">this &quot;How to&quot; video</a> on adding the Emote Wall to OBS.');
       break;
      case notice.Type.GLOBAL_DECRYPT:
       _setNotice(e, [_nC.t.e, _nC.s.g], sDecErr);
       break;
      case notice.Type.TWITCH_TOKEN:
       if (typeof loginT !== 'undefined' && loginT.inUse)
       {
        _setNotice(e, [_nC.t.e, _nC.s.t], 'OAuth Token Rejected<br>Please click &quot;Re-Auth&quot; to get a new Token.');
        loginT.showOut(true);
        window.setTimeout(function(){loginT.showIn();}, tRetry);
       }
       else
        _setNotice(e, [_nC.t.e, _nC.s.t], 'OAuth Token Rejected<br>Please update your OAuth Refresh token.');
       break;
      case notice.Type.TWITCH_IRC:
       _setNotice(e, [_nC.t.e, _nC.s.t], 'IRC Disconnected');
       break;
      case notice.Type.TWITCH_EVENTSUB:
       _setNotice(e, [_nC.t.e, _nC.s.t], 'EventSub Disconnected');
       break;
      case notice.Type.TWITCH_DECRYPT:
       switch (sMsg)
       {
        case notice.DecryptType.IV_MISSING:
         sDecErr = 'Encrypted Token Invalid<br>Your &quot;cfg.twitch.oauth_refresh&quot; value has no &quot;iv&quot; attribute.';
         break;
        case notice.DecryptType.B64_INVALID:
         sDecErr = 'Encrypted Token Invalid<br>Your &quot;cfg.twitch.oauth_refresh&quot; value has been corrupted.';
         break;
        case notice.DecryptType.DATA_INVALID:
         sDecErr = 'Decrypted Token Invalid<br>Your &quot;cfg.twitch.oauth_refresh&quot; value has been corrupted.';
         break;
       }
       _setNotice(e, [_nC.t.e, _nC.s.t], sDecErr);
       break;
      case notice.Type.YOUTUBE_TOKEN:
       if (typeof loginYT !== 'undefined' && loginYT.inUse)
       {
        _setNotice(e, [_nC.t.e, _nC.s.y], 'OAuth Token Rejected<br>Please click &quot;Re-Auth&quot; to get a new Token.');
        loginYT.showOut(true);
        window.setTimeout(function(){loginYT.showIn();}, tRetry);
       }
       else
        _setNotice(e, [_nC.t.e, _nC.s.y], 'OAuth Token Rejected<br>Please update your OAuth Refresh token.');
       break;
      case notice.Type.YOUTUBE_NETWORK:
       _setNotice(e, [_nC.t.e, _nC.s.y], 'Disconnected');
       break;
      case notice.Type.YOUTUBE_ACCOUNT:
       if (typeof loginYT !== 'undefined' && loginYT.inUse)
       {
        loginYT.showOut(true);
        window.setTimeout(function(){loginYT.showIn();}, tRetry);
       }
       _setNotice(e, [_nC.t.e, _nC.s.y], 'Streaming Not Available<br>Your YouTube account does not have streaming enabled.');
       break;
      case notice.Type.YOUTUBE_CORS:
       _setNotice(e, [_nC.t.e, _nC.s.y], 'YouTube Server Error<br>Unable to retrieve ' + sMsg + ': <a href="https://udn.realityripple.com/docs/Web/HTTP/CORS/Errors/CORSMissingAllowOrigin" target="_blank" title="Reason: CORS header \'Access-Control-Allow-Origin\' missing - HTTP" onclick="notice.copyAndOpen(this.href); return false;">CORS headers</a> not sent by YouTube.');
       break;
      case notice.Type.YOUTUBE_RATELIMIT:
       _setNotice(e, [_nC.t.e, _nC.s.y], 'YouTube Rate Limit Exceeded<br>You have sent too many requests. Please wait a while.');
       break;
      case notice.Type.YOUTUBE_UNKNOWN:
       _setNotice(e, [_nC.t.e, _nC.s.y], 'Unhandled YouTube Error<br>' + sMsg);
       break;
      case notice.Type.YOUTUBE_DECRYPT:
       switch (sMsg)
       {
        case notice.DecryptType.IV_MISSING:
         sDecErr = 'Encrypted Token Invalid<br>Your &quot;cfg.youtube.oauth_refresh&quot; value has no &quot;iv&quot; attribute.';
         break;
        case notice.DecryptType.B64_INVALID:
         sDecErr = 'Encrypted Token Invalid<br>Your &quot;cfg.youtube.oauth_refresh&quot; value has been corrupted.';
         break;
        case notice.DecryptType.DATA_INVALID:
         sDecErr = 'Decrypted Token Invalid<br>Your &quot;cfg.youtube.oauth_refresh&quot; value has been corrupted.';
         break;
       }
       _setNotice(e, [_nC.t.e, _nC.s.y], sDecErr);
       break;
      case notice.Type.KICK_NAME:
       _setNotice(e, [_nC.t.e, _nC.s.k], 'Connection Rejected<br>Please check your Kick channel name.');
       break;
      case notice.Type.KICK_NETWORK:
       _setNotice(e, [_nC.t.e, _nC.s.k], 'Disconnected');
       break;
      case notice.Type.KICK_UNKNOWN:
       _setNotice(e, [_nC.t.e, _nC.s.k], 'Kick Connection Error<br>' + sMsg);
       break;
      case notice.Type.LFG_NAME:
       _setNotice(e, [_nC.t.e, _nC.s.l], 'Connection Rejected<br>Please check your LFG channel name.');
       break;
      case notice.Type.LFG_ACCOUNT:
       if (typeof loginL !== 'undefined' && loginL.inUse)
       {
        loginL.showOut(true);
        window.setTimeout(function(){loginL.showIn();}, tRetry);
       }
       _setNotice(e, [_nC.t.e, _nC.s.l], 'Streaming Not Available<br>Your LFG account does not have streaming enabled.');
       break;
      case notice.Type.LFG_NETWORK:
       _setNotice(e, [_nC.t.e, _nC.s.l], 'Disconnected');
       break;
      case notice.Type.LFG_UNKNOWN:
       _setNotice(e, [_nC.t.e, _nC.s.l], 'LFG Connection Error<br>' + sMsg);
       break;
      case notice.Type.STREAMELEMENTS_TOKEN:
       _setNotice(e, [_nC.t.e, _nC.s.se], 'OAuth Token Rejected<br>Please update your StreamElements OAuth Token.');
       break;
      case notice.Type.STREAMELEMENTS_NETWORK:
       _setNotice(e, [_nC.t.e, _nC.s.se], 'Disconnected');
       break;
      case notice.Type.STREAMELEMENTS_DECRYPT_OAUTH:
       switch (sMsg)
       {
        case notice.DecryptType.IV_MISSING:
         sDecErr = 'Encrypted Token Invalid<br>Your &quot;cfg.streamelements.oauth_refresh&quot; value has no &quot;iv&quot; attribute.';
         break;
        case notice.DecryptType.B64_INVALID:
         sDecErr = 'Encrypted Token Invalid<br>Your &quot;cfg.streamelements.oauth_refresh&quot; value has been corrupted.';
         break;
        case notice.DecryptType.DATA_INVALID:
         sDecErr = 'Decrypted Token Invalid<br>Your &quot;cfg.streamelements.oauth_refresh&quot; value has been corrupted.';
         break;
       }
       _setNotice(e, [_nC.t.e, _nC.s.se], sDecErr);
       break;
      case notice.Type.STREAMELEMENTS_DECRYPT_JWT:
       switch (sMsg)
       {
        case notice.DecryptType.IV_MISSING:
         sDecErr = 'Encrypted Token Invalid<br>Your &quot;cfg.streamelements.token&quot; value has no &quot;iv&quot; attribute.';
         break;
        case notice.DecryptType.B64_INVALID:
         sDecErr = 'Encrypted Token Invalid<br>Your &quot;cfg.streamelements.token&quot; value has been corrupted.';
         break;
        case notice.DecryptType.DATA_INVALID:
         sDecErr = 'Decrypted Token Invalid<br>Your &quot;cfg.streamelements.token&quot; value has been corrupted.';
         break;
       }
       _setNotice(e, [_nC.t.e, _nC.s.se], sDecErr);
       break;
      case notice.Type.STREAMLABS_TOKEN:
       _setNotice(e, [_nC.t.e, _nC.s.sl], 'Socket Token Rejected<br>Please update your Streamlabs Socket Token.');
       break;
      case notice.Type.STREAMLABS_NETWORK:
       _setNotice(e, [_nC.t.e, _nC.s.sl], 'Disconnected');
       break;
      case notice.Type.STREAMLABS_DECRYPT:
       switch (sMsg)
       {
        case notice.DecryptType.IV_MISSING:
         sDecErr = 'Encrypted Token Invalid<br>Your &quot;cfg.streamlabs.token&quot; value has no &quot;iv&quot; attribute.';
         break;
        case notice.DecryptType.B64_INVALID:
         sDecErr = 'Encrypted Token Invalid<br>Your &quot;cfg.streamlabs.token&quot; value has been corrupted.';
         break;
        case notice.DecryptType.DATA_INVALID:
         sDecErr = 'Decrypted Token Invalid<br>Your &quot;cfg.streamlabs.token&quot; value has been corrupted.';
         break;
       }
       _setNotice(e, [_nC.t.e, _nC.s.sl], sDecErr);
       break;
      case notice.Type.BTTV_NETWORK:
       _setNotice(e, [_nC.t.e, _nC.s.b], 'Disconnected');
       break;
      case notice.Type['7TV_NETWORK']:
       _setNotice(e, [_nC.t.e, _nC.s['7']], 'Disconnected');
       break;
     }
    }

    function $initHide()
    {
     _tHide = window.setTimeout(_activeCheck, _iHide);
    }

    function $resetHide()
    {
     if (_tHide === false)
      return;
     window.clearTimeout(_tHide);
     notice.initHide();
    }

    function _buildNotices()
    {
     if (document.getElementById(idNotices))
      return;
     const n = document.createElement('div');
     n.setAttribute('id', idNotices);
     const b = document.createElement('div');
     b.setAttribute('id', idBadge);
     b.dataset.alerts = 0;
     b.innerHTML = b.dataset.alerts;
     n.appendChild(b);
     document.body.prepend(n);
    }

    function _nDesc(id)
    {
     return idNotice.replaceAll(cVARs.notice.desc, id.description);
    }

    function _setNotice(id, state, msg, t = 0)
    {
     const n = document.getElementById(idNotices);
     if (!n)
      return;
     const b = document.getElementById(idBadge);
     if (!b)
      return;
     b.classList.remove(cFade);
     let hasFader = false;
     const lines = n.getElementsByClassName(idNoticeLine);
     for (let i = 0, l = lines.length; i < l; i++)
     {
      if (!lines[i].classList.contains(cFader))
      {
       hasFader = true;
       break;
      }
     }
     if (!hasFader)
      b.classList.remove(cFader);
     let nID = document.getElementById(_nDesc(id));
     if (!nID)
     {
      b.dataset.alerts++;
      b.innerHTML = b.dataset.alerts;
      nID = document.createElement('div');
      nID.setAttribute('id', _nDesc(id));
      n.appendChild(nID);
     }
     nID.setAttribute('class', idNoticeLine + ' ' + state.join(' '));
     nID.innerHTML = msg;
     if (t > 0)
     {
      document.removeEventListener(evMove, _triggerFadeInNotice(id));
      if (_timers[id] !== false)
       window.clearTimeout(_timers[id]);
      _timers[id] = window.setTimeout(_clearNoticeBegin, t * 1000, id);
     }
     else
     {
      if (_timers[id] !== false)
       window.clearTimeout(_timers[id]);
      _timers[id] = window.setTimeout(_hideNotice, _errTime, id);
     }
     shared.hueSync();
    }

    function _clearNoticeBegin(id)
    {
     const nID = document.getElementById(_nDesc(id));
     if (!nID)
      return;
     nID.classList.add(cHide);
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     _timers[id] = window.setTimeout(_clearNoticeEnd, 300, id);
    }

    function _clearNoticeEnd(id)
    {
     if (_timers[id] !== false)
     {
      window.clearTimeout(_timers[id]);
      _timers[id] = false;
     }
     const n = document.getElementById(idNotices);
     if (!n)
      return;
     const nID = document.getElementById(_nDesc(id));
     if (!nID)
      return;
     n.removeChild(nID);
     const b = document.getElementById(idBadge);
     if (!b)
      return;
     b.dataset.alerts--;
     b.innerHTML = b.dataset.alerts;
    }

    function _hideNotice(id)
    {
     const nID = document.getElementById(_nDesc(id));
     if (!nID)
      return;
     nID.classList.add(cFader);
     nID.classList.add(cFade);
     document.addEventListener(evMove, _triggerFadeInNotice(id));
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     _timers[id] = window.setTimeout(_fadeOutEnd, 500, id);
     const n = document.getElementById(idNotices);
     if (!n)
      return;
     let hasVis = false;
     const lines = n.getElementsByClassName(idNoticeLine);
     for (let i = 0, l = lines.length; i < l; i++)
     {
      if (!lines[i].classList.contains(cFade))
      {
       hasVis = true;
       break;
      }
     }
     if (!hasVis)
     {
      const b = document.getElementById(idBadge);
      if (!b)
       return;
      b.classList.add(cFader);
      b.classList.add(cFade);
     }
    }

    const _triggerFadeInNotice = function(id)
    {
     return function()
     {
      _fadeInNotice(id);
     };
    };

    function _fadeInNotice(id)
    {
     const nID = document.getElementById(_nDesc(id));
     if (!nID)
      return;
     nID.classList.remove(cFaded);
     nID.classList.remove(cFade);
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     if (!nID.classList.contains(cFader))
      return;
     _timers[id] = window.setTimeout(_fadeOutNotice, _visTime, id);
     const b = document.getElementById(idBadge);
     if (!b)
      return;
     b.classList.remove(cFade);
    }

    function _fadeOutNotice(id)
    {
     const nID = document.getElementById(_nDesc(id));
     if (!nID)
      return;
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     if (!nID.classList.contains(cFader))
      return;
     _timers[id] = window.setTimeout(_fadeOutEnd, 500, id);
     nID.classList.add(cFade);
     const n = document.getElementById(idNotices);
     if (!n)
      return;
     let hasVis = false;
     const lines = n.getElementsByClassName(idNoticeLine);
     for (let i = 0, l = lines.length; i < l; i++)
     {
      if (!lines[i].classList.contains(cFade))
      {
       hasVis = true;
       break;
      }
     }
     if (!hasVis)
     {
      const b = document.getElementById(idBadge);
      if (!b)
       return;
      b.classList.add(cFade);
     }
    }

    function _fadeOutEnd(id)
    {
     const nID = document.getElementById(_nDesc(id));
     if (!nID)
      return;
     if (_timers[id] !== false)
     {
      window.clearTimeout(_timers[id]);
      _timers[id] = false;
     }
     if (!nID.classList.contains(cFader))
      return;
     nID.classList.add(cFaded);
    }

    function _activeCheck()
    {
     if (_tHide !== false)
     {
      window.clearTimeout(_tHide);
      _tHide = false;
     }
     const b = document.getElementById(idBadge);
     if (!b)
     {
      notice.initHide();
      return;
     }
     if (!b.dataset.hasOwnProperty('alerts'))
     {
      notice.initHide();
      return;
     }
     if (b.dataset.alerts !== '0')
     {
      notice.initHide();
      return;
     }
     if (notice.active !== notice.expect)
     {
      notice.initHide();
      return;
     }
     const css = document.getElementsByTagName('STYLE')[0];
     let spc = {indent: 0};
     let h = shared.unIndent(css.innerHTML, spc);
     h = h.replaceAll('/* {INSERT:NOTICE_OFF} *\/', 'display: none;');
     h = shared.reIndent(h, spc);
     css.innerHTML = h;
    }

    async function $copyAndOpen(h)
    {
     if (window.open(h, '_blank') !== null)
      return;
     try
     {
      await navigator.clipboard.writeText(h);
      alert('URL Copied to Clipboard');
     }
     catch
     {
      shared.inputBox('Unable to open a new window. Copy this URL:', h, false);
     }
    }

    return {
     info: $info,
     warning: $warning,
     error: $error,
     initHide: $initHide,
     resetHide: $resetHide,
     copyAndOpen: $copyAndOpen,
     expect: 0,
     active: 0,
     Type: Object.freeze({
      GLOBAL_CFG: Symbol(0x0000),
      GLOBAL_NET: Symbol(0x0001),
      GLOBAL_OBS: Symbol(0x0007),
      GLOBAL_DECRYPT: Symbol(0x000D),
      TWITCH_IRC: Symbol(0x0011),
      TWITCH_EVENTSUB: Symbol(0x0021),
      TWITCH_TOKEN: Symbol(0x0013),
      TWITCH_DECRYPT: Symbol(0x001D),
      YOUTUBE_NETWORK: Symbol(0x0101),
      YOUTUBE_TOKEN: Symbol(0x0103),
      YOUTUBE_ACCOUNT: Symbol(0x0104),
      YOUTUBE_CORS: Symbol(0x0107),
      YOUTUBE_RATELIMIT: Symbol(0x0108),
      YOUTUBE_UNKNOWN: Symbol(0x0109),
      YOUTUBE_DECRYPT: Symbol(0x010D),
      KICK_NETWORK: Symbol(0x0041),
      KICK_NAME: Symbol(0x0044),
      KICK_UNKNOWN: Symbol(0x0049),
      LFG_NETWORK: Symbol(0x0201),
      LFG_NAME: Symbol(0x0202),
      LFG_ACCOUNT: Symbol(0x0204),
      LFG_UNKNOWN: Symbol(0x0209),
      STREAMELEMENTS_NETWORK: Symbol(0x1001),
      STREAMELEMENTS_TOKEN: Symbol(0x1003),
      STREAMELEMENTS_DECRYPT_OAUTH: Symbol(0x100D),
      STREAMELEMENTS_DECRYPT_JWT: Symbol(0x100E),
      STREAMLABS_NETWORK: Symbol(0x2001),
      STREAMLABS_TOKEN: Symbol(0x2003),
      STREAMLABS_DECRYPT: Symbol(0x200D),
      BTTV_NETWORK: Symbol(0x4001),
      '7TV_NETWORK': Symbol(0x8001)
     }),
     DecryptType: Object.freeze({
      KEY_MISSING: Symbol(),
      KEY_INVALID: Symbol(),
      IV_MISSING: Symbol(),
      B64_INVALID: Symbol(),
      DATA_INVALID: Symbol()
     }),
     Connection: Object.freeze({
      TWITCH_IRC: 0x001,
      TWITCH_EVENTSUB: 0x002,
      KICK: 0x004,
      YOUTUBE: 0x010,
      LFG: 0x020,
      STREAMELEMENTS: 0x100,
      STREAMLABS: 0x200,
      BTTV: 0x400,
      '7TV': 0x800
     })
    };
   }();

   if (typeof cfg === 'undefined')
   {
    document.title = 'Emote Wall Configuration Error';
    window.addEventListener('load', function(){notice.error(notice.Type.GLOBAL_CFG);});
    throw new Error('Corrupted Configuration detected.');
   }
   document.title = 'RealityRipple\'s Home-Made Emote Wall';

   const display = function()
   {
    let _eActive = 0;
    let _iTitanic = 0;
    const _cRadius = Math.PI * 2;
    const _tAnim = Object.freeze({
     fade: Object.freeze({
      in: 8,
      out: 8
     }),
     zoom: Object.freeze({
      in: 17,
      out: 8
     })
    });

    const $emote = function()
    {
     const _toShow = [];
     const _toSift = new Set();

     let _tEmote = false;

     const $list = function()
     {
      function $Still(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = Date.now();
       if (_iTitanic > tInit)
        return;
       if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
        return;
       const variationSize = _rndVar(canV);
       eH = Math.ceil(eH * variationSize);
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const h = shared.rnd(sW - eW);
       const v = shared.rnd(sH - eH);
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Still.time);
       const s = 'top: ' + v + 'px;' +
        ' left: ' + h + 'px;' +
        ' --emote-height: ' + eH + 'px;' +
        ' --emote-width: ' + eW + 'px;' +
        _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s}, {space: false, time: tMS});
      }

      const $StraightLine = function()
      {
       const _Sides = Object.freeze({
        NONE: 0x00,
        LEFT: 0x01,
        RIGHT: 0x02,
        TOP: 0x04,
        BOTTOM: 0x08
       });

       function $c_StraightLine(eInf, sW, sH, eH, x = false, y = false, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
         return;
        const variationSize = _rndVar(canV);
        eH = Math.ceil(eH * variationSize);
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const eHh = Math.ceil(eH / 2);
        const eWh = Math.ceil(eW / 2);
        let h = x;
        if (h === false)
         h = shared.rnd(sW) - eWh;
        let v = y;
        if (v === false)
         v = shared.rnd(sH) - eHh;
        const r = Math.min(sW, sH) * (shared.rnd() + 1);
        let th = shared.rnd() * _cRadius;
        if (!cfg.display.toroidal && !x && !y)
        {
         const nH = eH * -1;
         const nW = eW * -1;
         while (!_safePoints(h, v, th, r, nW, nH, sW, sH))
         {
          th = shared.rnd() * _cRadius;
         }
        }
        const hD = Math.floor(h + r * Math.cos(th));
        const vD = Math.floor(v + r * Math.sin(th));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.StraightLine.time);
        const sO = 'transform: translate(' + h + 'px, ' + v + 'px);';
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         ' ' + sO +
         _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
        const aC = [display.emote.clsID.StraightLine];
        _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s, classes: aC}, {time: tMS}, {x: hD, y: vD});
        if (cfg.display.toroidal)
        {
         let pastL = (h > hD && hD < 0) ? Math.floor((Math.abs(hD) + sW) / sW) : 0;
         let pastR = (h < hD && hD > (sW - eW)) ? Math.floor(hD / sW) : 0;
         let pastT = (v > vD && vD < 0) ? Math.floor((Math.abs(vD) + sH) / sH) : 0;
         let pastB = (v < vD && vD > (sH - eH)) ? Math.floor(vD / sH) : 0;
         const negW = -1 * eW;
         const negH = -1 * eH;
         const sZ = 'transform: translate(' + cVARs.css.x + 'px, ' + cVARs.css.y + 'px);';
         while (pastT)
         {
          const lH = sH * pastT;
          const lowerV = v + lH;
          const lowerVD = vD + lH;
          const sB = s.replace(sO, sZ.replace(cVARs.css.x, h).replace(cVARs.css.y, lowerV));
          if (_csClip(negW, negH, sW, sH, h, lowerV, hD, lowerVD))
           _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sB, classes: aC}, {space: false, time: tMS}, {x: hD, y: lowerVD});
          let tL = pastL;
          while (tL)
          {
           const lW = sW * tL;
           const righterH = h + lW;
           const righterHD = hD + lW;
           const sR = s.replace(sO, sZ.replace(cVARs.css.x, righterH).replace(cVARs.css.y, lowerV));
           if (_csClip(negW, negH, sW, sH, righterH, lowerV, righterHD, lowerVD))
            _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sR, classes: aC}, {space: false, time: tMS}, {x: righterHD, y: lowerVD});
           tL--;
          }
          let tR = pastR;
          while (tR)
          {
           const lW = sW * tR;
           const lefterH = h - lW;
           const lefterHD = hD - lW;
           const sL = s.replace(sO, sZ.replace(cVARs.css.x, lefterH).replace(cVARs.css.y, lowerV));
           if (_csClip(negW, negH, sW, sH, lefterH, lowerV, lefterHD, lowerVD))
            _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sL, classes: aC}, {space: false, time: tMS}, {x: lefterHD, y: lowerVD});
           tR--;
          }
          pastT--;
         }
         while (pastB)
         {
          const lH = sH * pastB;
          const higherV = v - lH;
          const higherVD = vD - lH;
          const sT = s.replace(sO, sZ.replace(cVARs.css.x, h).replace(cVARs.css.y, higherV));
          if (_csClip(negW, negH, sW, sH, h, higherV, hD, higherVD))
           _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sT, classes: aC}, {space: false, time: tMS}, {x: hD, y: higherVD});
          let bL = pastL;
          while (bL)
          {
           const lW = sW * bL;
           const righterH = h + lW;
           const righterHD = hD + lW;
           const sR = s.replace(sO, sZ.replace(cVARs.css.x, righterH).replace(cVARs.css.y, higherV));
           if (_csClip(negW, negH, sW, sH, righterH, higherV, righterHD, higherVD))
            _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sR, classes: aC}, {space: false, time: tMS}, {x: righterHD, y: higherVD});
           bL--;
          }
          let bR = pastR;
          while (bR)
          {
           const lW = sW * bR;
           const lefterH = h - lW;
           const lefterHD = hD - lW;
           const sL = s.replace(sO, sZ.replace(cVARs.css.x, lefterH).replace(cVARs.css.y, higherV));
           if (_csClip(negW, negH, sW, sH, lefterH, higherV, lefterHD, higherVD))
            _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sL, classes: aC}, {space: false, time: tMS}, {x: lefterHD, y: higherVD});
           bR--;
          }
          pastB--;
         }
         while (pastL)
         {
          const lW = sW * pastL;
          const righterH = h + lW;
          const righterHD = hD + lW;
          const sR = s.replace(sO, sZ.replace(cVARs.css.x, righterH).replace(cVARs.css.y, v));
          if (_csClip(negW, negH, sW, sH, righterH, v, righterHD, vD))
           _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sR, classes: aC}, {space: false, time: tMS}, {x: righterHD, y: vD});
          pastL--;
         }
         while (pastR)
         {
          const lW = sW * pastR;
          const lefterH = h - lW;
          const lefterHD = hD - lW;
          const sL = s.replace(sO, sZ.replace(cVARs.css.x, lefterH).replace(cVARs.css.y, v));
          if (_csClip(negW, negH, sW, sH, lefterH, v, lefterHD, vD))
           _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sL, classes: aC}, {space: false, time: tMS}, {x: lefterHD, y: vD});
          pastR--;
         }
        }
       }

       function _csClip(xMin, yMin, xMax, yMax, x0, y0, x1, y1)
       {
        xMin++;
        yMin++;
        xMax--;
        yMax--;
        let outcode0 = _csOutCode(xMin, yMin, xMax, yMax, x0, y0);
        let outcode1 = _csOutCode(xMin, yMin, xMax, yMax, x1, y1);
        let a = false;
        while (true)
        {
         if ((outcode0 | outcode1) === _Sides.NONE)
         {
          a = true;
          break;
         }
         if ((outcode0 & outcode1) !== _Sides.NONE)
          break;
         let x;
         let y;
         const outcodeOut = Math.max(outcode1, outcode0);
         if ((outcodeOut & _Sides.BOTTOM) === _Sides.BOTTOM)
         {
          x = x0 + (x1 - x0) * (yMax - y0) / (y1 - y0);
          y = yMax;
         }
         else if ((outcodeOut & _Sides.TOP) === _Sides.TOP)
         {
          x = x0 + (x1 - x0) * (yMin - y0) / (y1 - y0);
          y = yMin;
         }
         else if ((outcodeOut & _Sides.RIGHT) === _Sides.RIGHT)
         {
          y = y0 + (y1 - y0) * (xMax - x0) / (x1 - x0);
          x = xMax;
         }
         else if ((outcodeOut & _Sides.LEFT) === _Sides.LEFT)
         {
          y = y0 + (y1 - y0) * (xMin - x0) / (x1 - x0);
          x = xMin;
         }
         if (outcodeOut === outcode0)
         {
          x0 = x;
          y0 = y;
          outcode0 = _csOutCode(xMin, yMin, xMax, yMax, x0, y0);
         }
         else
         {
          x1 = x;
          y1 = y;
          outcode1 = _csOutCode(xMin, yMin, xMax, yMax, x1, y1);
         }
        }
        return a;
       }

       function _csOutCode(xMin, yMin, xMax, yMax, x, y)
       {
        let code = _Sides.NONE;
        if (x < xMin)
         code |= _Sides.LEFT;
        else if (x > xMax)
         code |= _Sides.RIGHT;
        if (y < yMin)
         code |= _Sides.TOP;
        else if (y > yMax)
         code |= _Sides.BOTTOM;
        return code;
       }

       return $c_StraightLine;
      }();

      function $Rise(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = Date.now();
       if (_iTitanic > tInit)
        return;
       if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
        return;
       const variationSize = _rndVar(canV);
       eH = Math.ceil(eH * variationSize);
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const h = shared.rnd(sW) - eWh;
       const v = Math.floor(sH * _rndFromRange(timing.display.Rise.origin));
       const vD = Math.floor(sH * _rndFromRange(timing.display.Rise.dest));
       const aNames = [];
       const aDelays = [];
       const aDurs = [];
       const aTimings = [];
       const aFills = [];
       const aIters = [];
       if (shared.rnd(2) === 0)
        aNames.push('wiggleL');
       else
        aNames.push('wiggleR');
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Rise.time);
       const d = Math.floor(tMS * _rndFromRange(timing.display.Rise.wiggle.delay));
       aDelays.push(d + 'ms');
       const w = Math.floor(tMS * _rndFromRange(timing.display.Rise.wiggle));
       aDurs.push(w + 'ms');
       aTimings.push('ease-in-out');
       aFills.push('both');
       aIters.push('infinite');
       aNames.push('offsetPath');
       aDelays.push('0s');
       aDurs.push(tMS + 'ms');
       aTimings.push('linear');
       aFills.push('forwards');
       aIters.push('1');
       const sO = 'left: ' + h + 'px;';
       let pY = '-' + eH;
       if (cfg.emote.out.fade || cfg.emote.out.zoom)
        pY = vD;
       const s = sO +
        ' --emote-height: ' + eH + 'px;' +
        ' --emote-width: ' + eW + 'px;' +
        ' offset-path: path("M 0 ' + v + ' L 0 ' + pY + '") ;' +
        _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s}, {space: false, time: tMS});
       if (cfg.display.toroidal)
       {
        const pastL = h < eW;
        const pastR = h > (sW - eW);
        const sZ = 'left: ' + cVARs.css.x + 'px;';
        if (pastL)
        {
         const sR = s.replace(sO, sZ.replace(cVARs.css.x, h + sW));
         _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sR}, {space: false, time: tMS});
        }
        if (pastR)
        {
         const sL = s.replace(sO, sZ.replace(cVARs.css.x, h - sW));
         _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sL}, {space: false, time: tMS});
        }
       }
      }

      const $Bounce = function()
      {
       function $c_Bounce(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
         return;
        const variationSize = _rndVar(canV);
        eH = Math.ceil(eH * variationSize);
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const eWh = Math.ceil(eW / 2);
        const sWm = Math.ceil(sW / 2);
        const h = Math.floor(shared.rnd(sW) - eWh);
        const v = Math.floor(sH * _rndFromRange(timing.display.Bounce.origin));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Bounce.time);
        const vMS = (tMS / 300 / (16 + 2 / 3));
        let velH = _rndFromRange(timing.display.Bounce.velocity.h);
        const velV = _rndFromRange(timing.display.Bounce.velocity.v);
        if (h + eWh > sWm)
         velH *= -1;
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         ' transform: translate(' + h + 'px, ' + v + 'px);' +
         _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
        const bX = h;
        const bY = v;
        const iArr = _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s}, {time: tMS});
        if (iArr.length === 0)
         return;
        window.requestAnimationFrame(function(ts){_tLoop(tInit, eInf.origin, iArr, bX, bY, velH, velV, vMS, sH, eH, ts, ts);});
       }

       function _tLoop(tInit, oID, iArr, bX, bY, velH, velV, vMS, sH, eH, myT, ts)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        if (iArr[0].parentNode === null)
         return;
        let steps = 1;
        if (myT === 0)
         myT = ts;
        else
        {
         steps = Math.max(1, Math.floor((ts - myT) / 16));
         myT = ts;
        }
        for (let i = 0; i < steps; i++)
        {
         bX += velH / vMS;
         bY += velV / vMS;
         velV += timing.display.Bounce.gravity / vMS;
         const sB = sH - eH;
         if (bY >= sB)
         {
          bY = sB;
          velV *= -1 * (1 - timing.display.Bounce.velocity.loss);
          velV = Math.floor(velV);
         }
        }
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].style.transform = 'translate(' + bX + 'px, ' + bY + 'px)';
        }
        window.requestAnimationFrame(function(fTS){_tLoop(tInit, oID, iArr, bX, bY, velH, velV, vMS, sH, eH, myT, fTS);});
       }

       return $c_Bounce;
      }();

      function $Speed(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = Date.now();
       if (_iTitanic > tInit)
        return;
       if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
        return;
       const variationSize = _rndVar(canV);
       eH = Math.ceil(eH * variationSize);
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const sWm = Math.ceil(sW / 2);
       const h = shared.rnd(sW) - eWh;
       const v = Math.floor(sH * _rndFromRange(timing.display.Speed.origin));
       const aNames = [];
       const aDelays = [];
       const aDurs = [];
       const aTimings = [];
       const aFills = [];
       const aIters = [];
       const dsO = {};
       if (h + eWh > sWm)
       {
        dsO.origin = 'right';
        aNames.push('speedL');
       }
       else
       {
        dsO.origin = 'left';
        aNames.push('speedR');
       }
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Speed.time);
       const d = Math.floor(tMS * timing.display.Speed.delay);
       aDelays.push(d + 'ms');
       aDurs.push((tMS - d) + 'ms');
       aTimings.push('ease-in');
       aFills.push('forwards');
       aIters.push('1');
       const s = 'top: ' + v + 'px;' +
        ' left: ' + h + 'px;' +
        ' --emote-height: ' + eH + 'px;' +
        ' --emote-width: ' + eW + 'px;' +
        _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s, dataset: dsO}, {time: tMS});
      }

      function $Drop(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = Date.now();
       if (_iTitanic > tInit)
        return;
       if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
        return;
       const variationSize = _rndVar(canV);
       eH = Math.ceil(eH * variationSize);
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const h = shared.rnd(sW) - eWh;
       const aNames = [];
       const aDelays = [];
       const aDurs = [];
       const aTimings = [];
       const aFills = [];
       const aIters = [];
       const dsO = {};
       if (shared.rnd(2) === 0)
       {
        dsO.origin = 'topleft';
        aNames.push('dropL');
       }
       else
       {
        dsO.origin = 'topright';
        aNames.push('dropR');
       }
       aDelays.push('0s');
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Drop.time);
       aDurs.push(tMS + 'ms');
       aTimings.push('ease-in');
       aFills.push('forwards');
       aIters.push('1');
       const sO = 'left: ' + h + 'px;';
       const s = sO +
        ' --emote-height: ' + eH + 'px;' +
        ' --emote-width: ' + eW + 'px;' +
        _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s, dataset: dsO}, {space: false, time: tMS});
       if (cfg.display.toroidal)
       {
        const pastL = h < eW;
        const pastR = h > (sW - eW);
        const sZ = 'left: ' + cVARs.css.x + 'px;';
        if (pastL)
        {
         const sR = s.replace(sO, sZ.replace(cVARs.css.x, h + sW));
         _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sR, dataset: dsO}, {space: false, time: tMS});
        }
        if (pastR)
        {
         const sL = s.replace(sO, sZ.replace(cVARs.css.x, h - sW));
         _addEmoteAndZWEs(tInit, eInf, variationSize, {style: sL, dataset: dsO}, {space: false, time: tMS});
        }
       }
      }

      const $Crazy = function()
      {
       /* LAYOUT SHIFTS
        * =============
        * squashes via scale
        * offset-path requires support for offset-anchor/offset-position
        * due to transform-origin changes during squash
        */
       const _Wall = Object.freeze({
        NONE: 0,
        LEFT: 1,
        TOP: 2,
        RIGHT: 3,
        BOTTOM: 4
       });
       const _Origin = ['center', 'left', 'top', 'right', 'bottom'];
       const _Squash = ['no', 'horizontal', 'vertical', 'horizontal', 'vertical'];

       function $c_Crazy(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
         return;
        const variationSize = _rndVar(canV);
        eH = Math.ceil(eH * variationSize);
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const sR = sW - eW;
        const sB = sH - eH;
        const h = shared.rnd(sR - 5) + 10;
        const v = shared.rnd(sB - 5) + 10;
        const dests = [];
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time);
        const rate = Math.sqrt(timing.display.Crazy.distance ** 2 / 2) / tMS;
        const traj = {x: 0, y: 0};
        while (traj.x === 0 && traj.y === 0)
        {
         traj.x = shared.rnd() * (rate * 2) - rate;
         traj.y = shared.rnd() * (rate * 2) - rate;
        }
        const pos = {x: h, y: v, t: 0};
        let lastT = 0;
        let bCt = 0;
        const sqTime = Math.floor(tMS * timing.display.Crazy.squash.time * 2);
        while (bCt * sqTime + pos.t < tMS)
        {
         pos.x += traj.x;
         pos.y += traj.y;
         pos.t += 1;
         let wall = _Wall.NONE;
         if (pos.x <= 0)
         {
          pos.x = 0;
          traj.x *= -1;
          wall = _Wall.LEFT;
         }
         else if (pos.x >= sR)
         {
          pos.x = sR;
          traj.x *= -1;
          wall = _Wall.RIGHT;
         }
         if (pos.y <= 0)
         {
          pos.y = 0;
          traj.y *= -1;
          wall = _Wall.TOP;
         }
         else if (pos.y >= sB)
         {
          pos.y = sB;
          traj.y *= -1;
          wall = _Wall.BOTTOM;
         }
         if (wall !== _Wall.NONE)
         {
          bCt++;
          dests.push({x: Math.floor(pos.x), y: Math.floor(pos.y), t: pos.t - lastT, w: wall});
          lastT = pos.t;
         }
        }
        dests.push({x: pos.x, y: pos.y, t: pos.t - lastT, w: _Wall.NONE});
        const s = 'top: ' + v + 'px;' +
         ' left: ' + h + 'px;' +
         ' --emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
        const iArr = _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s}, {space: false, time: tMS});
        if (iArr.length === 0)
         return;
        const d = 0;
        const lA = iArr.length;
        const lD = dests.length;
        shared.doNextFrame(_tLoop, tInit, eInf.origin, lA, iArr, lD, dests, d);
       }

       function _tLoop(tInit, oID, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        if (d >= lD)
         return;
        const squashT = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time * timing.display.Crazy.squash.time);
        for (let i = 0; i < lA; i++)
        {
         iArr[i].dataset.origin = _Origin[0];
         iArr[i].dataset.squash = _Squash[0];
         iArr[i].style.top = dests[d].y + 'px';
         iArr[i].style.left = dests[d].x + 'px';
         iArr[i].style.transition = 'top ' + dests[d].t + 'ms linear, left ' + dests[d].t + 'ms linear, transform ' + squashT + 'ms linear';
        }
        d++;
        window.setTimeout(_tSquash, dests[d - 1].t, tInit, oID, lA, iArr, lD, dests, d);
       }

       function _tSquash(tInit, oID, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        const squashT = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time * timing.display.Crazy.squash.time);
        for (let i = 0; i < lA; i++)
        {
         if (dests[d - 1].w === _Wall.NONE)
          continue;
         iArr[i].dataset.origin = _Origin[dests[d - 1].w];
         iArr[i].dataset.squash = _Squash[dests[d - 1].w];
        }
        window.setTimeout(_tUnsquash, squashT, tInit, oID, lA, iArr, lD, dests, d);
       }

       function _tUnsquash(tInit, oID, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        const squashT = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time * timing.display.Crazy.squash.time);
        for (let i = 0; i < lA; i++)
        {
         iArr[i].dataset.squash = _Squash[0];
        }
        window.setTimeout(_tLoop, squashT, tInit, oID, lA, iArr, lD, dests, d);
       }

       return $c_Crazy;
      }();

      function $Confetti(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = Date.now();
       if (_iTitanic > tInit)
        return;
       if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
        return;
       const variationSize = _rndVar(canV);
       eH = Math.ceil(eH * variationSize);
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const h = shared.rnd(sW) - eWh;
       const aNames = [];
       const aDelays = [];
       const aDurs = [];
       const aTimings = [];
       const aFills = [];
       const aIters = [];
       switch (shared.rnd(3))
       {
        case 0:
         aNames.push('confettiA');
         break;
        case 1:
         aNames.push('confettiB');
         break;
        case 2:
         aNames.push('confettiC');
         break;
       }
       aDelays.push('0s');
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Confetti.time);
       aDurs.push(tMS + 'ms');
       aTimings.push('linear');
       aFills.push('forwards');
       aIters.push('1');
       const s = 'left: ' + h + 'px;' +
        ' --emote-height: ' + eH + 'px;' +
        ' --emote-width: ' + eW + 'px;' +
        _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, false, tMS);
       _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s}, {space: false, time: tMS});
      }

      const $Throw = function()
      {
       function $c_Throw(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
         return;
        const variationSize = _rndVar(canV);
        eH = Math.ceil(eH * variationSize);
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const sR = sW - eW;
        const sB = sH - eH;
        const h = shared.rnd(2) === 0 ? eW * -1 : sW;
        const v = shared.rnd(sH + eH) - eH;
        const hD = Math.floor(sR * _rndFromRange(timing.display.Throw.dest.h));
        const vD = Math.floor(sB * _rndFromRange(timing.display.Throw.dest.v));
        const dH = shared.rnd() * eH;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Throw.time);
        const t2 = Math.floor(tMS * timing.display.Throw.toss);
        const t3 = Math.floor(tMS * timing.display.Throw.drop);
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         ' transform: translate(' + h + 'px, ' + v + 'px);';
        const aNames = [];
        const aDelays = [];
        const aDurs = [];
        const aTimings = [];
        const aFills = [];
        const aIters = [];
        if (cfg.emote.out.fade)
        {
         const fOut = _tAnim.fade.out / 100;
         const t3F = t3 * fOut;
         aNames.push('fadeOut');
         aDelays.push(Math.floor(t3 - t3F) + 'ms');
         aDurs.push(Math.floor(t3F) + 'ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        else
        {
         aNames.push('noFadeOut');
         aDelays.push(t3 - 50 + 'ms');
         aDurs.push('50ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        if (cfg.emote.out.zoom)
        {
         const zOut = _tAnim.zoom.out / 100;
         const t3Z = t3 * zOut;
         aNames.push('zoomOut');
         aDelays.push(Math.floor(t3 - t3Z) + 'ms');
         aDurs.push(Math.floor(t3Z) + 'ms');
         aTimings.push('linear');
         aFills.push('forwards');
         aIters.push('1');
        }
        let r = '360';
        if (h > 0)
         r = '-360';
        const s2 = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         ' transform: translate(' + hD + 'px, ' + (sH - dH) + 'px) rotate(' + r + 'deg);' +
         _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters, tMS);
        const iArr = _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s, classes: [display.emote.clsID.Throw.Twist]}, {space: false, time: tMS});
        if (iArr.length === 0)
         return;
        shared.doNextFrame(_tMove, tInit, eInf.origin, iArr, hD, vD);
        window.setTimeout(_tDrop, t2, tInit, eInf.origin, iArr, s2);
       }

       function _tMove(tInit, oID, iArr, hD, vD)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
        }
       }

       function _tDrop(tInit, oID, iArr, s2)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].classList.replace(display.emote.clsID.Throw.Twist, display.emote.clsID.Throw.Drop);
         iArr[i].setAttribute('style', s2);
        }
       }

       return $c_Throw;
      }();

      const $Pop = function()
      {
       function $c_Pop(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
         return;
        const variationSize = _rndVar(canV);
        eH = Math.ceil(eH * variationSize);
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const sR = sW - eW;
        const sB = sH - eH;
        const h = shared.rnd(sR);
        const v = sH;
        const vT = Math.floor(sH * _rndFromRange(timing.display.Pop.top));
        const vB = Math.floor(sH * _rndFromRange(timing.display.Pop.bottom));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Pop.time);
        const t1 = Math.floor(tMS * timing.display.Pop.peek.up);
        const t2 = Math.floor(tMS * timing.display.Pop.peek.pause);
        const t3 = Math.floor(tMS * timing.display.Pop.peek.down);
        const t4 = Math.floor(tMS * timing.display.Pop.pause);
        const t5 = Math.floor(tMS * timing.display.Pop.jump.up);
        const t6 = Math.floor(tMS * timing.display.Pop.jump.pause);
        const t7 = Math.floor(tMS * timing.display.Pop.jump.down);
        const aNames = [];
        const aDelays = [];
        const aDurs = [];
        const aTimings = [];
        const aFills = [];
        const aIters = [];
        if (cfg.emote.out.fade)
        {
         const fOut = _tAnim.fade.out / 100;
         const t7F = t7 * fOut;
         aNames.push('fadeOut');
         aDelays.push(t1 + t2 + t3 + t4 + t5 + t6 + Math.floor(t7 - t7F) + 'ms');
         aDurs.push(Math.floor(t7F) + 'ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        else
        {
         aNames.push('noFadeOut');
         aDelays.push(t1 + t2 + t3 + t4 + t5 + t6 + t7 - 50 + 'ms');
         aDurs.push('50ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        if (cfg.emote.out.zoom)
        {
         const zOut = _tAnim.zoom.out / 100;
         const t7Z = t7 * zOut;
         aNames.push('zoomOut');
         aDelays.push(t1 + t2 + t3 + t4 + t5 + t6 + Math.floor(t7 - t7Z) + 'ms');
         aDurs.push(Math.floor(t7Z) + 'ms');
         aTimings.push('linear');
         aFills.push('forwards');
         aIters.push('1');
        }
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         ' left: ' + h + 'px;' +
         ' transform: translateY(' + v + 'px);' +
         _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters, tMS);
        const iArr = _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s, classes: [display.emote.clsID.Pop.Peek]}, {space: false, time: tMS});
        if (iArr.length === 0)
         return;
        shared.doNextFrame(_tMove, tInit, eInf.origin, iArr, sB);
        window.setTimeout(_tMove, t1 + t2, tInit, eInf.origin, iArr, v);
        window.setTimeout(_tMove, t1 + t2 + t3 + t4, tInit, eInf.origin, iArr, vT);
        window.setTimeout(_tMove, t1 + t2 + t3 + t4 + t5 + t6, tInit, eInf.origin, iArr, vB);
       }

       function _tMove(tInit, oID, iArr, vD)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].classList.replace(display.emote.clsID.Pop.JumpUp, display.emote.clsID.Pop.JumpDown);
         iArr[i].classList.replace(display.emote.clsID.Pop.PeekDown, display.emote.clsID.Pop.JumpUp);
         iArr[i].classList.replace(display.emote.clsID.Pop.PeekUp, display.emote.clsID.Pop.PeekDown);
         iArr[i].classList.replace(display.emote.clsID.Pop.Peek, display.emote.clsID.Pop.PeekUp);
         iArr[i].style.transform = 'translateY( ' + vD + 'px)';
        }
       }

       return $c_Pop;
      }();

      const $TheCube = function()
      {
       const _faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];

       function $c_TheCube(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
         return;
        const scene = document.createElement('div');
        scene.setAttribute('class', 'scene cube');
        const variationSize = _rndVar(canV);
        eH = Math.ceil(eH * variationSize);
        const eHh = Math.ceil(eH / 2);
        const nHh = eHh * -1;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.TheCube.time);
        const cube = document.createElement('div');
        cube.setAttribute('class', 'cube');
        cube.setAttribute('style', 'transform: translateZ(' + nHh + 'px);');
        for (let i = 0; i < 6; i++)
        {
         if (!eInf.hasOwnProperty('zwe') || eInf.zwe.length === 0)
         {
          const iFace = document.createElement('img');
          _setImgSrc(iFace, eInf.url);
          iFace.dataset.face = _faces[i];
          iFace.dataset.msgid = eInf.origin;
          cube.appendChild(iFace);
         }
         else
         {
          const dFace = document.createElement('div');
          dFace.dataset.face = _faces[i];
          const pFace = document.createElement('img');
          const btzwCE = _btzwClassForEmote(eInf.zwe);
          pFace.setAttribute('class', btzwCE.join(' '));
          _setImgSrc(pFace, eInf.url);
          pFace.dataset.msgid = eInf.origin;
          dFace.appendChild(pFace);
          for (let j = 0, l = eInf.zwe.length; j < l; j++)
          {
           const pctZ = document.createElement('img');
           const btzwCZ = _btzwClassForZWE(btzwCE, eInf.zwe[j].url);
           pctZ.setAttribute('class', btzwCZ.join(' '));
           _setImgSrc(pctZ, eInf.zwe[j].url);
           pctZ.dataset.msgid = eInf.origin;
           dFace.appendChild(pctZ);
          }
          cube.appendChild(dFace);
         }
        }
        scene.appendChild(cube);
        const h = shared.rnd(sW) - eHh;
        const v = shared.rnd(sH) - eHh;
        const r = Math.min(sW, sH) * (shared.rnd() + 1);
        let th = shared.rnd() * _cRadius;
        const nH = eH * -1;
        while (!_safePoints(h, v, th, r, nH, nH, sW, sH))
        {
         th = shared.rnd() * _cRadius;
        }
        const hD = Math.floor(h + r * Math.cos(th));
        const vD = Math.floor(v + r * Math.sin(th));
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eH + 'px;' +
         ' --cube-depth: ' + eHh + 'px;' +
         ' perspective: ' + eH * 3 + 'px;' +
         ' transform: translate(' + h + 'px, ' + v + 'px);' +
         _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false, tMS);
        scene.setAttribute('style', s);
        _eActive += 6;
        document.body.appendChild(scene);
        _gc.hook(scene, true, 6, tMS);
        shared.doNextFrame(_tMove, tInit, eInf.origin, cube, scene, hD, vD, eH);
       }

       function _tMove(tInit, oID, cube, scene, hD, vD, eH)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        const nHh = Math.ceil(eH / 2) * -1;
        let rX = 0;
        let rY = 0;
        while (Math.abs(rX) + Math.abs(rY) < 45)
        {
         rX = (360 - shared.rnd() * 720) * cfg.emote.cube.rotations;
         rY = (360 - shared.rnd() * 720) * cfg.emote.cube.rotations;
        }
        cube.style.transform = 'translateZ(' + nHh + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
        scene.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
       }

       return $c_TheCube;
      }();

      function $Fountain(eInf, sW, sH, eH, fX, fY, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = Date.now();
       if (_iTitanic > tInit)
        return;
       if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
        return;
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Fountain.time);
       const variationSize = _rndVar(canV);
       eH = Math.ceil(eH * variationSize);
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const sR = sW - eW;
       const sB = sH - eH;
       let h = fX;
       if (h === false)
        h = Math.floor(shared.rnd() * (sR * 0.33) + sR * 0.33);
       let hD;
       if (shared.rnd(2) === 0)
        hD = h - shared.rnd(sR * 0.2);
       else
        hD = h + shared.rnd(sR * 0.2);
       const aNames = [];
       const aDelays = [];
       const aDurs = [];
       const aTimings = [];
       const aFills = [];
       const aIters = [];
       aNames.push('offsetPath');
       aDelays.push('0s');
       aDurs.push(tMS + 'ms');
       aTimings.push('cubic-bezier(0, 0.9, 1, 0.15)');
       aFills.push('forwards');
       aIters.push('1');
       const s = '--emote-height: ' + eH + 'px;' +
        ' --emote-width: ' + eW + 'px;' +
        ' transform: translateX(' + h + 'px);' +
        ' offset-path: path("M 0 ' + sH + ' L 0 ' + Math.floor(fY * sH + shared.rnd(sB / 2)) + ' L 0 ' + (sH + eH) + '");' +
        _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters, tMS);
       _addEmoteAndZWEs(tInit, eInf, variationSize, {style: s, classes: [display.emote.clsID.Fountain]}, {time: tMS, space: false}, {x: hD});
      }

      return {
       Still: $Still,
       StraightLine: $StraightLine,
       Rise: $Rise,
       Bounce: $Bounce,
       Speed: $Speed,
       Drop: $Drop,
       Crazy: $Crazy,
       Confetti: $Confetti,
       Throw: $Throw,
       Pop: $Pop,
       TheCube: $TheCube,
       Fountain: $Fountain
      };
     }();

     function _rndVar(canV = true)
     {
      if (!canV)
       return 1;
      if (cfg.emote.size.variation === false)
       return 1;
      const chances = [];
      switch (typeof cfg.emote.size.variation)
      {
       case 'number':
        chances.push(0.5);
        chances.push(2);
        for (let i = 0; i < cfg.emote.size.variation; i++)
        {
         chances.push(1);
        }
        break;
       case 'object':
        if (!cfg.emote.size.variation.hasOwnProperty('chance'))
         return 1;
        if (!cfg.emote.size.variation.hasOwnProperty('range'))
         return 1;
        if (!Array.isArray(cfg.emote.size.variation.range))
         return 1;
        chances.push(...cfg.emote.size.variation.range);
        for (let i = 0; i < cfg.emote.size.variation.chance; i++)
        {
         chances.push(1);
        }
        break;
      }
      switch (chances.length)
      {
       case 0: return 1;
       case 1: return chances[0];
      }
      return chances[shared.rnd(chances.length)];
     }

     function _queueEmote(e)
     {
      shared.ec.halt();
      const sW = window.innerWidth;
      const sH = window.innerHeight;
      const eH = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
      document.documentElement.style.setProperty('--height', sH + 'px');
      document.documentElement.style.setProperty('--width', sW + 'px');
      const style = cfg.display.styles[shared.rnd(cfg.display.styles.length)];
      if (typeof style === 'undefined')
       return;
      display.emote.list[style](_appendHolidayZWE(e), sW, sH, eH);
     }

     function $showEmotes()
     {
      if (_tEmote !== false)
      {
       window.clearTimeout(_tEmote);
       _tEmote = false;
      }
      if (cfg.emote.max > 0 && _eActive >= cfg.emote.max)
      {
       _tEmote = window.setTimeout(display.emote.showEmotes, 500);
       return;
      }
      if (!!cfg.emote.threshold && !!cfg.emote.threshold.emotes && !!cfg.emote.threshold.seconds)
      {
       const rateE = cfg.emote.threshold.emotes;
       if (_toShow.length > 0)
       {
        let e = null;
        while (typeof (e = _toShow.pop()) !== 'undefined')
        {
         if (!e.hasOwnProperty('url') || !e.hasOwnProperty('timestamp'))
          continue;
         _toSift.add(e);
        }
       }
       const tNow = Date.now();
       const ctOf = {};
       for (const e of _toSift)
       {
        const showID = _urlToID(e.url);
        if (!ctOf.hasOwnProperty(showID))
         ctOf[showID] = 0;
        ctOf[showID]++;
       }
       for (const showID in ctOf)
       {
        if (!ctOf.hasOwnProperty(showID))
         continue;
        if (ctOf[showID] < rateE)
         delete ctOf[showID];
        else
         ctOf[showID] = Math.floor(ctOf[showID] / rateE) * rateE;
       }
       for (const e of _toSift)
       {
        const showID = _urlToID(e.url);
        if (!ctOf.hasOwnProperty(showID))
         continue;
        const ctOfID = ctOf[showID];
        if (ctOfID === 0)
         continue;
        ctOf[showID]--;
        _toSift.delete(e);
        if (ctOfID % rateE === 0)
         _toShow.push(e);
       }
       const rateMS = cfg.emote.threshold.seconds * 1000;
       for (const e of _toSift)
       {
        if (e.timestamp + rateMS < tNow)
         _toSift.delete(e);
       }
      }
      let e = null;
      while (typeof (e = _toShow.shift()) !== 'undefined')
      {
       _queueEmote(e);
       if (cfg.emote.max > 0 && _eActive > cfg.emote.max)
       {
        if (cfg.emote.queue > 0 && _toShow.length > cfg.emote.queue)
         _toShow.splice(0, _toShow.length - cfg.emote.queue);
        _tEmote = window.setTimeout(display.emote.showEmotes, 500);
        return;
       }
      }
      if (_toSift.size > 0)
       _tEmote = window.setTimeout(display.emote.showEmotes, 500);
     }

     function _urlToID(u)
     {
      const c = cCrew.prefix + encodeURIComponent(cCrew.svg.tag.open + cCrew.css.tag.open);
      if (u.slice(0, c.length) === c)
       return shared.hashCode(c);
      return shared.hashCode(u);
     }

     function $addToShowList(p)
     {
      _toShow.push(...p);
     }

     return {
      showEmotes: $showEmotes,
      addToShowList: $addToShowList,
      list: $list,
      clsID: Object.freeze({
       StraightLine: 'etStraightLine',
       Throw: Object.freeze({
        Twist: 'etThrowTwist',
        Drop: 'etThrowDrop'
       }),
       Pop: Object.freeze({
        Peek: 'etPopPeek',
        PeekUp: 'etPopPeekUp',
        PeekDown: 'etPopPeekDown',
        JumpUp: 'etPopJumpUp',
        JumpDown: 'etPopJumpDown'
       }),
       Fountain: 'etFountain'
      })
     };
    }();

    const $kappa = function()
    {
     const _toKappa = [];
     const _conga = new Map();
     const _codeCols = [];
     const _dKappa = 500;

     let _tKappa = false;

     const _list = function()
     {
      const $Fireworks = function()
      {
       function $c_Fireworks(kList, sW, sH, eH, iKC)
       {
        const tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
        if (kClean.length === 0)
         return;
        const oK = kClean[shared.rnd(kClean.length)];
        let eW = eH;
        if (oK.hasOwnProperty('width') && oK.hasOwnProperty('height'))
         eW = oK.width / oK.height * eH;
        const eWh = Math.ceil(eW / 2);
        const oX = sW * timing.kappa.Fireworks.origin.x[shared.rnd(timing.kappa.Fireworks.origin.x.length)] - eWh;
        const oY = sH * timing.kappa.Fireworks.origin.y[shared.rnd(timing.kappa.Fireworks.origin.y.length)];
        const cX = sW * timing.kappa.Fireworks.dest.x[shared.rnd(timing.kappa.Fireworks.dest.x.length)];
        const cY = sH * timing.kappa.Fireworks.dest.y[shared.rnd(timing.kappa.Fireworks.dest.y.length)];
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time);
        const sendUp = Math.floor(tMS * timing.kappa.Fireworks.speed.rocket);
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         ' transform: translate(' + oX + 'px, ' + oY + 'px);';
        _eActive--;
        const iArr = _addEmoteAndZWEs(tInit, oK, 1, {style: s, classes: [display.kappa.clsID.Firework.Rocket]}, false, {x: cX - eWh, y: cY});
        if (iArr.length === 0)
         return;
        window.setTimeout(_explode, sendUp, tInit, kList, iArr, cX, cY, eH, sW, sH, iKC);
       }

       async function _explode(tInit, kList, iArr, cX, cY, eH, sW, sH, iKC)
       {
        if (_iTitanic > tInit)
         return;
        let abort = false;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         if (iArr[i].parentNode === null)
         {
          abort = true;
          continue;
         }
         document.body.removeChild(iArr[i]);
         _eActive--;
        }
        if (abort)
         return;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time);
        const kTime = Math.floor(tMS * timing.kappa.Fireworks.speed.burst);
        const fA = _kAcTime(iKC, kTime);
        const r = Math.min(sW, sH) * timing.kappa.Fireworks.radius.base;
        const inner = Math.max(3, Math.floor(iKC * timing.kappa.Fireworks.quantity.small));
        const core = Math.floor(iKC * timing.kappa.Fireworks.quantity.medium);
        const outer = Math.max(3, Math.floor(iKC * timing.kappa.Fireworks.quantity.large));
        const sR = r * timing.kappa.Fireworks.radius.small;
        for (let v = 0; v < inner; v++)
        {
         if (_iTitanic > tInit)
          return;
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const sK = kClean[shared.rnd(kClean.length)];
         let eW = eH;
         if (sK.hasOwnProperty('width') && sK.hasOwnProperty('height'))
          eW = sK.width / sK.height * eH;
         const sA = shared.rnd();
         _eActive--;
         _sparkler(tInit, sK, cX, cY, eW, eH, sR, sA);
         if (v % fA.ct === fA.ct - 1)
          await _fPause(fA.f);
        }
        await _sleep(Math.floor(tMS * timing.kappa.Fireworks.delays.small));
        const mR = r * timing.kappa.Fireworks.radius.medium;
        const dT = Math.ceil(fA.ct / timing.kappa.Fireworks.spread);
        for (let v = 0; v < core; v++)
        {
         if (_iTitanic > tInit)
          return;
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const sK = kClean[shared.rnd(kClean.length)];
         let eW = eH;
         if (sK.hasOwnProperty('width') && sK.hasOwnProperty('height'))
          eW = sK.width / sK.height * eH;
         const sA = shared.rnd();
         _eActive--;
         _sparkler(tInit, sK, cX, cY, eW, eH, mR, sA);
         if (v % dT === dT - 1)
          await _fPause();
        }
        await _sleep(Math.floor(tMS * timing.kappa.Fireworks.delays.large));
        const lR = r * timing.kappa.Fireworks.radius.large;
        for (let v = 0; v < outer; v++)
        {
         if (_iTitanic > tInit)
          return;
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const sK = kClean[shared.rnd(kClean.length)];
         let eW = eH;
         if (sK.hasOwnProperty('width') && sK.hasOwnProperty('height'))
          eW = sK.width / sK.height * eH;
         const sA = shared.rnd();
         _eActive--;
         _sparkler(tInit, sK, cX, cY, eW, eH, lR, sA);
         if (v % fA.ct === fA.ct - 1)
          await _fPause(fA.f);
        }
       }

       function _sparkler(tInit, eInf, cX, cY, eW, eH, r, a)
       {
        if (_iTitanic > tInit)
         return;
        if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
         return;
        const th = a * _cRadius;
        const eWh = Math.ceil(eW / 2);
        const eX = cX - eWh;
        const hD = Math.floor(eX + r * Math.cos(th));
        const vD = Math.floor(cY + r * Math.sin(th));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time);
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         ' transform: translate(' + eX + 'px, ' + cY + 'px);' +
         _styleEmote([], [], [], [], [], [], true, false, true, false, tMS);
        _addEmoteAndZWEs(tInit, eInf, 1, {style: s, classes: [display.kappa.clsID.Firework.Sparkler]}, {space: false, time: tMS}, {x: hD, y: vD});
       }

       return $c_Fireworks;
      }();

      const $Spiral = function()
      {
       function $c_Spiral(kList, sW, sH, eH, iKC)
       {
        const tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        let maxW = 0;
        for (let i = 0, l = kList.length; i < l; i++)
        {
         let eW = eH;
         if (kList[i].hasOwnProperty('width') && kList[i].hasOwnProperty('height'))
          eW = kList[i].width / kList[i].height * eH;
         if (eW > maxW)
          maxW = eW;
        }
        const oX = shared.rnd(sW - maxW);
        const oY = shared.rnd(sH - eH);
        const r = Math.min(sW, sH);
        shared.doNextFrame(_init, tInit, kList, oX, oY, eH, r, iKC);
       }

       async function _init(tInit, kList, oX, oY, eH, r, iKC)
       {
        if (_iTitanic > tInit)
         return;
        const xt = (shared.rnd(5) + 1) / 7;
        let fr = _rndFromRange(timing.kappa.Spiral.vectors) + xt;
        if (fr > iKC)
         fr = iKC * 0.75 + xt;
        const c = _cRadius / fr;
        let th = shared.rnd() * _cRadius;
        const o = shared.rnd(2) === 0;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Spiral.time);
        const sA = _kAcTime(iKC, tMS);
        if (sA.ct > timing.kappa.Spiral.bulk)
         sA.ct = timing.kappa.Spiral.bulk;
        for (let i = 0; i < iKC; i++)
        {
         if (_iTitanic > tInit)
          return;
         if (o)
         {
          th -= c;
          if (th <= 0)
           th += _cRadius;
         }
         else
         {
          th += c;
          if (th >= _cRadius)
           th -= _cRadius;
         }
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const oK = kClean[shared.rnd(kClean.length)];
         let eW = eH;
         if (oK.hasOwnProperty('width') && oK.hasOwnProperty('height'))
          eW = oK.width / oK.height * eH;
         const eWh = Math.ceil(eW / 2);
         _eActive--;
         _sparkler(tInit, oK, oX - eWh, oY, eW, eH, r, th);
         if (i % sA.ct === sA.ct - 1)
          await _fPause(sA.f);
        }
       }

       function _sparkler(tInit, eInf, oX, oY, eW, eH, r, th)
       {
        if (_iTitanic > tInit)
         return;
        if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
         return;
        const hD = Math.floor(oX + r * Math.cos(th));
        const vD = Math.floor(oY + r * Math.sin(th));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Spiral.time);
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         ' transform: translate(' + oX + 'px, ' + oY + 'px);' +
         _styleEmote([], [], [], [], [], [], true, false, true, false, tMS);
        _addEmoteAndZWEs(tInit, eInf, 1, {style: s, classes: [display.kappa.clsID.Spiral]}, {space: false, time: tMS}, {x: hD, y: vD});
       }

       return $c_Spiral;
      }();

      const $Pyramid = function()
      {
       function $c_Pyramid(kList, sW, sH)
       {
        const tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        const drawn = [];
        let ct = 0;
        const lP = pyramidDist.length;
        const eH = sW / lP;
        for (let i = 0; i < lP; i++)
        {
         drawn.push(0);
         ct += pyramidDist[i];
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Pyramid.time);
        const sT = tMS * timing.kappa.Pyramid.show.total;
        const tPerB = Math.max(Math.floor(sT / ct), timing.kappa.Pyramid.show.min);
        const eT = tPerB * ct;
        const dT = Math.floor(tMS * timing.kappa.Pyramid.pause);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
         {
          x = shared.rnd(lP);
         } while (drawn[x] >= pyramidDist[x]);
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const oK = kClean[shared.rnd(kClean.length)];
         if (!oK.hasOwnProperty('zwe'))
          _block(tInit, oK.url, oK.origin, x, t, eH, sH, drawn[x] + 1, eT + dT);
         else
         {
          const btzwCE = _btzwClassForEmote(oK.zwe);
          _block(tInit, oK.url, oK.origin, x, t, eH, sH, drawn[x] + 1, eT + dT, btzwCE);
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           const btzwCZ = _btzwClassForZWE(btzwCE, oK.zwe[j].url);
           _eActive++;
           _block(tInit, oK.zwe[j].url, oK.zwe[j].origin, x, t, eH, sH, drawn[x] + 1, eT + dT, btzwCZ);
          }
         }
         drawn[x]++;
         t += tPerB;
        }
       }

       function _block(tInit, url, oID, x, t, eH, sH, dX, aT, cAppend = [])
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        const img = document.createElement('img');
        img.setAttribute('class', ['emote', display.kappa.clsID.Pyramid.Show, ...cAppend].join(' '));
        _setImgSrc(img, url);
        img.dataset.msgid = oID;
        const h = Math.floor(eH * x);
        const v = -1 * eH;
        const vD = sH - eH * dX;
        let pad = 2;
        if (cfg.display.hasOwnProperty('shadow') && cfg.display.shadow !== false && shared.shadowCSS(cfg.display.shadow) !== false)
         pad += 10;
        const s = 'left: ' + h + 'px;' +
         ' top: -' + pad + 'px;' +
         ' --emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eH + 'px;' +
         ' transform: translateY(' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tDrop, Math.floor(t / 10 + aT), tInit, oID, img, sH + pad);
        window.setTimeout(_tMove, t, tInit, oID, img, vD);
       }

       function _tMove(tInit, oID, img, vD)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        img.style.transform = 'translateY(' + vD + 'px)';
       }

       function _tDrop(tInit, oID, img, sH)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Pyramid.time);
        const pT = Math.floor(tMS * timing.kappa.Pyramid.hide);
        img.classList.replace(display.kappa.clsID.Pyramid.Show, display.kappa.clsID.Pyramid.Drop);
        img.style.transform = 'translateY(' + sH + 'px)';
        _gc.hook(img, false, true, pT);
       }

       return $c_Pyramid;
      }();

      const $SmallPyramid = function()
      {
       function $c_SmallPyramid(kList, sW, sH)
       {
        const tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        const drawn = [];
        let ct = 0;
        const lP = pyramidDist.length;
        const eH = Math.min(sW / lP, Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small));
        for (let i = 0; i < lP; i++)
        {
         drawn.push(0);
         ct += pyramidDist[i];
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.SmallPyramid.time);
        const sT = tMS * timing.kappa.SmallPyramid.show.total;
        const tPerB = Math.max(Math.floor(sT / ct), timing.kappa.SmallPyramid.show.min);
        const eT = tPerB * ct;
        const dT = Math.floor(tMS * timing.kappa.SmallPyramid.pause);
        const oX = shared.rnd(sW - eH * lP);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
         {
          x = shared.rnd(lP);
         } while (drawn[x] >= pyramidDist[x]);
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const oK = kClean[shared.rnd(kClean.length)];
         if (!oK.hasOwnProperty('zwe'))
          _block(tInit, oK.url, oK.origin, oX, x, t, eH, sH, drawn[x] + 1, eT + dT);
         else
         {
          const btzwCE = _btzwClassForEmote(oK.zwe);
          _block(tInit, oK.url, oK.origin, oX, x, t, eH, sH, drawn[x] + 1, eT + dT, btzwCE);
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           const btzwCZ = _btzwClassForZWE(btzwCE, oK.zwe[j].url);
           _eActive++;
           _block(tInit, oK.zwe[j].url, oK.zwe[j].origin, oX, x, t, eH, sH, drawn[x] + 1, eT + dT, btzwCZ);
          }
         }
         drawn[x]++;
         t += tPerB;
        }
       }

       function _block(tInit, url, oID, oX, x, t, eH, sH, dX, aT, cAppend = [])
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        const img = document.createElement('img');
        img.setAttribute('class', ['emote', display.kappa.clsID.SmallPyramid.Show, ...cAppend].join(' '));
        _setImgSrc(img, url);
        img.dataset.msgid = oID;
        const h = oX + eH * x;
        const v = -1 * eH;
        const vD = sH - eH * dX;
        let pad = 2;
        if (cfg.display.hasOwnProperty('shadow') && cfg.display.shadow !== false && shared.shadowCSS(cfg.display.shadow) !== false)
         pad += 10;
        const s = 'left: ' + h + 'px;' +
         ' top: -' + pad + 'px;' +
         ' --emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eH + 'px;' +
         ' transform: translateY(' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tDrop, Math.floor(t / 10 + aT), tInit, oID, img, sH + pad);
        window.setTimeout(_tMove, t, tInit, oID, img, vD);
       }

       function _tMove(tInit, oID, img, vD)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        img.style.transform = 'translateY(' + vD + 'px)';
       }

       function _tDrop(tInit, oID, img, sH)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.SmallPyramid.time);
        const pT = Math.floor(tMS * timing.kappa.SmallPyramid.hide);
        img.classList.replace(display.kappa.clsID.SmallPyramid.Show, display.kappa.clsID.SmallPyramid.Drop);
        img.style.transform = 'translateY(' + sH + 'px)';
        _gc.hook(img, false, true, pT);
       }

       return $c_SmallPyramid;
      }();

      const $CodeLines = function()
      {
       async function $c_CodeLines(kList, sW, sH, eH, iKC, tInit = -1)
       {
        if (tInit === -1)
         tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
        if (kClean.length === 0)
         return;
        const rows = Math.floor(sH / eH);
        const rowSpc = (sH - (rows * eH)) / (rows - 1);
        const cols = Math.floor(sW / eH);
        const colSpc = (sW - (cols * eH)) / (cols - 1);
        const uCols = Math.max(Math.min(Math.ceil(iKC / rows), Math.min(cols, 8)), 2);
        if (_codeCols.length < cols)
         _codeCols.length = cols;
        if (cols - _codeColCt() < uCols)
        {
         window.setTimeout(_list.CodeLines, _dKappa, kList, sW, sH, eH, iKC, tInit);
         return;
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.CodeLines.time);
        const iv = Math.floor(tMS / uCols);
        const it = Math.floor(iv * (1 / timing.kappa.CodeLines.overlap));
        const tCL = Math.floor(tMS * timing.kappa.CodeLines.fade);
        const tEnd = tMS - (uCols * it + tCL);
        const orX = [];
        for (let x = 0; x < cols; x++)
        {
         orX.push(x);
        }
        const shX = [];
        while (shX.length < uCols)
        {
         let r = shared.rnd(orX.length);
         while (_codeCols[orX[r]])
          r = shared.rnd(orX.length);
         shX.push(orX.splice(r, 1));
        }
        shX.length = uCols;
        for (let i = 0; i < uCols; i++)
        {
         _codeCols[shX[i]] = true;
        }
        let t = 0;
        const arr = [];
        for (let i = 0; i < uCols; i++)
        {
         const x = shX[i];
         const c = [];
         for (let y = 0; y < rows; y++)
         {
          const oK = kClean[shared.rnd(kClean.length)];
          const r = _block(tInit, oK, x * (eH + colSpc), y * (eH + rowSpc), eH, tMS);
          if (r === false)
           return;
          c.push(r);
         }
         arr.push(c);
         shared.doNextFrame(_colStart, tInit, c, iv);
         t += it;
         await _sleep(it);
        }
        if (_iTitanic > tInit)
        {
         for (let i = 0; i < uCols; i++)
         {
          _codeCols[shX[i]] = false;
         }
         return;
        }
        const et = Math.max(tEnd - t, 0);
        t = it;
        while (t < et)
        {
         window.setTimeout(_column, t, tInit, arr, iv);
         t += it;
        }
        for (let i = 0; i < uCols; i++)
        {
         const x = shX[i];
         window.setTimeout(_colEnd, et + i * it, tInit, arr[i], x, iv);
        }
       }

       function _block(tInit, oK, x, y, eH, tMS)
       {
        if (_iTitanic > tInit)
         return false;
        const s = 'left: ' + x + 'px;' +
         ' top: ' + y + 'px;' +
         ' --emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eH + 'px;' +
         ' opacity: 0;';
        return _addEmoteAndZWEs(tInit, oK, 1, {style: s, classes: [display.kappa.clsID.CodeLine.show]}, {space: false, time: tMS});
       }

       function _colStart(tInit, col, t)
       {
        if (_iTitanic > tInit)
         return;
        let tCt = 0;
        for (let y = 0; y < col.length; y++)
        {
         window.setTimeout(_show, tCt, tInit, col[y]);
         tCt += Math.floor(t / col.length);
        }
       }

       function _column(tInit, arr, t)
       {
        if (_iTitanic > tInit)
         return;
        const rX = shared.rnd(arr.length);
        let tCt = 0;
        for (let y = 0; y < arr[rX].length; y++)
        {
         window.setTimeout(_show, tCt, tInit, arr[rX][y]);
         tCt += Math.floor(t / arr[rX].length);
        }
       }

       function _colEnd(tInit, col, x, t)
       {
        _codeCols[x] = false;
        if (_iTitanic > tInit)
         return;
        let tCt = 0;
        for (let y = 0; y < col.length; y++)
        {
         window.setTimeout(_show, tCt, tInit, col[y], true);
         tCt += Math.floor(t / col.length);
        }
       }

       function _show(tInit, img, lastShow = false)
       {
        if (_iTitanic > tInit)
         return;
        for (let z = 0; z < img.length; z++)
        {
         img[z].classList.replace(display.kappa.clsID.CodeLine.hide, display.kappa.clsID.CodeLine.show);
         img[z].style.opacity = 1;
        }
        if (lastShow)
         shared.doNextFrame(_end, tInit, img);
        else
         shared.doNextFrame(_hide, tInit, img);
       }

       function _hide(tInit, img)
       {
        if (_iTitanic > tInit)
         return;
        for (let z = 0; z < img.length; z++)
        {
         img[z].classList.replace(display.kappa.clsID.CodeLine.show, display.kappa.clsID.CodeLine.hide);
         img[z].style.opacity = timing.kappa.CodeLines.opacity;
        }
       }

       function _end(tInit, img)
       {
        if (_iTitanic > tInit)
         return;
        for (let z = 0; z < img.length; z++)
        {
         img[z].classList.replace(display.kappa.clsID.CodeLine.show, display.kappa.clsID.CodeLine.hide);
         img[z].style.opacity = 0;
        }
       }

       function _codeColCt()
       {
        let aCt = 0;
        for (let i = 0; i < _codeCols.length; i++)
        {
         if (_codeCols[i])
          aCt++;
        }
        return aCt;
       }

       return $c_CodeLines;
      }();

      const $Stampede = function()
      {
       async function $c_Stampede(kList, sW, sH, eH, iKC)
       {
        const tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        const bandHeight = eH * timing.kappa.Stampede.height;
        const d = shared.rnd(2) === 0;
        const bandTop = shared.rnd(sH - bandHeight + (eH * timing.kappa.Stampede.top.min) + (eH * timing.kappa.Stampede.top.max)) + (eH * (-1 * timing.kappa.Stampede.top.min));
        const b1 = _rndFromRange(timing.kappa.Stampede.bunch[1]);
        const b2 = shared.rnd(timing.kappa.Stampede.bunch[2] - b1) + b1;
        const b4 = _rndFromRange(timing.kappa.Stampede.bunch[4]);
        _eActive += b1 + b2 + iKC + b4;
        const hasB4 = b4 > 0;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Stampede.time);
        const tSpeed = Math.floor(tMS * timing.kappa.Stampede.speed);
        const t1 = Math.floor(tSpeed * timing.kappa.Stampede.pause['1']);
        let maxW = 0;
        for (let i = 0, l = kList.length; i < l; i++)
        {
         let eW = eH;
         if (kList[i].hasOwnProperty('width') && kList[i].hasOwnProperty('height'))
          eW = kList[i].width / kList[i].height * eH;
         if (eW > maxW)
          maxW = eW;
        }
        await _stampede(tInit, kList, b1, t1, false, bandTop, bandHeight, d, sW, eH, maxW);
        if (_iTitanic > tInit)
         return;
        const t2 = Math.floor(tSpeed * timing.kappa.Stampede.pause['2']);
        await _stampede(tInit, kList, b2, t2, false, bandTop, bandHeight, d, sW, eH, maxW);
        if (_iTitanic > tInit)
         return;
        const sA = _kAcTime(iKC, tMS);
        if (sA.ct > timing.kappa.Stampede.maxdensity)
         sA.ct = timing.kappa.Stampede.maxdensity;
        await _stampede(tInit, kList, iKC, hasB4, sA, bandTop, bandHeight, d, sW, eH, maxW);
        if (_iTitanic > tInit)
         return;
        if (hasB4)
         await _stampede(tInit, kList, b4, false, false, bandTop, bandHeight, d, sW, eH, maxW);
       }

       async function _stampede(tInit, kList, ct, pause, sA, bandTop, bandHeight, d, sW, eH, maxW)
       {
        if (_iTitanic > tInit)
         return;
        const imgs = new Set();
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const oK = kClean[shared.rnd(kClean.length)];
         let eW = eH;
         if (oK.hasOwnProperty('width') && oK.hasOwnProperty('height'))
          eW = oK.width / oK.height * eH;
         const y = bandTop + shared.rnd(bandHeight);
         _eActive--;
         const oE = _run(tInit, oK, y, d, sW, eW, eH, maxW);
         if (oE === null)
          return;
         imgs.add(oE);
         if (sA === false)
          await _sleep(_rndFromRange(timing.kappa.Stampede.smallSleep));
         else
         {
          if (i % sA.ct === sA.ct - 1)
          {
           let wF = sA.f;
           if (wF === 1)
            wF = shared.rnd(3);
           else
            wF *= (shared.rnd() * 3) / 2;
           if (wF !== 0)
            await _fPause(wF);
          }
         }
        }
        if (pause === false)
         return;
        if (pause !== true)
        {
         await _sleep(pause);
         return;
        }
        do
        {
         if (_iTitanic > tInit)
          return;
         await _sleep(100);
         for (const img of imgs)
         {
          if (img === null)
           imgs.delete(img);
          if (img.parentNode === null)
           imgs.delete(img);
          if (img.hasAttribute('deleted'))
           imgs.delete(img);
         }
        } while (imgs.size > 0);
       }

       function _run(tInit, eInf, v, d, sW, eW, eH, maxW)
       {
        if (_iTitanic > tInit)
         return null;
        if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
         return null;
        const h = -2 * maxW;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Stampede.time);
        const tSpeed = Math.floor(tMS * timing.kappa.Stampede.speed);
        const oX = d ? h : sW + maxW;
        const dX = d ? sW + maxW : h;
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         ' transform: translate(' + oX + 'px, ' + v + 'px);' +
          _styleEmoteString([], [], [], [], [], []);
        const r = _addEmoteAndZWEs(tInit, eInf, 1, {style: s, classes: [display.kappa.clsID.Stampede]}, {space: false, time: tSpeed}, {x: dX, y: v});
        if (r.length === 0)
         return null;
        window.setTimeout(_tMark, tSpeed, tInit, eInf.origin, r[0]);
        return r[0];
       }

       function _tMark(tInit, oID, img)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        if (img === null)
         return;
        if (img.parentNode !== null)
         document.body.removeChild(img);
        img.setAttribute('deleted', true);
       }

       return $c_Stampede;
      }();

      const $Conga = function()
      {
       async function $c_Conga(kList, sW, sH, eH, nM, tInit = -1)
       {
        if (tInit === -1)
         tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        let v = 0;
        const bS = Math.ceil(eH * timing.kappa.Conga.size);
        const seg = Math.floor(eH * timing.kappa.Conga.height);
        const sht = Math.floor(sH / seg);
        let lns = sht;
        if (nM)
         lns = timing.kappa.Conga.avoidMiddle;
        if (_conga.size >= lns)
        {
         window.setTimeout(_list.Conga, _dKappa, kList, sW, sH, eH, nM, tInit);
         return;
        }
        if (nM)
        {
         const hMid = Math.floor(timing.kappa.Conga.avoidMiddle / 2);
         do
         {
          v = shared.rnd(timing.kappa.Conga.avoidMiddle);
          if (v >= hMid)
           v = sht - 1 - (v - hMid);
          v *= seg;
         } while (_conga.has(v));
        }
        else
        {
         do
         {
          v = shared.rnd(sht) * seg;
         } while (_conga.has(v));
        }
        _conga.set(v, false);
        const urls = [];
        const zurls = [];
        const ct = Math.floor(sW / bS);
        for (let i = 0; i < ct; i++)
        {
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const oK = kClean[shared.rnd(kClean.length)];
         urls.push(oK);
         const oZ = [];
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           oZ.push(oK.zwe[j]);
          }
         }
         zurls.push(oZ);
        }
        const d = v / seg % 2 === 0;
        const xtra = Math.floor((sW - ct * bS) / 2);
        const imgs = [];
        const zimgs = [];
        for (let i = 0; i < ct; i++)
        {
         _eActive--;
         const btzwCE = _btzwClassForEmote(zurls[i]);
         const dBox = _dance(tInit, urls[i].url, urls[i].origin, i, sW, v, eH, bS, ct, d, xtra, btzwCE);
         if (dBox === false)
          return;
         imgs.push(dBox);
         const oZ = [];
         for (let j = 0, l = zurls[i].length; j < l; j++)
         {
          const btzwCZ = _btzwClassForZWE(btzwCE, zurls[i][j].url);
          const zBox = _dance(tInit, zurls[i][j].url, zurls[i][j].origin, i, sW, v, eH, bS, ct, d, xtra, btzwCZ);
          if (zBox === false)
           return;
          oZ.push(zBox);
         }
         zimgs.push(oZ);
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Conga.time.show);
        await _sleep(tMS);
        await _sleep(Math.floor(cfg.display.kappa.conga.time * 1000));
        if (cfg.display.kappa.conga.contagious)
        {
         let ex = _conga.size > 1;
         _conga.set(v, true);
         while ([..._conga.values()].includes(false))
         {
          if (_iTitanic > tInit)
           return;
          if (!ex && _conga.size > 1)
           ex = true;
          await _sleep(100);
         }
        }
        for (let i = 0, l = imgs.length; i < l; i++)
        {
         _endDance(tInit, imgs[i], i, sW, bS, ct, d, xtra);
         for (let j = 0, m = zimgs[i].length; j < m; j++)
         {
          _endDance(tInit, zimgs[i][j], i, sW, bS, ct, d, xtra);
         }
        }
        await _sleep(tMS);
        _conga.delete(v);
       }

       function _dance(tInit, url, oID, col, sW, v, eH, bS, ct, d, xtra, cAppend = [])
       {
        if (_iTitanic > tInit)
         return false;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return false;
        const box = document.createElement('div');
        box.setAttribute('class', 'scene ' + display.kappa.clsID.Conga.In);
        const img = document.createElement('img');
        img.setAttribute('class', ['dancer', ...cAppend].join(' '));
        _setImgSrc(img, url);
        img.dataset.msgid = oID;
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eH + 'px;';
        img.setAttribute('style', s);
        let sE = bS * col + xtra;
        let sB = sE - sW;
        if (d)
        {
         sE = bS * (ct - 1 - col) + xtra;
         sB = sE + sW;
        }
        const s2 = 'top: ' + v + 'px;' +
         ' left: 0px;' +
         ' height: ' + bS + 'px;' +
         ' width: ' + bS + 'px;' +
         ' z-index: ' + v + ';' +
         ' transform: translateX(' + sB + 'px);';
        box.setAttribute('style', s2);
        _eActive++;
        box.appendChild(img);
        document.body.appendChild(box);
        shared.doNextFrame(_tMove, tInit, box, sE);
        return box;
       }

       function _endDance(tInit, box, col, sW, bS, ct, d, xtra)
       {
        if (_iTitanic > tInit)
         return;
        let sB = bS * col + xtra;
        let sE = sB + sW;
        if (d)
        {
         sB = bS * (ct - 1 - col) + xtra;
         sE = sB - sW;
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Conga.time.hide);
        box.classList.replace(display.kappa.clsID.Conga.In, display.kappa.clsID.Conga.Out);
        _gc.hook(box, true, true, Math.ceil(tMS * 1.25));
        shared.doNextFrame(_tMove, tInit, box, sE);
       }

       function _tMove(tInit, box, sE)
       {
        if (_iTitanic > tInit)
         return;
        box.style.transform = 'translateX(' + sE + 'px)';
       }

       return $c_Conga;
      }();

      const $Coaster = function()
      {
       async function $c_Coaster(kList, sW, sH, eH, iKC)
       {
        const tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        const d = shared.rnd(2) === 0;
        const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
        if (kClean.length === 0)
         return;
        let maxW = 0;
        const kCars = [];
        for (let i = 0; i < iKC; i++)
        {
         const oK = kClean[shared.rnd(kClean.length)];
         kCars.push(oK);
         let eW = eH;
         if (oK.hasOwnProperty('width') && oK.hasOwnProperty('height'))
          eW = oK.width / oK.height * eH;
         if (eW > maxW)
          maxW = eW;
        }
        const tMS = cfg.emote.time * 1000 * timing.kappa.Coaster.time;
        const yBase = Math.floor(sH * _rndFromRange(timing.kappa.Coaster.bottom));
        const yCrest = Math.floor(sH * _rndFromRange(timing.kappa.Coaster.top));
        const xAt = Math.floor((sW + maxW) * _rndFromRange(timing.kappa.Coaster.at));
        const dist = xAt + ((yBase - yCrest) * Math.PI);
        const vel = tMS / dist;
        for (let i = 0; i < iKC; i++)
        {
         let eW = eH;
         if (kCars[i].hasOwnProperty('width') && kCars[i].hasOwnProperty('height'))
          eW = kCars[i].width / kCars[i].height * eH;
         let ms = Math.ceil(eW * vel);
         if (ms < shared.mspf.value)
          ms = shared.mspf.value;
         if (d)
          await _sleep(ms);
         shared.doNextFrame(_car, tInit, kCars[i], d, vel, yBase, yCrest, xAt, sW, eH, maxW);
         if (!d)
          await _sleep(ms);
        }
       }

       function _car(tInit, eInf, d, vel, yBase, yCrest, xAt, sW, eH, maxW)
       {
        if (_iTitanic > tInit)
         return;
        if (eInf.hasOwnProperty('origin') && display.erasedMsgs.includes(eInf.origin))
         return;
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const oX = d ? sW : -1 * maxW;
        const oR = (yBase - yCrest) / 2;
        const xForm = {
         str: 'perspective(10px) translateZ(0px) translateX(%Apx) rotate(%Bdeg) translateZ(%Cpx)',
         a: 0,
         b: 0,
         c: 0,
         get val(){return this.str.replaceAll('%A', this.a).replaceAll('%B', this.b).replaceAll('%C', this.c);}
        };
        const s = 'left: ' + oX + 'px;' +
         ' top: ' + yBase + 'px;' +
         ' --emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eW + 'px;' +
         ' transform: ' + xForm.val + ';' +
         ' transform-origin: center -' + oR + 'px;' +
         ' transition: transform linear 0ms;' +
          _styleEmoteString([], [], [], [], [], []);
        const tLoop = cfg.emote.time * 1000 * timing.kappa.Coaster.time;
        _eActive--;
        const r = _addEmoteAndZWEs(tInit, eInf, 1, {style: s}, {space: false, time: tLoop});
        if (r.length === 0)
         return;
        shared.doNextFrame(_straight, tInit, r, eInf.origin, d, vel, xForm, yBase, yCrest, xAt);
       }

       function _straight(tInit, r, oID, d, vel, xForm, yBase, yCrest, xAt)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        xForm.a = d ? -1 * xAt : xAt;
        const tNext = Math.floor(vel * xAt);
        for (let i = 0, l = r.length; i < l; i++)
        {
         r[i].style.transitionDuration = tNext + 'ms';
         r[i].style.transform = xForm.val;
        }
        window.setTimeout(_loop, tNext, tInit, r, oID, d, vel, xForm, yBase, yCrest);
       }

       function _loop(tInit, r, oID, d, vel, xForm, yBase, yCrest)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        const xLoop = (yBase - yCrest) * Math.PI;
        xForm.b = d ? 360 : -360;
        xForm.c = 7;
        const tNext = Math.floor(vel * xLoop);
        for (let i = 0, l = r.length; i < l; i++)
        {
         r[i].style.transitionDuration = tNext + 'ms';
         r[i].style.transform = xForm.val;
        }
       }

       return $c_Coaster;
      }();

      const $TheCube = function()
      {
       const _faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];

       function $c_TheCube(kList, sW, sH, eH, bC, iR)
       {
        const tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        const eHh = Math.ceil(eH / 2);
        const nHh = eHh * -1;
        const sWm = Math.ceil(sW / 2);
        const sHm = Math.ceil(sH / 2);
        const scene = document.createElement('div');
        scene.setAttribute('class', 'scene cube kappa');
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.TheCube.time);
        const cube = document.createElement('div');
        cube.setAttribute('class', 'cube');
        cube.setAttribute('style', 'transform: translateZ(' + nHh + 'px);');
        const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
        if (kClean.length === 0)
         return;
        const eFaces = [];
        for (let i = 0; i < 6; i++)
        {
         eFaces.push(kClean[shared.rnd(kClean.length)]);
        }
        for (let i = 0; i < 6; i++)
        {
         if (!eFaces[i].hasOwnProperty('zwe') || eFaces[i].zwe.length === 0)
         {
          const iFace = document.createElement('img');
          _setImgSrc(iFace, eFaces[i].url);
          iFace.dataset.face = _faces[i];
          iFace.dataset.msgid = eFaces[i].origin;
          cube.appendChild(iFace);
         }
         else
         {
          const dFace = document.createElement('div');
          dFace.dataset.face = _faces[i];
          const pFace = document.createElement('img');
          const btzwCE = _btzwClassForEmote(eFaces[i].zwe);
          pFace.setAttribute('class', btzwCE.join(' '));
          _setImgSrc(pFace, eFaces[i].url);
          pFace.dataset.msgid = eFaces[i].origin;
          dFace.appendChild(pFace);
          for (let j = 0, l = eFaces[i].zwe.length; j < l; j++)
          {
           const pctZ = document.createElement('img');
           const btzwCZ = _btzwClassForZWE(btzwCE, eFaces[i].zwe[j].url);
           pctZ.setAttribute('class', btzwCZ.join(' '));
           _setImgSrc(pctZ, eFaces[i].zwe[j].url);
           pctZ.dataset.msgid = eFaces[i].origin;
           dFace.appendChild(pctZ);
          }
          cube.appendChild(dFace);
         }
        }
        scene.appendChild(cube);
        let h = shared.rnd(sW - eH);
        let v = shared.rnd(sH - eH);
        if (bC)
        {
         h = Math.floor(sWm - eHh);
         v = Math.floor(sHm - eHh);
        }
        const s = '--emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eH + 'px;' +
         ' --cube-depth: ' + eHh + 'px;' +
         ' perspective: ' + eH * 3 + 'px;' +
         ' transform: translate(' + h + 'px, ' + v + 'px);' +
         _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false, tMS);
        scene.setAttribute('style', s);
        document.body.appendChild(scene);
        _gc.hook(scene, false, 6, tMS);
        shared.doNextFrame(_tMove, tInit, cube, iR, eH);
       }

       function _tMove(tInit, cube, iR, eH)
       {
        if (_iTitanic > tInit)
         return;
        const nHh = Math.ceil(eH / 2) * -1;
        let rX = 0;
        let rY = 0;
        while (Math.abs(rX) + Math.abs(rY) < 45)
        {
         rX = (360 - shared.rnd() * 720) * iR;
         rY = (360 - shared.rnd() * 720) * iR;
        }
        cube.style.transform = 'translateZ(' + nHh + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
       }

       return $c_TheCube;
      }();

      const $Text = function()
      {
       let _mL = 0;

       function $c_Text(kList, sW, sH, sMsg, iTime)
       {
        const tInit = Date.now();
        if (_iTitanic > tInit)
         return;
        const msgDist = _buildMsgArr(sMsg);
        let ct = 0;
        let ctT = 0;
        const drawn = [];
        const lM = msgDist.length;
        for (let x = 0; x < lM; x++)
        {
         const lX = msgDist[x].length;
         for (let y = 0; y < lX; y++)
         {
          if (msgDist[x][y] !== 0)
           ctT += 1;
         }
         ct += lX;
         drawn.push(0);
        }
        const eH = Math.min(Math.floor(sW / (lM + 2)), Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small));
        const tMS = Math.floor(iTime * 1000 * timing.kappa.Text.time);
        const sT = tMS * timing.kappa.Text.show.total;
        const tPerB = Math.max(Math.floor(sT / ct), timing.kappa.Text.show.min);
        const eT = tPerB * ctT;
        const lF = msgDist[0].length;
        const lFS = eH * lF;
        const vH = shared.rnd(sH - lFS) + lFS;
        const oX = shared.rnd(sW - eH * lM);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
         {
          x = shared.rnd(lM);
         } while (drawn[x] >= msgDist[x].length);
         if (msgDist[x][drawn[x]] !== 0)
         {
          const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
          if (kClean.length === 0)
           return;
          const oK = kClean[shared.rnd(kClean.length)];
          if (!oK.hasOwnProperty('zwe'))
           _block(tInit, oK.url, oK.origin, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, eH);
          else
          {
           const btzwCE = _btzwClassForEmote(oK.zwe);
           _block(tInit, oK.url, oK.origin, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, eH, btzwCE);
           for (let j = 0, l = oK.zwe.length; j < l; j++)
           {
            const btzwCZ = _btzwClassForZWE(btzwCE, oK.zwe[j].url);
            _block(tInit, oK.zwe[j].url, oK.zwe[j].origin, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, eH, btzwCZ);
           }
          }
          t += tPerB;
         }
         drawn[x]++;
        }
       }

       function _buildMsgArr(s)
       {
        const o = [];
        const spc = [];
        if (_mL === 0)
        {
         for (let i = 0, k = Object.keys(alnumDist), l = k.length; i < l; i++)
         {
          _mL = Math.max(_mL, alnumDist[k[i]][0].length);
         }
        }
        for (let y = 0; y < _mL; y++)
        {
         spc.push(0);
        }
        for (let i = 0, l = s.length; i < l; i++)
        {
         if (i > 0)
          o.push(spc);
         if (s[i] === ' ')
         {
          o.push(spc);
          o.push(spc);
          continue;
         }
         const v = s[i];
         if (!alnumDist.hasOwnProperty(v))
          continue;
         const c = alnumDist[v];
         for (let x = 0, m = c.length; x < m; x++)
         {
          o.push(c[x]);
         }
        }
        return o;
       }

       function _block(tInit, url, oID, vH, oX, dX, tPerB, eT, iTime, x, t, sH, eH, cAppend = [])
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        const img = document.createElement('img');
        img.setAttribute('class', ['emote', ...cAppend].join(' '));
        _setImgSrc(img, url);
        img.dataset.msgid = oID;
        const h = oX + eH * x;
        const v = -1 * eH;
        const vD = vH - eH * dX;
        let pad = 2;
        if (cfg.display.hasOwnProperty('shadow') && cfg.display.shadow !== false && shared.shadowCSS(cfg.display.shadow) !== false)
         pad += 10;
        const s = 'left: ' + h + 'px;' +
         ' top: -' + pad + 'px;' +
         ' --emote-height: ' + eH + 'px;' +
         ' --emote-width: ' + eH + 'px;' +
         ' transition: transform ' + tPerB + 'ms ease-in;' +
         ' transform: translateY(' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        _eActive++;
        const tMS = Math.floor(iTime * 1000 * timing.kappa.Text.time);
        window.setTimeout(_tDrop, Math.floor(eT + tMS + t / 10), tInit, oID, img, sH + pad, tMS);
        window.setTimeout(_tMove, t, tInit, oID, img, vD);
       }

       function _tMove(tInit, oID, img, vD)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        img.style.transform = 'translateY(' + vD + 'px)';
       }

       function _tDrop(tInit, oID, img, sH, tMS)
       {
        if (_iTitanic > tInit)
         return;
        if (typeof oID !== 'undefined' && display.erasedMsgs.includes(oID))
         return;
        const pT = Math.floor(tMS * timing.kappa.Text.hide);
        img.style.transform = 'translateY(' + sH + 'px)';
        img.style.transitionDuration = pT + 'ms';
        _gc.hook(img, false, true, pT);
       }

       return $c_Text;
      }();

      return {
       Fireworks: $Fireworks,
       Spiral: $Spiral,
       Pyramid: $Pyramid,
       SmallPyramid: $SmallPyramid,
       CodeLines: $CodeLines,
       Stampede: $Stampede,
       Conga: $Conga,
       Coaster: $Coaster,
       TheCube: $TheCube,
       Text: $Text
      };
     }();

     function _canShowKappa(k)
     {
      if (cfg.emote.max < 1)
       return true;
      if (_eActive < 1)
       return true;
      let tC = cfg.display.kappa.count;
      if (k !== false)
       tC = _getKappaCountEstimate(k);
      const cM = Math.max(cfg.emote.max, tC);
      return _eActive + tC < cM;
     }

     function _showKappas()
     {
      if (_tKappa !== false)
      {
       window.clearTimeout(_tKappa);
       _tKappa = false;
      }
      if (_toKappa.length === 0)
       return;
      let nK = _getNextKappa(_toKappa[0]);
      if (nK === false)
       return;
      if (!_canShowKappa(nK))
      {
       _tKappa = window.setTimeout(_showKappas, _dKappa);
       return;
      }
      let e = null;
      while (typeof (e = _toKappa.shift()) !== 'undefined')
      {
       nK = false;
       const a = {};
       a[e.style] = e.prefs;
       display.kappa.show(e.list, a, e.params);
       if (_toKappa.length === 0)
        return;
       nK = _getNextKappa(_toKappa[0]);
       if (nK === false)
        return;
       if (!_canShowKappa(nK))
       {
        if (cfg.emote.queue > 0 && _toKappa.length > cfg.emote.queue)
         _toKappa.splice(0, _toKappa.length - cfg.emote.queue);
        _tKappa = window.setTimeout(_showKappas, _dKappa);
        return;
       }
      }
     }

     function _getNextKappa(k)
     {
      const a = [];
      a[k.style] = k.prefs;
      return _getNextKappaEx(a, k.params);
     }

     function _getKappaCountParam(p)
     {
      const a = p.split(' ');
      for (let i = 0, l = a.length; i < l; i++)
      {
       if (shared.nReg.i.test(a[i]))
        return parseInt(a[i], 10);
      }
      return false;
     }

     const _arith = function()
     {
      const _nReg = new RegExp(/^([+-]?\d*\.?\d+)$/);
      const _pReg = new RegExp(/\(([^()]*)\)/);
      const _mReg = new RegExp(/([+-]?\d*\.?\d+)([*\/])([+-]?\d*\.?\d+)/);
      const _aReg = new RegExp(/([+-]?\d*\.?\d+)([+-])([+-]?\d*\.?\d+)/);

      function $c_arith(eq, v)
      {
       eq = eq.replaceAll(' ', '');
       eq = eq.replaceAll('n', v);
       let cur;
       while (!_nReg.test(eq))
       {
        eq = _parens(eq);
        if (eq === cur)
         return false;
        cur = eq;
       }
       return +eq;
      }

      function _parens(eq)
      {
       while (_pReg.test(eq))
       {
        eq = eq.replace(_pReg, function(m, p1){return _add(_mul(p1));});
       }
       return _add(_mul(eq));
      }

      function _mul(eq)
      {
       while (_mReg.test(eq))
       {
        eq = eq.replace(_mReg,
         function(m)
         {
          const s = _mReg.exec(m);
          const r = s[2] === '*' ? s[1] * s[3] : s[1] / s[3];
          if (r >= 0)
           return '+' + r;
          return r;
         }
        );
       }
       return eq;
      }

      function _add(eq)
      {
       while (_aReg.test(eq))
       {
        eq = eq.replace(_aReg,
         function(m)
         {
          const s = _aReg.exec(m);
          if (s[2] === '+')
           return +s[1] + (+s[3]);
          return s[1] - s[3];
         }
        );
       }
       return eq;
      }

      return $c_arith;
     }();

     function _getNextKappaEx(kS = false, kP = false)
     {
      if (typeof kS !== 'object')
      {
       if (cfg.display.kappa.styles.length === 0)
        return false;
       kS = cfg.display.kappa.styles;
      }
      let s, p;
      const keys = Object.keys(kS);
      if (cfg.display.kappa.conga.contagious && _conga.size > 0)
      {
       s = 'Conga';
       p = {};
       if (keys.includes(s))
        p = kS[s];
       else
       {
        const s2 = keys[shared.rnd(keys.length)];
        if (kS[s2].hasOwnProperty('emotes'))
         p.emotes = kS[s2].emotes;
       }
      }
      else
      {
       s = keys[shared.rnd(keys.length)];
       p = kS[s];
      }
      if (typeof s === 'undefined')
       return false;
      let iKC = cfg.display.kappa.count;
      if (cfg.display.kappa.styles.hasOwnProperty(s) && cfg.display.kappa.styles[s].hasOwnProperty('count') && cfg.display.kappa.styles[s].count > 0)
       iKC = cfg.display.kappa.styles[s].count;
      if (typeof p === 'undefined')
       p = {};
      let pMax = cfg.emote.max;
      if (p.hasOwnProperty('count'))
      {
       let tKC = 0;
       if (Number.isInteger(p.count))
        tKC = p.count;
       else
       {
        if (p.count.hasOwnProperty('maximum'))
         pMax = p.count.maximum;
        if (p.count.hasOwnProperty('default'))
         tKC = p.count.default;
        if (p.count.hasOwnProperty('dynamic') && p.count.dynamic !== false)
        {
         if (p.hasOwnProperty('params') && p.params !== null)
         {
          const pC = _getKappaCountParam(p.params);
          if (pC !== false)
           tKC = pC;
         }
         if (p.count.hasOwnProperty('eq') && p.count.eq !== false)
         {
          const rEq = _arith(p.count.eq, tKC);
          if (rEq !== false)
           tKC = Math.round(rEq);
         }
        }
       }
       if (tKC === -1 && kP !== false && kP.hasOwnProperty(cVARs.evt.amount) && Math.ceil(kP[cVARs.evt.amount]) > 0)
       {
        tKC = Math.ceil(kP[cVARs.evt.amount]);
        if (p.count.hasOwnProperty('eq') && p.count.eq !== false)
        {
         const rEq = _arith(p.count.eq, tKC);
         if (rEq !== false)
          tKC = Math.round(rEq);
        }
       }
       if (tKC > 0)
        iKC = tKC;
      }
      if (pMax > 0 && iKC > pMax)
       iKC = pMax;
      return {style: s, prefs: p, count: iKC};
     }

     function _getKappaCountEstimate(k)
     {
      switch (k.style)
      {
       case 'Pyramid':
       case 'SmallPyramid':
        let c = 0;
        for (let i = 0, l = pyramidDist.length; i < l; i++)
        {
         c += pyramidDist[i];
        }
        return c;
       case 'Fireworks':
        const inner = Math.max(3, Math.floor(k.count * timing.kappa.Fireworks.quantity.small));
        const core = Math.floor(k.count * timing.kappa.Fireworks.quantity.medium);
        const outer = Math.max(3, Math.floor(k.count * timing.kappa.Fireworks.quantity.large));
        return 1 + inner + core + outer;
       case 'Conga':
        const sW = window.innerWidth;
        const sH = window.innerHeight;
        const eH = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
        const bS = Math.ceil(eH * timing.kappa.Conga.size);
        return Math.floor(sW / bS);
       case 'TheCube':
        return 6;
      }
      return k.count;
     }

     function _StringArrayToEmoteArray(s)
     {
      const r = [];
      let idx = 0;
      for (let i = 0, l = s.length; i < l; i++)
      {
       const v = {};
       v.str = s[i];
       v.pos = idx;
       idx += s[i].length + 1;
       if (s[i].includes('//'))
       {
        v.svc = cSources.service.url;
        v.scope = cSources.scope.global;
        v.url = s[i];
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('twitch') && service.emotes.twitch.hasOwnProperty(s[i]) && service.emotes.twitch[s[i]].scope === cSources.scope.channel)
       {
        v.svc = cSources.service.twitch;
        v.url = service.emotes.twitch[s[i]].url;
        v.scope = service.emotes.twitch[s[i]].scope;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('youtube') && service.emotes.youtube.hasOwnProperty(s[i]) && service.emotes.youtube[s[i]].scope === cSources.scope.channel)
       {
        v.svc = cSources.service.youtube;
        v.url = service.emotes.youtube[s[i]].url;
        v.scope = service.emotes.youtube[s[i]].scope;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('kick') && service.emotes.kick.hasOwnProperty(s[i]) && service.emotes.kick[s[i]].scope === cSources.scope.channel)
       {
        v.svc = cSources.service.kick;
        v.url = service.emotes.kick[s[i]].url;
        v.scope = service.emotes.kick[s[i]].scope;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('lfg') && service.emotes.lfg.hasOwnProperty(s[i]) && service.emotes.lfg[s[i]].scope === cSources.scope.channel)
       {
        v.svc = cSources.service.lfg;
        v.url = service.emotes.lfg[s[i]].url;
        v.scope = service.emotes.lfg[s[i]].scope;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('ffz') && service.emotes.ffz.hasOwnProperty(s[i]) && service.emotes.ffz[s[i]].scope === cSources.scope.channel)
       {
        v.svc = cSources.service.ffz;
        v.url = service.emotes.ffz[s[i]].url;
        v.scope = service.emotes.ffz[s[i]].scope;
        v.width = service.emotes.ffz[s[i]].width;
        v.height = service.emotes.ffz[s[i]].height;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('bttv') && service.emotes.bttv.hasOwnProperty(s[i]) && service.emotes.bttv[s[i]].scope === cSources.scope.channel)
       {
        v.svc = cSources.service.bttv;
        v.url = service.emotes.bttv[s[i]].url;
        v.scope = service.emotes.bttv[s[i]].scope;
        v.width = service.emotes.bttv[s[i]].width;
        v.height = service.emotes.bttv[s[i]].height;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('7tv') && service.emotes['7tv'].hasOwnProperty(s[i]) && service.emotes['7tv'][s[i]].scope === cSources.scope.channel)
       {
        v.svc = cSources.service['7tv'];
        v.url = service.emotes['7tv'][s[i]].url;
        v.scope = service.emotes['7tv'][s[i]].scope;
        v.width = service.emotes['7tv'][s[i]].width;
        v.height = service.emotes['7tv'][s[i]].height;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('twitch') && service.emotes.twitch.hasOwnProperty(s[i]) && service.emotes.twitch[s[i]].scope === cSources.scope.global)
       {
        v.svc = cSources.service.twitch;
        v.url = service.emotes.twitch[s[i]].url;
        v.scope = service.emotes.twitch[s[i]].scope;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('youtube') && service.emotes.youtube.hasOwnProperty(s[i]) && service.emotes.youtube[s[i]].scope === cSources.scope.global)
       {
        v.svc = cSources.service.youtube;
        v.url = service.emotes.youtube[s[i]].url;
        v.scope = service.emotes.youtube[s[i]].scope;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('kick') && service.emotes.kick.hasOwnProperty(s[i]) && service.emotes.kick[s[i]].scope === cSources.scope.global)
       {
        v.svc = cSources.service.kick;
        v.url = service.emotes.kick[s[i]].url;
        v.scope = service.emotes.kick[s[i]].scope;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('ffz') && service.emotes.ffz.hasOwnProperty(s[i]) && service.emotes.ffz[s[i]].scope === cSources.scope.global)
       {
        v.svc = cSources.service.ffz;
        v.url = service.emotes.ffz[s[i]].url;
        v.scope = service.emotes.ffz[s[i]].scope;
        v.width = service.emotes.ffz[s[i]].width;
        v.height = service.emotes.ffz[s[i]].height;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('bttv') && service.emotes.bttv.hasOwnProperty(s[i]) && service.emotes.bttv[s[i]].scope === cSources.scope.global)
       {
        v.svc = cSources.service.bttv;
        v.url = service.emotes.bttv[s[i]].url;
        v.scope = service.emotes.bttv[s[i]].scope;
        v.width = service.emotes.bttv[s[i]].width;
        v.height = service.emotes.bttv[s[i]].height;
        r.push(v);
        continue;
       }
       if (service.emotes.hasOwnProperty('7tv') && service.emotes['7tv'].hasOwnProperty(s[i]) && service.emotes['7tv'][s[i]].scope === cSources.scope.global)
       {
        v.svc = cSources.service['7tv'];
        v.url = service.emotes['7tv'][s[i]].url;
        v.scope = service.emotes['7tv'][s[i]].scope;
        v.width = service.emotes['7tv'][s[i]].width;
        v.height = service.emotes['7tv'][s[i]].height;
        r.push(v);
        continue;
       }
       if (cfg.display.useEmoji !== false)
       {
        const eMoji = service.parse.content.emoji(s[i], true);
        if (eMoji.length > 0)
        {
         v.svc = cSources.service.emoji;
         v.scope = cSources.scope.global;
         const vStart = v.pos;
         for (let j = 0, m = eMoji.length; j < m; j++)
         {
          v.url = eMoji[j].url;
          v.str = eMoji[j].str;
          v.width = eMoji[j].width;
          v.height = eMoji[j].height;
          v.pos = vStart + eMoji[j].pos;
          r.push(v);
         }
         continue;
        }
       }
      }
      return r;
     }

     async function $show(kList, kStyles = false, kParams = false)
     {
      let gOrigin = false;
      if (Array.isArray(kList) && kList.length === 1 && kList[0].hasOwnProperty('url') && kList[0].url === false && kList[0].hasOwnProperty('origin'))
      {
       gOrigin = kList[0].origin;
       kList = false;
      }
      const kStyle = _getNextKappaEx(kStyles, kParams);
      if (kStyle === false)
       return;
      if (!kStyle.hasOwnProperty('style'))
       return;
      if (typeof kStyle.style === 'undefined')
       return;
      if (kStyle.prefs.hasOwnProperty('emotes'))
      {
       let kForce = [];
       let bForce = false;
       if (Array.isArray(kStyle.prefs.emotes))
        kForce = kStyle.prefs.emotes;
       else
       {
        if (kStyle.prefs.emotes.hasOwnProperty('list'))
         kForce = kStyle.prefs.emotes.list;
        if (kStyle.prefs.emotes.hasOwnProperty('dynamic') && kStyle.prefs.emotes.dynamic === false)
         bForce = true;
       }
       if (!Array.isArray(kList) || kList.length === 0)
        bForce = true;
       if (bForce)
       {
        const fList = _StringArrayToEmoteArray(kForce);
        if (fList.length > 0)
         kList = fList;
       }
      }
      if (!Array.isArray(kList) || kList.length === 0)
       kList = JSON.parse(JSON.stringify(service.cSafe));
      if (!Array.isArray(kList) || kList.length === 0)
       kList = JSON.parse(JSON.stringify(bareList));
      if (gOrigin !== false && Array.isArray(kList) && kList.length > 0)
      {
       for (let i = 0, l = kList.length; i < l; i++)
       {
        if (kList[i].hasOwnProperty('origin') && kList[i].origin !== false)
         continue;
        kList[i].origin = gOrigin;
       }
      }
      const sW = window.innerWidth;
      const sH = window.innerHeight;
      const eH = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
      const eHh = Math.max(cfg.emote.size.min, Math.min(Math.floor(cfg.emote.size.max / 2), Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small)));
      const sB = sH - eH;
      document.documentElement.style.setProperty('--height', sH + 'px');
      document.documentElement.style.setProperty('--width', sW + 'px');
      const waitFor = _getKappaCountEstimate(kStyle);
      if (!_canShowKappa(kStyle))
      {
       _toKappa.push({list: kList, style: kStyle.style, prefs: kStyle.prefs, params: kParams});
       if (_tKappa !== false)
       {
        window.clearTimeout(_tKappa);
        _tKappa = false;
       }
       _tKappa = window.setTimeout(_showKappas, _dKappa);
       return;
      }
      _eActive += waitFor;
      const lK = kList.length;
      for (let i = 0; i < lK; i++)
      {
       kList[i] = _appendHolidayZWE(kList[i]);
      }
      const tInit = Date.now();
      let estMS = Math.floor(cfg.emote.time * 1000);
      if (timing.kappa.hasOwnProperty(kStyle.style) && timing.kappa[kStyle.style].hasOwnProperty('time'))
       estMS = Math.floor(cfg.emote.time * 1000 * timing.kappa[kStyle.style].time);
      else if (timing.display.hasOwnProperty(kStyle.style) && timing.display[kStyle.style].hasOwnProperty('time'))
       estMS = Math.floor(cfg.emote.time * 1000 * timing.display[kStyle.style].time);
      shared.ec.halt();
      switch (kStyle.style)
      {
       case 'Stampede':
        _eActive -= waitFor;
        await _list.Stampede(kList, sW, sH, eH, kStyle.count);
        break;
       case 'Fireworks':
        _list.Fireworks(kList, sW, sH, eHh, kStyle.count);
        break;
       case 'Spiral':
        _list.Spiral(kList, sW, sH, eHh, kStyle.count);
        break;
       case 'Pyramid':
        _list.Pyramid(kList, sW, sH);
        break;
       case 'SmallPyramid':
        _list.SmallPyramid(kList, sW, sH);
        break;
       case 'CodeLines':
        _eActive -= waitFor;
        _list.CodeLines(kList, sW, sH, eHh, kStyle.count);
        break;
       case 'Conga':
        let avoidMiddle = false;
        if (cfg.display.kappa.conga.hasOwnProperty('avoidMiddle') && cfg.display.kappa.conga.avoidMiddle === true)
         avoidMiddle = true;
        if (kStyle.prefs.hasOwnProperty('avoidMiddle') && kStyle.prefs.avoidMiddle === true)
         avoidMiddle = true;
        _list.Conga(kList, sW, sH, eH, avoidMiddle);
        break;
       case 'Coaster':
        _list.Coaster(kList, sW, sH, eHh, kStyle.count);
        break;
       case 'Text':
        _eActive -= waitFor;
        let sTM = 'HYPE!';
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('message'))
         sTM = cfg.display.kappa.styles[kStyle.style].message[shared.rnd(cfg.display.kappa.styles[kStyle.style].message.length)];
        if (kStyle.prefs.hasOwnProperty('message') && Array.isArray(kStyle.prefs.message) && kStyle.prefs.message.length > 0)
         sTM = kStyle.prefs.message[shared.rnd(kStyle.prefs.message.length)];
        let sTT = cfg.emote.time;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('time'))
         sTT = cfg.display.kappa.styles[kStyle.style].time;
        if (kStyle.prefs.hasOwnProperty('time') && kStyle.prefs.time > 0)
         sTT = kStyle.prefs.time;
        if (kParams !== false)
        {
         const pK = Object.keys(kParams);
         for (let i = 0, l = pK.length; i < l; i++)
         {
          sTM = sTM.replaceAll(pK[i], kParams[pK[i]]);
         }
        }
        _list.Text(kList, sW, sH, sTM, sTT);
        break;
       case 'TheCube':
        const cS = Math.min(sW, sH);
        let sCS = 8 / 10;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('size'))
         sCS = cfg.display.kappa.styles[kStyle.style].size;
        if (kStyle.prefs.hasOwnProperty('size'))
         sCS = kStyle.prefs.size;
        let sCC = true;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('center'))
         sCC = cfg.display.kappa.styles[kStyle.style].center;
        if (kStyle.prefs.hasOwnProperty('center'))
         sCC = kStyle.prefs.center;
        let sCR = 5;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('rotations'))
         sCR = cfg.display.kappa.styles[kStyle.style].rotations;
        if (kStyle.prefs.hasOwnProperty('rotations'))
         sCR = kStyle.prefs.rotations;
        let bF = false;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('faces'))
         bF = cfg.display.kappa.styles[kStyle.style].faces;
        if (kStyle.prefs.hasOwnProperty('faces'))
         bF = kStyle.prefs.faces === true;
        let kUse = [];
        if (bF)
         kUse = kList;
        else
         kUse.push(kList[shared.rnd(lK)]);
        _list.TheCube(kUse, sW, sH, Math.floor(cS * sCS), sCC, sCR);
        break;
       case 'Burst':
        const oH = _rndFromRange(timing.kappa[kStyle.style].left);
        const oV = _rndFromRange(timing.kappa[kStyle.style].top) * sB;
        const bA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const rB = shared.rnd(kClean.length);
         _eActive--;
         let eWb = eH;
         if (kClean[rB].hasOwnProperty('width') && kClean[rB].hasOwnProperty('height'))
          eWb = kClean[rB].width / kClean[rB].height * eH;
         const sRb = sW - Math.ceil(eWb / 2);
         display.emote.list.StraightLine(kClean[rB], sW, sH, eH, oH * sRb, oV, false, tInit);
         if (i % bA.ct === bA.ct - 1)
          await _fPause(bA.f);
        }
        break;
       case 'Fountain':
        const fX = _rndFromRange(timing.kappa[kStyle.style].left) * sW;
        const fY = _rndFromRange(timing.kappa[kStyle.style].top);
        const fA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const rF = shared.rnd(kClean.length);
         _eActive--;
         display.emote.list.Fountain(kClean[rF], sW, sH, eH, fX, fY, false, tInit);
         if (i % fA.ct === fA.ct - 1)
          await _fPause(fA.f);
        }
        break;
       case 'Confetti':
        const cA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const rN = shared.rnd(kClean.length);
         _eActive--;
         display.emote.list.Confetti(kClean[rN], sW, sH, eHh, false, tInit);
         if (i % cA.ct === cA.ct - 1)
          await _fPause(cA.f);
        }
        break;
       default:
        if (typeof display.emote.list[kStyle.style] === 'undefined')
         return;
        const kA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const kClean = kList.filter(function(oK){return !(oK.hasOwnProperty('origin') && display.erasedMsgs.includes(oK.origin));});
         if (kClean.length === 0)
          return;
         const r = shared.rnd(kClean.length);
         _eActive--;
         if (kStyle.style === 'StraightLine')
          display.emote.list.StraightLine(kClean[r], sW, sH, eH, false, false, false, tInit);
         else
          display.emote.list[kStyle.style](kClean[r], sW, sH, eH, false, tInit);
         if (i % kA.ct === kA.ct - 1)
          await _fPause(kA.f);
        }
      }
     }

     function $hide()
     {
      if (_tKappa !== false)
      {
       window.clearTimeout(_tKappa);
       _tKappa = false;
      }
      _toKappa.length = 0;
      _conga.clear();
      _codeCols.length = 0;
     }

     function $eraseConga(id)
     {
      if (_conga.has(id))
       _conga.delete(id);
     }

     function _sleep(ms)
     {
      if (ms < shared.mspf.value)
       return _fPause();
      return new Promise(
       function(resolve)
       {
        let n = 0;
        function _next(ts)
        {
         if (n === 0)
         {
          n = ts;
          window.requestAnimationFrame(_next);
          return;
         }
         else if (ts - n < ms)
         {
          window.requestAnimationFrame(_next);
          return;
         }
         resolve(true);
        }
        window.requestAnimationFrame(_next);
       }
      );
     }

     function _fPause(frames = 1)
     {
      return new Promise(
       function(resolve)
       {
        if (frames < 1)
        {
         resolve(false);
         return;
        }
        let n = 0;
        function _next()
        {
         n++;
         if (n < frames)
         {
          window.requestAnimationFrame(_next);
          return;
         }
         resolve(true);
        }
        window.requestAnimationFrame(_next);
       }
      );
     }

     function _kAcTime(ct, t = false)
     {
      if (t === false)
       t = Math.floor(cfg.emote.time * 1000);
      const f = Math.floor(t / shared.mspf.value);
      const r = f / ct;
      if (r > 1)
       return {f: Math.ceil(r), ct: 1};
      return {f: 1, ct: Math.ceil(1 / r)};
     }

     return {
      show: $show,
      hide: $hide,
      eraseConga: $eraseConga,
      clsID: Object.freeze({
       Firework: Object.freeze({
        Rocket: 'ktFireworkRocket',
        Sparkler: 'ktFireworkSparkler'
       }),
       Spiral: 'ktSpiral',
       Pyramid: Object.freeze({
        Show: 'ktPyramid',
        Drop: 'ktPyramidDrop'
       }),
       SmallPyramid: Object.freeze({
        Show: 'ktSmallPyramid',
        Drop: 'ktSmallPyramidDrop'
       }),
       CodeLine: Object.freeze({
        show: 'ktCodeLineShow',
        hide: 'ktCodeLineHide'
       }),
       Stampede: 'ktStampede',
       Conga: Object.freeze({
        In: 'ktCongaIn',
        Out: 'ktCongaOut'
       })
      })
     };
    }();

    const _gc = function()
    {
     const _toGC = new Set();

     let _tGC = false;

     function _doGC()
     {
      if (_tGC === false)
       return;
      window.clearTimeout(_tGC);
      _tGC = false;
      const tNow = Date.now();
      for (const g of _toGC)
      {
       if (g.space)
       {
        const r = g.img.getBoundingClientRect();
        if (g.end > tNow && r.bottom > 0 && r.right > 0 && r.top < window.innerHeight && r.left < window.innerWidth)
         continue;
       }
       else
       {
        if (g.end > tNow)
         continue;
       }
       _toGC.delete(g);
       if (g.img.parentNode !== null)
        g.img.parentNode.removeChild(g.img);
       if (g.dec === true)
        _eActive--;
       else if (g.dec !== false && Number.isInteger(g.dec))
        _eActive -= g.dec;
      }
      if (_toGC.size > 0)
       _tGC = window.setTimeout(_doGC, 500);
     }

     function $hook(img, space = true, decActive = true, t = false)
     {
      if (t === false)
       t = Math.floor(cfg.emote.time * 1000);
      _toGC.add({img: img, space: space, dec: decActive, end: Date.now() + t});
      if (_tGC === false)
       _tGC = window.setTimeout(_doGC, 500);
     }

     return {
      hook: $hook
     };
    }();

    function _rndFromRange(range)
    {
     return shared.rnd(range.max - range.min) + range.min;
    }

    function _safePoints(h, v, th, r, fL, fT, fR, fB)
    {
     const hD = Math.floor(h + r * Math.cos(th));
     const vD = Math.floor(v + r * Math.sin(th));
     const slope = Math.tan(th);
     let hL = Number.MAX_SAFE_INTEGER;
     let hU = 0;
     let vL = Number.MAX_SAFE_INTEGER;
     let vU = 0;
     if (hD < fL)
      hL = h - (hU = fL);
     else if (hD > fR)
      hL = (hU = fR) - h;
     if (vD < fT)
      vL = v - (vU = fT);
     else if (vD > fB)
      vL = (vU = fB) - v;
     if (vU === 0 && hU === 0)
      return true;
     let vT = vU;
     let hT = hU;
     if (hL > vL)
      hT = Math.floor((vT - v) / slope + h);
     else
      vT = Math.floor((hT - h) * slope + v);
     const l = Math.sqrt(Math.abs(h - hT) ** 2 + Math.abs(v - vT) ** 2);
     return (l > Math.ceil(r / 2));
    }

    function _appendHolidayZWE(e)
    {
     if (!cfg.display.extended.useZWE)
      return e;
     if (!cfg.display.extended.holidayZWE)
      return e;
     if (!service.emotes.hasOwnProperty('zwe'))
      return e;
     if (!service.emotes.zwe.hasOwnProperty('bttv'))
      return e;
     const nowM = new Date().getMonth() + 1;
     const nowD = new Date().getDate();
     for (const hID in bttvHoliday)
     {
      if (!bttvHoliday.hasOwnProperty(hID))
       continue;
      if (bttvHoliday[hID].min.month > nowM)
       continue;
      if (bttvHoliday[hID].min.month === nowM && bttvHoliday[hID].min.day > nowD)
       continue;
      if (bttvHoliday[hID].max.month < nowM)
       continue;
      if (bttvHoliday[hID].max.month === nowM && bttvHoliday[hID].max.day < nowD)
       continue;
      let idx = e.pos;
      if (!e.hasOwnProperty('zwe'))
       e.zwe = [];
      else
      {
       for (let i = 0, l = e.zwe.length; i < l; i++)
       {
        if (idx < e.zwe[i].pos)
         idx = e.zwe[i].pos;
       }
      }
      e.zwe.push({svc: service.emotes.zwe.bttv, scope: cSources.scope.global, pos: idx + 1, str: bttvHoliday[hID].code, url: cURLs.cdn.bttv.emote.replaceAll(cVARs.url.emoteID, hID), width: bttvHoliday[hID].width, height: bttvHoliday[hID].height});
     }
     return e;
    }

    function _addEmoteAndZWEs(tInit, eInf, variationSize, attrs = {}, oGC = {}, oT = false)
    {
     const r = [];
     if (!eInf.hasOwnProperty('zwe'))
     {
      const oE = _addEmoteToDoc(tInit, eInf.url, eInf.origin, variationSize, attrs, oGC, oT);
      if (oE === null)
       return [];
      r.push(oE);
     }
     else
     {
      const btzwCE = _btzwClassForEmote(eInf.zwe);
      const cAttrs = JSON.parse(JSON.stringify(attrs));
      if (!cAttrs.hasOwnProperty('classes'))
       cAttrs.classes = [];
      cAttrs.classes.push(...btzwCE);
      const oE = _addEmoteToDoc(tInit, eInf.url, eInf.origin, variationSize, cAttrs, oGC, oT);
      if (oE === null)
       return [];
      r.push(oE);
      for (let i = 0, l = eInf.zwe.length; i < l; i++)
      {
       const btzwCZ = _btzwClassForZWE(btzwCE, eInf.zwe[i].url);
       const zAttrs = JSON.parse(JSON.stringify(attrs));
       if (!zAttrs.hasOwnProperty('classes'))
        zAttrs.classes = [];
       zAttrs.classes.push(...btzwCZ);
       const oZ = _addEmoteToDoc(tInit, eInf.zwe[i].url, eInf.origin, variationSize, zAttrs, oGC, oT);
       if (oZ === null)
        return [];
       r.push(oZ);
      }
     }
     return r;
    }

    function _addEmoteToDoc(tInit, uri, oID, variationSize, attrs = {}, oGC = {}, oT = false)
    {
     if (_iTitanic > tInit)
      return null;
     const img = document.createElement('img');
     const c = [];
     c.push('emote');
     if (attrs.hasOwnProperty('classes'))
      c.push(...attrs.classes);
     const rV = variationSize.toFixed(3).replace('.', '_');
     c.push('eSize-' + rV);
     img.classList.add(...c);
     if (typeof oID !== 'undefined')
      img.setAttribute('data-msgid', oID);
     _setImgSrc(img, uri);
     if (attrs.hasOwnProperty('style'))
      img.setAttribute('style', attrs.style);
     if (attrs.hasOwnProperty('dataset'))
     {
      for (let i = 0, k = Object.keys(attrs.dataset), l = k.length; i < l; i++)
      {
       img.setAttribute('data-' + k[i], attrs.dataset[k[i]]);
      }
     }
     _eActive++;
     document.body.appendChild(img);
     let space = true;
     let decActive = true;
     let t = false;
     if (oGC !== false)
     {
      if (oGC.hasOwnProperty('space'))
       space = oGC.space;
      if (oGC.hasOwnProperty('decrement'))
       decActive = oGC.decrement;
      if (oGC.hasOwnProperty('time'))
       t = oGC.time;
      _gc.hook(img, space, decActive, t);
     }
     if (oT !== false)
     {
      let sTF = null;
      if (oT.hasOwnProperty('x') && oT.hasOwnProperty('y'))
       sTF = 'translate(' + oT.x + 'px, ' + oT.y + 'px)';
      else if (oT.hasOwnProperty('x'))
       sTF = 'translateX(' + oT.x + 'px)';
      else if (oT.hasOwnProperty('y'))
       sTF = 'translateY(' + oT.y + 'px)';
      if (sTF !== null)
       shared.doNextFrame(_tMoveOnDock, tInit, img, sTF);
     }
     return img;
    }

    function _tMoveOnDock(tInit, img, sTF)
    {
     if (_iTitanic > tInit)
      return;
     img.style.transform = sTF;
    }

    function _setImgSrc(img, url)
    {
     shared.ec.halt();
     let iTry = 1;
     img.alt = '';
     img.onload = function()
     {
      img.onerror = null;
      img.onload = null;
      shared.ec.save(url, img.naturalWidth, img.naturalHeight);
     };
     img.onerror = function()
     {
      iTry++;
      if (iTry > 3)
      {
       img.onerror = null;
       img.onload = null;
       img.src = bareList[shared.rnd(bareList.length)].url;
       return;
      }
      img.removeAttribute('src');
      img.setAttribute('src', url);
     };
     img.setAttribute('src', url);
    }

    function _btzwClassForEmote(zList)
    {
     const r = [];
     if (!Array.isArray(zList))
      return r;
     for (let i = 0, l = zList.length; i < l; i++)
     {
      r.push(..._btzwClassFromZWE(zList[i].url));
     }
     return r;
    }

    function _btzwClassForZWE(cList, url)
    {
     const r = ['zwe'];
     const cZ = _btzwClassFromZWE(url);
     if (cZ.length === 0)
      return r;
     if (cZ.includes('zweFramed'))
      return r;
     if (cZ.includes('zweLPad') && cList.includes('zweFramed'))
     {
      r.push('zweFramed');
      return r;
     }
     if (cZ.includes('zweHat'))
     {
      if (cList.includes('zweFramed'))
       r.push('zweFramed');
      if (cList.includes('zweLPad') && !cZ.includes('zweLPad'))
       r.push('zweLPad');
      return r;
     }
     return r;
    }

    function _btzwClassFromZWE(url)
    {
     const btzwCE = [];
     for (const zID in bttvZWE)
     {
      if (!bttvZWE.hasOwnProperty(zID))
       continue;
      if (cURLs.cdn.bttv.emote.replaceAll(cVARs.url.emoteID, zID) !== url)
       continue;
      for (let i = 0, l = bttvZWE[zID].length; i < l; i++)
      {
       if (btzwCE.includes(bttvZWE[zID][i]))
        continue;
       btzwCE.push(bttvZWE[zID][i]);
      }
     }
     return btzwCE;
    }

    function _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters)
    {
     let s = '';
     if (aNames.length > 0)
     {
      s += ' animation-name: ' + aNames.join() + ';';
      s += ' animation-delay: ' + aDelays.join() + ';';
      s += ' animation-duration: ' + aDurs.join() + ';';
      s += ' animation-timing-function: ' + aTimings.join() + ';';
      s += ' animation-fill-mode: ' + aFills.join() + ';';
      s += ' animation-iteration-count: ' + aIters.join() + ';';
     }
     if (aNames.includes('fadeIn'))
      s += ' opacity: 0;';
     return s;
    }

    function _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, fadeIn = true, zoomIn = true, fadeOut = true, zoomOut = true, tMS = false)
    {
     if (tMS === false)
      tMS = Math.floor(cfg.emote.time * 1000);
     const tFI = _tAnim.fade.in / 100;
     const tFO = _tAnim.fade.out / 100;
     const tZI = _tAnim.zoom.in / 100;
     const tZO = _tAnim.zoom.out / 100;
     if (fadeIn)
     {
      aNames.push('fadeIn');
      aDelays.push('0s');
      aDurs.push(Math.floor(tMS * tFI) + 'ms');
      aTimings.push('ease-in');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (zoomIn)
     {
      aNames.push('zoomIn');
      aDelays.push('0s');
      aDurs.push(Math.floor(tMS * tZI) + 'ms');
      aTimings.push('linear');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (fadeOut)
     {
      aNames.push('fadeOut');
      aDelays.push(Math.floor(tMS - tMS * tFO) + 'ms');
      aDurs.push(Math.floor(tMS * tFO) + 'ms');
      aTimings.push('ease-out');
      aFills.push('forwards');
      aIters.push('1');
     }
     else
     {
      aNames.push('noFadeOut');
      aDelays.push(tMS - 50 + 'ms');
      aDurs.push('50ms');
      aTimings.push('ease-out');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (zoomOut)
     {
      aNames.push('zoomOut');
      aDelays.push(Math.floor(tMS - tMS * tZO) + 'ms');
      aDurs.push(Math.floor(tMS * tZO) + 'ms');
      aTimings.push('linear');
      aFills.push('forwards');
      aIters.push('1');
     }
     return _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
    }

    function $eraseMsg(oID)
    {
     display.erasedMsgs.push(oID);
     const zwes = document.querySelectorAll('img.zwe[data-msgid="' + oID + '"]');
     for (let i = zwes.length - 1; i >= 0; i--)
     {
      zwes[i].parentNode.removeChild(zwes[i]);
     }
     const hLines = document.querySelectorAll('img.' + display.kappa.clsID.CodeLine.hide + '[data-msgid="' + oID + '"]');
     for (let i = hLines.length - 1; i >= 0; i--)
     {
      hLines[i].parentNode.removeChild(hLines[i]);
     }
     const imgs = document.querySelectorAll('img[data-msgid="' + oID + '"]');
     const death = dieList[shared.rnd(dieList.length)];
     for (let i = 0; i < imgs.length; i++)
     {
      imgs[i].src = death.url;
     }
     window.setTimeout(_eraseMsgPart2, death.time, oID);
    }

    function _eraseMsgPart2(oID)
    {
     const dancers = document.querySelectorAll('div.scene img[data-msgid="' + oID + '"].dancer');
     for (let i = dancers.length - 1; i >= 0; i--)
     {
      if (dancers[i].parentNode === null)
       continue;
      if (dancers[i].parentNode.parentNode === null)
       continue;
      if (dancers[i].parentNode.style.zIndex !== '')
       display.kappa.eraseConga(parseInt(dancers[i].parentNode.style.zIndex, 10));
      dancers[i].parentNode.parentNode.removeChild(dancers[i].parentNode);
     }
     const cubes = document.querySelectorAll('div.scene.cube img[data-msgid="' + oID + '"]');
     for (let i = cubes.length - 1; i >= 0; i--)
     {
      if (cubes[i].parentNode === null)
       continue;
      if (cubes[i].parentNode.parentNode === null)
       continue;
      if (cubes[i].parentNode.parentNode.parentNode === null)
       continue;
      cubes[i].parentNode.parentNode.parentNode.removeChild(cubes[i].parentNode.parentNode);
     }
     const imgs = document.querySelectorAll('img[data-msgid="' + oID + '"]');
     for (let i = imgs.length - 1; i >= 0; i--)
     {
      if (imgs[i].parentNode.classList.contains('scene'))
       imgs[i].parentNode.parentNode.removeChild(imgs[i].parentNode);
      else
       imgs[i].parentNode.removeChild(imgs[i]);
     }
     service.parse.clearCooldowns();
     _eActive = 0;
    }

    function $eraseAll()
    {
     _iTitanic = Date.now();
     display.kappa.hide();
     const zwes = document.getElementsByClassName('zwe');
     while (zwes.length)
     {
      zwes[0].parentNode.removeChild(zwes[0]);
     }
     const hLines = document.getElementsByClassName(display.kappa.clsID.CodeLine.hide);
     while (hLines.length)
     {
      hLines[0].parentNode.removeChild(hLines[0]);
     }
     const imgs = document.getElementsByTagName('img');
     const death = dieList[shared.rnd(dieList.length)];
     for (let i = 0; i < imgs.length; i++)
     {
      imgs[i].src = death.url;
     }
     window.setTimeout(_eraseAllPart2, death.time);
    }

    function _eraseAllPart2()
    {
     const cubes = document.getElementsByClassName('scene');
     while (cubes.length)
     {
      cubes[0].parentNode.removeChild(cubes[0]);
     }
     const imgs = document.getElementsByTagName('img');
     while (imgs.length)
     {
      imgs[0].parentNode.removeChild(imgs[0]);
     }
     service.parse.clearCooldowns();
     _eActive = 0;
    }

    return {
     emote: $emote,
     kappa: $kappa,
     eraseMsg: $eraseMsg,
     eraseAll: $eraseAll,
     erasedMsgs: []
    };
   }();

   const twitch = function()
   {
    const _rList = {};
    let _aTagged = {};

    const $net = function()
    {
     function _findBestURL(imgs)
     {
      const themes = ['dark', 'light'];
      const anims = ['animated', 'static'];
      const sizes = ['4', '3', '2', '1.5', '1'];
      for (const theme of themes)
      {
       if (!imgs.hasOwnProperty(theme))
        continue;
       for (const anim of anims)
       {
        if (!imgs[theme].hasOwnProperty(anim))
         continue;
        for (const size of sizes)
        {
         if (!imgs[theme][anim].hasOwnProperty(size))
          continue;
         return imgs[theme][anim][size];
        }
       }
      }
      return false;
     }

     async function _loadCheer_channel(chID)
     {
      if (!service.emotes.hasOwnProperty('cheer'))
       service.emotes.cheer = {};
      const url = cURLs.api.twitch.bits.cheermotes.replaceAll(cVARs.url.channelID, chID);
      const r = await shared.httpRequest('GET', url, twitch.net.oAuth.headers());
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('data'))
       return false;
      for (let c = 0, l = j.data.length; c < l; c++)
      {
       const set = j.data[c];
       if (!set.hasOwnProperty('prefix'))
        continue;
       if (!set.hasOwnProperty('tiers'))
        continue;
       const prefix = set.prefix;
       const tierList = [];
       for (let i = set.tiers.length - 1; i >= 0; i--)
       {
        if (!set.tiers[i].hasOwnProperty('min_bits'))
         continue;
        if (!set.tiers[i].hasOwnProperty('images'))
         continue;
        if (set.tiers[i].hasOwnProperty('can_cheer') && set.tiers[i].can_cheer === false)
         continue;
        const amt = set.tiers[i].min_bits;
        const img = _findBestURL(set.tiers[i].images);
        if (img === false)
         continue;
        tierList.push({min: amt, img: img});
       }
       service.emotes.cheer[prefix] = tierList;
      }
      return true;
     }

     const _eventSub = function()
     {
      let _wsURL = cURLs.ws.twitch.eventSub;
      let _wsRetry = null;
      let _ws = null;
      let _oldWS = null;
      let _lTimeout = 5000;
      let _tTimeout = false;
      const _lOldTimeout = 10000;
      let _tOldTimeout = false;

      function $c_eventSub(chID = null)
      {
       notice.expect |= notice.Connection.TWITCH_EVENTSUB;
       if (chID !== null)
        twitch.net.eventSubCtl.channelID = chID;
       _ws = new WebSocket(_wsURL);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      }

      function _wsClose()
      {
       notice.error(notice.Type.TWITCH_EVENTSUB);
       notice.active &= ~notice.Connection.TWITCH_EVENTSUB;
       notice.resetHide();
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws !== null)
       {
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
       }
       if (twitch.net.dead)
        return;
       if (_wsURL.length > cURLs.ws.twitch.eventSub.length && _wsURL.slice(0, cURLs.ws.twitch.eventSub.length) === cURLs.ws.twitch.eventSub)
        _wsURL = cURLs.ws.twitch.eventSub;
       const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(_eventSub, wsWait);
      }

      const _wsMessage = function()
      {
       async function $c_wsMessage(ev)
       {
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (twitch.net.dead)
        {
         if (_ws === null)
          return;
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         return;
        }
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        const r = JSON.parse(ev.data);
        if (!r.hasOwnProperty('metadata'))
         return;
        if (!r.hasOwnProperty('payload'))
         return;
        notice.info(notice.Type.TWITCH_EVENTSUB);
        notice.active |= notice.Connection.TWITCH_EVENTSUB;
        notice.resetHide();
        switch (r.metadata.message_type)
        {
         case 'session_welcome':
          await _session_welcome(r.payload);
          break;
         case 'session_keepalive':
          _wsRetry = 0;
          break;
         case 'session_reconnect':
          _session_reconnect(r.payload);
          break;
         case 'revocation':
          await _revocation(r.metadata);
          break;
         case 'notification':
          await _notification(r);
          break;
        }
       }

       async function _session_welcome(p)
       {
        if (_oldWS !== null)
        {
         _oldWS.close();
         _oldWS = null;
         if (_tOldTimeout !== false)
         {
          window.clearTimeout(_tOldTimeout);
          _tOldTimeout = false;
         }
        }
        if (!p.hasOwnProperty('session'))
         return;
        if (p.session.hasOwnProperty('id'))
         twitch.net.eventSubCtl.sessionID = p.session.id;
        if (p.session.hasOwnProperty('keepalive_timeout_seconds'))
        {
         _lTimeout = parseInt(p.session.keepalive_timeout_seconds, 10) * 2 * 1000;
         if (_tTimeout !== false)
         {
          window.clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        }
        const haveSubs = await twitch.net.eventSubCtl.init();
        if (haveSubs)
         return;
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_ws !== null)
        {
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
        }
       }

       function _session_reconnect(p)
       {
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (p.hasOwnProperty('session'))
        {
         if (p.session.hasOwnProperty('id'))
          twitch.net.eventSubCtl.sessionID = p.session.id;
         if (p.session.hasOwnProperty('keepalive_timeout_seconds') && p.session.keepalive_timeout_seconds !== null)
          _lTimeout = parseInt(p.session.keepalive_timeout_seconds, 10) * 2 * 1000;
         if (p.session.hasOwnProperty('reconnect_url'))
          _wsURL = p.session.reconnect_url;
        }
        else
        {
         twitch.net.eventSubCtl.sessionID = null;
         _lTimeout = 5000;
         _wsURL = cURLs.ws.twitch.eventSub;
        }
        if (_ws !== null)
        {
         _oldWS = _ws;
         _oldWS.onclose = null;
         _oldWS.onmessage = null;
         _tOldTimeout = window.setTimeout(_oldWSTimeout, _lOldTimeout);
         _ws = null;
        }
        const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
        if (_wsRetry < 2)
         _wsRetry += 0.2;
        window.setTimeout(_eventSub, wsWait);
       }

       async function _revocation(m)
       {
        if (!m.hasOwnProperty('subscription_type'))
         return;
        const subType = m.subscription_type;
        let subVer = '1';
        if (m.hasOwnProperty('subscription_version'))
         subVer = m.subscription_version;
        await twitch.net.eventSubCtl.subscribe(subType, subVer);
       }

       const _notification = function()
       {
        async function $c_notification(r)
        {
         if (!r.metadata.hasOwnProperty('subscription_type'))
          return;
         if (!r.payload.hasOwnProperty('event'))
          return;
         switch (r.metadata.subscription_type)
         {
          case twitch.net.eventSubCtl.sub.tag:
           await _channel_update(r.payload.event);
           return;
         }
         if (document.visibilityState === 'hidden')
          return;
         switch (r.metadata.subscription_type)
         {
          case twitch.net.eventSubCtl.sub.redeem:
           _channel_points_redeem(r.payload.event);
           return;
          case twitch.net.eventSubCtl.sub.auto_redeem:
           _channel_points_auto_redeem(r.payload.event);
           return;
          case twitch.net.eventSubCtl.sub.follow:
           _follow(r.payload.event);
           break;
          case twitch.net.eventSubCtl.sub.shoutout.create:
           await _shoutout_create(r.payload.event);
           break;
          case twitch.net.eventSubCtl.sub.shoutout.receive:
           await _shoutout_receive(r.payload.event);
           break;
          case twitch.net.eventSubCtl.sub.hypetrain.begin:
           _train_begin(r.payload.event);
           return;
          case twitch.net.eventSubCtl.sub.hypetrain.end:
           _train_end(r.payload.event);
           break;
          case twitch.net.eventSubCtl.sub.poll.begin:
           _poll_begin(r.payload.event);
           break;
          case twitch.net.eventSubCtl.sub.poll.end:
           _poll_end(r.payload.event);
           break;
          case twitch.net.eventSubCtl.sub.prediction.begin:
           _prediction_begin(r.payload.event);
           break;
          case twitch.net.eventSubCtl.sub.prediction.end:
           _prediction_end(r.payload.event);
           break;
          case twitch.net.eventSubCtl.sub.charity:
           _charity(r.payload.event);
           break;
          case twitch.net.eventSubCtl.sub.goal.begin:
           _goal_begin(r.payload.event);
           break;
          case twitch.net.eventSubCtl.sub.goal.end:
           _goal_end(r.payload.event);
           break;
         }
        }

        function _channel_points_redeem(ev)
        {
         let ln = false;
         if (ev.user_login)
          ln = ev.user_login;
         if (!!ln && cfg.ignore.users !== false && cfg.ignore.users.includes(ln))
          return;
         if (!ev.reward)
          return;
         if (!ev.reward.hasOwnProperty('title'))
          return;
         const n = ev.reward.title;
         if (!ev.hasOwnProperty('user_input') || ev.user_input === '')
         {
          _parse.event.redeem(n, false);
          return;
         }
         if (!ev.reward.hasOwnProperty('id'))
          return;
         const lnID = ev.reward.id;
         if (!_rList.hasOwnProperty(lnID))
         {
          _rList[lnID] = {name: n, cmds: []};
          return;
         }
         if (_rList[lnID].name === false)
          _rList[lnID].name = n;
         while (_rList[lnID].cmds.length > 0)
         {
          _parse.event.redeem(n, _rList[lnID].cmds.shift());
         }
        }

        function _channel_points_auto_redeem(ev)
        {
         if (!ev.hasOwnProperty('reward'))
          return;
         if (!ev.reward.hasOwnProperty('type'))
          return;
         switch (ev.reward.type)
         {
          case 'random_sub_emote_unlock':
           _parse.event.random_emote(ev);
           break;
          case 'chosen_sub_emote_unlock':
           _parse.event.chosen_emote(ev);
           break;
          case 'chosen_modified_sub_emote_unlock':
           _parse.event.modified_emote(ev);
           break;
         }
        }

        async function _channel_update(ev)
        {
         if (!ev.hasOwnProperty('title'))
          return;
         await _addToChannelTitleTags(ev.title);
        }

        const _follow = function()
        {
         const _fHist = new Set();

         function $c_follow(ev)
         {
          if (!ev.hasOwnProperty('user_id'))
           return;
          twitch.net.fList[ev.user_id] = {value: true, t: Date.now()};
          if (_fHist.has(ev.user_id))
           return;
          _fHist.add(ev.user_id);
          _parse.event.follow(ev);
         }

         return $c_follow;
        }();

        async function _shoutout_create(ev)
        {
         await _parse.event.shoutout.create(ev);
        }

        async function _shoutout_receive(ev)
        {
         await _parse.event.shoutout.receive(ev);
        }

        function _train_begin(ev)
        {
         if (ev.hasOwnProperty('type'))
         {
          switch (ev.type)
          {
           case 'golden_kappa':
            _parse.event.train.kappa.begin();
            return;
           case 'treasure':
            _parse.event.train.treasure.begin();
            return;
          }
         }
         _parse.event.train.hype.begin();
        }

        function _train_end(ev)
        {
         if (!ev.hasOwnProperty('level'))
          return;
         if (ev.level < 2)
          return;
         if (ev.hasOwnProperty('type'))
         {
          switch (ev.type)
          {
           case 'golden_kappa':
            _parse.event.train.kappa.end(ev);
            return;
           case 'treasure':
            _parse.event.train.treasure.end(ev);
            return;
          }
         }
         _parse.event.train.hype.end(ev);
        }

        function _poll_begin(ev)
        {
         _parse.event.poll.begin(ev);
        }

        function _poll_end(ev)
        {
         if (!ev.hasOwnProperty('status'))
          return;
         if (ev.status !== 'completed')
          return;
         _parse.event.poll.end(ev);
        }

        function _prediction_begin(ev)
        {
         _parse.event.prediction.begin(ev);
        }

        function _prediction_end(ev)
        {
         if (!ev.hasOwnProperty('status'))
          return;
         if (ev.status !== 'resolved')
          return;
         _parse.event.prediction.end(ev);
        }

        function _charity(ev)
        {
         _parse.event.charity(ev);
        }

        function _goal_begin(ev)
        {
         _parse.event.goal.begin(ev);
        }

        function _goal_end(ev)
        {
         if (!ev.hasOwnProperty('is_achieved'))
          return;
         if (ev.is_achieved !== true)
          return;
         _parse.event.goal.end(ev);
        }

        return $c_notification;
       }();

       return $c_wsMessage;
      }();

      function _wsTimeout()
      {
       if (_lTimeout === 5000)
       {
        notice.error(notice.Type.TWITCH_EVENTSUB);
        notice.active &= ~notice.Connection.TWITCH_EVENTSUB;
        notice.resetHide();
       }
       else
        _lTimeout = 5000;
       if (_wsURL.length > cURLs.ws.twitch.eventSub.length && _wsURL.slice(0, cURLs.ws.twitch.eventSub.length) === cURLs.ws.twitch.eventSub)
        _wsURL = cURLs.ws.twitch.eventSub;
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (twitch.net.dead === true)
        return;
       _eventSub();
      }

      function _oldWSTimeout()
      {
       if (_tOldTimeout !== false)
       {
        window.clearTimeout(_tOldTimeout);
        _tOldTimeout = false;
       }
       if (_oldWS === null)
        return;
       _oldWS.onopen = null;
       _oldWS.onmessage = null;
       _oldWS.onclose = null;
       _oldWS.close();
       _oldWS = null;
      }

      return $c_eventSub;
     }();

     const $eventSubCtl = function()
     {
      async function $init()
      {
       const aSubs = [
        {id: twitch.net.eventSubCtl.sub.follow, v: '2', scope: [cScopes.twitch.followers], cfg: ['event.twitch.follow']},
        {id: twitch.net.eventSubCtl.sub.redeem, scope: [cScopes.twitch.redemptions], cfg: false},
        {id: twitch.net.eventSubCtl.sub.auto_redeem, v: '2', scope: [cScopes.twitch.redemptions], cfg: ['event.twitch.redeem.random_emote', 'event.twitch.redeem.chosen_emote', 'event.twitch.redeem.modified_emote']},
        {id: twitch.net.eventSubCtl.sub.shoutout.create, scope: [cScopes.twitch.shoutouts], cfg: ['event.twitch.shoutout.create.styles']},
        {id: twitch.net.eventSubCtl.sub.shoutout.receive, scope: [cScopes.twitch.shoutouts], cfg: ['event.twitch.shoutout.receive.styles']},
        {id: twitch.net.eventSubCtl.sub.hypetrain.begin, v: '2', scope: [cScopes.twitch.hypetrains], cfg: ['event.twitch.hypetrain.begin']},
        {id: twitch.net.eventSubCtl.sub.hypetrain.end, v: '2', scope: [cScopes.twitch.hypetrains], cfg: ['event.twitch.hypetrain.success']},
        {id: twitch.net.eventSubCtl.sub.poll.begin, scope: [cScopes.twitch.polls], cfg: ['event.twitch.poll.begin']},
        {id: twitch.net.eventSubCtl.sub.poll.end, scope: [cScopes.twitch.polls], cfg: ['event.twitch.poll.end']},
        {id: twitch.net.eventSubCtl.sub.prediction.begin, scope: [cScopes.twitch.predictions], cfg: ['event.twitch.prediction.begin']},
        {id: twitch.net.eventSubCtl.sub.prediction.end, scope: [cScopes.twitch.predictions], cfg: ['event.twitch.prediction.resolved']},
        {id: twitch.net.eventSubCtl.sub.goal.begin, scope: [cScopes.twitch.goals], cfg: ['event.twitch.goal.begin']},
        {id: twitch.net.eventSubCtl.sub.goal.end, scope: [cScopes.twitch.goals], cfg: ['event.twitch.goal.achieved']},
        {id: twitch.net.eventSubCtl.sub.charity, scope: [cScopes.twitch.charity], cfg: ['event.twitch.charity']},
        {id: twitch.net.eventSubCtl.sub.tag, scope: false, cfg: ['event.twitch.tag.styles']}
       ];
       const aActive = await _cleanAndRecover();
       let didSomething = aActive.length > 0;
       const toHandle = [];
       for (let i = 0, l = aSubs.length; i < l; i++)
       {
        toHandle.push(_handleSub(aSubs[i], aActive));
       }
       if (toHandle.length > 0)
       {
        const handled = await Promise.allSettled(toHandle);
        for (let i = 0, l = handled.length; i < l; i++)
        {
         if (handled[i].status !== 'fulfilled')
          continue;
         if (handled[i].value !== false)
         {
          didSomething = true;
          break;
         }
        }
       }
       return didSomething;
      }

      function _handleSub(sub, aActive)
      {
       if (sub.hasOwnProperty('cfg') && sub.cfg !== false)
       {
        let found = true;
        for (let i = 0, l = sub.cfg.length; i < l; i++)
        {
         const aPref = sub.cfg[i].split('.');
         let cPref = cfg;
         found = true;
         for (let j = 0, m = aPref.length; j < m; j++)
         {
          if (!cPref.hasOwnProperty(aPref[j]))
          {
           found = false;
           break;
          }
          if (cPref[aPref[j]] === false)
          {
           found = false;
           break;
          }
          cPref = cPref[aPref[j]];
         }
         if (found !== false)
          break;
        }
        if (found === false)
         return false;
       }
       else if (sub.id === twitch.net.eventSubCtl.sub.redeem)
       {
        let found = false;
        for (const k of cfg.commands)
        {
         if (!k.hasOwnProperty('redeem') || !Array.isArray(k.redeem) || k.redeem.length === 0)
          continue;
         found = true;
         break;
        }
        if (found === false)
         return false;
       }
       if (sub.hasOwnProperty('scope') && sub.scope !== false)
       {
        for (let i = 0, l = sub.scope.length; i < l; i++)
        {
         if (!twitch.net.oAuth.auth.scope.includes(sub.scope[i]))
          return false;
        }
       }
       if (aActive.includes(sub.id))
        return false;
       if (!sub.hasOwnProperty('v'))
        return twitch.net.eventSubCtl.subscribe(sub.id);
       return twitch.net.eventSubCtl.subscribe(sub.id, sub.v);
      }

      async function _getList()
      {
       const r = await shared.httpRequest('GET', cURLs.api.twitch.eventSub.get, twitch.net.oAuth.headers());
       if (!r.success)
        return [];
       const j = r.json;
       if (j === null)
        return [];
       if (!j.hasOwnProperty('data'))
        return [];
       if (!j.hasOwnProperty('total'))
        return [];
       if (j.total < 1)
        return [];
       return j.data;
      }

      async function $erase()
      {
       const d = await _getList();
       if (d.length === 0)
        return;
       const unList = [];
       for (let i = 0, l = d.length; i < l; i++)
       {
        if (!d[i].hasOwnProperty('id'))
         continue;
        unList.push(_unsubscribe(d[i].id));
       }
       if (unList.length > 0)
        await Promise.allSettled(unList);
       if (window.location.hash.length < 2)
        window.location.reload();
       else
        window.location = window.location.href.slice(0, -1 * window.location.hash.length);
      }

      async function _cleanAndRecover()
      {
       const d = await _getList();
       if (d.length === 0)
        return [];
       const rList = [];
       const unList = [];
       for (let i = 0, l = d.length; i < l; i++)
       {
        if (!d[i].hasOwnProperty('id'))
         continue;
        if (!d[i].hasOwnProperty('status'))
         continue;
        switch (d[i].status)
        {
         case 'enabled':
          if (!d[i].hasOwnProperty('type'))
           continue;
          if (!d[i].hasOwnProperty('transport'))
           continue;
          if (!d[i].transport.hasOwnProperty('method'))
           continue;
          if (d[i].transport.method !== 'websocket')
           continue;
          if (!d[i].transport.hasOwnProperty('session_id'))
           continue;
          if (d[i].transport.session_id !== twitch.net.eventSubCtl.sessionID)
           continue;
          rList.push(d[i].type);
          break;
         case 'authorization_revoked':
         case 'moderator_removed':
         case 'user_removed':
         case 'version_removed':
         case 'websocket_disconnected':
         case 'websocket_failed_ping_pong':
         case 'websocket_received_inbound_traffic':
         case 'websocket_connection_unused':
         case 'websocket_internal_error':
         case 'websocket_network_timeout':
         case 'websocket_network_error':
          unList.push(_unsubscribe(d[i].id));
          break;
        }
       }
       if (unList.length > 0)
        await Promise.allSettled(unList);
       return rList;
      }

      async function $subscribe(type, version = '1')
      {
       const d = {
        'type': type,
        'version': version,
        'condition': {'broadcaster_user_id': twitch.net.eventSubCtl.channelID},
        'transport': {'method': 'websocket', 'session_id': twitch.net.eventSubCtl.sessionID}
       };
       switch (type)
       {
        case twitch.net.eventSubCtl.sub.follow:
        case twitch.net.eventSubCtl.sub.shoutout.create:
        case twitch.net.eventSubCtl.sub.shoutout.receive:
         d.condition.moderator_user_id = twitch.net.eventSubCtl.channelID;
         break;
       }
       const r = await shared.httpRequest('POST', cURLs.api.twitch.eventSub.get, twitch.net.oAuth.headers(true), JSON.stringify(d), false);
       if (r.success)
        return true;
       if (r.code === 429)
       {
        const eNote = document.getElementById('notice' + notice.Type.TWITCH_EVENTSUB.description);
        if (!eNote || !eNote.classList.contains('noticeWarning'))
         notice.warning(notice.Type.TWITCH_EVENTSUB);
       }
       return false;
      }

      async function _unsubscribe(id)
      {
       const r = await shared.httpRequest('DELETE', cURLs.api.twitch.eventSub.delete.replaceAll(cVARs.url.eventID, id), twitch.net.oAuth.headers(), null, false);
       if (!r.success)
        return false;
       return true;
      }

      return {
       init: $init,
       subscribe: $subscribe,
       erase: $erase,
       channelID: 0,
       sessionID: null,
       sub: Object.freeze({
        follow: 'channel.follow',
        redeem: 'channel.channel_points_custom_reward_redemption.add',
        auto_redeem: 'channel.channel_points_automatic_reward_redemption.add',
        shoutout: Object.freeze({
         create: 'channel.shoutout.create',
         receive: 'channel.shoutout.receive'
        }),
        hypetrain: Object.freeze({
         begin: 'channel.hype_train.begin',
         end: 'channel.hype_train.end'
        }),
        poll: Object.freeze({
         begin: 'channel.poll.begin',
         end: 'channel.poll.end'
        }),
        prediction: Object.freeze({
         begin: 'channel.prediction.begin',
         end: 'channel.prediction.end'
        }),
        goal: Object.freeze({
         begin: 'channel.goal.begin',
         end: 'channel.goal.end'
        }),
        charity: 'channel.charity_campaign.donate',
        tag: 'channel.update'
       })
      };
     }();

     const $irc = function()
     {
      let _wsRetry = 0;
      let _firstRS = true;
      let _ws = null;
      let _msgHistory = {};
      const _lPing = 30000;
      const _lTimeout = 35000;
      const _lExpire = 5000;
      let _tTimeout = false;
      let _tExpire = false;
      let _tPing = 0;

      function $c_irc()
      {
       notice.expect |= notice.Connection.TWITCH_IRC;
       _tPing = 0;
       _firstRS = true;
       _ws = new WebSocket(cURLs.ws.twitch.irc);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
       _tExpire = window.setTimeout(_wsExpire, _lExpire);
       _ws.send('CAP REQ :twitch.tv/commands twitch.tv/tags');
       _ws.send('PASS oauth:' + twitch.net.oAuth.auth.access_token);
       _ws.send('NICK ' + twitch.net.oAuth.auth.channel);
       _ws.send('JOIN #' + twitch.net.oAuth.auth.channel);
      }

      function _wsClose()
      {
       notice.error(notice.Type.TWITCH_IRC);
       notice.active &= ~notice.Connection.TWITCH_IRC;
       notice.resetHide();
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(twitch.net.irc, wsWait);
      }

      const _wsMessage = function()
      {
       async function $c_wsMessage(ev)
       {
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, _lPing);
        if (_ws === null)
         return;
        if (twitch.net.dead)
        {
         if (_tExpire !== false)
         {
          window.clearTimeout(_tExpire);
          _tExpire = false;
         }
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         return;
        }
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        _wsRetry = 0;
        const data = ev.data.split('\r\n');
        for (let i = 0, l = data.length; i < l; i++)
        {
         if (data[i].length === 0)
          continue;
         const cmd = _parse.message(data[i]);
         if (cmd === false || !cmd.hasOwnProperty('command'))
          continue;
         notice.info(notice.Type.TWITCH_IRC);
         notice.active |= notice.Connection.TWITCH_IRC;
         notice.resetHide();
         switch (cmd.command)
         {
          case 'PING':
           await _PING(cmd);
           break;
          case 'PRIVMSG':
           await _PRIVMSG(cmd);
           break;
          case 'NOTICE':
           if (await _NOTICE(cmd))
            return;
           break;
          case 'ROOMSTATE':
           await _ROOMSTATE(cmd);
           break;
          case 'USERNOTICE':
           _USERNOTICE(cmd);
           break;
          case 'CLEARMSG':
           _CLEARMSG(cmd);
           break;
          case 'CLEARCHAT':
           await _CLEARCHAT(cmd);
           break;
          case 'RECONNECT':
           _RECONNECT();
           return;
         }
        }
       }

       async function _PING(cmd)
       {
        if (_ws.readyState === 1)
         _ws.send('PONG ' + cmd.params[0]);
        if (!twitch.net.oAuth.hasRefresh)
         return;
        await twitch.net.oAuth.update();
        if (!twitch.net.oAuth.hasLogin)
         notice.error(notice.Type.TWITCH_TOKEN);
       }

       async function _PRIVMSG(cmd)
       {
        if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('user-id') && cmd.tags.hasOwnProperty('id'))
        {
         if (!_msgHistory.hasOwnProperty(cmd.tags['user-id']))
          _msgHistory[cmd.tags['user-id']] = new Set();
         _msgHistory[cmd.tags['user-id']].add(cmd.tags.id);
        }
        if (document.visibilityState === 'hidden')
         return;
        if (!cfg.twitch.sharedChat && cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('source-room-id') && cmd.tags.hasOwnProperty('room-id') && cmd.tags['room-id'] !== cmd.tags['source-room-id'])
         return;
        if (cmd.params.length > 1)
         cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d');
        if (await _parse.event.cheer(cmd))
         return;
        _parse.line(cmd);
       }

       async function _NOTICE(cmd)
       {
        if (cmd.params.length < 2)
         return false;
        if (cmd.params[1] !== 'Login authentication failed')
         return false;
        if (_tExpire !== false)
        {
         window.clearTimeout(_tExpire);
         _tExpire = false;
        }
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        if (await twitch.net.oAuth.reinit())
        {
         window.setTimeout(twitch.net.irc, 1000);
         return true;
        }
        twitch.net.dead = true;
        notice.error(notice.Type.TWITCH_TOKEN);
        if (!loginT.inUse)
         twitch.net.oAuth.clear();
        return false;
       }

       async function _ROOMSTATE(cmd)
       {
        if (!cmd.hasOwnProperty('tags'))
         return;
        if (!cmd.tags.hasOwnProperty('room-id'))
         return;
        const newID = twitch.net.channelID !== cmd.tags['room-id'];
        twitch.net.channelID = cmd.tags['room-id'];
        if (!_firstRS)
         return;
        if (_tExpire !== false)
        {
         window.clearTimeout(_tExpire);
         _tExpire = false;
        }
        _firstRS = false;
        if (!newID)
         return;
        await _loadEmote_channel(twitch.net.channelID);
        await _loadCheer_channel(twitch.net.channelID);
        if (!!cfg.event.twitch.tag && !!cfg.event.twitch.tag.styles)
         await _getChannelTitleTags(twitch.net.channelID);
        if (cfg.display.extended.useFFZ)
         thirdparty.ffz.channel('twitch', twitch.net.channelID);
        if (cfg.display.extended.useBTTV)
        {
         thirdparty.bttv.channel('twitch', twitch.net.channelID);
         thirdparty.bttv.socket.join('twitch', twitch.net.channelID);
        }
        if (cfg.display.extended.use7TV)
        {
         thirdparty['7tv'].channel('twitch', twitch.net.channelID);
         await thirdparty['7tv'].socketEx.join('twitch', twitch.net.channelID);
        }
        if (cfg.display.extended.useFFZ | cfg.display.extended.use7TV)
         thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval);
        if (cfg.display.extended.useBTTV)
         thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, thirdparty.interval);
        _eventSub(twitch.net.channelID);
       }

       function _USERNOTICE(cmd)
       {
        if (document.visibilityState === 'hidden')
         return;
        if (!cmd.hasOwnProperty('tags'))
         return;
        if (!cfg.twitch.sharedChat && cmd.tags.hasOwnProperty('source-room-id') && cmd.tags.hasOwnProperty('room-id') && cmd.tags['room-id'] !== cmd.tags['source-room-id'])
         return;
        if (!cmd.tags.hasOwnProperty('msg-id'))
         return;
        if (cmd.params.length > 1)
         cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d');
        switch (cmd.tags['msg-id'])
        {
         case 'raid':
          _parse.event.raid(cmd);
          break;
         case 'sub':
         case 'resub':
         case 'subgift':
         case 'submysterygift':
         case 'giftpaidupgrade':
         case 'primepaidupgrade':
          _parse.event.sub(cmd);
          break;
         case 'bitsbadgetier':
          _parse.event.badge(cmd);
          break;
         default:
          if (cmd.params.length > 1)
           _parse.line(cmd);
          break;
        }
       }

       function _CLEARMSG(cmd)
       {
        if (!cmd.tags.hasOwnProperty('target-msg-id'))
         return;
        for (const uID in _msgHistory)
        {
         if (!_msgHistory.hasOwnProperty(uID))
          continue;
         if (!_msgHistory[uID].has(cmd.tags['target-msg-id']))
          continue;
         _msgHistory[uID].delete(cmd.tags['target-msg-id']);
         break;
        }
        const mID = 'twitch:' + cmd.tags['target-msg-id'];
        display.eraseMsg(mID);
       }

       async function _CLEARCHAT(cmd)
       {
        switch (cmd.params.length)
        {
         case 1:
          _msgHistory = {};
          if (cfg.event.twitch.hasOwnProperty('clear') && cfg.event.twitch.clear)
           display.eraseAll();
          break;
         case 2:
          if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('target-user-id') && _msgHistory.hasOwnProperty(cmd.tags['target-user-id']))
          {
           for (const mID of _msgHistory[cmd.tags['target-user-id']])
           {
            display.eraseMsg('twitch:' + mID);
           }
           delete _msgHistory[cmd.tags['target-user-id']];
          }
          if (document.visibilityState === 'hidden')
           return;
          if (cmd.tags.hasOwnProperty('ban-duration'))
           await _parse.event.timeout(cmd);
          else
           await _parse.event.ban(cmd);
          break;
        }
       }

       function _RECONNECT()
       {
        if (_tExpire !== false)
        {
         window.clearTimeout(_tExpire);
         _tExpire = false;
        }
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        if (twitch.net.dead === true)
         return;
        window.setTimeout(twitch.net.irc, 1000);
       }

       return $c_wsMessage;
      }();

      function _wsExpire()
      {
       notice.error(notice.Type.TWITCH_IRC);
       notice.active &= ~notice.Connection.TWITCH_IRC;
       notice.resetHide();
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_ws === null)
        return;
       if (twitch.net.dead === true)
        return;
       twitch.net.dead = true;
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       _ws.close();
       _ws = null;
      }

      function _wsPing()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send('PING');
      }

      function _wsTimeout()
      {
       notice.error(notice.Type.TWITCH_IRC);
       notice.active &= ~notice.Connection.TWITCH_IRC;
       notice.resetHide();
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (twitch.net.dead === true)
        return;
       twitch.net.irc();
      }

      return $c_irc;
     }();

     async function _loadEmote_channel(chID)
     {
      if (!service.emotes.hasOwnProperty('twitch'))
       service.emotes.twitch = {};
      const r = await _findEmote_channel(chID, service.emotes.twitch);
      if (r.length === 0)
       return false;
      if (service.cList.length === 0)
       service.cList = r;
      else
      {
       for (const n in service.emotes.twitch)
       {
        if (!service.emotes.twitch[n].hasOwnProperty('scope'))
         continue;
        if (service.emotes.twitch[n].scope !== cSources.scope.channel)
         continue;
        for (let c = service.cList.length - 1; c >= 0; c--)
        {
         if (service.cList[c].url !== service.emotes.twitch[n].url)
          continue;
         service.cList.splice(c, 1);
         break;
        }
       }
       for (let i = 0, l = r.length; i < l; i++)
       {
        if (!service.cList.includes(r[i]))
         service.cList.push(r[i]);
       }
      }
      service.syncList();
      return true;
     }

     async function $userInfo(u, isID = false)
     {
      let url = cURLs.api.twitch.users.name.replaceAll(cVARs.url.user, u);
      if (isID)
       url = cURLs.api.twitch.users.id.replaceAll(cVARs.url.userID, u);
      const r = await shared.httpRequest('GET', url, twitch.net.oAuth.headers());
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('data'))
       return false;
      if (j.data.length !== 1)
       return false;
      return j.data[0];
     }

     async function _getChannelTitleTags(chID)
     {
      const url = cURLs.api.twitch.channels.root.replaceAll(cVARs.url.channelID, chID);
      const r = await shared.httpRequest('GET', url, twitch.net.oAuth.headers());
      if (!r.success)
       return;
      const j = r.json;
      if (j === null)
       return;
      if (!j.hasOwnProperty('data'))
       return;
      if (j.data.length !== 1)
       return;
      if (!j.data[0].hasOwnProperty('title'))
       return;
      await _addToChannelTitleTags(j.data[0].title);
     }

     async function _addToChannelTitleTags(title)
     {
      const tReg = /(?:^| )(?:@([A-Za-z0-9_]+))/g;
      const tList = [];
      let match = null;
      while ((match = tReg.exec(title)) !== null)
      {
       tList.push(match);
      }
      if (tList.length === 0)
       return;
      _aTagged = {};
      const pList = [];
      for (let i = 0, l = tList.length; i < l; i++)
      {
       if (tList[i][1].length === 0)
        continue;
       pList.push(twitch.net.userInfo(tList[i][1]));
      }
      const rList = await Promise.allSettled(pList);
      for (let i = 0, l = rList.length; i < l; i++)
      {
       if (rList[i].status !== 'fulfilled')
        continue;
       const u = rList[i].value;
       if (u === false)
        continue;
       if (!u.hasOwnProperty('id'))
        continue;
       if (!u.hasOwnProperty('login'))
        continue;
       _aTagged[u.login] = u.id;
      }
     }

     const $oAuth = function()
     {
      const _pathRefresh = '.refresh';

      async function $init()
      {
       if (cfg.twitch.hasOwnProperty('oauth_refresh') && cfg.twitch.oauth_refresh === null)
       {
        loginT.cfgHash = false;
        loginT.inUse = false;
        _populateAuth();
        return;
       }
       if (cfg.twitch.hasOwnProperty('oauth') && cfg.twitch.oauth !== null && cfg.twitch.oauth !== false && cfg.twitch.oauth !== 'OAUTH_ID')
       {
        loginT.inUse = false;
        loginT.cfgHash = shared.hashCode(cfg.twitch.oauth);
        await _genAccess(cfg.twitch.oauth);
        return;
       }
       if (cfg.twitch.hasOwnProperty('oauth_refresh') && cfg.twitch.oauth_refresh !== null && cfg.twitch.oauth_refresh !== false && cfg.twitch.oauth_refresh !== 'OAUTH_REFRESH')
       {
        loginT.inUse = false;
        let sRef = cfg.twitch.oauth_refresh;
        loginT.cfgHash = shared.hashCode(sRef);
        const lsRef = shared.storage.getItem(loginT.path() + _pathRefresh);
        if (lsRef !== null)
         sRef = lsRef;
        const sRet = await _genRefresh(sRef);
        if (sRet !== false)
         shared.storage.setItem(loginT.path() + _pathRefresh, sRet);
        else
         shared.storage.removeItem(loginT.path() + _pathRefresh);
        return;
       }
       loginT.inUse = true;
       loginT.cfgHash = false;
       const h = shared.getHashParams();
       if (h.hasOwnProperty('service') && h.service === 'twitch' && h.hasOwnProperty('oauth_refresh'))
       {
        const sHRet = await _genRefresh(h.oauth_refresh);
        if (sHRet !== false)
         shared.storage.setItem(loginT.path() + _pathRefresh, sHRet);
        else
         shared.storage.removeItem(loginT.path() + _pathRefresh);
        return;
       }
       const lsRefresh = shared.storage.getItem(loginT.path() + _pathRefresh);
       if (lsRefresh === null)
       {
        _populateAuth();
        return;
       }
       const sLRet = await _genRefresh(lsRefresh);
       if (sLRet !== false)
        shared.storage.setItem(loginT.path() + _pathRefresh, sLRet);
       else
        shared.storage.removeItem(loginT.path() + _pathRefresh);
      }

      async function _genAccess(a)
      {
       const oV = await _validate(a);
       if (oV === false)
       {
        _populateAuth();
        return false;
       }
       _populateAuth(a, false, oV);
       return a;
      }

      async function _genRefresh(r)
      {
       const oR = await _refresh(r);
       if (oR === false)
       {
        _populateAuth();
        return false;
       }
       const a = oR.access_token;
       const r2 = oR.refresh_token;
       const oV = await _validate(a);
       if (oV === false)
       {
        _populateAuth();
        return false;
       }
       _populateAuth(a, r2, oV);
       return r2;
      }

      function _populateAuth(a = null, r = null, j = null)
      {
       twitch.net.oAuth.auth.time = Date.now();
       if (a === null || r === null || j === null)
       {
        twitch.net.oAuth.auth.client_id = false;
        twitch.net.oAuth.auth.channel = false;
        twitch.net.oAuth.auth.scope = [];
        twitch.net.oAuth.auth.access_token = false;
        twitch.net.oAuth.auth.refresh_token = false;
        twitch.net.oAuth.auth.expires = 0;
        return;
       }
       twitch.net.oAuth.auth.client_id = j.client_id;
       twitch.net.oAuth.auth.channel = j.login;
       twitch.net.oAuth.auth.scope = j.scopes;
       twitch.net.oAuth.auth.access_token = a;
       twitch.net.oAuth.auth.refresh_token = r;
       twitch.net.oAuth.auth.expires = j.expires_in;
      }

      async function _refresh(t)
      {
       const url = cURLs.api.rr.refresh.t;
       let b = 'refresh=' + encodeURIComponent(t);
       if (cfg.twitch.share)
        b += '&share=1';
       const r = await shared.httpRequest('POST', url, {}, b, false);
       if (!r.success)
       {
        if (r.code === 401)
        {
         notice.error(notice.Type.TWITCH_TOKEN);
         twitch.net.oAuth.clear();
        }
        const eJ = r.json;
        if (eJ !== null && eJ.hasOwnProperty('message') && eJ.message === 'Invalid refresh token')
        {
         notice.error(notice.Type.TWITCH_TOKEN);
         twitch.net.oAuth.clear();
        }
        return false;
       }
       const j = r.json;
       if (j === null)
        return false;
       if (!j.hasOwnProperty('access_token'))
        return false;
       if (!j.hasOwnProperty('refresh_token'))
        return false;
       return j;
      }

      async function _validate(t)
      {
       const url = cURLs.api.twitch.validate;
       const h = {'Authorization': 'Bearer ' + t};
       const r = await shared.httpRequest('GET', url, h, null, false);
       if (!r.success)
       {
        if (r.code === 401)
        {
         notice.error(notice.Type.TWITCH_TOKEN);
         twitch.net.oAuth.clear();
        }
        return false;
       }
       const j = r.json;
       if (j === null)
        return false;
       if (!j.hasOwnProperty('client_id'))
        return false;
       if (!j.hasOwnProperty('login'))
        return false;
       if (!j.hasOwnProperty('scopes'))
        return false;
       if (!j.hasOwnProperty('expires_in'))
        return false;
       return j;
      }

      async function $update()
      {
       if (twitch.net.oAuth.auth.expires > 0)
       {
        const nowTime = Date.now();
        const exTime = twitch.net.oAuth.auth.time + (twitch.net.oAuth.auth.expires * 1000 * 0.75);
        if (nowTime < exTime)
         return;
       }
       const r = await _refresh(twitch.net.oAuth.auth.refresh_token);
       if (r === false)
       {
        _populateAuth();
        return;
       }
       const sAccess = r.access_token;
       const sRefresh = r.refresh_token;
       const v = await _validate(sAccess);
       if (v === false)
       {
        _populateAuth();
        return;
       }
       _populateAuth(sAccess, sRefresh, v);
       if (sRefresh !== twitch.net.oAuth.auth.refresh_token)
        shared.storage.setItem(loginT.path() + _pathRefresh, sRefresh);
      }

      async function $reinit()
      {
       if (!twitch.net.oAuth.hasRefresh)
        return false;
       twitch.net.oAuth.auth.expires = 0;
       await twitch.net.oAuth.update();
       if (twitch.net.oAuth.hasLogin)
        return true;
       twitch.net.oAuth.clear();
       return false;
      }

      function $clear()
      {
       _populateAuth();
       shared.storage.removeItem(loginT.path() + _pathRefresh);
      }

      function _cfgVals()
      {
       let r = 0;
       const lsRefresh = shared.storage.getItem(loginT.path() + _pathRefresh);
       if (lsRefresh !== null)
        r |= shared.cfgVal.REFRESH_TOKEN;
       if (twitch.net.oAuth.auth.refresh_token !== false)
        r |= shared.cfgVal.REFRESH_TOKEN;
       if (twitch.net.oAuth.auth.access_token !== false)
        r |= shared.cfgVal.ACCESS_TOKEN;
       return r;
      }

      function $headers(post = false)
      {
       const h = {
        'Authorization': 'Bearer ' + twitch.net.oAuth.auth.access_token,
        'Client-Id': twitch.net.oAuth.auth.client_id
       };
       if (post)
        h['Content-Type'] = 'application/json';
       return h;
      }

      return {
       init: $init,
       update: $update,
       reinit: $reinit,
       clear: $clear,
       get hasRefresh() {return (_cfgVals() & shared.cfgVal.REFRESH_TOKEN) === shared.cfgVal.REFRESH_TOKEN;},
       get hasLogin() {return (_cfgVals() & shared.cfgVal.ACCESS_TOKEN) === shared.cfgVal.ACCESS_TOKEN;},
       headers: $headers,
       auth: {
        client_id: false,
        channel: false,
        scope: [],
        access_token: false,
        refresh_token: false,
        time: 0,
        expires: 0
       }
      };
     }();

     return {
      channelID: 0,
      fList: {},
      dead: false,
      eventSubCtl: $eventSubCtl,
      irc: $irc,
      userInfo: $userInfo,
      oAuth: $oAuth
     };
    }();

    const _parse = function()
    {
     function _parseUser(cmd)
     {
      const ret = {
       id: 0,
       _slug: false,
       _name: false,
       ascii: false
      };
      if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('user-id'))
       ret.id = cmd.tags['user-id'];
      if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('display-name'))
       ret._name = cmd.tags['display-name'];
      if (cmd.hasOwnProperty('prefix'))
      {
       let data = cmd.prefix;
       if (data.includes('!'))
       {
        const nick = data.slice(0, data.indexOf('!'));
        if (!ret._slug)
         ret._slug = nick;
        data = data.slice(data.indexOf('!') + 1);
       }
       if (data.includes('@'))
       {
        const host = data.slice(0, data.indexOf('@'));
        if (!ret._slug)
         ret._slug = host;
        data = data.slice(data.indexOf('@') + 1);
       }
       if (data.slice(-14) === '.tmi.twitch.tv')
       {
        const user = data.slice(0, -14);
        if (!ret._slug)
         ret._slug = user;
       }
      }
      const gReg = new RegExp(service.parse.uReg, 'g');
      if (!!ret._name && ret._name === ret._name.replaceAll(gReg, ''))
       ret.ascii = ret._name;
      if (!ret.ascii && !!ret._slug)
       ret.ascii = ret._slug;
      if (!ret.ascii)
       ret.ascii = anonName;
      return ret;
     }

     function $message(line)
     {
      const cmd = {};
      if (line.slice(0, 1) === '@')
      {
       line = line.slice(1);
       if (!line.includes(' '))
        return false;
       cmd.tags = {};
       const t = line.slice(0, line.indexOf(' '));
       line = line.slice(line.indexOf(' ') + 1);
       const a = t.split(';');
       for (let i = 0, l = a.length; i < l; i++)
       {
        const k = a[i].slice(0, a[i].indexOf('='));
        const v = a[i].slice(a[i].indexOf('=') + 1).replaceAll(/\\s/g, ' ');
        cmd.tags[k] = v;
       }
      }
      if (line.slice(0, 1) === ':')
      {
       line = line.slice(1);
       if (!line.includes(' '))
        return false;
       cmd.prefix = line.slice(0, line.indexOf(' '));
       line = line.slice(line.indexOf(' ') + 1);
      }
      if (!line.includes(' '))
      {
       cmd.command = line;
       return cmd;
      }
      cmd.command = line.slice(0, line.indexOf(' '));
      line = line.slice(line.indexOf(' ') + 1);
      cmd.params = [];
      if (!line.includes(' '))
      {
       cmd.params.push(line);
       return cmd;
      }
      while (line.includes(' '))
      {
       if (line.slice(0, 1) === ':')
       {
        cmd.params.push(line.slice(1));
        return cmd;
       }
       cmd.params.push(line.slice(0, line.indexOf(' ')));
       line = line.slice(line.indexOf(' ') + 1);
      }
      if (line.slice(0, 1) === ':')
       line = line.slice(1);
      cmd.params.push(line);
      return cmd;
     }

     const $content = function()
     {
      function $emoji(cmd, dup = null)
      {
       if (cmd.params.length < 2)
        return [];
       const msg = cmd.params[1];
       return service.parse.content.emoji(msg, dup);
      }

      function $twitch(cmd, dup = null)
      {
       if (!cmd.hasOwnProperty('tags'))
        return [];
       if (!cmd.tags.hasOwnProperty('emotes'))
        return [];
       if (cmd.tags.emotes === '')
        return [];
       if (cmd.params.length < 2)
        return [];
       const m = cmd.params[1];
       const e = cmd.tags.emotes.split('/');
       if (dup === null)
        dup = cfg.display.duplicates;
       const ret = [];
       for (let i = 0, n = e.length; i < n; i++)
       {
        const eID = e[i].slice(0, e[i].indexOf(':'));
        const u = cURLs.cdn.twitch.emote.replaceAll(cVARs.url.emoteID, eID);
        const eVals = e[i].slice(e[i].indexOf(':') + 1).split(',');
        const eStart = parseInt(eVals[0].split('-')[0], 10);
        const eEnd = parseInt(eVals[0].split('-')[1], 10);
        const sName = m.slice(eStart, eEnd + 1);
        let sc = cSources.scope.channel;
        if (service.emotes.twitch.hasOwnProperty(sName) && service.emotes.twitch[sName].hasOwnProperty('scope'))
         sc = service.emotes.twitch[sName].scope;
        if (eID === '80393')
         sc = cSources.scope.user;
        let l = eVals.length;
        if (dup === false)
         l = 1;
        else if (dup !== true)
         l = Math.min(l, dup);
        for (let c = 0; c < l; c++)
        {
         const p = parseInt(eVals[c].split('-')[0], 10);
         ret.push({svc: cSources.service.twitch, url: u, str: sName, pos: p, scope: sc});
        }
       }
       return ret;
      }

      function $bits(cmd)
      {
       const p = [];
       if (!service.emotes.hasOwnProperty('cheer'))
        return p;
       if (cmd.tags.bits < 1)
        return p;
       const msg = cmd.params[1].split(' ');
       for (let m = 0, l = msg.length; m < l; m++)
       {
        for (const prefix in service.emotes.cheer)
        {
         if (!service.emotes.cheer.hasOwnProperty(prefix))
          continue;
         const firstChars = prefix.length;
         if (msg[m].slice(0, firstChars).toLowerCase() !== prefix.toLowerCase())
          continue;
         const amt = msg[m].slice(firstChars);
         if (!shared.nReg.i.test(amt))
          continue;
         let iP = 0;
         for (let j = 0; j < m; j++)
         {
          iP += msg[j].length + 1;
         }
         for (let i = 0, n = service.emotes.cheer[prefix].length; i < n; i++)
         {
          if (parseInt(amt, 10) < service.emotes.cheer[prefix][i].min)
           continue;
          const sName = prefix + service.emotes.cheer[prefix][i].min;
          p.push({svc: cSources.service.cheer, url: service.emotes.cheer[prefix][i].img, str: sName, pos: iP, scope: null});
          break;
         }
        }
       }
       return p;
      }

      const $3rdparty = function()
      {
       const $ffz = function()
       {
        function $general(cmd, dup = null)
        {
         if (cmd.params.length < 2)
          return [];
         let chID = twitch.net.channelID;
         if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('room-id'))
          chID = cmd.tags['room-id'];
         return service.parse.content['3rdparty'].ffz.general(cmd.params[1], 'twitch:' + chID, dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         if (cmd.params.length < 2)
          return;
         let chID = twitch.net.channelID;
         if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('room-id'))
          chID = cmd.tags['room-id'];
         const u = _parseUser(cmd);
         if (u.id === 0)
          return;
         service.parse.content['3rdparty'].ffz.zwe(l, 'twitch:' + u.id, 'twitch:' + chID, cmd.params[1], pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          if (cmd.params.length < 2)
           return [];
          const u = _parseUser(cmd);
          if (u.id === 0)
           return [];
          return service.parse.content['3rdparty'].ffz.user.general('twitch:' + u.id, cmd.params[1], dup);
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          if (cmd.params.length < 2)
           return;
          const u = _parseUser(cmd);
          if (u.id === 0)
           return;
          service.parse.content['3rdparty'].ffz.user.zwe(l, 'twitch:' + u.id, cmd.params[1], pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $bttv = function()
       {
        function $general(cmd, dup = null)
        {
         if (cmd.params.length < 2)
          return [];
         let chID = twitch.net.channelID;
         if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('room-id'))
          chID = cmd.tags['room-id'];
         return service.parse.content['3rdparty'].bttv.general(cmd.params[1], 'twitch:' + chID, dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         if (cmd.params.length < 2)
          return;
         let chID = twitch.net.channelID;
         if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('room-id'))
          chID = cmd.tags['room-id'];
         const u = _parseUser(cmd);
         if (u.id === 0)
          return;
         service.parse.content['3rdparty'].bttv.zwe(l, 'twitch:' + u.id, 'twitch:' + chID, cmd.params[1], pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          if (cmd.params.length < 2)
           return [];
          const u = _parseUser(cmd);
          if (u.id === 0)
           return [];
          return service.parse.content['3rdparty'].bttv.user.general('twitch:' + u.id, cmd.params[1], dup);
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          if (cmd.params.length < 2)
           return;
          const u = _parseUser(cmd);
          if (u.id === 0)
           return;
          service.parse.content['3rdparty'].bttv.user.zwe(l, 'twitch:' + u.id, cmd.params[1], pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $7tv = function()
       {
        function $general(cmd, dup = null)
        {
         if (cmd.params.length < 2)
          return [];
         let chID = twitch.net.channelID;
         if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('room-id'))
          chID = cmd.tags['room-id'];
         return service.parse.content['3rdparty']['7tv'].general(cmd.params[1], 'twitch:' + chID, dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         if (cmd.params.length < 2)
          return;
         let chID = twitch.net.channelID;
         if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('room-id'))
          chID = cmd.tags['room-id'];
         const u = _parseUser(cmd);
         if (u.id === 0)
          return;
         service.parse.content['3rdparty']['7tv'].zwe(l, 'twitch:' + u.id, 'twitch:' + chID, cmd.params[1], pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          if (cmd.params.length < 2)
           return [];
          const u = _parseUser(cmd);
          if (u.id === 0)
           return [];
          return service.parse.content['3rdparty']['7tv'].user.general('twitch:' + u.id, cmd.params[1], dup);
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          if (cmd.params.length < 2)
           return;
          const u = _parseUser(cmd);
          if (u.id === 0)
           return;
          service.parse.content['3rdparty']['7tv'].user.zwe(l, 'twitch:' + u.id, cmd.params[1], pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       return {
        ffz: $ffz,
        bttv: $bttv,
        '7tv': $7tv
       };
      }();

      return {
       emoji: $emoji,
       twitch: $twitch,
       bits: $bits,
       '3rdparty': $3rdparty
      };
     }();

     const $line = function()
     {
      async function $c_line(cmd, andCheers = true)
      {
       const u = _parseUser(cmd);
       if (service.parse.ignored(u))
        return;
       if (_parsePowerUp(cmd))
        return;
       if (_parseHighlight(cmd))
        return;
       if (_parseCustomReward(cmd))
        return;
       if (cmd.params.length < 2)
        return;
       const lvChk = new _level(cmd);
       if (await _parseTaggedChannel(cmd, lvChk))
        return;
       if (await _parseCommand(cmd, lvChk))
        return;
       const p = _handleDuplicates(_eListFromCmd(cmd, null, andCheers));
       if (p.length === 0)
        return;
       if (!(await lvChk.check(cfg.display.access)))
        return;
       display.emote.addToShowList(p);
       display.emote.showEmotes();
      }

      const _parsePowerUp = function()
      {
       function $c_parse(cmd)
       {
        if (!cmd.hasOwnProperty('tags'))
         return false;
        if (!cmd.tags.hasOwnProperty('msg-id'))
         return false;
        const pwrID = cmd.tags['msg-id'];
        switch (pwrID)
        {
         case 'gigantified-emote-message': return _gigantified(cmd);
         case 'animated-message': return _animated(cmd);
        }
        return false;
       }

       function _gigantified(cmd)
       {
        if (!cfg.event.twitch.powerup)
         return false;
        if (!cfg.event.twitch.powerup.emote)
         return false;
        const a = _handleDuplicates(_eListFromCmd(cmd, true));
        if (a.length === 0)
         return false;
        const u = _parseUser(cmd);
        const g = a.pop();
        display.kappa.show([g], cfg.event.twitch.powerup.emote, {[cVARs.evt.user]: u.ascii});
        if (a.length === 0)
         return true;
        display.emote.addToShowList(a);
        display.emote.showEmotes();
        return true;
       }

       function _animated(cmd)
       {
        if (!cfg.event.twitch.powerup)
         return false;
        if (!cfg.event.twitch.powerup.message)
         return false;
        if (!cmd.hasOwnProperty('tags'))
         return false;
        if (!cmd.tags.hasOwnProperty('animation-id'))
         return false;
        const u = _parseUser(cmd);
        const a = _handleDuplicates(_eListFromCmd(cmd, true));
        const animID = cmd.tags['animation-id'];
        switch (animID)
        {
         case 'simmer':
          if (!cfg.event.twitch.powerup.message.simmer)
           return false;
          display.kappa.show(a, cfg.event.twitch.powerup.message.simmer, {[cVARs.evt.user]: u.ascii});
          return true;
         case 'rainbow-eclipse':
          if (!cfg.event.twitch.powerup.message.eclipse)
           return false;
          display.kappa.show(a, cfg.event.twitch.powerup.message.eclipse, {[cVARs.evt.user]: u.ascii});
          return true;
         case 'cosmic-abyss':
          if (!cfg.event.twitch.powerup.message.abyss)
           return false;
          display.kappa.show(a, cfg.event.twitch.powerup.message.abyss, {[cVARs.evt.user]: u.ascii});
          return true;
        }
        return false;
       }

       return $c_parse;
      }();

      function _parseHighlight(cmd)
      {
       if (!cfg.event.twitch.redeem)
        return false;
       if (!cfg.event.twitch.redeem.highlight)
        return false;
       if (!cmd.hasOwnProperty('tags'))
        return false;
       if (!cmd.tags.hasOwnProperty('msg-id') || cmd.tags['msg-id'] !== 'highlighted-message')
        return false;
       const p = _handleDuplicates(_eListFromCmd(cmd));
       if (p.length === 0)
        return false;
       display.kappa.show(p, cfg.event.twitch.redeem.highlight);
       return true;
      }

      function _parseCustomReward(cmd)
      {
       if (!cmd.hasOwnProperty('tags'))
        return false;
       if (!cmd.tags.hasOwnProperty('custom-reward-id'))
        return false;
       const lnID = cmd.tags['custom-reward-id'];
       if (!_rList.hasOwnProperty(lnID))
       {
        _rList[lnID] = {name: false, cmds: [cmd]};
        return true;
       }
       _rList[lnID].cmds.push(cmd);
       if (_rList[lnID].name === false)
        return true;
       while (_rList[lnID].cmds.length > 0)
       {
        _parse.event.redeem(_rList[lnID].name, _rList[lnID].cmds.shift());
       }
       return true;
      }

      async function _parseTaggedChannel(cmd, lvChk)
      {
       if (Object.keys(_aTagged).length === 0)
        return false;
       if (!cfg.event.twitch.tag)
        return false;
       if (!cfg.event.twitch.tag.styles)
        return false;
       const m = cmd.params[1];
       if (m.slice(0, 1) !== '@')
        return false;
       let uTagged = m.slice(1);
       if (uTagged.indexOf(' ') > -1)
        uTagged = uTagged.slice(0, uTagged.indexOf(' '));
       uTagged = uTagged.toLowerCase();
       if (!_aTagged.hasOwnProperty(uTagged))
        return false;
       const uID = _aTagged[uTagged];
       if (!cfg.event.twitch.tag.onReply && cmd.tags.hasOwnProperty('reply-parent-user-id') && uID === cmd.tags['reply-parent-user-id'])
        return false;
       let rq = cfg.display.kappa.access;
       if (cfg.event.twitch.tag.hasOwnProperty('access') && cfg.event.twitch.tag.access >= 0)
        rq = cfg.event.twitch.tag.access;
       if (!(await lvChk.check(rq)))
        return false;
       if (!cfg.event.twitch.tag.targetEmotes)
       {
        display.kappa.show(false, cfg.event.twitch.tag.styles, {[cVARs.evt.user]: uTagged});
        return true;
       }
       const e = await _findEmote_channel(uID);
       if (cfg.event.twitch.tag.targetExtendedEmotes)
       {
        e.push(...await _findFFZ_channel(uID));
        e.push(...await _findBTTV_channel(uID));
        e.push(...await _find7TV_channel(uID, cfg.event.twitch.tag.targetExtendedEmotes));
       }
       display.kappa.show(e, cfg.event.twitch.tag.styles, {[cVARs.evt.user]: uTagged});
       return true;
      }

      function _parseCommand(cmd, lvChk)
      {
       const m = cmd.params[1].toLowerCase();
       const a = _handleDuplicates(_eListFromCmd(cmd, true));
       let mID = false;
       if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('id'))
        mID = 'twitch:' + cmd.tags.id;
       return service.parse.line.parseCommand(m, lvChk, a, mID);
      }

      return $c_line;
     }();

     const $event = function()
     {
      async function $cheer(cmd)
      {
       if (!service.emotes.hasOwnProperty('cheer'))
        return false;
       if (!cfg.event.twitch.cheer)
        return false;
       if (!cfg.event.twitch.cheer.bits)
        return false;
       const u = _parseUser(cmd);
       if (service.parse.ignored(u))
        return false;
       if (!cmd.hasOwnProperty('tags'))
        return false;
       if (!cmd.tags.hasOwnProperty('bits'))
        return false;
       if (cmd.tags.bits < 1)
        return false;
       let p = [];
       if (cfg.event.twitch.cheer.useMsg)
       {
        const a = _eListFromCmd(cmd);
        p.push(...a);
       }
       else
       {
        const b = _parse.content.bits(cmd);
        p.push(...b);
        await _parse.line(cmd, false);
       }
       p = _handleDuplicates(p);
       if (p.length === 0)
        return false;
       const r = shared.findInMaybeRange(cfg.event.twitch.cheer.bits, cmd.tags.bits);
       if (r === false)
       {
        display.emote.addToShowList(p);
        display.emote.showEmotes();
        return true;
       }
       display.kappa.show(p, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: cmd.tags.bits});
       return true;
      }

      async function $raid(cmd)
      {
       if (!cfg.event.twitch.raid)
        return;
       if (!cfg.event.twitch.raid.raiders)
        return;
       if (!cmd.hasOwnProperty('tags'))
        return;
       if (!cmd.tags.hasOwnProperty('msg-param-viewerCount'))
        return;
       const c = cmd.tags['msg-param-viewerCount'];
       const r = shared.findInMaybeRange(cfg.event.twitch.raid.raiders, c);
       if (r === false)
        return;
       const u = _parseUser(cmd);
       if (service.parse.ignored(u))
        return;
       if (!cfg.event.twitch.raid.originEmotes || u.id === 0)
       {
        display.kappa.show(false, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: c});
        return;
       }
       const e = await _findEmote_channel(u.id);
       if (cfg.event.twitch.raid.originExtendedEmotes)
       {
        e.push(...await _findFFZ_channel(u.id));
        e.push(...await _findBTTV_channel(u.id));
        e.push(...await _find7TV_channel(u.id, cfg.event.twitch.raid.originExtendedEmotes));
       }
       display.kappa.show(e, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: c});
      }

      const $sub = function()
      {
       const _bList = {
        bombs: new Set(),
        bulk: new Set(),
        check: new Set()
       };
       let _tGC = null;

       async function $c_sub(cmd)
       {
        if (!cfg.event.twitch.sub)
         return;
        const subPlan = _parsePlan(cmd);
        if (subPlan === false)
         return;
        if (!cfg.event.twitch.sub[subPlan])
         return;
        if (!cmd.tags.hasOwnProperty('msg-id'))
         return;
        const mID = cmd.tags['msg-id'];
        let mpoi = false;
        if (cmd.tags.hasOwnProperty('msg-param-origin-id'))
         mpoi = cmd.tags['msg-param-origin-id'];
        const usesBomb = _usesBomb(subPlan);
        if (mpoi !== false && usesBomb)
        {
         if (_bList.bombs.has(mpoi))
          return;
         if (mID === 'subgift')
         {
          if (_bList.bulk.has(mpoi))
           return;
          if (_bList.check.has(mpoi))
          {
           _bList.bulk.add(mpoi);
           _bList.check.delete(mpoi);
           _resetGC();
           return;
          }
         }
        }
        let a = [];
        if (cmd.params.length > 1)
        {
         if (cfg.event.twitch.sub.useMsg)
          a = _eListFromCmd(cmd, true);
         else
          await _parse.line(cmd);
        }
        let mpm = 1;
        if (cmd.tags.hasOwnProperty('msg-param-months'))
         mpm = parseInt(cmd.tags['msg-param-months'], 10);
        let mpcm = 1;
        if (cmd.tags.hasOwnProperty('msg-param-cumulative-months'))
         mpcm = parseInt(cmd.tags['msg-param-cumulative-months'], 10);
        let mpmgc = 1;
        if (cmd.tags.hasOwnProperty('msg-param-mass-gift-count'))
         mpmgc = parseInt(cmd.tags['msg-param-mass-gift-count'], 10);
        const u = _parseUser(cmd);
        if (service.parse.ignored(u))
         return;
        if (cmd.tags.hasOwnProperty('login') && cfg.ignore.users !== false && cfg.ignore.users.includes(cmd.tags.login))
         return;
        let mprdn = anonName;
        if (cmd.tags.hasOwnProperty('msg-param-recipient-display-name'))
         mprdn = cmd.tags['msg-param-recipient-display-name'];
        if (mpoi !== false && usesBomb)
        {
         if (_bList.bombs.has(mpoi))
          return;
         if (mID === 'subgift')
         {
          if (_bList.bulk.has(mpoi))
           return;
          if (_bList.check.has(mpoi))
          {
           _bList.bulk.add(mpoi);
           _bList.check.delete(mpoi);
           _resetGC();
           return;
          }
          if (!cmd.tags.hasOwnProperty('msg-param-sender-count') || cmd.tags['msg-param-sender-count'] === '0')
          {
           _bList.check.add(mpoi);
           window.setTimeout(_show, 2000, mID, subPlan, mpoi, mpm, mpcm, mpmgc, u.ascii, mprdn, a);
           _resetGC();
           return;
          }
         }
        }
        _show(mID, subPlan, mpoi, mpm, mpcm, mpmgc, u.ascii, mprdn, a);
       }

       function _show(id, subPlan, mpoi, mpm, mpcm, mpmgc, dn, mprdn, a)
       {
        const usesBomb = _usesBomb(subPlan);
        if (mpoi !== false && usesBomb)
        {
         if (_bList.bombs.has(mpoi))
          return;
         if (id === 'subgift' && _bList.bulk.has(mpoi))
         {
          _resetGC();
          return;
         }
        }
        switch (id)
        {
         case 'sub':
          if (!cfg.event.twitch.sub[subPlan].first)
           return;
          display.kappa.show(a, cfg.event.twitch.sub[subPlan].first, {[cVARs.evt.user]: dn});
          break;
         case 'resub':
          if (!cfg.event.twitch.sub[subPlan].resub)
           return;
          const rs = shared.findInMaybeRange(cfg.event.twitch.sub[subPlan].resub, mpcm);
          if (rs === false)
           return;
          display.kappa.show(a, rs, {[cVARs.evt.user]: dn, [cVARs.evt.amount]: mpcm});
          break;
         case 'primepaidupgrade':
          if (!cfg.event.twitch.sub[subPlan].upgrade)
           return;
          if (!cfg.event.twitch.sub[subPlan].upgrade.prime)
           return;
          display.kappa.show(a, cfg.event.twitch.sub[subPlan].upgrade.prime, {[cVARs.evt.user]: dn});
          break;
         case 'giftpaidupgrade':
          if (!cfg.event.twitch.sub[subPlan].upgrade)
           return;
          if (!cfg.event.twitch.sub[subPlan].upgrade.gift)
           return;
          display.kappa.show(a, cfg.event.twitch.sub[subPlan].upgrade.gift, {[cVARs.evt.user]: dn});
          break;
         case 'subgift':
          if (!cfg.event.twitch.sub[subPlan].gift)
           return;
          if (mpm === 1)
          {
           if (!cfg.event.twitch.sub[subPlan].gift.first)
            return;
           display.kappa.show(a, cfg.event.twitch.sub[subPlan].gift.first, {[cVARs.evt.sender]: dn, [cVARs.evt.user]: mprdn});
           return;
          }
          if (!cfg.event.twitch.sub[subPlan].gift.resub)
           return;
          const gpr = shared.findInMaybeRange(cfg.event.twitch.sub[subPlan].gift.resub, mpm);
          if (gpr === false)
           return;
          display.kappa.show(a, gpr, {[cVARs.evt.sender]: dn, [cVARs.evt.user]: mprdn, [cVARs.evt.amount]: mpm});
          break;
         case 'submysterygift':
          if (!usesBomb)
           return;
          if (mpoi !== false)
          {
           _bList.bombs.add(mpoi);
           if (_bList.bulk.has(mpoi))
            _bList.bulk.delete(mpoi);
           if (_bList.check.has(mpoi))
            _bList.check.delete(mpoi);
           _resetGC();
          }
          const gpb = shared.findInMaybeRange(cfg.event.twitch.sub[subPlan].gift.bomb, mpmgc);
          if (gpb === false)
           return;
          display.kappa.show(a, gpb, {[cVARs.evt.sender]: dn, [cVARs.evt.amount]: mpmgc});
          break;
        }
       }

       function _parsePlan(c)
       {
        if (!c.tags.hasOwnProperty('msg-param-sub-plan'))
         return false;
        const p = c.tags['msg-param-sub-plan'];
        switch (p)
        {
         case '1000': return 't1';
         case '2000': return 't2';
         case '3000': return 't3';
         case 'Prime': return 'prime';
        }
        return false;
       }

       function _usesBomb(tier)
       {
        if (!cfg.event.twitch.sub[tier].gift)
         return false;
        return !!cfg.event.twitch.sub[tier].gift.bomb;
       }

       function _resetGC()
       {
        if (_tGC !== null)
        {
         window.clearTimeout(_tGC);
         _tGC = null;
        }
        _tGC = window.setTimeout(_tmrGC, 10000);
       }

       function _tmrGC()
       {
        if (_tGC === null)
         return;
        window.clearTimeout(_tGC);
        _tGC = null;
        _bList.check.clear();
        _bList.bulk.clear();
       }

       return $c_sub;
      }();

      function $badge(cmd)
      {
       if (!cfg.event.twitch.badge)
        return;
       const u = _parseUser(cmd);
       if (service.parse.ignored(u))
        return;
       if (!cmd.tags.hasOwnProperty('msg-param-threshold'))
        return;
       const c = cmd.tags['msg-param-threshold'];
       if (cfg.event.twitch.badge.hasOwnProperty(c) && cfg.event.twitch.badge[c] !== false)
       {
        display.kappa.show(false, cfg.event.twitch.badge[c], {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: c});
        return;
       }
       let closest = null;
       for (const b in cfg.event.twitch.badge)
       {
        if (!cfg.event.twitch.badge.hasOwnProperty(b))
         continue;
        if (closest === null)
        {
         closest = b;
         continue;
        }
        if (Math.abs(parseInt(closest, 10) - parseInt(c, 10)) > Math.abs(parseInt(b, 10) - parseInt(c, 10)))
         closest = b;
       }
       if (closest === null)
        return;
       if (cfg.event.twitch.badge[closest] === false)
        return;
       display.kappa.show(false, cfg.event.twitch.badge[closest], {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: c});
      }

      async function $ban(cmd)
      {
       if (!cfg.event.twitch.ban)
        return;
       const ln = cmd.params[1];
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(ln))
        return;
       let dn = ln;
       if (cmd.tags.hasOwnProperty('target-user-id'))
       {
        const r = await twitch.net.userInfo(cmd.tags['target-user-id'], true);
        if (r.hasOwnProperty('display_name'))
         dn = r.display_name;
       }
       display.kappa.show(false, cfg.event.twitch.ban, {[cVARs.evt.user]: dn});
      }

      async function $timeout(cmd)
      {
       if (!cfg.event.twitch.timeout)
        return;
       const ln = cmd.params[1];
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(ln))
        return;
       let dn = ln;
       if (cmd.tags.hasOwnProperty('target-user-id'))
       {
        const r = await twitch.net.userInfo(cmd.tags['target-user-id'], true);
        if (r.hasOwnProperty('display_name'))
         dn = r.display_name;
       }
       const dDur = cmd.tags['ban-duration'];
       const r = shared.findInMaybeRange(cfg.event.twitch.timeout, dDur);
       if (r === false)
        return;
       display.kappa.show(false, r, {[cVARs.evt.user]: dn, [cVARs.evt.amount]: dDur});
      }

      function $redeem(title, cmd)
      {
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('redeem'))
         continue;
        if (!k.redeem.includes(title))
         continue;
        const kC = k.styles;
        if (cmd === false)
        {
         display.kappa.show(false, kC);
         return;
        }
        const a = _handleDuplicates(_eListFromCmd(cmd, true));
        display.kappa.show(a, kC);
        return;
       }
      }

      function $random_emote(ev)
      {
       if (!cfg.event.twitch.redeem)
        return;
       if (!cfg.event.twitch.redeem.random_emote)
        return;
       if (!ev.hasOwnProperty('user_login'))
        return;
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(ev.user_login))
        return;
       if (!ev.reward.emote)
        return;
       if (!ev.reward.emote.hasOwnProperty('id'))
        return;
       if (!ev.reward.emote.hasOwnProperty('name'))
        return;
       const u = cURLs.cdn.twitch.emote.replaceAll(cVARs.url.emoteID, ev.reward.emote.id);
       const p = [];
       p.push({
        svc: cSources.service.twitch,
        url: u,
        str: ev.reward.emote.name,
        pos: 0,
        scope: cSources.scope.channel,
        timestamp: Date.now(),
        origin: 'twitch:' + ev.id
       });
       const sz = shared.ec.get(u);
       if (sz !== null)
       {
        p[0].width = sz.width;
        p[0].height = sz.height;
       }
       display.kappa.show(p, cfg.event.twitch.redeem.random_emote);
      }

      function $chosen_emote(ev)
      {
       if (!cfg.event.twitch.redeem)
        return;
       if (!cfg.event.twitch.redeem.chosen_emote)
        return;
       if (!ev.hasOwnProperty('user_login'))
        return;
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(ev.user_login))
        return;
       if (!ev.reward.emote)
        return;
       if (!ev.reward.emote.hasOwnProperty('id'))
        return;
       if (!ev.reward.emote.hasOwnProperty('name'))
        return;
       const u = cURLs.cdn.twitch.emote.replaceAll(cVARs.url.emoteID, ev.reward.emote.id);
       const p = [];
       p.push({
        svc: cSources.service.twitch,
        url: u,
        str: ev.reward.emote.name,
        pos: 0,
        scope: cSources.scope.channel,
        timestamp: Date.now(),
        origin: 'twitch:' + ev.id
       });
       const sz = shared.ec.get(u);
       if (sz !== null)
       {
        p[0].width = sz.width;
        p[0].height = sz.height;
       }
       display.kappa.show(p, cfg.event.twitch.redeem.chosen_emote);
      }

      function $modified_emote(ev)
      {
       if (!cfg.event.twitch.redeem)
        return;
       if (!cfg.event.twitch.redeem.modified_emote)
        return;
       if (!ev.hasOwnProperty('user_login'))
        return;
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(ev.user_login))
        return;
       if (!ev.reward.emote)
        return;
       if (!ev.reward.emote.hasOwnProperty('id'))
        return;
       if (!ev.reward.emote.hasOwnProperty('name'))
        return;
       const u = cURLs.cdn.twitch.emote.replaceAll(cVARs.url.emoteID, ev.reward.emote.id);
       const p = [];
       p.push({
        svc: cSources.service.twitch,
        url: u,
        str: ev.reward.emote.name,
        pos: 0,
        scope: cSources.scope.channel,
        timestamp: Date.now(),
        origin: 'twitch:' + ev.id
       });
       const sz = shared.ec.get(u);
       if (sz !== null)
       {
        p[0].width = sz.width;
        p[0].height = sz.height;
       }
       display.kappa.show(p, cfg.event.twitch.redeem.modified_emote);
      }

      function $follow(ev)
      {
       if (!cfg.event.twitch.follow)
        return;
       let uName = anonName;
       if (ev.user_login)
       {
        uName = ev.user_login;
        if (cfg.ignore.users !== false && cfg.ignore.users.includes(uName))
         return;
       }
       let dName = uName;
       if (ev.user_name)
        dName = ev.user_name;
       display.kappa.show(false, cfg.event.twitch.follow, {[cVARs.evt.user]: dName});
      }

      const $shoutout = function()
      {
       async function $create(ev)
       {
        if (!cfg.event.twitch.shoutout)
         return;
        if (!cfg.event.twitch.shoutout.create)
         return;
        if (!cfg.event.twitch.shoutout.create.styles)
         return;
        if (!ev.hasOwnProperty('to_broadcaster_user_name'))
         return;
        const uName = ev.to_broadcaster_user_name;
        if (!cfg.event.twitch.shoutout.create.targetEmotes)
        {
         display.kappa.show(false, cfg.event.twitch.shoutout.create.styles, {[cVARs.evt.user]: uName});
         return;
        }
        if (!ev.hasOwnProperty('to_broadcaster_user_id'))
         return;
        const uID = ev.to_broadcaster_user_id;
        const e = await _findEmote_channel(uID);
        if (cfg.event.twitch.shoutout.create.targetExtendedEmotes)
        {
         e.push(...await _findFFZ_channel(uID));
         e.push(...await _findBTTV_channel(uID));
         e.push(...await _find7TV_channel(uID, cfg.event.twitch.shoutout.create.targetExtendedEmotes));
        }
        display.kappa.show(e, cfg.event.twitch.shoutout.create.styles, {[cVARs.evt.user]: uName});
       }

       async function $receive(ev)
       {
        if (!cfg.event.twitch.shoutout)
         return;
        if (!cfg.event.twitch.shoutout.receive)
         return;
        if (!cfg.event.twitch.shoutout.receive.styles)
         return;
        if (!ev.hasOwnProperty('from_broadcaster_user_login'))
         return;
        let uName = ev.from_broadcaster_user_login;
        if (cfg.ignore.users !== false && cfg.ignore.users.includes(uName))
         return;
        if (ev.hasOwnProperty('from_broadcaster_user_name'))
         uName = ev.from_broadcaster_user_name;
        if (!cfg.event.twitch.shoutout.receive.originEmotes)
        {
         display.kappa.show(false, cfg.event.twitch.shoutout.receive.styles, {[cVARs.evt.user]: uName});
         return;
        }
        if (!ev.hasOwnProperty('from_broadcaster_user_id'))
         return;
        const uID = ev.from_broadcaster_user_id;
        const e = await _findEmote_channel(uID);
        if (cfg.event.twitch.shoutout.receive.originExtendedEmotes)
        {
         e.push(...await _findFFZ_channel(uID));
         e.push(...await _findBTTV_channel(uID));
         e.push(...await _find7TV_channel(uID, cfg.event.twitch.shoutout.receive.originExtendedEmotes));
        }
        display.kappa.show(e, cfg.event.twitch.shoutout.receive.styles, {[cVARs.evt.user]: uName});
       }

       return {
        create: $create,
        receive: $receive
       };
      }();

      const $train = function()
      {
       const $hype = function()
       {
        function $begin()
        {
         if (!cfg.event.twitch.hypetrain)
          return;
         if (!cfg.event.twitch.hypetrain.begin)
          return;
         display.kappa.show(false, cfg.event.twitch.hypetrain.begin);
        }

        function $end(ev)
        {
         if (!cfg.event.twitch.hypetrain)
          return;
         if (!cfg.event.twitch.hypetrain.success)
          return;
         const rs = shared.findInMaybeRange(cfg.event.twitch.hypetrain.success, ev.level - 1);
         if (rs === false)
          return;
         display.kappa.show(false, rs);
        }

        return {
         begin: $begin,
         end: $end
        };
       }();

       const $kappa = function()
       {
        function $begin()
        {
         if (!cfg.event.twitch.kappatrain)
          return;
         if (!cfg.event.twitch.kappatrain.begin)
          return;
         display.kappa.show(false, cfg.event.twitch.kappatrain.begin);
        }

        function $end(ev)
        {
         if (!cfg.event.twitch.kappatrain)
          return;
         if (!cfg.event.twitch.kappatrain.success)
          return;
         const rs = shared.findInMaybeRange(cfg.event.twitch.kappatrain.success, ev.level - 1);
         if (rs === false)
          return;
         display.kappa.show(false, rs);
        }

        return {
         begin: $begin,
         end: $end
        };
       }();

       const $treasure = function()
       {
        function $begin()
        {
         if (!cfg.event.twitch.treasuretrain)
          return;
         if (!cfg.event.twitch.treasuretrain.begin)
          return;
         display.kappa.show(false, cfg.event.twitch.treasuretrain.begin);
        }

        function $end(ev)
        {
         if (!cfg.event.twitch.treasuretrain)
          return;
         if (!cfg.event.twitch.treasuretrain.success)
          return;
         const rs = shared.findInMaybeRange(cfg.event.twitch.treasuretrain.success, ev.level - 1);
         if (rs === false)
          return;
         display.kappa.show(false, rs);
        }

        return {
         begin: $begin,
         end: $end
        };
       }();

       return {
        hype: $hype,
        kappa: $kappa,
        treasure: $treasure
       };
      }();

      const $poll = function()
      {
       function $begin(ev)
       {
        if (!cfg.event.twitch.poll)
         return;
        if (!cfg.event.twitch.poll.begin)
         return;
        if (!ev.hasOwnProperty('title'))
         return;
        display.kappa.show(false, cfg.event.twitch.poll.begin, {[cVARs.evt.title]: ev.title});
       }

       function $end(ev)
       {
        if (!cfg.event.twitch.poll)
         return;
        if (!cfg.event.twitch.poll.end)
         return;
        if (!ev.hasOwnProperty('title'))
         return;
        if (!ev.hasOwnProperty('choices'))
         return;
        let vPoll = 0;
        for (let i = 0, l = ev.choices.length; i < l; i++)
        {
         if (!ev.choices[i].hasOwnProperty('title'))
          continue;
         if (!ev.choices[i].hasOwnProperty('votes'))
          continue;
         vPoll = Math.max(vPoll, ev.choices[i].votes);
        }
        const rPoll = [];
        for (let i = 0, l = ev.choices.length; i < l; i++)
        {
         if (!ev.choices[i].hasOwnProperty('title'))
          continue;
         if (!ev.choices[i].hasOwnProperty('votes'))
          continue;
         if (ev.choices[i].votes === vPoll)
          rPoll.push(ev.choices[i].title);
        }
        let sPoll = 'None';
        if (rPoll.length > 0)
         sPoll = rPoll.join(' + ');
        display.kappa.show(false, cfg.event.twitch.poll.end, {[cVARs.evt.title]: ev.title, [cVARs.evt.result]: sPoll});
       }

       return {
        begin: $begin,
        end: $end
       };
      }();

      const $prediction = function()
      {
       function $begin(ev)
       {
        if (!cfg.event.twitch.prediction)
         return;
        if (!cfg.event.twitch.prediction.begin)
         return;
        if (!ev.hasOwnProperty('title'))
         return;
        display.kappa.show(false, cfg.event.twitch.prediction.begin, {[cVARs.evt.title]: ev.title});
       }

       function $end(ev)
       {
        if (!cfg.event.twitch.prediction)
         return;
        if (!cfg.event.twitch.prediction.resolved)
         return;
        if (!ev.hasOwnProperty('title'))
         return;
        if (!ev.hasOwnProperty('winning_outcome_id'))
         return;
        if (!ev.hasOwnProperty('outcomes'))
         return;
        let sPrediction = 'None';
        for (let i = 0, l = ev.outcomes.length; i < l; i++)
        {
         if (!ev.outcomes[i].hasOwnProperty('id'))
          continue;
         if (ev.outcomes[i].id !== ev.winning_outcome_id)
          continue;
         if (!ev.outcomes[i].hasOwnProperty('title'))
          continue;
         sPrediction = ev.outcomes[i].title;
         break;
        }
        display.kappa.show(false, cfg.event.twitch.prediction.resolved, {[cVARs.evt.title]: ev.title, [cVARs.evt.result]: sPrediction});
       }

       return {
        begin: $begin,
        end: $end
       };
      }();

      function $charity(ev)
      {
       if (!cfg.event.twitch.charity)
        return;
       if (!ev.hasOwnProperty('user_login'))
        return;
       let uName = ev.user_login;
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(uName))
        return;
       if (ev.hasOwnProperty('user_name'))
        uName = ev.user_name;
       if (!ev.hasOwnProperty('amount'))
        return;
       if (!ev.amount.hasOwnProperty('value'))
        return;
       if (!ev.amount.hasOwnProperty('decimal_places'))
        return;
       if (!ev.amount.hasOwnProperty('currency'))
        return;
       const dAmt = ev.amount.value / Math.pow(10, ev.decimal_places) + ' ' + ev.amount.currency;
       const rd = shared.findInMaybeRange(cfg.event.twitch.charity, ev.amount.value);
       if (rd === false)
        return;
       display.kappa.show(false, rd, {[cVARs.evt.user]: uName, [cVARs.evt.amount]: dAmt});
      }

      const $goal = function()
      {
       function $begin(ev)
       {
        if (!cfg.event.twitch.goal)
         return;
        if (!cfg.event.twitch.goal.begin)
         return;
        if (!ev.hasOwnProperty('type'))
         return;
        if (!ev.hasOwnProperty('description'))
         return;
        if (!ev.hasOwnProperty('target_amount'))
         return;
        display.kappa.show(false, cfg.event.twitch.goal.begin, {[cVARs.evt.title]: ev.description, [cVARs.evt.type]: _type(ev.type), [cVARs.evt.amount]: ev.target_amount});
       }

       function $end(ev)
       {
        if (!cfg.event.twitch.goal)
         return;
        if (!cfg.event.twitch.goal.achieved)
         return;
        if (!ev.hasOwnProperty('type'))
         return;
        if (!ev.hasOwnProperty('description'))
         return;
        if (!ev.hasOwnProperty('current_amount'))
         return;
        display.kappa.show(false, cfg.event.twitch.goal.achieved, {[cVARs.evt.title]: ev.description, [cVARs.evt.type]: _type(ev.type), [cVARs.evt.amount]: ev.current_amount});
       }

       function _type(t)
       {
        switch (t)
        {
         case 'follow': return 'Follows';
         case 'subscription':
         case 'subscription_count': return 'Subscriptions';
         case 'new_subscription':
         case 'new_subscription_count': return 'New Subscriptions';
         case 'new_bit': return 'Bits';
         case 'new_cheerer': return 'Cheerers';
        }
        return t.replace('_', ' ');
       }

       return {
        begin: $begin,
        end: $end
       };
      }();

      return {
       cheer: $cheer,
       raid: $raid,
       sub: $sub,
       badge: $badge,
       ban: $ban,
       timeout: $timeout,
       redeem: $redeem,
       random_emote: $random_emote,
       chosen_emote: $chosen_emote,
       modified_emote: $modified_emote,
       follow: $follow,
       shoutout: $shoutout,
       train: $train,
       poll: $poll,
       prediction: $prediction,
       charity: $charity,
       goal: $goal
      };
     }();

     class _level
     {
      constructor(cmd)
      {
       this.cmd = cmd;
       this.rFH = 3600000;
      }

      check(rq)
      {
       let r = twitch.Access.STRANGER;
       if (this.cmd.tags.hasOwnProperty('mod') && this.cmd.tags.mod === '1')
        r |= twitch.Access.MODERATOR;
       if (this.cmd.tags.hasOwnProperty('vip') && this.cmd.tags.vip === '1')
        r |= twitch.Access.VIP;
       if (this.cmd.tags.hasOwnProperty('badges'))
       {
        const badges = this.cmd.tags.badges.split(',');
        for (let i = 0, l = badges.length; i < l; i++)
        {
         const bData = _level._jSplit(badges[i], '/', 2);
         switch (bData[0])
         {
          case 'broadcaster':
           r |= twitch.Access.BROADCASTER;
           break;
          case 'moderator':
           r |= twitch.Access.MODERATOR;
           break;
          case 'vip':
           r |= twitch.Access.VIP;
           break;
          case 'artist-badge':
           r |= twitch.Access.ARTIST;
           break;
          case 'founder':
           r |= twitch.Access.FOUNDER;
           break;
          case 'bits':
           r |= twitch.Access.CHEERER;
           break;
          case 'subscriber':
           const badge = parseInt(bData[1], 10);
           if (badge < 2000)
            r |= twitch.Access.SUBSCRIBER_T1;
           else if (badge < 3000)
            r |= twitch.Access.SUBSCRIBER_T2;
           else
            r |= twitch.Access.SUBSCRIBER_T3;
           break;
         }
        }
       }
       if (this.cmd.tags.hasOwnProperty('bits') && this.cmd.tags.bits > 0)
        r |= twitch.Access.CHEERER;
       const accessSub = twitch.Access.SUBSCRIBER_T1 | twitch.Access.SUBSCRIBER_T2 | twitch.Access.SUBSCRIBER_T3;
       if ((r & twitch.Access.BROADCASTER) === twitch.Access.BROADCASTER && (r & accessSub) !== 0)
        r &= ~accessSub;
       if ((r & rq) !== 0)
        return true;
       if ((rq & twitch.Access.FOLLOWER) === 0)
        return false;
       /* api-heavy, only check if follower access is allowed and there's a chance it matters */
       const uID = this.cmd.tags['user-id'];
       const rID = this.cmd.tags['room-id'];
       return this._checkFollower(uID, rID);
      }

      async _checkFollower(uID, rID, retry = true)
      {
       if (twitch.net.fList.hasOwnProperty(uID))
       {
        const tDif = Date.now() - twitch.net.fList[uID].t;
        if (tDif < this.rFH)
         return twitch.net.fList[uID].value;
       }
       const url = cURLs.api.twitch.channels.followers.replaceAll(cVARs.url.userID, uID).replaceAll(cVARs.url.channelID, rID);
       const r = await shared.httpRequest('GET', url, twitch.net.oAuth.headers());
       if (!r.success)
       {
        if (r.code === 401)
        {
         if (retry && await twitch.net.oAuth.reinit())
          return this._checkFollower(uID, rID, false);
         notice.error(notice.Type.TWITCH_TOKEN);
         if (!loginT.inUse)
          twitch.net.oAuth.clear();
        }
        return false;
       }
       const j = r.json;
       if (j === null)
        return false;
       if (j.hasOwnProperty('data') && j.data.length > 0)
       {
        twitch.net.fList[uID] = {value: true, t: Date.now()};
        return true;
       }
       twitch.net.fList[uID] = {value: false, t: Date.now()};
       return false;
      }

      static _jSplit(s, sep, limit)
      {
       const arr = [];
       let v = '';
       for (let i = 0, l = s.length; i < l; i++)
       {
        if (arr.length < limit - 1)
        {
         if (s[i] === sep)
         {
          arr.push(v);
          v = '';
          continue;
         }
        }
        v += s[i];
       }
       if (v.length > 0)
        arr.push(v);
       return arr;
      }
     }

     function _handleDuplicates(a)
     {
      const lA = a.length;
      if (lA < 1)
       return a;
      const r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.url)
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.cheer)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === cSources.scope.user)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.twitch && a[i].scope === cSources.scope.channel)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let p = 0; p < cfg.display.extended.priority.length; p++)
      {
       for (let i = 0; i < lA; i++)
       {
        if (a[i].scope === cSources.scope.channel && a[i].svc === cSources.service[cfg.display.extended.priority[p]])
        {
         if (service.parse.notDupe(a[i], r))
          r.push(a[i]);
        }
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.twitch && a[i].scope === cSources.scope.global)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let p = 0; p < cfg.display.extended.priority.length; p++)
      {
       for (let i = 0; i < lA; i++)
       {
        if (a[i].scope === cSources.scope.global && a[i].svc === cSources.service[cfg.display.extended.priority[p]])
        {
         if (service.parse.notDupe(a[i], r))
          r.push(a[i]);
        }
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.emoji)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      return r;
     }

     function _eListFromCmd(cmd, dup = null, andCheers = true)
     {
      const r = [];
      const u = _parseUser(cmd);
      if (service.parse.ignored(u))
       return r;
      if (andCheers && cmd.tags.hasOwnProperty('bits') && cmd.tags.bits > 0)
       r.push(..._parse.content.bits(cmd));
      r.push(..._parse.content.twitch(cmd, dup));
      if (cfg.display.useEmoji)
       r.push(..._parse.content.emoji(cmd, dup));
      if (cfg.display.extended.useFFZ)
      {
       r.push(..._parse.content['3rdparty'].ffz.general(cmd, dup));
       r.push(..._parse.content['3rdparty'].ffz.user.general(cmd, dup));
      }
      if (cfg.display.extended.useBTTV)
      {
       r.push(..._parse.content['3rdparty'].bttv.general(cmd, dup));
       r.push(..._parse.content['3rdparty'].bttv.user.general(cmd, dup));
      }
      if (cfg.display.extended.use7TV)
      {
       r.push(..._parse.content['3rdparty']['7tv'].general(cmd, dup));
       r.push(..._parse.content['3rdparty']['7tv'].user.general(cmd, dup));
      }
      if (cfg.display.extended.useFFZ)
      {
       _parse.content['3rdparty'].ffz.zwe(r, cmd, 1, dup);
       _parse.content['3rdparty'].ffz.user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       _parse.content['3rdparty'].bttv.zwe(r, cmd, 1, dup);
       _parse.content['3rdparty'].bttv.user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.use7TV)
      {
       _parse.content['3rdparty']['7tv'].zwe(r, cmd, 1, dup);
       _parse.content['3rdparty']['7tv'].user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.useFFZ)
      {
       _parse.content['3rdparty'].ffz.zwe(r, cmd, 2, dup);
       _parse.content['3rdparty'].ffz.user.zwe(r, cmd, 2, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       _parse.content['3rdparty'].bttv.zwe(r, cmd, 2, dup);
       _parse.content['3rdparty'].bttv.user.zwe(r, cmd, 2, dup);
      }
      if (cfg.display.extended.use7TV)
      {
       _parse.content['3rdparty']['7tv'].zwe(r, cmd, 2, dup);
       _parse.content['3rdparty']['7tv'].user.zwe(r, cmd, 2, dup);
      }
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.length > 0)
      {
       for (let i = r.length - 1; i >= 0; i--)
       {
        const m = r[i].str;
        if (cfg.ignore.emotes.includes(m))
         r.splice(i, 1);
       }
      }
      const t = Date.now();
      for (let i = 0, l = r.length; i < l; i++)
      {
       r[i].timestamp = t;
       if (r[i].hasOwnProperty('width') || r[i].hasOwnProperty('height'))
        continue;
       if (!r[i].hasOwnProperty('url'))
        continue;
       const sz = shared.ec.get(r[i].url);
       if (sz === null)
        continue;
       r[i].width = sz.width;
       r[i].height = sz.height;
      }
      if (cmd.tags.hasOwnProperty('id'))
      {
       for (let i = 0, l = r.length; i < l; i++)
       {
        r[i].origin = 'twitch:' + cmd.tags.id;
       }
      }
      return r;
     }

     return {
      message: $message,
      content: $content,
      line: $line,
      event: $event
     };
    }();

    const _findEmote_channel = function()
    {
     const _rCH = 300000;
     const _chList = {};

     async function $c_findEmote_channel(chID, n = false, retry = true)
     {
      if (n === false && _chList.hasOwnProperty(chID))
      {
       const tDif = Date.now() - _chList[chID].t;
       if (tDif < _rCH)
        return _chList[chID].value;
      }
      const url = cURLs.api.twitch.chat.emotes.root.replaceAll(cVARs.url.channelID, chID);
      const r = await shared.httpRequest('GET', url, twitch.net.oAuth.headers());
      if (!r.success)
      {
       if (r.code === 401)
       {
        if (retry && await twitch.net.oAuth.reinit())
         return _findEmote_channel(chID, n, false);
        notice.error(notice.Type.TWITCH_TOKEN);
        if (!loginT.inUse)
         twitch.net.oAuth.clear();
       }
       return [];
      }
      const j = r.json;
      if (j === null)
       return [];
      if (!j.hasOwnProperty('data'))
       return [];
      if (!Array.isArray(j.data))
       return [];
      const ret = [];
      for (let i = 0, l = j.data.length; i < l; i++)
      {
       if (!j.data[i].hasOwnProperty('id'))
        continue;
       if (cfg.ignore.emotes !== false && j.data[i].hasOwnProperty('name') && cfg.ignore.emotes.includes(j.data[i].name))
        continue;
       const eURL = cURLs.cdn.twitch.emote.replaceAll(cVARs.url.emoteID, j.data[i].id);
       if (n !== false && j.data[i].hasOwnProperty('name'))
       {
        n[j.data[i].name] = {
         scope: cSources.scope.channel,
         url: eURL,
         id: j.data[i].id
        };
       }
       ret.push({url: eURL});
      }
      _chList[chID] = {t: Date.now(), value: ret};
      return ret;
     }

     return $c_findEmote_channel;
    }();

    async function _findFFZ_channel(chID)
    {
     if (!cfg.display.extended.useFFZ)
      return [];
     const rFFZ = await thirdparty.ffz.channelEx('twitch', chID);
     if (rFFZ === false)
      return [];
     const e = [];
     for (let i = 0, l = rFFZ.length; i < l; i++)
     {
      if (rFFZ[i].modifier !== false)
       continue;
      e.push({url: rFFZ[i].url, width: rFFZ[i].width, height: rFFZ[i].height});
     }
     return e;
    }

    async function _findBTTV_channel(chID)
    {
     if (!cfg.display.extended.useBTTV)
      return [];
     const rBTTV = await thirdparty.bttv.channelEx('twitch', chID);
     if (rBTTV === false)
      return [];
     const e = [];
     for (let i = 0, l = rBTTV.length; i < l; i++)
     {
      e.push({url: rBTTV[i].url, width: rBTTV[i].width, height: rBTTV[i].height});
     }
     return e;
    }

    async function _find7TV_channel(chID, cVal)
    {
     if (!cfg.display.extended.use7TV)
      return [];
     const r7TV = await thirdparty['7tv'].channelEx('twitch', chID, cVal === 'listed');
     if (r7TV === false)
      return [];
     const e = [];
     for (let i = 0, l = r7TV.length; i < l; i++)
     {
      if ((r7TV[i].vis & thirdparty['7tv'].Modifier.ZWE) === thirdparty['7tv'].Modifier.ZWE)
       continue;
      e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
     }
     return e;
    }

    async function $global(retry = true)
    {
     if (!service.emotes.hasOwnProperty('twitch'))
      service.emotes.twitch = {};
     const url = cURLs.api.twitch.chat.emotes.global;
     const r = await shared.httpRequest('GET', url, twitch.net.oAuth.headers());
     if (!r.success)
     {
      if (r.code === 401)
      {
       if (retry && await twitch.net.oAuth.reinit())
        return twitch.global(false);
       notice.error(notice.Type.TWITCH_TOKEN);
       if (!loginT.inUse)
        twitch.net.oAuth.clear();
      }
      return false;
     }
     const j = r.json;
     if (j === null)
      return false;
     if (!j.hasOwnProperty('data'))
      return false;
     if (!Array.isArray(j.data))
      return false;
     for (let i = 0, l = j.data.length; i < l; i++)
     {
      if (!j.data[i].hasOwnProperty('id'))
       continue;
      if (!j.data[i].hasOwnProperty('name'))
       continue;
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.includes(j.data[i].name))
       continue;
      service.emotes.twitch[j.data[i].name] = {
       scope: cSources.scope.global,
       url: cURLs.cdn.twitch.emote.replaceAll(cVARs.url.emoteID, j.data[i].id),
       id: j.data[i].id
      };
     }
     return true;
    }

    return {
     net: $net,
     global: $global,
     Access: Object.freeze({
      STRANGER: 0x001,
      FOLLOWER: 0x002,
      CHEERER: 0x004,
      SUBSCRIBER_T1: 0x010,
      SUBSCRIBER_T2: 0x020,
      SUBSCRIBER_T3: 0x040,
      ARTIST: 0x080,
      VIP: 0x100,
      FOUNDER: 0x200,
      MODERATOR: 0x400,
      BROADCASTER: 0x800
     })
    };
   }();

   const youtube = function()
   {
    const _eStickers = {};
    const _defCDN = 'yt3';
    let _bestCDN = _defCDN;

    const $net = function()
    {
     const $broadcasts = function()
     {
      const _aC = new Set();
      const _msgHistory = {};
      let  _tS = false;
      const _bcInterval = 30000;

      async function $updateStream()
      {
       if (_tS !== false)
       {
        window.clearTimeout(_tS);
        _tS = false;
       }
       const lStreams = await _getActiveStreams();
       if (lStreams === null)
       {
        notice.error(notice.Type.YOUTUBE_NETWORK);
        notice.active &= ~notice.Connection.YOUTUBE;
        notice.resetHide();
        return;
       }
       notice.info(notice.Type.YOUTUBE_NETWORK);
       notice.active |= notice.Connection.YOUTUBE;
       notice.resetHide();
       if (lStreams === false)
       {
        _tS = window.setTimeout(youtube.net.broadcasts.updateStream, _bcInterval);
        return;
       }
       let didSomething = false;
       for (let i = 0, l = lStreams.length; i < l; i++)
       {
        if (!youtube.net.channelIDs.includes(lStreams[i].channel))
        {
         youtube.net.channelIDs.push(lStreams[i].channel);
         await _loadEmote_channel(lStreams[i].channel);
         if (cfg.display.extended.useFFZ)
          thirdparty.ffz.channel('youtube', lStreams[i].channel);
         if (cfg.display.extended.useBTTV)
         {
          thirdparty.bttv.channel('youtube', lStreams[i].channel);
          thirdparty.bttv.socket.join('youtube', lStreams[i].channel);
         }
         if (cfg.display.extended.use7TV)
         {
          thirdparty['7tv'].channel('youtube', lStreams[i].channel);
          await thirdparty['7tv'].socketEx.join('youtube', lStreams[i].channel);
         }
         if (cfg.display.extended.useBTTV)
          thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, thirdparty.interval);
        }
        if (!_aC.has(lStreams[i].chat))
        {
         didSomething = true;
         _aC.add(lStreams[i].chat);
         window.setTimeout(youtube.net.broadcasts.getMessages.start, 48, lStreams[i]);
        }
       }
       if (didSomething && cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('recheck') && cfg.youtube.connect_to.recheck === false)
        return;
       _tS = window.setTimeout(youtube.net.broadcasts.updateStream, _bcInterval);
       const sC = lStreams.map(function(s){return s.chat;});
       for (const chat of _aC)
       {
        if (sC.includes(chat))
         continue;
        youtube.net.broadcasts.getMessages.stop(chat);
        _aC.delete(chat);
       }
      }

      async function _getActiveStreams()
      {
       if (youtube.net.oAuth.hasRefresh)
       {
        await youtube.net.oAuth.update();
        if (!youtube.net.oAuth.hasLogin)
        {
         notice.error(notice.Type.YOUTUBE_NETWORK);
         notice.error(notice.Type.YOUTUBE_TOKEN);
         youtube.net.dead = true;
         return null;
        }
       }
       if (!youtube.net.oAuth.hasLogin)
        return null;
       if (!youtube.net.oAuth.auth.scope.includes(cScopes.youtube.readonly))
       {
        notice.error(notice.Type.YOUTUBE_NETWORK);
        notice.error(notice.Type.YOUTUBE_TOKEN);
        youtube.net.dead = true;
        return null;
       }
       const r = await shared.httpRequest('GET', cURLs.api.youtube.broadcasts, youtube.net.oAuth.headers());
       const j = r.json;
       if (!r.success)
       {
        if (r.code === 0 && r.data === '')
        {
         if (_aC.size !== 0)
          return false;
         notice.error(notice.Type.YOUTUBE_CORS, 'current live streams');
         notice.active &= ~notice.Connection.YOUTUBE;
         notice.resetHide();
         return false;
        }
        if (r.code === 408 && r.data === shared.errTimeout)
         return false;
        if (j !== null)
        {
         const e = _flatJSON(j);
         if (e.hasOwnProperty('error.errors.0.reason'))
         {
          const er = e['error.errors.0.reason'];
          switch (er)
          {
           case 'liveStreamingNotEnabled':
            notice.error(notice.Type.YOUTUBE_NETWORK);
            notice.error(notice.Type.YOUTUBE_ACCOUNT);
            youtube.net.oAuth.clear(true);
            youtube.net.dead = true;
            return null;
           case 'SERVICE_UNAVAILABLE':
            if (_aC.size !== 0)
             return false;
            notice.error(notice.Type.YOUTUBE_NETWORK);
            notice.active &= ~notice.Connection.YOUTUBE;
            notice.resetHide();
            return false;
           case 'backendError':
            if (_aC.size !== 0)
             return false;
            notice.error(notice.Type.YOUTUBE_NETWORK);
            notice.active &= ~notice.Connection.YOUTUBE;
            notice.resetHide();
            return false;
           case 'authError':
            notice.error(notice.Type.YOUTUBE_NETWORK);
            notice.error(notice.Type.YOUTUBE_TOKEN);
            youtube.net.oAuth.clear(true);
            youtube.net.dead = true;
            return null;
          }
         }
        }
        notice.error(notice.Type.YOUTUBE_UNKNOWN, 'Error Getting Streams: ' + r.code);
        return null;
       }
       if (j === null)
        return false;
       if (!j.hasOwnProperty('pageInfo'))
        return false;
       if (!j.pageInfo.hasOwnProperty('totalResults'))
        return false;
       if (j.pageInfo.totalResults < 1)
        return false;
       if (!j.hasOwnProperty('items'))
        return false;
       if (!Array.isArray(j.items))
        return false;
       const lcList = [];
       if (cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('title') && cfg.youtube.connect_to.title !== false && cfg.youtube.connect_to.title !== '')
       {
        for (let i = 0, l = j.items.length; i < l; i++)
        {
         if (!j.items[i].hasOwnProperty('id'))
          continue;
         if (!j.items[i].hasOwnProperty('snippet'))
          continue;
         if (!j.items[i].snippet.hasOwnProperty('liveChatId'))
          continue;
         if (!j.items[i].snippet.hasOwnProperty('channelId'))
          continue;
         if (!j.items[i].snippet.hasOwnProperty('title'))
          continue;
         if (j.items[i].snippet.title === '')
          continue;
         const sTitle = j.items[i].snippet.title;
         if (sTitle.toLowerCase() !== cfg.youtube.connect_to.title.toLowerCase())
          continue;
         let nPublished = false;
         if (j.items[i].snippet.hasOwnProperty('publishedAt') && j.items[i].snippet.publishedAt !== '')
          nPublished = new Date(j.items[i].snippet.publishedAt).getTime();
         let nStarted = false;
         if (j.items[i].snippet.hasOwnProperty('actualStartTime') && j.items[i].snippet.actualStartTime !== '')
          nStarted = new Date(j.items[i].snippet.actualStartTime).getTime();
         let sDesc = false;
         if (j.items[i].snippet.hasOwnProperty('description') && j.items[i].snippet.description !== '')
          sDesc = j.items[i].snippet.description;
         lcList.push({channel: j.items[i].snippet.channelId, chat: j.items[i].snippet.liveChatId, publishedAt: nPublished, actualStartTime: nStarted, title: sTitle, description: sDesc});
        }
        lcList.sort(_ytSort);
        if (cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('max') && Number.isInteger(cfg.youtube.connect_to.max) && cfg.youtube.connect_to.max > 0 && lcList.length > cfg.youtube.connect_to.max)
         lcList.length = cfg.youtube.connect_to.max;
        return lcList;
       }
       for (let i = 0, l = j.items.length; i < l; i++)
       {
        if (!j.items[i].hasOwnProperty('id'))
         continue;
        if (!j.items[i].hasOwnProperty('snippet'))
         continue;
        if (!j.items[i].snippet.hasOwnProperty('liveChatId'))
         continue;
        if (!j.items[i].snippet.hasOwnProperty('channelId'))
         continue;
        if (j.items[i].hasOwnProperty('status') && j.items[i].status.hasOwnProperty('lifeCycleStatus') && cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('list') && Array.isArray(cfg.youtube.connect_to.list) && cfg.youtube.connect_to.list.length > 0 && !cfg.youtube.connect_to.list.includes(j.items[i].status.lifeCycleStatus))
         continue;
        let nPublished = false;
        if (j.items[i].snippet.hasOwnProperty('publishedAt') && j.items[i].snippet.publishedAt !== '')
         nPublished = new Date(j.items[i].snippet.publishedAt).getTime();
        let nStarted = false;
        if (j.items[i].snippet.hasOwnProperty('actualStartTime') && j.items[i].snippet.actualStartTime !== '')
         nStarted = new Date(j.items[i].snippet.actualStartTime).getTime();
        let sTitle = false;
        if (j.items[i].snippet.hasOwnProperty('title') && j.items[i].snippet.title !== '')
         sTitle = j.items[i].snippet.title;
        let sDesc = false;
        if (j.items[i].snippet.hasOwnProperty('description') && j.items[i].snippet.description !== '')
         sDesc = j.items[i].snippet.description;
        lcList.push({channel: j.items[i].snippet.channelId, chat: j.items[i].snippet.liveChatId, publishedAt: nPublished, actualStartTime: nStarted, title: sTitle, description: sDesc});
       }
       lcList.sort(_ytSort);
       if (cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('max') && Number.isInteger(cfg.youtube.connect_to.max) && cfg.youtube.connect_to.max > 0 && lcList.length > cfg.youtube.connect_to.max)
        lcList.length = cfg.youtube.connect_to.max;
       return lcList;
      }

      function _ytSort(a, b)
      {
       let sortOrder = {
        'actualStartTime': 'desc',
        'publishedAt': 'desc'
       };
       if (cfg.youtube.hasOwnProperty('connect_to') && cfg.youtube.connect_to.hasOwnProperty('sort') && typeof cfg.youtube.connect_to.sort === 'object' && cfg.youtube.connect_to.sort !== null && Object.keys(cfg.youtube.connect_to.sort).length > 0)
        sortOrder = cfg.youtube.connect_to.sort;
       const sortMap = new Map(Object.entries(sortOrder));
       for (const [attr, order] of sortMap)
       {
        const chooseA = order === 'asc' ? 1 : -1;
        const chooseB = -1 * chooseA;
        if (!a.hasOwnProperty(attr))
         return chooseB;
        if (!b.hasOwnProperty(attr))
         return chooseA;
        const aA = a[attr];
        const aB = b[attr];
        if (aA === aB)
         continue;
        if (aA === false)
         return chooseB;
        if (aB === false)
         return chooseA;
        if (!shared.nReg.f.test(aA) || !shared.nReg.f.test(aB))
        {
         const cmp = aA.localeCompare(aB);
         if (cmp === 0)
          continue;
         if (cmp < 0)
          return chooseA;
         return chooseB;
        }
        if (aA > aB)
         return chooseA;
        return chooseB;
       }
       return 0;
      }

      const $getMessages = function()
      {
       const _tM = {};
       let _bSlower = 0;
       const _mInterval = 1000;
       const _mStep = 1000;
       const _mWait = 4000;
       const _mLimit = 15000 - _mInterval;
       let _tInit = false;

       async function $start(stream, page = false)
       {
        const chatID = stream.chat;
        if (_tM.hasOwnProperty(chatID) && _tM[chatID] !== false)
         window.clearTimeout(_tM[chatID]);
        _tM[chatID] = false;
        if (youtube.net.dead)
         return;
        if (youtube.net.oAuth.hasRefresh)
        {
         await youtube.net.oAuth.update();
         if (!youtube.net.oAuth.hasLogin)
         {
          notice.error(notice.Type.YOUTUBE_NETWORK);
          notice.error(notice.Type.YOUTUBE_TOKEN);
          youtube.net.dead = true;
          notice.active &= ~notice.Connection.YOUTUBE;
          notice.resetHide();
          return;
         }
        }
        if (!youtube.net.oAuth.hasLogin)
         return;
        if (!youtube.net.oAuth.auth.scope.includes(cScopes.youtube.readonly))
        {
         notice.error(notice.Type.YOUTUBE_NETWORK);
         notice.error(notice.Type.YOUTUBE_TOKEN);
         notice.active &= ~notice.Connection.YOUTUBE;
         youtube.net.dead = true;
         notice.resetHide();
         return;
        }
        let q = cURLs.api.youtube.livechat.messages.init;
        if (page !== false)
        {
         q = cURLs.api.youtube.livechat.messages.page;
         q = q.replaceAll(cVARs.url.page, encodeURIComponent(page));
        }
        q = q.replaceAll(cVARs.url.chatID, encodeURIComponent(chatID));
        q = q.replaceAll(cVARs.url.part, encodeURIComponent('snippet,authorDetails'));
        const r = await shared.httpRequest('GET', q, youtube.net.oAuth.headers());
        const j = r.json;
        if (!r.success)
        {
         if (r.code === 0 && r.data === '')
         {
          if (page !== false)
          {
           if (!_tM.hasOwnProperty(chatID))
            return;
           const cWait = _mWait + _bSlower;
           _tM[chatID] = window.setTimeout(youtube.net.broadcasts.getMessages.start, cWait, stream);
           return;
          }
          notice.error(notice.Type.YOUTUBE_CORS, 'live chat');
          notice.active &= ~notice.Connection.YOUTUBE;
          notice.resetHide();
          return;
         }
         if (r.code === 408 && r.data === shared.errTimeout)
         {
          if (!_tM.hasOwnProperty(chatID))
           return;
          const tWait = _mWait + _bSlower;
          _tM[chatID] = window.setTimeout(youtube.net.broadcasts.getMessages.start, tWait, stream);
          return;
         }
         if (r.code === 404)
         {
          notice.info(notice.Type.YOUTUBE_NETWORK);
          youtube.net.broadcasts.updateStream();
          return;
         }
         if (j !== null)
         {
          const e = _flatJSON(j);
          if (e.hasOwnProperty('error.errors.0.reason'))
          {
           const er = e['error.errors.0.reason'];
           switch (er)
           {
            case 'quotaExceeded':
             notice.error(notice.Type.YOUTUBE_RATELIMIT);
             return;
            case 'liveChatEnded':
            case 'liveChatDisabled':
            case 'liveChatNotFound':
             _aC.delete(chatID);
             youtube.net.broadcasts.getMessages.stop(chatID);
             return;
            case 'rateLimitExceeded':
             _bSlower += _mStep;
             if (_bSlower > _mLimit)
             {
              _bSlower = _mLimit;
              notice.error(notice.Type.YOUTUBE_RATELIMIT);
             }
             if (!_tM.hasOwnProperty(chatID))
              return;
             const tWait = _mWait + _bSlower;
             _tM[chatID] = window.setTimeout(youtube.net.broadcasts.getMessages.start, tWait, stream);
             return;
            case 'backendError':
             if (!_tM.hasOwnProperty(chatID))
              return;
             const rWait = _mWait + _bSlower;
             _tM[chatID] = window.setTimeout(youtube.net.broadcasts.getMessages.start, rWait, stream);
             return;
           }
          }
         }
         if (page !== false)
         {
          if (!_tM.hasOwnProperty(chatID))
           return;
          const eWait = _mWait + _bSlower;
          _tM[chatID] = window.setTimeout(youtube.net.broadcasts.getMessages.start, eWait, stream);
          return;
         }
         notice.error(notice.Type.YOUTUBE_NETWORK);
         notice.active &= ~notice.Connection.YOUTUBE;
         notice.resetHide();
         notice.error(notice.Type.YOUTUBE_UNKNOWN, 'Error Getting Messages: ' + r.code);
         return;
        }
        if (j === null)
         return;
        if (page === false || _tInit === false)
        {
         const pJitter = (_mWait + _bSlower) * (2 + (_bSlower > 0 ? Math.floor(_mStep / _bSlower) : 0));
         if (r.headers.hasOwnProperty('date'))
          _tInit = new Date(r.headers.date).getTime() - pJitter;
         else
          _tInit = Date.now() - pJitter;
        }
        notice.info(notice.Type.YOUTUBE_NETWORK);
        notice.active |= notice.Connection.YOUTUBE;
        notice.resetHide();
        let nextPoll = _mInterval;
        if (j.hasOwnProperty('pollingIntervalMillis'))
         nextPoll = j.pollingIntervalMillis;
        nextPoll += _bSlower;
        let nextPage = false;
        if (j.hasOwnProperty('nextPageToken'))
         nextPage = j.nextPageToken;
        if (j.hasOwnProperty('items') && Array.isArray(j.items) && j.items.length > 0)
        {
         for (let i = 0, l = j.items.length; i < l; i++)
         {
          const cmd = j.items[i];
          if (!cmd.hasOwnProperty('snippet'))
           continue;
          if (!cmd.snippet.hasOwnProperty('type'))
           continue;
          if (cmd.snippet.hasOwnProperty('publishedAt'))
          {
           const pTime = new Date(cmd.snippet.publishedAt).getTime();
           if (_tInit > pTime)
            continue;
          }
          if (!cmd.hasOwnProperty('_channel'))
           cmd._channel = stream.channel;
          switch (cmd.snippet.type)
          {
           case 'textMessageEvent':
            await _textMessageEvent(cmd);
            break;
           case 'superChatEvent':
            await _superChatEvent(cmd);
            break;
           case 'newSponsorEvent':
            _newSponsorEvent(cmd);
            break;
           case 'memberMilestoneChatEvent':
            await _memberMilestoneChatEvent(cmd);
            break;
           case 'superStickerEvent':
            _superStickerEvent(cmd);
            break;
           case 'membershipGiftingEvent':
            _membershipGiftingEvent(cmd);
            break;
           case 'messageDeletedEvent':
            _messageDeletedEvent(cmd);
            break;
           case 'userBannedEvent':
            _userBannedEvent(cmd);
            break;
          }
         }
        }
        if (!_tM.hasOwnProperty(chatID))
         return;
        _tM[chatID] = window.setTimeout(youtube.net.broadcasts.getMessages.start, nextPoll, stream, nextPage);
       }

       function $stop(chatID)
       {
        if (!_tM.hasOwnProperty(chatID))
         return;
        if (_tM[chatID] === false)
         return;
        window.clearTimeout(_tM[chatID]);
        delete _tM[chatID];
       }

       async function _textMessageEvent(cmd)
       {
        if (document.visibilityState === 'hidden')
         return;
        const u = _parse.user(cmd);
        if (cmd.hasOwnProperty('id') && u.id !== 0)
        {
         if (!_msgHistory.hasOwnProperty(u.id))
          _msgHistory[u.id] = new Set();
         _msgHistory[u.id].add(cmd.id);
        }
        await _parse.line(cmd);
       }

       async function _superChatEvent(cmd)
       {
        if (document.visibilityState === 'hidden')
         return;
        if (!cmd.hasOwnProperty('authorDetails'))
         return;
        if (!cmd.snippet.hasOwnProperty('superChatDetails'))
         return;
        const u = _parse.user(cmd);
        if (cmd.hasOwnProperty('id') && u.id !== 0)
        {
         if (!_msgHistory.hasOwnProperty(u.id))
          _msgHistory[u.id] = new Set();
         _msgHistory[u.id].add(cmd.id);
        }
        await _parse.event.superchat(cmd);
       }

       function _newSponsorEvent(cmd)
       {
        if (document.visibilityState === 'hidden')
         return;
        if (!cmd.hasOwnProperty('authorDetails'))
         return;
        if (!cmd.snippet.hasOwnProperty('newSponsorDetails'))
         return;
        if (cmd.snippet.newSponsorDetails.hasOwnProperty('isUpgrade') && cmd.snippet.newSponsorDetails.isUpgrade)
         return;
        _parse.event.membership.first(cmd);
       }

       async function _memberMilestoneChatEvent(cmd)
       {
        if (document.visibilityState === 'hidden')
         return;
        if (!cmd.hasOwnProperty('authorDetails'))
         return;
        if (!cmd.snippet.hasOwnProperty('memberMilestoneChatDetails'))
         return;
        await _parse.event.membership.milestone(cmd);
       }

       function _superStickerEvent(cmd)
       {
        if (document.visibilityState === 'hidden')
         return;
        if (!cmd.hasOwnProperty('authorDetails'))
         return;
        if (!cmd.snippet.hasOwnProperty('superStickerDetails'))
         return;
        const u = _parse.user(cmd);
        if (cmd.hasOwnProperty('id') && u.id !== 0)
        {
         if (!_msgHistory.hasOwnProperty(u.id))
          _msgHistory[u.id] = new Set();
         _msgHistory[u.id].add(cmd.id);
        }
        _parse.event.supersticker(cmd);
       }

       function _membershipGiftingEvent(cmd)
       {
        if (document.visibilityState === 'hidden')
         return;
        if (!cmd.hasOwnProperty('authorDetails'))
         return;
        if (!cmd.snippet.hasOwnProperty('membershipGiftingDetails'))
         return;
        _parse.event.membership.gift(cmd);
       }

       function _messageDeletedEvent(cmd)
       {
        if (!cmd.snippet.hasOwnProperty('messageDeletedDetails'))
         return;
        if (!cmd.snippet.messageDeletedDetails.hasOwnProperty('deletedMessageId'))
         return;
        const u = _parse.user(cmd);
        if (u.id !== 0 && _msgHistory.hasOwnProperty(u.id) && _msgHistory[u.id].has(cmd.snippet.messageDeletedDetails.deletedMessageId))
         _msgHistory[u.id].delete(cmd.snippet.messageDeletedDetails.deletedMessageId);
        const mID = 'youtube:' + cmd.snippet.messageDeletedDetails.deletedMessageId;
        display.eraseMsg(mID);
       }

       function _userBannedEvent(cmd)
       {
        if (!cmd.snippet.hasOwnProperty('userBannedDetails'))
         return;
        if (!cmd.snippet.userBannedDetails.hasOwnProperty('banType'))
         return;
        const u = _parse.user(cmd.snippet.userBannedDetails);
        if (u.id !== 0 && _msgHistory.hasOwnProperty(u.id))
        {
         for (const mID of _msgHistory[u.id])
         {
          display.eraseMsg('youtube:' + mID);
         }
         delete _msgHistory[u.id];
        }
        if (document.visibilityState === 'hidden')
         return;
        if (cmd.snippet.userBannedDetails.banType === 'temporary')
         _parse.event.timeout(cmd);
        else
         _parse.event.ban(cmd);
       }

       return {
        start: $start,
        stop: $stop
       };
      }();

      return {
       updateStream: $updateStream,
       getMessages: $getMessages
      };
     }();

     const $subscribers = function()
     {
      const _sHist = new Set();
      let _uLS = false;
      let _tS = false;
      const _rSC = 12000;
      const _rSH = 3600000;
      let _bSlower = 0;

      function $init()
      {
       if (!youtube.net.oAuth.auth.scope.includes(cScopes.youtube.readonly))
       {
        notice.error(notice.Type.YOUTUBE_NETWORK);
        notice.error(notice.Type.YOUTUBE_TOKEN);
        youtube.net.dead = true;
        return;
       }
       _tS = window.setTimeout(_detect, _rSC + _bSlower);
      }

      async function _detect()
      {
       if (youtube.net.dead)
        return;
       if (_tS === false)
        return;
       window.clearTimeout(_tS);
       _tS = false;
       const fRet = await _getChange();
       if (document.visibilityState !== 'hidden' && fRet !== false && fRet.length > 0)
       {
        for (let i = 0, l = fRet.length; i < l; i++)
        {
         if (_sHist.has(fRet[i].channelId))
          continue;
         _sHist.add(fRet[i].channelId);
         _parse.event.subscribe(fRet[i]);
        }
       }
       _tS = window.setTimeout(_detect, _rSC + _bSlower);
      }

      async function _getChange()
      {
       const url = cURLs.api.youtube.subscriptions.recent.replaceAll(cVARs.url.part, encodeURIComponent('snippet,subscriberSnippet'));
       const r = await shared.httpRequest('GET', url, youtube.net.oAuth.headers());
       const j = r.json;
       if (!r.success)
       {
        if (r.code === 0 && r.data === '')
         return [];
        if (r.code === 408 && r.data === shared.errTimeout)
         return false;
        if (j !== null)
        {
         const e = _flatJSON(j);
         if (e.hasOwnProperty('error.errors.0.reason'))
         {
          const er = e['error.errors.0.reason'];
          switch (er)
          {
           case 'authError':
           case 'subscriptionForbidden':
            notice.error(notice.Type.YOUTUBE_NETWORK);
            notice.error(notice.Type.YOUTUBE_TOKEN);
            youtube.net.oAuth.clear(true);
            youtube.net.dead = true;
            return false;
           case 'rateLimitExceeded':
            _bSlower += 1000;
            if (_bSlower > 14000)
            {
             _bSlower = 14000;
             notice.error(notice.Type.YOUTUBE_RATELIMIT);
            }
            return false;
           case 'backendError':
            return [];
          }
         }
        }
        notice.error(notice.Type.YOUTUBE_UNKNOWN, 'Error Getting Subscribers: ' + r.code);
        return false;
       }
       if (j === null)
        return false;
       if (!j.hasOwnProperty('items') || !Array.isArray(j.items) || j.items.length === 0)
        return false;
       for (let i = 0, l = j.items.length; i < l; i++)
       {
        if (!j.items[i].hasOwnProperty('snippet'))
         continue;
        if (!j.items[i].snippet.hasOwnProperty('resourceId'))
         continue;
        if (!j.items[i].snippet.resourceId.hasOwnProperty('channelId'))
         continue;
        const u = _parse.user(j.items[i]);
        if (u.id === 0)
         continue;
        const chID = j.items[i].snippet.resourceId.channelId;
        if (!youtube.net.sList.hasOwnProperty(chID))
         youtube.net.sList[chID] = {};
        youtube.net.sList[chID][u.id] = {value: true, t: Date.now()};
       }
       const findU = _uLS;
       for (let i = 0, l = j.items.length; i < l; i++)
       {
        const u = _parse.user(j.items[i]);
        if (u.id === 0)
         continue;
        _uLS = u.id;
        break;
       }
       if (findU === false)
        return false;
       const s = [];
       for (let i = 0, l = j.items.length; i < l; i++)
       {
        const u = _parse.user(j.items[i]);
        if (u.id === 0)
         continue;
        if (!u._name)
         continue;
        if (u.id === findU)
         return s.reverse();
        s.push(j.items[i].subscriberSnippet);
       }
       return [];
      }

      async function $checkUser(chID, uID)
      {
       if (youtube.net.sList.hasOwnProperty(chID) && youtube.net.sList[chID].hasOwnProperty(uID))
       {
        const tDif = Date.now() - youtube.net.sList[chID][uID].t;
        if (tDif < _rSH)
         return youtube.net.sList[chID][uID].value;
       }
       const url = cURLs.api.youtube.subscriptions.match.replaceAll(cVARs.url.part, encodeURIComponent('subscriberSnippet')).replaceAll(cVARs.url.user, encodeURIComponent(uID)).replaceAll(cVARs.url.channelID, encodeURIComponent(chID));
       const r = await shared.httpRequest('GET', url, youtube.net.oAuth.headers());
       const j = r.json;
       if (!r.success)
       {
        if (r.code === 0 && r.data === '')
         return false;
        if (r.code === 408 && r.data === shared.errTimeout)
         return false;
        if (j === null)
         return false;
        const e = _flatJSON(j);
        if (!e.hasOwnProperty('error.errors.0.reason'))
         return false;
        if (e['error.errors.0.reason'] !== 'subscriptionForbidden')
         return false;
        if (!youtube.net.sList.hasOwnProperty(chID))
         youtube.net.sList[chID] = {};
        youtube.net.sList[chID][uID] = {value: false, t: Date.now()};
        return false;
       }
       if (j === null)
        return false;
       if (!j.hasOwnProperty('pageInfo'))
        return false;
       if (!j.pageInfo.hasOwnProperty('totalResults'))
        return false;
       if (!youtube.net.sList.hasOwnProperty(chID))
        youtube.net.sList[chID] = {};
       if (j.pageInfo.totalResults > 0)
       {
        youtube.net.sList[chID][uID] = {value: true, t: Date.now()};
        return true;
       }
       youtube.net.sList[chID][uID] = {value: false, t: Date.now()};
       return false;
      }

      return {
       init: $init,
       checkUser: $checkUser
      };
     }();

     async function _loadEmote_channel(chName)
     {
      if (!service.emotes.hasOwnProperty('youtube'))
       service.emotes.youtube = {};
      const r = await _findEmote_channel(chName, service.emotes.youtube);
      if (r.length === 0)
       return;
      if (service.cList.length === 0)
       service.cList = r;
      else
      {
       for (const n in service.emotes.youtube)
       {
        if (!service.emotes.youtube[n].hasOwnProperty('scope'))
         continue;
        if (service.emotes.youtube[n].scope !== cSources.scope.channel)
         continue;
        for (let c = service.cList.length - 1; c >= 0; c--)
        {
         if (service.cList[c].url !== service.emotes.youtube[n].url)
          continue;
         service.cList.splice(c, 1);
         break;
        }
       }
       for (let i = 0, l = r.length; i < l; i++)
       {
        if (!service.cList.includes(r[i]))
         service.cList.push(r[i]);
       }
      }
      service.syncList();
     }

     const $cdnTest = function()
     {
      async function $c_cdnTest()
      {
       const stKeys = Object.keys(_eStickers);
       if (cfg.youtube.cdn === true)
       {
        const oLowest = {subdomain: _defCDN, ping: Number.MAX_SAFE_INTEGER};
        const oPings = [];
        for (let i = 0, l = cURLs.cdn.youtube.subdomain.length; i < l; i++)
        {
         const stX = shared.rnd(stKeys.length);
         const u = _eStickers[stKeys[stX]].url.replace('//' + _defCDN + '.', '//' + cURLs.cdn.youtube.subdomain[i] + '.');
         oPings.push(_ping(u));
        }
        const oRets = await Promise.allSettled(oPings);
        for (let i = 0, l = cURLs.cdn.youtube.subdomain.length; i < l; i++)
        {
         if (oRets[i].status !== 'fulfilled')
          continue;
         if (oRets[i].value === false)
          continue;
         const c = cURLs.cdn.youtube.subdomain[i];
         const t = oRets[i].value;
         if (oLowest.ping > t)
         {
          oLowest.subdomain = c;
          oLowest.ping = t;
         }
        }
        _bestCDN = oLowest.subdomain;
       }
       else
        _bestCDN = cfg.youtube.cdn;
       for (let i = 0, l = stKeys.length; i < l; i++)
       {
        _eStickers[stKeys[i]].url = _eStickers[stKeys[i]].url.replace('//' + _defCDN + '.', '//' + _bestCDN + '.');
       }
       if (service.emotes.hasOwnProperty('youtube'))
       {
        for (const eID in service.emotes.youtube)
        {
         if (!service.emotes.youtube.hasOwnProperty(eID))
          continue;
         service.emotes.youtube[eID].url = service.emotes.youtube[eID].url.replace('//' + _defCDN + '.', '//' + _bestCDN + '.');
        }
       }
       return _bestCDN;
      }

      async function _ping(file)
      {
       const tStart = Date.now();
       const r = await shared.httpRequest('HEAD', file, {}, null, true, false);
       if (!r)
        return false;
       return (Date.now() - tStart);
      }

      return $c_cdnTest;
     }();

     const $oAuth = function()
     {
      const _pathRefresh = '.refresh';

      async function $init()
      {
       if (cfg.youtube.hasOwnProperty('oauth_refresh') && cfg.youtube.oauth_refresh === null)
       {
        loginYT.cfgHash = false;
        loginYT.inUse = false;
        _populateAuth();
        return;
       }
       if (cfg.youtube.hasOwnProperty('oauth') && cfg.youtube.oauth !== null && cfg.youtube.oauth !== false && cfg.youtube.oauth !== 'OAUTH_ID')
       {
        loginYT.inUse = false;
        loginYT.cfgHash = shared.hashCode(cfg.youtube.oauth);
        await _genAccess(cfg.youtube.oauth);
        return;
       }
       if (cfg.youtube.hasOwnProperty('oauth_refresh') && cfg.youtube.oauth_refresh !== null && cfg.youtube.oauth_refresh !== false && cfg.youtube.oauth_refresh !== 'OAUTH_REFRESH')
       {
        loginYT.inUse = false;
        let sRef = cfg.youtube.oauth_refresh;
        loginYT.cfgHash = shared.hashCode(sRef);
        const lsRef = shared.storage.getItem(loginYT.path() + _pathRefresh);
        if (lsRef !== null)
         sRef = lsRef;
        const sRet = await _genRefresh(sRef);
        if (sRet !== false)
         shared.storage.setItem(loginYT.path() + _pathRefresh, sRet);
        else
         shared.storage.removeItem(loginYT.path() + _pathRefresh);
        return;
       }
       loginYT.inUse = true;
       loginYT.cfgHash = false;
       const h = shared.getHashParams();
       if (h.hasOwnProperty('service') && h.service === 'youtube' && h.hasOwnProperty('oauth_refresh'))
       {
        const sHRet = await _genRefresh(h.oauth_refresh);
        if (sHRet !== false)
         shared.storage.setItem(loginYT.path() + _pathRefresh, sHRet);
        else
         shared.storage.removeItem(loginYT.path() + _pathRefresh);
        return;
       }
       const lsRefresh = shared.storage.getItem(loginYT.path() + _pathRefresh);
       if (lsRefresh === null)
       {
        _populateAuth();
        return;
       }
       const sLRet = await _genRefresh(lsRefresh);
       if (sLRet !== false)
        shared.storage.setItem(loginYT.path() + _pathRefresh, sLRet);
       else
        shared.storage.removeItem(loginYT.path() + _pathRefresh);
      }

      async function _genAccess(a)
      {
       const oV = await _validate(a);
       if (oV === false)
       {
        _populateAuth();
        return false;
       }
       _populateAuth(a, false, oV);
       return a;
      }

      async function _genRefresh(r)
      {
       const oR = await _refresh(r);
       if (oR === false)
       {
        _populateAuth();
        return false;
       }
       const a = oR.access_token;
       let r2 = r;
       if (oR.hasOwnProperty('refresh_token'))
        r2 = oR.refresh_token;
       const oV = await _validate(a);
       if (oV === false)
       {
        _populateAuth();
        return false;
       }
       _populateAuth(a, r2, oV);
       return r2;
      }

      function _populateAuth(a = null, r = null, j = null)
      {
       youtube.net.oAuth.auth.time = Date.now();
       if (a === null || r === null || j === null)
       {
        youtube.net.oAuth.auth.client_id = false;
        youtube.net.oAuth.auth.scope = [];
        youtube.net.oAuth.auth.access_token = false;
        youtube.net.oAuth.auth.refresh_token = false;
        youtube.net.oAuth.auth.expires = 0;
        return;
       }
       youtube.net.oAuth.auth.client_id = j.azp;
       youtube.net.oAuth.auth.scope = j.scope.split(' ');
       youtube.net.oAuth.auth.access_token = a;
       youtube.net.oAuth.auth.refresh_token = r;
       youtube.net.oAuth.auth.expires = parseInt(j.expires_in, 10);
      }

      async function _refresh(t, retries = false)
      {
       const url = cURLs.api.rr.refresh.yt;
       let b = 'refresh=' + encodeURIComponent(t);
       if (cfg.youtube.share)
        b += '&share=1';
       const r = await shared.httpRequest('POST', url, {}, b, false);
       const j = r.json;
       if (!r.success)
       {
        if (r.code === 0 && r.data === '')
        {
         notice.error(notice.Type.YOUTUBE_CORS, 'OAuth token');
         youtube.net.oAuth.clear(false);
         youtube.net.dead = true;
         return false;
        }
        if (r.code === 408 && r.data === shared.errTimeout)
        {
         if (retries === false)
          return _refresh(t, true);
         return false;
        }
        if (j !== null)
        {
         const e = _flatJSON(j);
         if (e.hasOwnProperty('error'))
         {
          if (e.error === 'internal_failure')
          {
           if (retries === false)
            return _refresh(t, true);
           notice.error(notice.Type.YOUTUBE_UNKNOWN, 'The server ran into an internal problem.');
           youtube.net.oAuth.clear(false);
           youtube.net.dead = true;
           return false;
          }
          if (e.error === 'invalid_grant' & e.hasOwnProperty('error_description'))
          {
           switch (e.error_description)
           {
            case 'Token has been expired or revoked.':
             notice.error(notice.Type.YOUTUBE_NETWORK);
             notice.error(notice.Type.YOUTUBE_TOKEN);
             youtube.net.oAuth.clear(true);
             youtube.net.dead = true;
             return false;
            case 'Bad Request':
             notice.error(notice.Type.YOUTUBE_UNKNOWN, 'The server did not like the request.');
             youtube.net.oAuth.clear(false);
             youtube.net.dead = true;
             return false;
           }
          }
         }
        }
        notice.error(notice.Type.YOUTUBE_UNKNOWN, 'Error Getting OAuth Token: ' + r.code);
        return false;
       }
       if (j === null)
        return false;
       if (!j.hasOwnProperty('access_token'))
        return false;
       return j;
      }

      async function _validate(t)
      {
       const url = cURLs.api.youtube.tokeninfo.replaceAll(cVARs.url.token, encodeURIComponent(t));
       const r = await shared.httpRequest('GET', url, {}, null, false);
       if (!r.success)
       {
        if (r.code === 0 && r.data === '')
        {
         notice.error(notice.Type.YOUTUBE_CORS, 'OAuth token info');
         youtube.net.oAuth.clear(false);
         youtube.net.dead = true;
         return false;
        }
        if (r.code === 408 && r.data === shared.errTimeout)
         return false;
        if (r.code === 400)
        {
         notice.error(notice.Type.YOUTUBE_TOKEN);
         youtube.net.oAuth.clear();
        }
        return false;
       }
       const j = r.json;
       if (j === null)
        return false;
       if (!j.hasOwnProperty('azp'))
        return false;
       if (!j.hasOwnProperty('scope'))
        return false;
       if (!j.hasOwnProperty('expires_in'))
        return false;
       return j;
      }

      async function $update()
      {
       if (youtube.net.oAuth.auth.expires > 0)
       {
        const nowTime = Date.now();
        const exTime = youtube.net.oAuth.auth.time + (youtube.net.oAuth.auth.expires * 1000 * 0.75);
        if (nowTime < exTime)
         return;
       }
       const r = await _refresh(youtube.net.oAuth.auth.refresh_token);
       if (r === false)
       {
        _populateAuth();
        return;
       }
       const sAccess = r.access_token;
       let sRefresh = youtube.net.oAuth.auth.refresh_token;
       if (r.hasOwnProperty('refresh_token'))
        sRefresh = r.refresh_token;
       const v = await _validate(sAccess);
       if (v === false)
       {
        _populateAuth();
        return;
       }
       _populateAuth(sAccess, sRefresh, v);
       if (sRefresh !== youtube.net.oAuth.auth.refresh_token)
        shared.storage.setItem(loginYT.path() + _pathRefresh, sRefresh);
      }

      function $clear()
      {
       _populateAuth();
       shared.storage.removeItem(loginYT.path() + _pathRefresh);
      }

      function _cfgVals()
      {
       let r = 0;
       const lsRefresh = shared.storage.getItem(loginYT.path() + _pathRefresh);
       if (lsRefresh !== null)
        r |= shared.cfgVal.REFRESH_TOKEN;
       if (youtube.net.oAuth.auth.refresh_token !== false)
        r |= shared.cfgVal.REFRESH_TOKEN;
       if (youtube.net.oAuth.auth.access_token !== false)
        r |= shared.cfgVal.ACCESS_TOKEN;
       return r;
      }

      function $headers()
      {
       return {
        'Authorization': 'Bearer ' + youtube.net.oAuth.auth.access_token,
        'Accept': 'application/json'
       };
      }

      return {
       init: $init,
       update: $update,
       clear: $clear,
       get hasRefresh() {return (_cfgVals() & shared.cfgVal.REFRESH_TOKEN) === shared.cfgVal.REFRESH_TOKEN;},
       get hasLogin() {return (_cfgVals() & shared.cfgVal.ACCESS_TOKEN) === shared.cfgVal.ACCESS_TOKEN;},
       headers: $headers,
       auth: {
        client_id: false,
        scope: [],
        access_token: false,
        refresh_token: false,
        time: 0,
        expires: 0
       }
      };
     }();

     function _flatJSON(j, r = {}, p = '')
     {
      for (const k in j)
      {
       if (typeof j[k] !== 'object')
        r[p + k] = j[k];
       else
        _flatJSON(j[k], r, p + k + '.');
      }
      return r;
     }

     return {
      channelIDs: [],
      sList: {},
      dead: false,
      broadcasts: $broadcasts,
      subscribers: $subscribers,
      cdnTest: $cdnTest,
      oAuth: $oAuth
     };
    }();

    const _parse = function()
    {
     function $parseUser(cmd)
     {
      const ret = {
       id: 0,
       _name: false,
       ascii: false
      };
      if (cmd.hasOwnProperty('authorDetails'))
      {
       if (cmd.authorDetails.hasOwnProperty('channelId'))
        ret.id = cmd.authorDetails.channelId;
       if (cmd.authorDetails.hasOwnProperty('displayName'))
        ret._name = cmd.authorDetails.displayName;
      }
      if (cmd.hasOwnProperty('bannedUserDetails'))
      {
       if (cmd.bannedUserDetails.hasOwnProperty('channelId'))
        ret.id = cmd.bannedUserDetails.channelId;
       if (cmd.bannedUserDetails.hasOwnProperty('displayName'))
        ret._name = cmd.bannedUserDetails.displayName;
      }
      if (cmd.hasOwnProperty('subscriberSnippet'))
      {
       if (cmd.subscriberSnippet.hasOwnProperty('channelId'))
        ret.id = cmd.subscriberSnippet.channelId;
       if (cmd.subscriberSnippet.hasOwnProperty('title'))
        ret._name = cmd.subscriberSnippet.title;
      }
      const gReg = new RegExp(service.parse.uReg, 'g');
      if (!!ret._name && ret._name === ret._name.replaceAll(gReg, ''))
       ret.ascii = ret._name;
      if (!ret.ascii)
       ret.ascii = anonName;
      return ret;
     }

     function _getMessage(cmd)
     {
      if (cmd.snippet.hasOwnProperty('textMessageDetails') && cmd.snippet.textMessageDetails.hasOwnProperty('messageText'))
       return cmd.snippet.textMessageDetails.messageText;
      if (cmd.snippet.hasOwnProperty('memberMilestoneChatDetails') && cmd.snippet.memberMilestoneChatDetails.hasOwnProperty('userComment'))
       return cmd.snippet.memberMilestoneChatDetails.userComment;
      if (cmd.snippet.hasOwnProperty('superChatDetails') && cmd.snippet.superChatDetails.hasOwnProperty('userComment'))
       return cmd.snippet.superChatDetails.userComment;
      if (cmd.snippet.hasOwnProperty('displayMessage'))
       return cmd.snippet.displayMessage;
      return false;
     }

     const $content = function()
     {
      function $emoji(cmd, dup = null)
      {
       const msg = _getMessage(cmd);
       if (msg === false)
        return [];
       return service.parse.content.emoji(msg, dup);
      }

      const $youtube = function()
      {
       function $c_youtube(cmd, dup = null)
       {
        const msg = _getMessage(cmd);
        if (msg === false)
         return [];
        const emSeg = /(:[^: ]+:)/g;
        const emList = [];
        let match = null;
        while ((match = emSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        if (emList.length === 0)
         return [];
        if (dup === null)
         dup = cfg.display.duplicates;
        if (dup === false)
         dup = 1;
        const ret = [];
        for (let i = 0, l = emList.length; i < l; i++)
        {
         const u = _ttu(emList[i][0]);
         if (u === false)
          continue;
         let sc = cSources.scope.global;
         if (u.hasOwnProperty('scope'))
          sc = u.scope;
         if (sc === cSources.scope.channel && !_emoteAccess(cmd))
          continue;
         if (dup !== true)
         {
          let ct = 0;
          for (let j = 0, m = ret.length; j < m; j++)
          {
           if (ret[j].str === emList[i][0])
            ct++;
          }
          if (ct >= dup)
           continue;
         }
         ret.push({svc: cSources.service.youtube, url: u.url, str: emList[i][0], pos: emList[i].index, scope: sc});
        }
        return ret;
       }

       function _ttu(t)
       {
        if (t.slice(0, 1) !== ':')
         return false;
        t = t.slice(1);
        if (t.slice(-1) !== ':')
         return false;
        t = t.slice(0, -1);
        if (!service.emotes.youtube.hasOwnProperty(t))
         return false;
        return service.emotes.youtube[t];
       }

       return $c_youtube;
      }();

      const $3rdparty = function()
      {
       const $ffz = function()
       {
        function $general(cmd, dup = null)
        {
         const msg = _getMessage(cmd);
         if (msg === false)
          return [];
         return service.parse.content['3rdparty'].ffz.general(msg, 'youtube:' + cmd._channel, dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         const u = _parse.user(cmd);
         if (u.id === 0)
          return;
         const msg = _getMessage(cmd);
         if (msg === false)
          return;
         service.parse.content['3rdparty'].ffz.zwe(l, 'youtube:' + u.id, 'youtube:' + cmd._channel, msg, pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          const u = _parse.user(cmd);
          if (u.id === 0)
           return [];
          const msg = _getMessage(cmd);
          if (msg === false)
           return [];
          return service.parse.content['3rdparty'].ffz.user.general('youtube:' + u.id, msg, dup);
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          const u = _parse.user(cmd);
          if (u.id === 0)
           return;
          const msg = _getMessage(cmd);
          if (msg === false)
           return;
          service.parse.content['3rdparty'].ffz.user.zwe(l, 'youtube:' + u.id, msg, pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $bttv = function()
       {
        function $general(cmd, dup = null)
        {
         const msg = _getMessage(cmd);
         if (msg === false)
          return [];
         return service.parse.content['3rdparty'].bttv.general(msg, 'youtube:' + cmd._channel, dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         const u = _parse.user(cmd);
         if (u.id === 0)
          return;
         const msg = _getMessage(cmd);
         if (msg === false)
          return;
         service.parse.content['3rdparty'].bttv.zwe(l, 'youtube:' + u.id, 'youtube:' + cmd._channel, msg, pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          const msg = _getMessage(cmd);
          if (msg === false)
           return [];
          const u = _parse.user(cmd);
          if (u.id === 0)
           return [];
          return service.parse.content['3rdparty'].bttv.user.general('youtube:' + u.id, msg, dup);
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          const u = _parse.user(cmd);
          if (u.id === 0)
           return;
          const msg = _getMessage(cmd);
          if (msg === false)
           return;
          service.parse.content['3rdparty'].bttv.user.zwe(l, 'youtube:' + u.id, msg, pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $7tv = function()
       {
        function $general(cmd, dup = null)
        {
         const msg = _getMessage(cmd);
         if (msg === false)
          return [];
         return service.parse.content['3rdparty']['7tv'].general(msg, 'youtube:' + cmd._channel, dup);
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         const u = _parse.user(cmd);
         if (u.id === 0)
          return;
         const msg = _getMessage(cmd);
         if (msg === false)
          return;
         service.parse.content['3rdparty']['7tv'].zwe(l, 'youtube:' + u.id, 'youtube:' + cmd._channel, msg, pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          const u = _parse.user(cmd);
          if (u.id === 0)
           return [];
          const msg = _getMessage(cmd);
          if (msg === false)
           return [];
          return service.parse.content['3rdparty']['7tv'].user.general('youtube:' + u.id, msg, dup);
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          const u = _parse.user(cmd);
          if (u.id === 0)
           return;
          const msg = _getMessage(cmd);
          if (msg === false)
           return;
          service.parse.content['3rdparty']['7tv'].user.zwe(l, 'youtube:' + u.id, msg, pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       return {
        ffz: $ffz,
        bttv: $bttv,
        '7tv': $7tv
       };
      }();

      return {
       emoji: $emoji,
       youtube: $youtube,
       '3rdparty': $3rdparty
      };
     }();

     const $line = function()
     {
      async function $c_line(cmd)
      {
       const u = _parse.user(cmd);
       if (service.parse.ignored(u))
        return;
       const lvChk = new _level(cmd);
       if (await _parseCommand(cmd, lvChk))
        return;
       const p = _handleDuplicates(_eListFromCmd(cmd));
       if (p.length === 0)
        return;
       if (!(await lvChk.check(cfg.display.access)))
        return;
       display.emote.addToShowList(p);
       display.emote.showEmotes();
      }

      function _parseCommand(cmd, lvChk)
      {
       const m = _getMessage(cmd).toLowerCase();
       const a = _handleDuplicates(_eListFromCmd(cmd, true));
       let mID = false;
       if (cmd.hasOwnProperty('id'))
        mID = 'youtube:' + cmd.id;
       return service.parse.line.parseCommand(m, lvChk, a, mID);
      }

      return $c_line;
     }();

     const $event = function()
     {
      function $subscribe(cmd)
      {
       if (!cfg.event.youtube.sub)
        return;
       let uName = anonName;
       if (cmd.title)
       {
        uName = cmd.title;
        if (cfg.ignore.users !== false && cfg.ignore.users.includes(uName))
         return;
       }
       display.kappa.show(false, cfg.event.youtube.sub, {[cVARs.evt.user]: uName});
      }

      const $superchat = function()
      {
       const _minUSD = [0, 1, 2, 5, 10, 20, 50, 100, 200, 300, 400, 500];

       async function $c_superchat(cmd)
       {
        if (!cfg.event.youtube.superchat)
         return false;
        if (!cfg.event.youtube.superchat.level)
         return false;
        const u = _parse.user(cmd);
        if (service.parse.ignored(u))
         return false;
        if (!cmd.snippet.superChatDetails.hasOwnProperty('tier') || cmd.snippet.superChatDetails.tier === null)
         return false;
        const lv = cmd.snippet.superChatDetails.tier;
        if (lv < 1)
         return false;
        let p = [];
        if (cmd.snippet.superChatDetails.hasOwnProperty('userComment') && cmd.snippet.superChatDetails.userComment !== null)
        {
         if (cfg.event.youtube.superchat.useMsg)
         {
          const a = _eListFromCmd(cmd);
          p.push(...a);
         }
         else
          await _parse.line(cmd);
         p = _handleDuplicates(p);
        }
        if (p.length === 0)
         p = false;
        const r = shared.findInMaybeRange(cfg.event.youtube.superchat.level, lv);
        if (r === false)
        {
         if (p !== false)
         {
          display.emote.addToShowList(p);
          display.emote.showEmotes();
         }
         return true;
        }
        let amt = _minUSD[lv] + ' USD';
        if (cmd.snippet.superChatDetails.hasOwnProperty('amountDisplayString') && cmd.snippet.superChatDetails.amountDisplayString !== '')
         amt = cmd.snippet.superChatDetails.amountDisplayString;
        display.kappa.show(p, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: amt});
        return true;
       }

       return $c_superchat;
      }();

      const $supersticker = function()
      {
       const _minUSD = [0, 1, 2, 5, 10, 20, 50, 100, 200, 300, 400, 500];

       function $c_supersticker(cmd)
       {
        if (!cfg.event.youtube.supersticker)
         return false;
        const u = _parse.user(cmd);
        if (service.parse.ignored(u))
         return false;
        if (!cmd.snippet.superStickerDetails.hasOwnProperty('superStickerMetadata') || cmd.snippet.superStickerDetails.superStickerMetadata === null)
         return false;
        if (!cmd.snippet.superStickerDetails.hasOwnProperty('tier') || cmd.snippet.superStickerDetails.tier === null)
         return false;
        if (!cmd.snippet.superStickerDetails.superStickerMetadata.hasOwnProperty('stickerId'))
         return false;
        const lv = cmd.snippet.superStickerDetails.tier;
        if (lv < 1)
         return false;
        let p = [];
        const sId = cmd.snippet.superStickerDetails.superStickerMetadata.stickerId;
        if (_eStickers.hasOwnProperty(sId))
         p.push(_eStickers[sId]);
        if (p.length === 0)
         p = false;
        const r = shared.findInMaybeRange(cfg.event.youtube.supersticker, lv);
        if (r === false)
         return true;
        let amt = _minUSD[lv] + ' USD';
        if (cmd.snippet.superStickerDetails.hasOwnProperty('amountDisplayString') && cmd.snippet.superStickerDetails.amountDisplayString !== '')
         amt = cmd.snippet.superStickerDetails.amountDisplayString;
        let alt = 'Unknown';
        if (cmd.snippet.superStickerDetails.superStickerMetadata.hasOwnProperty('altText') && cmd.snippet.superStickerDetails.superStickerMetadata.altText !== '')
         alt = cmd.snippet.superStickerDetails.superStickerMetadata.altText;
        display.kappa.show(p, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.sticker]: alt, [cVARs.evt.amount]: amt});
        return true;
       }

       return $c_supersticker;
      }();

      const $membership = function()
      {
       function $first(cmd)
       {
        if (!cfg.event.youtube.member)
         return;
        const u = _parse.user(cmd);
        if (service.parse.ignored(u))
         return;
        let c = cfg.event.youtube.member;
        if (cmd.snippet.newSponsorDetails.memberLevelName)
        {
         const l = cmd.snippet.newSponsorDetails.memberLevelName;
         if (!!c[l] && c[l].hasOwnProperty('first'))
          c = c[l];
        }
        if (!c.hasOwnProperty('first'))
         return;
        if (c.first === false)
         return;
        display.kappa.show(false, c.first, {[cVARs.evt.user]: u.ascii});
       }

       async function $milestone(cmd)
       {
        if (!cfg.event.youtube.member)
         return;
        const u = _parse.user(cmd);
        if (service.parse.ignored(u))
         return;
        let c = cfg.event.youtube.member;
        if (cmd.snippet.memberMilestoneChatDetails.memberLevelName)
        {
         const l = cmd.snippet.memberMilestoneChatDetails.memberLevelName;
         if (!!c[l] && c[l].hasOwnProperty('milestone'))
          c = c[l];
        }
        if (!c.hasOwnProperty('milestone'))
         return;
        let a = [];
        if (cmd.snippet.memberMilestoneChatDetails.hasOwnProperty('userComment') && cmd.snippet.memberMilestoneChatDetails.userComment !== '')
        {
         if (cfg.event.youtube.member.useMsg)
          a = _eListFromCmd(cmd, true);
         else
          await _parse.line(cmd);
        }
        if (!cmd.snippet.memberMilestoneChatDetails.hasOwnProperty('memberMonth'))
         return;
        const mpcm = cmd.snippet.memberMilestoneChatDetails.memberMonth;
        const rs = shared.findInMaybeRange(c.milestone, mpcm);
        if (rs === false)
         return;
        display.kappa.show(a, rs, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: mpcm});
       }

       function $gift(cmd)
       {
        if (!cfg.event.youtube.member)
         return;
        const u = _parse.user(cmd);
        if (service.parse.ignored(u))
         return;
        if (!cmd.snippet.membershipGiftingDetails.hasOwnProperty('giftMembershipsCount'))
         return;
        let c = cfg.event.youtube.member;
        if (cmd.snippet.membershipGiftingDetails.giftMembershipsLevelName)
        {
         const l = cmd.snippet.membershipGiftingDetails.giftMembershipsLevelName;
         if (!!c[l] && c[l].hasOwnProperty('giftbomb'))
          c = c[l];
        }
        if (!c.hasOwnProperty('giftbomb'))
         return;
        const mpmgc = cmd.snippet.membershipGiftingDetails.giftMembershipsCount;
        const gpb = shared.findInMaybeRange(c.giftbomb, mpmgc);
        if (gpb === false)
         return;
        display.kappa.show(false, gpb, {[cVARs.evt.sender]: u.ascii, [cVARs.evt.amount]: mpmgc});
       }

       return {
        first: $first,
        milestone: $milestone,
        gift: $gift
       };
      }();

      function $ban(cmd)
      {
       if (!cfg.event.youtube.ban)
        return;
       let dn = anonName;
       if (cmd.snippet.hasOwnProperty('userBannedDetails'))
       {
        const u = _parse.user(cmd.snippet.userBannedDetails);
        if (service.parse.ignored(u))
         return;
        dn = u.ascii;
       }
       display.kappa.show(false, cfg.event.youtube.ban, {[cVARs.evt.user]: dn});
      }

      function $timeout(cmd)
      {
       if (!cfg.event.youtube.timeout)
        return;
       if (!cmd.snippet.userBannedDetails.hasOwnProperty('banDurationSeconds'))
        return;
       let dn = anonName;
       if (cmd.snippet.hasOwnProperty('userBannedDetails'))
       {
        const u = _parse.user(cmd.snippet.userBannedDetails);
        if (service.parse.ignored(u))
         return;
        dn = u.ascii;
       }
       const dDur = cmd.snippet.userBannedDetails.banDurationSeconds;
       const r = shared.findInMaybeRange(cfg.event.youtube.timeout, dDur);
       if (r === false)
        return;
       display.kappa.show(false, r, {[cVARs.evt.user]: dn, [cVARs.evt.amount]: dDur});
      }

      return {
       subscribe: $subscribe,
       superchat: $superchat,
       supersticker: $supersticker,
       membership: $membership,
       ban: $ban,
       timeout: $timeout
      };
     }();

     function _emoteAccess(cmd)
     {
      if (!cmd.hasOwnProperty('authorDetails'))
       return false;
      if (cmd.authorDetails.hasOwnProperty('isChatOwner') && cmd.authorDetails.isChatOwner !== false)
       return true;
      if (cmd.authorDetails.hasOwnProperty('isMember') && cmd.authorDetails.isMember !== false)
       return true;
      return false;
     }

     class _level
     {
      constructor(cmd)
      {
       this.cmd = cmd;
      }

      check(rq)
      {
       let r = youtube.Access.STRANGER;
       if (!this.cmd.hasOwnProperty('authorDetails'))
        return (r & rq) !== 0;
       const author = this.cmd.authorDetails;
       if (author.hasOwnProperty('isChatOwner') && author.isChatOwner !== false)
        r |= youtube.Access.BROADCASTER;
       if (author.hasOwnProperty('isChatModerator') && author.isChatModerator !== false)
        r |= youtube.Access.MODERATOR;
       if (author.hasOwnProperty('isChatSponsor') && author.isChatSponsor !== false)
        r |= youtube.Access.MEMBER;
       if (author.hasOwnProperty('isMember') && author.isMember !== false)
        r |= youtube.Access.MEMBER;
       if (author.hasOwnProperty('isVerified') && author.isVerified !== false)
        r |= youtube.Access.VERIFIED;
       if (author.hasOwnProperty('isSubscriber') && author.isSubscriber !== false)
        r |= youtube.Access.SUBSCRIBER;
       if ((r & youtube.Access.BROADCASTER) === youtube.Access.BROADCASTER && (r & youtube.Access.MEMBER) !== 0)
        r &= ~youtube.Access.MEMBER;
       if ((r & rq) !== 0)
        return true;
       if ((rq & youtube.Access.SUBSCRIBER) === 0)
        return false;
       /* api-heavy, only check if subscriber access is allowed and there's a chance it matters */
       if (!this.cmd.hasOwnProperty('_channel'))
        return false;
       const u = _parse.user(this.cmd);
       if (u.id === 0)
        return false;
       const chID = this.cmd._channel;
       return youtube.net.subscribers.checkUser(chID, u.id);
      }
     }

     function _handleDuplicates(a)
     {
      const lA = a.length;
      if (lA < 1)
       return a;
      const r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.url)
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.cheer)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === cSources.scope.user)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.youtube && a[i].scope === cSources.scope.channel)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let p = 0; p < cfg.display.extended.priority.length; p++)
      {
       for (let i = 0; i < lA; i++)
       {
        if (a[i].scope === cSources.scope.channel && a[i].svc === cSources.service[cfg.display.extended.priority[p]])
        {
         if (service.parse.notDupe(a[i], r))
          r.push(a[i]);
        }
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.youtube && a[i].scope === cSources.scope.global)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let p = 0; p < cfg.display.extended.priority.length; p++)
      {
       for (let i = 0; i < lA; i++)
       {
        if (a[i].scope === cSources.scope.global && a[i].svc === cSources.service[cfg.display.extended.priority[p]])
        {
         if (service.parse.notDupe(a[i], r))
          r.push(a[i]);
        }
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.emoji)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      return r;
     }

     function _eListFromCmd(cmd, dup = null)
     {
      const r = [];
      const u = _parse.user(cmd);
      if (service.parse.ignored(u))
       return r;
      r.push(..._parse.content.youtube(cmd, dup));
      if (cfg.display.useEmoji)
       r.push(..._parse.content.emoji(cmd, dup));
      if (cfg.display.extended.useFFZ)
      {
       r.push(..._parse.content['3rdparty'].ffz.general(cmd, dup));
       r.push(..._parse.content['3rdparty'].ffz.user.general(cmd, dup));
      }
      if (cfg.display.extended.useBTTV)
      {
       r.push(..._parse.content['3rdparty'].bttv.general(cmd, dup));
       r.push(..._parse.content['3rdparty'].bttv.user.general(cmd, dup));
      }
      if (cfg.display.extended.use7TV)
      {
       r.push(..._parse.content['3rdparty']['7tv'].general(cmd, dup));
       r.push(..._parse.content['3rdparty']['7tv'].user.general(cmd, dup));
      }
      if (cfg.display.extended.useFFZ)
      {
       _parse.content['3rdparty'].ffz.zwe(r, cmd, 1, dup);
       _parse.content['3rdparty'].ffz.user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       _parse.content['3rdparty'].bttv.zwe(r, cmd, 1, dup);
       _parse.content['3rdparty'].bttv.user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.use7TV)
      {
       _parse.content['3rdparty']['7tv'].zwe(r, cmd, 1, dup);
       _parse.content['3rdparty']['7tv'].user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.useFFZ)
      {
       _parse.content['3rdparty'].ffz.zwe(r, cmd, 2, dup);
       _parse.content['3rdparty'].ffz.user.zwe(r, cmd, 2, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       _parse.content['3rdparty'].bttv.zwe(r, cmd, 2, dup);
       _parse.content['3rdparty'].bttv.user.zwe(r, cmd, 2, dup);
      }
      if (cfg.display.extended.use7TV)
      {
       _parse.content['3rdparty']['7tv'].zwe(r, cmd, 2, dup);
       _parse.content['3rdparty']['7tv'].user.zwe(r, cmd, 2, dup);
      }
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.length > 0)
      {
       for (let i = r.length - 1; i >= 0; i--)
       {
        const m = r[i].str;
        if (cfg.ignore.emotes.includes(m))
         r.splice(i, 1);
       }
      }
      const t = Date.now();
      for (let i = 0, l = r.length; i < l; i++)
      {
       r[i].timestamp = t;
       if (r[i].hasOwnProperty('width') || r[i].hasOwnProperty('height'))
        continue;
       if (!r[i].hasOwnProperty('url'))
        continue;
       const sz = shared.ec.get(r[i].url);
       if (sz === null)
        continue;
       r[i].width = sz.width;
       r[i].height = sz.height;
      }
      if (cmd.hasOwnProperty('id'))
      {
       for (let i = 0, l = r.length; i < l; i++)
       {
        r[i].origin = 'youtube:' + cmd.id;
       }
      }
      return r;
     }

     return {
      user: $parseUser,
      content: $content,
      line: $line,
      event: $event
     };
    }();

    const _findEmote_channel = function()
    {
     const _rCH = 300000;
     const _chList = {};

     async function $c_findEmote_channel(chName, n = false)
     {
      if (n === false && _chList.hasOwnProperty(chName))
      {
       const tDif = Date.now() - _chList[chName].t;
       if (tDif < _rCH)
        return _chList[chName].value;
      }
      const url = cURLs.api.youtube.livechat.emojis;
      const b = 'u=' + encodeURIComponent(chName);
      const r = await shared.httpRequest('POST', url, {}, b);
      if (!r.success)
       return [];
      const j = r.json;
      if (j === null)
       return [];
      if (typeof j !== 'object')
       return [];
      const ret = [];
      const jIDs = Object.keys(j);
      for (let i = 0, l = jIDs.length; i < l; i++)
      {
       if (!j.hasOwnProperty(jIDs[i]))
        continue;
       if (!j[jIDs[i]].hasOwnProperty('name'))
        continue;
       if (!j[jIDs[i]].hasOwnProperty('image'))
        continue;
       const aN = _retrNames(j[jIDs[i]]);
       if (cfg.ignore.emotes !== false && _arrayInArray(aN, cfg.ignore.emotes))
        continue;
       const eURL = cURLs.cdn.youtube.emoji.replace('//' + _defCDN + '.', '//' + _bestCDN + '.').replaceAll(cVARs.url.emojiID, j[jIDs[i]].image);
       ret.push({url: eURL});
       if (n === false)
        continue;
       for (let k = 0, c = aN.length; k < c; k++)
       {
        n[aN[k]] = {
         scope: cSources.scope.channel,
         url: eURL,
         id: jIDs[i]
        };
       }
      }
      _chList[chName] = {t: Date.now(), value: ret};
      return ret;
     }

     return $c_findEmote_channel;
    }();

    async function $global()
    {
     if (!service.emotes.hasOwnProperty('youtube'))
      service.emotes.youtube = {};
     const url = cURLs.api.youtube.livechat.emojis;
     const r = await shared.httpRequest('GET', url);
     if (!r.success)
      return false;
     const j = r.json;
     if (j === null)
      return false;
     if (typeof j !== 'object')
      return false;
     const jIDs = Object.keys(j);
     for (let i = 0, l = jIDs.length; i < l; i++)
     {
      if (!j.hasOwnProperty(jIDs[i]))
       continue;
      if (!j[jIDs[i]].hasOwnProperty('name'))
       continue;
      if (!j[jIDs[i]].hasOwnProperty('image'))
       continue;
      const aN = _retrNames(j[jIDs[i]]);
      if (cfg.ignore.emotes !== false && _arrayInArray(aN, cfg.ignore.emotes))
       continue;
      for (let k = 0, c = aN.length; k < c; k++)
      {
       service.emotes.youtube[aN[k]] = {
        scope: cSources.scope.global,
        url: cURLs.cdn.youtube.emoji.replace('//' + _defCDN + '.', '//' + _bestCDN + '.').replaceAll(cVARs.url.emojiID, j[jIDs[i]].image),
        id: jIDs[i]
       };
      }
     }
     return true;
    }

    function _retrNames(o)
    {
     const r = [];
     for (let i = 0, l = o.name.length; i < l; i++)
     {
      let eName = o.name[i];
      if (eName.slice(0, 1) !== ':')
       continue;
      if (eName.slice(-1) !== ':')
       continue;
      eName = eName.slice(1, -1);
      r.push(eName);
     }
     return r;
    }

    function _arrayInArray(find, subject)
    {
     for (let i = 0, l = find.length; i < l; i++)
     {
      if (subject.includes(find[i]))
       return true;
     }
     return false;
    }

    async function $stickers()
    {
     const url = cURLs.api.youtube.livechat.superstickers;
     const r = await shared.httpRequest('GET', url, {}, null, false);
     if (!r.success)
      return false;
     const j = r.json;
     if (j === null)
      return false;
     if (!j.hasOwnProperty('list'))
      return false;
     if (typeof j.list !== 'object')
      return false;
     if (j.list === null)
      return false;
     let eCDN = cURLs.cdn.youtube.sticker;
     if (j.hasOwnProperty('template'))
      eCDN = j.template;
     const jNames = Object.keys(j.list);
     for (let i = 0, l = jNames.length; i < l; i++)
     {
      _eStickers[jNames[i]] = {
       scope: cSources.scope.global,
       url: eCDN.replaceAll(cVARs.url.stickerID, j.list[jNames[i]]),
       id: j.list[jNames[i]]
      };
     }
     return true;
    }

    return {
     net: $net,
     global: $global,
     stickers: $stickers,
     Access: Object.freeze({
      STRANGER: 0x001,
      SUBSCRIBER: 0x002,
      VERIFIED: 0x008,
      MEMBER: 0x010,
      MODERATOR: 0x400,
      BROADCASTER: 0x800
     })
    };
   }();

   const kick = function()
   {
    let _usesHyphen = 0;

    const $net = function()
    {
     const $socket = function()
     {
      let _wsRetry = 0;
      let _ws = null;
      let _msgHistory = {};
      let _lPing = 30000;
      let _lTimeout = 120000;
      const _lExpire = 5000;
      let _tTimeout = false;
      let _tExpire = false;
      let _tPing = 0;
      let _tPoll = false;

      async function $c_socket()
      {
       notice.expect |= notice.Connection.KICK;
       if (kick.net.channelID === 0 || kick.net.chatID === 0)
       {
        await _getChIDs();
        if (kick.net.channelID === 0 || kick.net.chatID === 0)
        {
         notice.error(notice.Type.KICK_NAME);
         kick.net.dead = true;
         return;
        }
       }
       _tPing = 0;
       const appID = await _getAppID();
       _ws = new WebSocket(cURLs.ws.kick.replaceAll(cVARs.url.chatID, appID));
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
       _tExpire = window.setTimeout(_wsExpire, _lExpire);
      }

      function _wsClose()
      {
       notice.error(notice.Type.KICK_NETWORK);
       notice.active &= ~notice.Connection.KICK;
       notice.resetHide();
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (kick.net.dead)
        return;
       const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(kick.net.socket, wsWait);
      }

      const _wsMessage = function()
      {
       async function $c_wsMessage(ev)
       {
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        if (_ws === null)
         return;
        if (kick.net.dead)
        {
         if (_tExpire !== false)
         {
          window.clearTimeout(_tExpire);
          _tExpire = false;
         }
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         return;
        }
        const j = JSON.parse(ev.data);
        if (!j.hasOwnProperty('event') || j.event === null)
         return;
        if (j.event === 'pusher:error')
        {
         _pusher_error(j);
         return;
        }
        if (!j.hasOwnProperty('data') || j.data === null)
         return;
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        _tPing = window.setInterval(_wsPing, _lPing);
        _wsRetry = 0;
        notice.info(notice.Type.KICK_NETWORK);
        notice.active |= notice.Connection.KICK;
        notice.resetHide();
        if (j.event.startsWith('pusher:'))
        {
         _pusher(j);
         return;
        }
        if (j.event.startsWith('pusher_internal:'))
        {
         await _pusher_internal(j);
         return;
        }
        if (j.event.startsWith('App\\Events\\'))
        {
         await _App_Events(j);
         return;
        }
        switch (j.event)
        {
         case 'RewardRedeemedEvent':
          _RewardRedeemedEvent(j);
          return;
         case 'PredictionCreated':
          _PredictionCreated(j);
          return;
         case 'PredictionUpdated':
          _PredictionUpdated(j);
          return;
         case 'GiftedSubscriptionsEvent':
          _GiftedSubscriptionsEvent(j);
          return;
         case 'KicksGifted':
          await _KicksGifted(j);
          return;
        }
       }

       function _pusher_error(j)
       {
        if (!j.hasOwnProperty('data'))
         return;
        if (j.data === null)
         return;
        if (!j.data.hasOwnProperty('code'))
         return;
        if (j.data.code === null)
         return;
        if (_tExpire !== false)
        {
         window.clearTimeout(_tExpire);
         _tExpire = false;
        }
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        if (kick.net.dead === true)
         return;
        if (j.data.code >= 4000 && j.data.code <= 4099)
        {
         if (j.data.hasOwnProperty('message') && j.data.message !== null)
          notice.error(notice.Type.KICK_UNKNOWN, j.data.message);
         notice.error(notice.Type.KICK_NETWORK);
         return;
        }
        if (j.data.code >= 4100 && j.data.code <= 4199)
        {
         const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
         if (_wsRetry < 2)
          _wsRetry += 0.2;
         window.setTimeout(kick.net.socket, wsWait);
         return;
        }
        if (j.data.code >= 4200 && j.data.code <= 4299)
        {
         window.setTimeout(kick.net.socket, 200);
         return;
        }
       }

       const _pusher = function()
       {
        function $c_pusher(j)
        {
         const jData = JSON.parse(j.data);
         switch (j.event.slice(7))
         {
          case 'pong':
           return;
          case 'ping':
           _ws.send(JSON.stringify({event: 'pusher:pong', data: {}}));
           return;
          case 'connection_established':
           _connection_established(jData);
           return;
         }
        }

        function _connection_established(jData)
        {
         _lTimeout = 120000;
         _lPing = 30000;
         if (jData.hasOwnProperty('activity_timeout') && jData.activity_timeout !== null)
         {
          _lTimeout = jData.activity_timeout * 1000;
          _lPing = Math.floor(_lTimeout / 2);
         }
         if (_tTimeout !== false)
         {
          window.clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
         if (_tPing !== 0)
         {
          window.clearInterval(_tPing);
          _tPing = 0;
         }
         _tPing = window.setInterval(_wsPing, _lPing);
         _ws.send(JSON.stringify({event: 'pusher:subscribe', data: {auth: '', channel: 'chatroom_' + kick.net.chatID}}));
         _ws.send(JSON.stringify({event: 'pusher:subscribe', data: {auth: '', channel: 'channel_' + kick.net.channelID}}));
         _ws.send(JSON.stringify({event: 'pusher:subscribe', data: {auth: '', channel: 'chatrooms.' + kick.net.chatID + '.v2'}}));
         _ws.send(JSON.stringify({event: 'pusher:subscribe', data: {auth: '', channel: 'predictions-channel-' + kick.net.channelID}}));
        }

        return $c_pusher;
       }();

       const _pusher_internal = function()
       {
        async function $c_pusher_internal(j)
        {
         switch (j.event.slice(16))
         {
          case 'subscription_succeeded':
           await _subscription_succeded(j);
           return;
         }
        }

        async function _subscription_succeded(j)
        {
         if (!j.hasOwnProperty('channel') || j.channel === null)
          return;
         if (j.channel !== 'chatrooms.' + kick.net.chatID + '.v2')
          return;
         if (_tExpire !== false)
         {
          window.clearTimeout(_tExpire);
          _tExpire = false;
         }
         await _loadEmote_channel(kick.net.oAuth.auth.channel);
         if (cfg.display.extended.use7TV && kick.net.userID !== 0)
         {
          thirdparty['7tv'].channel('kick', kick.net.userID);
          await thirdparty['7tv'].socketEx.join('kick', kick.net.userID);
          thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval);
         }
        }

        return $c_pusher_internal;
       }();

       const _App_Events = function()
       {
        async function $c_App_Events(j)
        {
         const jData = JSON.parse(j.data);
         if (jData.hasOwnProperty('content') && jData.content !== null)
          jData.content = jData.content.replaceAll(/\s+/g, ' ').replaceAll(/([^ ])\[emote:/g, '$1 [emote:');
         switch (j.event.slice(11))
         {
          case 'ChatMessageEvent':
           _ChatMessageEvent(jData);
           return;
          case 'UserBannedEvent':
           _UserBannedEvent(jData);
           return;
          case 'StreamHostEvent':
           await _StreamHostEvent(jData);
           return;
          case 'SubscriptionEvent':
           _SubscriptionEvent(jData);
           return;
          case 'PollUpdateEvent':
           _PollUpdateEvent(jData);
           return;
          case 'PollDeleteEvent':
           _PollDeleteEvent();
           return;
          case 'MessageDeletedEvent':
           _MessageDeletedEvent(jData);
           return;
          case 'ChatroomClearEvent':
           _ChatroomClearEvent();
           return;
         }
        }

        function _ChatMessageEvent(jData)
        {
         if (jData.hasOwnProperty('id') && jData.id !== null && jData.hasOwnProperty('sender') && jData.sender !== null && jData.sender.hasOwnProperty('id') && jData.sender.id !== null)
         {
          if (!_msgHistory.hasOwnProperty(jData.sender.id))
           _msgHistory[jData.sender.id] = new Set();
          _msgHistory[jData.sender.id].add(jData.id);
         }
         if (document.visibilityState === 'hidden')
          return;
         _parse.line(jData);
        }

        function _UserBannedEvent(jData)
        {
         if (jData.hasOwnProperty('user') && jData.user !== null && jData.user.hasOwnProperty('id') && jData.user.id !== null && _msgHistory.hasOwnProperty(jData.user.id))
         {
          for (const mID of _msgHistory[jData.user.id])
          {
           display.eraseMsg('kick:' + mID);
          }
          delete _msgHistory[jData.user.id];
         }
         if (document.visibilityState === 'hidden')
          return;
         if (jData.hasOwnProperty('expires_at') && jData.expires_at !== null)
         {
          if (cfg.event.kick.timeout !== false)
           _parse.event.timeout(jData);
         }
         else
         {
          if (cfg.event.kick.ban !== false)
           _parse.event.ban(jData);
         }
        }

        async function _StreamHostEvent(jData)
        {
         if (document.visibilityState === 'hidden')
          return;
         await _parse.event.raid(jData);
        }

        function _SubscriptionEvent(jData)
        {
         if (document.visibilityState === 'hidden')
          return;
         _parse.event.sub(jData);
        }

        function _PollUpdateEvent(jData)
        {
         if (!cfg.event.kick.poll)
          return;
         if (!cfg.event.kick.poll.begin && !cfg.event.kick.poll.end)
          return;
         if (!jData.hasOwnProperty('poll') || jData.poll === null)
          return;
         if (!jData.poll.hasOwnProperty('remaining') || jData.poll.remaining === null)
          return;
         if (_tPoll !== false)
         {
          window.clearTimeout(_tPoll);
          _tPoll = false;
         }
         _tPoll = window.setTimeout(_PollEndCheck, jData.poll.remaining * 1000, jData.poll);
         if (!jData.poll.hasOwnProperty('duration') || jData.poll.duration === null)
          return;
         if (jData.poll.duration !== jData.poll.remaining)
          return;
         if (document.visibilityState === 'hidden')
          return;
         _parse.event.poll.begin(jData.poll);
        }

        function _PollDeleteEvent()
        {
         if (_tPoll !== false)
         {
          window.clearTimeout(_tPoll);
          _tPoll = false;
         }
        }

        function _PollEndCheck(ev)
        {
         if (_tPoll === false)
          return;
         _tPoll = false;
         if (document.visibilityState === 'hidden')
          return;
         _parse.event.poll.end(ev);
        }

        function _MessageDeletedEvent(jData)
        {
         if (!jData.hasOwnProperty('message'))
          return;
         if (!jData.message.hasOwnProperty('id'))
          return;
         for (const uID in _msgHistory)
         {
          if (!_msgHistory.hasOwnProperty(uID))
           continue;
          if (!_msgHistory[uID].has(jData.message.id))
           continue;
          _msgHistory[uID].delete(jData.message.id);
          break;
         }
         const mID = 'kick:' + jData.message.id;
         display.eraseMsg(mID);
        }

        function _ChatroomClearEvent()
        {
         _msgHistory = {};
         if (cfg.event.kick.hasOwnProperty('clear') && cfg.event.kick.clear)
          display.eraseAll();
        }

        return $c_App_Events;
       }();

       function _RewardRedeemedEvent(j)
       {
        const jData = JSON.parse(j.data);
        if (!jData.hasOwnProperty('reward_title'))
         return;
        if (!jData.hasOwnProperty('user_id'))
         return;
        if (!jData.hasOwnProperty('username'))
         return;
        if (jData.hasOwnProperty('user_input') && jData.user_input !== '')
         jData.user_input = jData.user_input.replaceAll(/\s+/g, ' ').replaceAll(/([^ ])\[emote:/g, '$1 [emote:');
        if (document.visibilityState === 'hidden')
         return;
        const cmd = {
         type: 'redeem',
         sender: {
          id: jData.user_id,
          username: jData.username
         }
        };
        if (jData.hasOwnProperty('channel_id'))
         cmd.chatroom_id = jData.channel_id;
        if (jData.hasOwnProperty('user_input'))
         cmd.user_input = jData.user_input;
        _parse.event.redeem(jData.reward_title, cmd);
       }

       function _PredictionCreated(j)
       {
        const jData = JSON.parse(j.data);
        if (!jData.hasOwnProperty('prediction'))
         return;
        if (!jData.prediction.hasOwnProperty('state'))
         return;
        if (jData.prediction.state !== 'ACTIVE')
         return;
        if (document.visibilityState === 'hidden')
         return;
        _parse.event.prediction.begin(jData.prediction);
       }

       function _PredictionUpdated(j)
       {
        const jData = JSON.parse(j.data);
        if (!jData.hasOwnProperty('prediction'))
         return;
        if (!jData.prediction.hasOwnProperty('state'))
         return;
        if (jData.prediction.state !== 'RESOLVED')
         return;
        if (!jData.prediction.hasOwnProperty('winning_outcome_id'))
         return;
        if (document.visibilityState === 'hidden')
         return;
        _parse.event.prediction.end(jData.prediction);
       }

       function _GiftedSubscriptionsEvent(j)
       {
        const jData = JSON.parse(j.data);
        if (document.visibilityState === 'hidden')
         return;
        _parse.event.gift(jData);
       }

       async function _KicksGifted(j)
       {
        const jData = JSON.parse(j.data);
        if (jData.hasOwnProperty('message') && jData.message !== null)
         jData.message = jData.message.replaceAll(/\s+/g, ' ').replaceAll(/([^ ])\[emote:/g, '$1 [emote:');
        if (document.visibilityState === 'hidden')
         return;
        if (await _parse.event.cheer(jData))
         return;
        _parse.line(jData, 'message');
       }

       return $c_wsMessage;
      }();

      function _wsExpire()
      {
       notice.error(notice.Type.KICK_NETWORK);
       notice.active &= ~notice.Connection.KICK;
       notice.resetHide();
       if (_ws === null)
        return;
       if (kick.net.dead === true)
        return;
       kick.net.dead = true;
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       _ws.close();
       _ws = null;
      }

      function _wsPing()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send(JSON.stringify({event: 'pusher:ping', data: {}}));
      }

      function _wsTimeout()
      {
       if (_lTimeout === 120000)
       {
        notice.error(notice.Type.KICK_NETWORK);
        notice.active &= ~notice.Connection.KICK;
        notice.resetHide();
       }
       else
        _lTimeout = 120000;
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       _lPing = 30000;
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (kick.net.dead === true)
        return;
       kick.net.socket();
      }

      const _getAppID = function()
      {
       const _defAppID = '32cbd69e4b950bf97679';
       let _cachedAppID = false;

       async function $c_getAppID()
       {
        if (!!_cachedAppID)
         return _cachedAppID;
        const r = await shared.httpRequest('GET', cURLs.cdn.kick.appid);
        if (!r.success)
         return _defAppID;
        const j = r.json;
        if (j === null)
         return _defAppID;
        if (!j.hasOwnProperty('PUSHER_APP_ID') || j.PUSHER_APP_ID === null)
         return _defAppID;
        _cachedAppID = j.PUSHER_APP_ID;
        return j.PUSHER_APP_ID;
       }

       return $c_getAppID;
      }();

      async function _getChIDs()
      {
       const slug = _usesHyphen === true ? kick.net.oAuth.auth.channel.replaceAll('_', '-') : kick.net.oAuth.auth.channel;
       const url = cURLs.api.kick.channels.replaceAll(cVARs.url.channelName, encodeURIComponent(slug));
       const r = await shared.httpRequest('GET', url);
       if (!r.success)
       {
        if (r.code === 404 && _usesHyphen === 0)
        {
         _usesHyphen = true;
         return _getChIDs();
        }
        return false;
       }
       const j = r.json;
       if (j === null)
        return false;
       if (!j.hasOwnProperty('id') || j.id === null)
        return false;
       if (!j.hasOwnProperty('chatroom') || j.chatroom === null)
        return false;
       if (!j.hasOwnProperty('user_id') || j.user_id === null)
        return false;
       if (!j.chatroom.hasOwnProperty('id') || j.chatroom.id === null)
        return false;
       if (_usesHyphen === 0)
        _usesHyphen = false;
       kick.net.channelID = j.id;
       kick.net.chatID = j.chatroom.id;
       kick.net.userID = j.user_id;
       return true;
      }

      return $c_socket;
     }();

     const $followers = function()
     {
      let _uLC = -1;
      let _tS = false;
      const _rSC = 5000;

      function $c_followers()
      {
       if (!cfg.event.kick.follow)
        return;
       _tS = window.setTimeout(_detect, _rSC);
      }

      async function _detect()
      {
       if (_tS === false)
        return;
       window.clearTimeout(_tS);
       _tS = false;
       if (kick.net.dead === true)
        return;
       const fRet = await _getChange();
       if (document.visibilityState !== 'hidden' && fRet > 0)
       {
        for (let i = 0, l = fRet; i < l; i++)
        {
         display.kappa.show(false, cfg.event.kick.follow, {[cVARs.evt.user]: 'Kick User'});
        }
       }
       _tS = window.setTimeout(_detect, _rSC);
      }

      async function _getChange()
      {
       const slug = _usesHyphen === true ? kick.net.oAuth.auth.channel.replaceAll('_', '-') : kick.net.oAuth.auth.channel;
       const url = cURLs.api.kick.followers.replaceAll(cVARs.url.channelName, encodeURIComponent(slug));
       const r = await shared.httpRequest('GET', url);
       if (!r.success)
       {
        if (r.code === 0 && r.data === '')
         return 0;
        if (r.code === 404 && _usesHyphen === 0)
        {
         _usesHyphen = true;
         return _getChange();
        }
        return 0;
       }
       const j = r.json;
       if (j === null)
        return 0;
       if (!j.hasOwnProperty('data') || j.data === null)
        return 0;
       if (!j.data.hasOwnProperty('count') || j.data.count === null)
        return 0;
       if (_usesHyphen === 0)
        _usesHyphen = false;
       if (_uLC === -1)
        _uLC = j.data.count;
       if (j.data.count !== _uLC)
       {
        kick.net.fList = {};
        if (j.data.count > _uLC)
        {
         const cDif = j.data.count - _uLC;
         _uLC = j.data.count;
         return cDif;
        }
        _uLC = j.data.count;
       }
       return 0;
      }

      return $c_followers;
     }();

     async function _loadEmote_channel(chName)
     {
      if (!service.emotes.hasOwnProperty('kick'))
       service.emotes.kick = {};
      const r = await _findEmote_channel(chName, service.emotes.kick);
      if (r.length === 0)
       return;
      if (service.cList.length === 0)
       service.cList = r;
      else
      {
       for (const n in service.emotes.kick)
       {
        if (!service.emotes.kick[n].hasOwnProperty('scope'))
         continue;
        if (service.emotes.kick[n].scope !== cSources.scope.channel)
         continue;
        for (let c = service.cList.length - 1; c >= 0; c--)
        {
         if (service.cList[c].url !== service.emotes.kick[n].url)
          continue;
         service.cList.splice(c, 1);
         break;
        }
       }
       for (let i = 0, l = r.length; i < l; i++)
       {
        if (!service.cList.includes(r[i]))
         service.cList.push(r[i]);
       }
      }
      service.syncList();
     }

     const $oAuth = function()
     {
      function $init()
      {
       if (cfg.kick.hasOwnProperty('channel') && cfg.kick.channel === null)
       {
        loginK.inUse = false;
        _populateAuth();
        return;
       }
       if (cfg.kick.hasOwnProperty('channel') && cfg.kick.channel !== null && cfg.kick.channel !== false && cfg.kick.channel !== 'CHANNEL_NAME')
       {
        loginK.inUse = false;
        _populateAuth(cfg.kick.channel);
        return;
       }
       loginK.inUse = true;
       const lsChannel = shared.storage.getItem(loginK.path() + '.channel');
       if (lsChannel === null)
       {
        _populateAuth();
        return;
       }
       _populateAuth(lsChannel);
      }

      function _populateAuth(c = null)
      {
       kick.net.oAuth.auth.time = Date.now();
       if (c === null)
       {
        kick.net.oAuth.auth.channel = false;
        return;
       }
       kick.net.oAuth.auth.channel = c;
      }

      function _cfgVals()
      {
       let r = 0;
       if (kick.net.oAuth.auth.channel !== false)
        r |= shared.cfgVal.CHANNEL;
       return r;
      }

      return {
       init: $init,
       get hasLogin() {return (_cfgVals() & shared.cfgVal.CHANNEL) === shared.cfgVal.CHANNEL;},
       auth: {
        channel: false,
        time: 0
       }
      };
     }();

     return {
      channelID: 0,
      chatID: 0,
      userID: 0,
      sckID: false,
      fList: {},
      dead: false,
      socket: $socket,
      followers: $followers,
      oAuth: $oAuth
     };
    }();

    const _parse = function()
    {
     function _parseUser(cmd, prop = 'sender')
     {
      const ret = {
       id: 0,
       _slug: false,
       _name: false,
       ascii: false
      };
      if (cmd.hasOwnProperty(prop))
      {
       const data = cmd[prop];
       if (data.hasOwnProperty('id') && data.id !== null)
        ret.id = data.id;
       if (data.hasOwnProperty('slug') && data.slug !== null)
        ret._slug = data.slug;
       if (data.hasOwnProperty('username') && data.username !== null)
        ret._name = data.username;
      }
      const gReg = new RegExp(service.parse.uReg, 'g');
      if (!!ret._name && ret._name === ret._name.replaceAll(gReg, ''))
       ret.ascii = ret._name;
      if (!ret.ascii && !!ret._slug)
       ret.ascii = ret._slug;
      if (!ret.ascii)
       ret.ascii = anonName;
      return ret;
     }

     const $content = function()
     {
      function $emoji(cmd, attrContent, dup = null)
      {
       if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
        return [];
       const msg = cmd[attrContent];
       return service.parse.content.emoji(msg, dup);
      }

      function $kick(cmd, attrContent, dup = null)
      {
       if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
        return [];
       const m = cmd[attrContent];
       if (dup === null)
        dup = cfg.display.duplicates;
       if (dup === false)
        dup = 1;
       const emSeg = /(\[emote:(\d+):([^\]]*)\])/gu;
       const ret = [];
       const ids = [];
       const emList = [];
       let match = null;
       while ((match = emSeg.exec(m)) !== null)
       {
        emList.push(match);
       }
       if (emList.length === 0)
        return [];
       for (let i = 0, n = emList.length; i < n; i++)
       {
        if (emList[i].length !== 4)
         continue;
        const eID = emList[i][2];
        if (dup !== true)
        {
         let ct = 0;
         for (let j = 0, l = ids.length; j < l; j++)
         {
          if (ids[j] === eID)
           ct++;
         }
         if (ct >= dup)
          continue;
        }
        const u = cURLs.cdn.kick.emote.replaceAll(cVARs.url.emoteID, eID);
        const p = emList[i].index;
        let sc = cSources.scope.channel;
        const sName = emList[i][3];
        if (sName !== '')
        {
         if (service.emotes.kick.hasOwnProperty(sName) && service.emotes.kick[sName].hasOwnProperty('scope'))
          sc = service.emotes.kick[sName].scope;
        }
        ret.push({svc: cSources.service.kick, url: u, str: emList[i][0], pos: p, scope: sc});
        ids.push(eID);
       }
       return ret;
      }

      function $kicks(cmd)
      {
       const p = [];
       if (!cmd.hasOwnProperty('gift'))
        return p;
       if (!cmd.gift.hasOwnProperty('name'))
        return p;
       if (!cmd.gift.hasOwnProperty('gift_id'))
        return p;
       let gID = cmd.gift.gift_id.replaceAll('_', '-');
       if (gID === 'boooom')
        gID = 'boom';
       const url = cURLs.cdn.kick.cheer.replaceAll(cVARs.url.emoteID, gID);
       p.push({svc: cSources.service.cheer, url: url, str: cmd.gift.name, pos: 0, scope: null});
       return p;
      }

      const $3rdparty = function()
      {
       const $ffz = function()
       {
        function $general(cmd, attrContent, dup = null)
        {
         if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
          return [];
         return service.parse.content['3rdparty'].ffz.general(cmd[attrContent], 'kick:' + kick.net.userID, dup);
        }

        function $zwe(l, cmd, attrContent, pass, dup = null)
        {
         if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
          return;
         const u = _parseUser(cmd);
         if (u.id === 0)
          return;
         service.parse.content['3rdparty'].ffz.zwe(l, 'kick:' + u.id, 'kick:' + kick.net.userID, cmd[attrContent], pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, attrContent, dup = null)
         {
          if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
           return [];
          const u = _parseUser(cmd);
          if (u.id === 0)
           return [];
          return service.parse.content['3rdparty'].ffz.user.general('kick:' + u.id, cmd[attrContent], dup);
         }

         function $userZWE(l, cmd, attrContent, pass, dup = null)
         {
          if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
           return;
          const u = _parseUser(cmd);
          if (u.id === 0)
           return;
          service.parse.content['3rdparty'].ffz.user.zwe(l, 'kick:' + u.id, cmd[attrContent], pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $bttv = function()
       {
        function $general(cmd, attrContent, dup = null)
        {
         if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
          return [];
         return service.parse.content['3rdparty'].bttv.general(cmd[attrContent], 'kick:' + kick.net.userID, dup);
        }

        function $zwe(l, cmd, attrContent, pass, dup = null)
        {
         if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
          return;
         const u = _parseUser(cmd);
         if (u.id === 0)
          return;
         service.parse.content['3rdparty'].bttv.zwe(l, 'kick:' + u.id, 'kick:' + kick.net.userID, cmd[attrContent], pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, attrContent, dup = null)
         {
          if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
           return [];
          const u = _parseUser(cmd);
          if (u.id === 0)
           return [];
          return service.parse.content['3rdparty'].bttv.user.general('kick:' + u.id, cmd[attrContent], dup);
         }

         function $userZWE(l, cmd, attrContent, pass, dup = null)
         {
          if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
           return;
          const u = _parseUser(cmd);
          if (u.id === 0)
           return;
          service.parse.content['3rdparty'].bttv.user.zwe(l, 'kick:' + u.id, cmd[attrContent], pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $7tv = function()
       {
        function $general(cmd, attrContent, dup = null)
        {
         if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
          return [];
         return service.parse.content['3rdparty']['7tv'].general(cmd[attrContent], 'kick:' + kick.net.userID, dup);
        }

        function $zwe(l, cmd, attrContent, pass, dup = null)
        {
         if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
          return;
         const u = _parseUser(cmd);
         if (u.id === 0)
          return;
         service.parse.content['3rdparty']['7tv'].zwe(l, 'kick:' + u.id, 'kick:' + kick.net.userID, cmd[attrContent], pass, dup);
        }

        const $user = function()
        {
         function $userGeneral(cmd, attrContent, dup = null)
         {
          if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
           return [];
          const u = _parseUser(cmd);
          if (u.id === 0)
           return [];
          return service.parse.content['3rdparty']['7tv'].user.general('kick:' + u.id, cmd[attrContent], dup);
         }

         function $userZWE(l, cmd, attrContent, pass, dup = null)
         {
          if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
           return;
          const u = _parseUser(cmd);
          if (u.id === 0)
           return;
          service.parse.content['3rdparty']['7tv'].user.zwe(l, 'kick:' + u.id, cmd[attrContent], pass, dup);
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       return {
        ffz: $ffz,
        bttv: $bttv,
        '7tv': $7tv
       };
      }();

      return {
       emoji: $emoji,
       kick: $kick,
       kicks: $kicks,
       '3rdparty': $3rdparty
      };
     }();

     const $line = function()
     {
      async function $c_line(cmd, attrContent = 'content', andCheers = true)
      {
       const u = _parseUser(cmd);
       if (service.parse.ignored(u))
        return;
       if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
        return;
       const lvChk = new _level(cmd);
       if (await _parseCommand(cmd, attrContent, lvChk))
        return;
       const p = _handleDuplicates(_eListFromCmd(cmd, attrContent, null, andCheers));
       if (p.length === 0)
        return;
       if (!(await lvChk.check(cfg.display.access)))
        return;
       display.emote.addToShowList(p);
       display.emote.showEmotes();
      }

      function _parseCommand(cmd, attrContent, lvChk)
      {
       const m = cmd[attrContent].toLowerCase();
       const a = _handleDuplicates(_eListFromCmd(cmd, attrContent, true));
       let mID = false;
       if (cmd.hasOwnProperty('id'))
        mID = 'kick:' + cmd.id;
       return service.parse.line.parseCommand(m, lvChk, a, mID);
      }

      return $c_line;
     }();

     const $event = function()
     {
      async function $cheer(cmd)
      {
       if (!cfg.event.kick.cheer)
        return false;
       if (!cfg.event.kick.cheer.kicks)
        return false;
       const u = _parseUser(cmd);
       if (service.parse.ignored(u))
        return false;
       if (!cmd.hasOwnProperty('gift'))
        return false;
       if (!cmd.gift.hasOwnProperty('amount'))
        return false;
       if (cmd.gift.amount < 1)
        return false;
       let p = [];
       if (cfg.event.kick.cheer.useMsg)
       {
        const a = _eListFromCmd(cmd, 'message');
        p.push(...a);
       }
       else
       {
        const b = _parse.content.kicks(cmd);
        p.push(...b);
        await _parse.line(cmd, 'message', false);
       }
       p = _handleDuplicates(p);
       if (p.length === 0)
        return false;
       const r = shared.findInMaybeRange(cfg.event.kick.cheer.kicks, cmd.gift.amount);
       if (r === false)
       {
        display.emote.addToShowList(p);
        display.emote.showEmotes();
        return true;
       }
       display.kappa.show(p, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.sticker]: cmd.gift.name, [cVARs.evt.amount]: cmd.gift.amount});
       return true;
      }

      async function $raid(cmd)
      {
       if (!cfg.event.kick.raid)
        return;
       if (!cfg.event.kick.raid.raiders)
        return;
       if (!cmd.host_username)
        return;
       if (!cmd.number_viewers)
        return;
       const c = cmd.number_viewers;
       const r = shared.findInMaybeRange(cfg.event.kick.raid.raiders, c);
       if (r === false)
        return;
       const dn = cmd.host_username;
       const u = await _getUserProfile(dn);
       if (u === false)
        return;
       if (service.parse.ignored(u))
        return;
       if (!cfg.event.kick.raid.originEmotes)
       {
        display.kappa.show(false, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: c});
        return;
       }
       if (!u._slug)
        return;
       const e = await _findEmote_channel(u._slug);
       if (cfg.event.kick.raid.originExtendedEmotes)
       {
        e.push(...await _find7TV_channel(u.id, cfg.event.kick.raid.originExtendedEmotes));
       }
       display.kappa.show(e, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: c});
      }

      function $sub(cmd)
      {
       if (!cmd.hasOwnProperty('months') || cmd.months === null)
        return;
       if (!cmd.hasOwnProperty('username') || cmd.username === null)
        return;
       if (cmd.months === 1)
       {
        if (!cfg.event.kick.sub.first)
         return;
        display.kappa.show(false, cfg.event.kick.sub.first, {[cVARs.evt.user]: cmd.username});
        return;
       }
       if (!cfg.event.kick.sub.resub)
        return;
       const rs = shared.findInMaybeRange(cfg.event.kick.sub.resub, cmd.months);
       if (rs === false)
        return;
       display.kappa.show(false, rs, {[cVARs.evt.user]: cmd.username, [cVARs.evt.amount]: cmd.months});
      }

      function $gift(cmd)
      {
       if (!cmd.hasOwnProperty('gifter_username') || cmd.gifter_username === null)
        return;
       if (!cmd.hasOwnProperty('gifted_usernames') || cmd.gifted_usernames === null)
        return;
       const mpmgc = cmd.gifted_usernames.length;
       if (mpmgc === 1)
       {
        if (!cfg.event.kick.sub.gift)
         return;
        display.kappa.show(false, cfg.event.kick.sub.gift, {[cVARs.evt.sender]: cmd.gifter_username, [cVARs.evt.user]: cmd.gifted_usernames[0]});
        return;
       }
       if (!cfg.event.kick.sub.giftbomb)
       {
        if (!cfg.event.kick.sub.gift)
         return;
        for (let i = 0; i < mpmgc; i++)
        {
         display.kappa.show(false, cfg.event.kick.sub.gift, {[cVARs.evt.sender]: cmd.gifter_username, [cVARs.evt.user]: cmd.gifted_usernames[i]});
        }
        return;
       }
       const gpb = shared.findInMaybeRange(cfg.event.kick.sub.giftbomb, mpmgc);
       if (gpb === false)
        return;
       display.kappa.show(false, gpb, {[cVARs.evt.sender]: cmd.gifter_username, [cVARs.evt.amount]: mpmgc});
      }

      function $ban(cmd)
      {
       const u = _parseUser(cmd, 'user');
       if (service.parse.ignored(u))
        return;
       display.kappa.show(false, cfg.event.kick.ban, {[cVARs.evt.user]: u.ascii});
      }

      function $timeout(cmd)
      {
       const u = _parseUser(cmd, 'user');
       if (service.parse.ignored(u))
        return;
       if (!cmd.hasOwnProperty('expires_at') || cmd.expires_at === null)
        return;
       const tExp = new Date(cmd.expires_at).getTime();
       const dDur = Math.ceil((tExp - Date.now()) / 1000);
       const r = shared.findInMaybeRange(cfg.event.kick.timeout, dDur);
       if (r === false)
        return;
       display.kappa.show(false, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: dDur});
      }

      function $redeem(title, cmd)
      {
       const u = _parseUser(cmd);
       if (service.parse.ignored(u))
        return;
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('redeem'))
         continue;
        if (!k.redeem.includes(title))
         continue;
        const kC = k.styles;
        if (cmd === false)
        {
         display.kappa.show(false, kC);
         return;
        }
        const a = _handleDuplicates(_eListFromCmd(cmd, 'user_input', true));
        display.kappa.show(a, kC);
        return;
       }
      }

      const $poll = function()
      {
       function $begin(ev)
       {
        if (!cfg.event.kick.poll.begin)
         return;
        if (!ev.title)
         return;
        display.kappa.show(false, cfg.event.kick.poll.begin, {[cVARs.evt.title]: ev.title});
       }

       function $end(ev)
       {
        if (!cfg.event.kick.poll.end)
         return;
        if (!ev.title)
         return;
        let vPoll = 0;
        for (let i = 0, l = ev.options.length; i < l; i++)
        {
         if (!ev.options[i].hasOwnProperty('label') || ev.options[i].label === null)
          continue;
         if (!ev.options[i].hasOwnProperty('votes') || ev.options[i].votes === null)
          continue;
         vPoll = Math.max(vPoll, ev.options[i].votes);
        }
        const rPoll = [];
        for (let i = 0, l = ev.options.length; i < l; i++)
        {
         if (!ev.options[i].hasOwnProperty('label') || ev.options[i].label === null)
          continue;
         if (!ev.options[i].hasOwnProperty('votes') || ev.options[i].votes === null)
          continue;
         if (ev.options[i].votes === vPoll)
          rPoll.push(ev.options[i].label);
        }
        let sPoll = 'None';
        if (rPoll.length > 0)
         sPoll = rPoll.join(' + ');
        display.kappa.show(false, cfg.event.kick.poll.end, {[cVARs.evt.title]: ev.title, [cVARs.evt.result]: sPoll});
       }

       return {
        begin: $begin,
        end: $end
       };
      }();

      const $prediction = function()
      {
       function $begin(ev)
       {
        if (!cfg.event.kick.prediction)
         return;
        if (!cfg.event.kick.prediction.begin)
         return;
        if (!ev.hasOwnProperty('title'))
         return;
        display.kappa.show(false, cfg.event.kick.prediction.begin, {[cVARs.evt.title]: ev.title});
       }

       function $end(ev)
       {
        if (!cfg.event.kick.prediction)
         return;
        if (!cfg.event.kick.prediction.resolved)
         return;
        if (!ev.hasOwnProperty('title'))
         return;
        if (!ev.hasOwnProperty('winning_outcome_id'))
         return;
        if (!ev.hasOwnProperty('outcomes'))
         return;
        let sPrediction = 'None';
        for (let i = 0, l = ev.outcomes.length; i < l; i++)
        {
         if (!ev.outcomes[i].hasOwnProperty('id'))
          continue;
         if (ev.outcomes[i].id !== ev.winning_outcome_id)
          continue;
         if (!ev.outcomes[i].hasOwnProperty('title'))
          continue;
         sPrediction = ev.outcomes[i].title;
         break;
        }
        display.kappa.show(false, cfg.event.kick.prediction.resolved, {[cVARs.evt.title]: ev.title, [cVARs.evt.result]: sPrediction});
       }

       return {
        begin: $begin,
        end: $end
       };
      }();

      return {
       cheer: $cheer,
       raid: $raid,
       sub: $sub,
       gift: $gift,
       ban: $ban,
       timeout: $timeout,
       redeem: $redeem,
       poll: $poll,
       prediction: $prediction
      };
     }();

     class _level
     {
      constructor(cmd)
      {
       this.cmd = cmd;
       this.rFH = 3600000;
      }

      check(rq)
      {
       let r = kick.Access.STRANGER;
       if (this.cmd.hasOwnProperty('gift') && this.cmd.gift.hasOwnProperty('amount') && this.cmd.gift.amount > 0)
        r |= kick.Access.CHEERER;
       if (!this.cmd.hasOwnProperty('sender') || this.cmd.sender === null)
        return (r & rq) !== 0;
       if (this.cmd.sender.hasOwnProperty('identity') && this.cmd.sender.identity !== null && this.cmd.sender.identity.hasOwnProperty('badges') && this.cmd.sender.identity.badges !== null && Array.isArray(this.cmd.sender.identity.badges) && this.cmd.sender.identity.badges.length > 0)
       {
        for (let i = 0, l = this.cmd.sender.identity.badges.length; i < l; i++)
        {
         if (!this.cmd.sender.identity.badges[i].hasOwnProperty('type') || this.cmd.sender.identity.badges[i].type === null)
          continue;
         switch (this.cmd.sender.identity.badges[i].type)
         {
          case 'broadcaster':
           r |= kick.Access.BROADCASTER;
           break;
          case 'moderator':
           r |= kick.Access.MODERATOR;
           break;
          case 'founder':
           r |= kick.Access.FOUNDER;
           break;
          case 'vip':
           r |= kick.Access.VIP;
           break;
          case 'og':
           r |= kick.Access.OG;
           break;
          case 'subscriber':
           r |= kick.Access.SUBSCRIBER;
           break;
          case 'verified':
           r |= kick.Access.VERIFIED;
           break;
          case 'sub_gifter':
           break;
          case 'staff':
           break;
         }
        }
       }
       if ((r & kick.Access.BROADCASTER) === kick.Access.BROADCASTER && (r & kick.Access.SUBSCRIBER) !== 0)
        r &= ~kick.Access.SUBSCRIBER;
       if ((r & rq) !== 0)
        return true;
       if ((rq & kick.Access.FOLLOWER) === 0)
        return false;
       /* api-heavy, only check if follower access is allowed and there's a chance it matters */
       const u = _parseUser(this.cmd);
       if (u.id === 0 || !u._name)
        return (r & rq) !== 0;
       return this._checkFollower(u);
      }

      async _checkFollower(u)
      {
       if (u.id === 0)
        return false;
       if (kick.net.fList.hasOwnProperty(u.id))
       {
        const tDif = Date.now() - kick.net.fList[u.id].t;
        if (tDif < this.rFH)
         return kick.net.fList[u.id].value;
       }
       if (!u._name)
        return false;
       const p = await _getUserProfile(u._name);
       if (p === false)
        return false;
       if (p.follower !== false)
       {
        kick.net.fList[u.id] = {value: true, t: Date.now()};
        return true;
       }
       kick.net.fList[u.id] = {value: false, t: Date.now()};
       return false;
      }
     }

     function _handleDuplicates(a)
     {
      const lA = a.length;
      if (lA < 1)
       return a;
      const r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.url)
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.cheer)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === cSources.scope.user)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.kick && a[i].scope === cSources.scope.channel)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let p = 0; p < cfg.display.extended.priority.length; p++)
      {
       for (let i = 0; i < lA; i++)
       {
        if (a[i].scope === cSources.scope.channel && a[i].svc === cSources.service[cfg.display.extended.priority[p]])
        {
         if (service.parse.notDupe(a[i], r))
          r.push(a[i]);
        }
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.kick && a[i].scope === cSources.scope.global)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let p = 0; p < cfg.display.extended.priority.length; p++)
      {
       for (let i = 0; i < lA; i++)
       {
        if (a[i].scope === cSources.scope.global && a[i].svc === cSources.service[cfg.display.extended.priority[p]])
        {
         if (service.parse.notDupe(a[i], r))
          r.push(a[i]);
        }
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.emoji)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      return r;
     }

     function _eListFromCmd(cmd, attrContent = 'content', dup = null, andCheers = true)
     {
      const r = [];
      const u = _parseUser(cmd);
      if (service.parse.ignored(u))
       return r;
      if (andCheers && cmd.hasOwnProperty('gift') && cmd.gift.hasOwnProperty('amount') && cmd.gift.amount > 0)
       r.push(..._parse.content.kicks(cmd));
      r.push(..._parse.content.kick(cmd, attrContent, dup));
      if (cfg.display.useEmoji)
       r.push(..._parse.content.emoji(cmd, attrContent, dup));
      if (cfg.display.extended.useFFZ)
      {
       r.push(..._parse.content['3rdparty'].ffz.general(cmd, attrContent, dup));
       r.push(..._parse.content['3rdparty'].ffz.user.general(cmd, attrContent, dup));
      }
      if (cfg.display.extended.useBTTV)
      {
       r.push(..._parse.content['3rdparty'].bttv.general(cmd, attrContent, dup));
       r.push(..._parse.content['3rdparty'].bttv.user.general(cmd, attrContent, dup));
      }
      if (cfg.display.extended.use7TV)
      {
       r.push(..._parse.content['3rdparty']['7tv'].general(cmd, attrContent, dup));
       r.push(..._parse.content['3rdparty']['7tv'].user.general(cmd, attrContent, dup));
      }
      if (cfg.display.extended.useFFZ)
      {
       _parse.content['3rdparty'].ffz.zwe(r, cmd, attrContent, 1, dup);
       _parse.content['3rdparty'].ffz.user.zwe(r, cmd, attrContent, 1, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       _parse.content['3rdparty'].bttv.zwe(r, cmd, attrContent, 1, dup);
       _parse.content['3rdparty'].bttv.user.zwe(r, cmd, attrContent, 1, dup);
      }
      if (cfg.display.extended.use7TV)
      {
       _parse.content['3rdparty']['7tv'].zwe(r, cmd, attrContent, 1, dup);
       _parse.content['3rdparty']['7tv'].user.zwe(r, cmd, attrContent, 1, dup);
      }
      if (cfg.display.extended.useFFZ)
      {
       _parse.content['3rdparty'].ffz.zwe(r, cmd, attrContent, 2, dup);
       _parse.content['3rdparty'].ffz.user.zwe(r, cmd, attrContent, 2, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       _parse.content['3rdparty'].bttv.zwe(r, cmd, attrContent, 2, dup);
       _parse.content['3rdparty'].bttv.user.zwe(r, cmd, attrContent, 2, dup);
      }
      if (cfg.display.extended.use7TV)
      {
       _parse.content['3rdparty']['7tv'].zwe(r, cmd, attrContent, 2, dup);
       _parse.content['3rdparty']['7tv'].user.zwe(r, cmd, attrContent, 2, dup);
      }
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.length > 0)
      {
       for (let i = r.length - 1; i >= 0; i--)
       {
        const m = r[i].str;
        if (cfg.ignore.emotes.includes(m))
         r.splice(i, 1);
       }
      }
      const t = Date.now();
      for (let i = 0, l = r.length; i < l; i++)
      {
       r[i].timestamp = t;
       if (r[i].hasOwnProperty('width') || r[i].hasOwnProperty('height'))
        continue;
       if (!r[i].hasOwnProperty('url'))
        continue;
       const sz = shared.ec.get(r[i].url);
       if (sz === null)
        continue;
       r[i].width = sz.width;
       r[i].height = sz.height;
      }
      if (cmd.hasOwnProperty('id'))
      {
       for (let i = 0, l = r.length; i < l; i++)
       {
        r[i].origin = 'kick:' + cmd.id;
       }
      }
      return r;
     }

     return {
      content: $content,
      line: $line,
      event: $event
     };
    }();

    const _findEmote_channel = function()
    {
     const _rCH = 300000;
     const _chList = {};

     async function $c_findEmote_channel(chName, n = false, useHyphen = false)
     {
      if (n === false && _chList.hasOwnProperty(chName))
      {
       const tDif = Date.now() - _chList[chName].t;
       if (tDif < _rCH)
        return _chList[chName].value;
      }
      const slug = useHyphen === true ? chName.replaceAll('_', '-') : chName;
      const url = cURLs.api.kick.emotes.replaceAll(cVARs.url.channelName, encodeURIComponent(slug));
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
      {
       if (r.code === 404 && chName.includes('_'))
        return _findEmote_channel(chName, n, true);
       return [];
      }
      const j = r.json;
      if (j === null)
       return [];
      if (!Array.isArray(j))
       return [];
      const ret = [];
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('id') || j[i].id === null)
        continue;
       if (j[i].id === 'Global')
       {
        _scrapeGlobal(j[i]);
        continue;
       }
       if (j[i].id === 'Emoji')
        continue;
       if (!j[i].hasOwnProperty('emotes') || j[i].emotes === null)
        continue;
       if (!Array.isArray(j[i].emotes))
        continue;
       for (let e = 0, m = j[i].emotes.length; e < m; e++)
       {
        if (cfg.ignore.emotes !== false && j[i].emotes[e].hasOwnProperty('name') && j[i].emotes[e].name !== null && cfg.ignore.emotes.includes(j[i].emotes[e].name))
         continue;
        const eURL = cURLs.cdn.kick.emote.replaceAll(cVARs.url.emoteID, j[i].emotes[e].id);
        if (n !== false && j[i].emotes[e].hasOwnProperty('name') && j[i].emotes[e].name !== null)
        {
         n[j[i].emotes[e].name] = {
          scope: cSources.scope.channel,
          url: eURL,
          id: j[i].emotes[e].id
         };
        }
        ret.push({url: eURL});
       }
       _chList[chName] = {t: Date.now(), value: ret};
      }
      return ret;
     }

     function _scrapeGlobal(d)
     {
      if (!d.hasOwnProperty('emotes') || d.emotes === null)
       return;
      if (!Array.isArray(d.emotes))
       return;
      if (!service.emotes.hasOwnProperty('kick'))
       service.emotes.kick = {};
      for (let e = 0, m = d.emotes.length; e < m; e++)
      {
       if (!d.emotes[e].hasOwnProperty('name') || d.emotes[e].name === null)
        continue;
       if (cfg.ignore.emotes !== false && cfg.ignore.emotes.includes(d.emotes[e].name))
        continue;
       const eURL = cURLs.cdn.kick.emote.replaceAll(cVARs.url.emoteID, d.emotes[e].id);
       service.emotes.kick[d.emotes[e].name] = {
        scope: cSources.scope.global,
        url: eURL,
        id: d.emotes[e].id
       };
      }
     }

     return $c_findEmote_channel;
    }();

    async function _find7TV_channel(chID, cVal)
    {
     if (!cfg.display.extended.use7TV)
      return [];
     const r7TV = await thirdparty['7tv'].channelEx('kick', chID, cVal === 'listed');
     if (r7TV === false)
      return [];
     const e = [];
     for (let i = 0, l = r7TV.length; i < l; i++)
     {
      if ((r7TV[i].vis & thirdparty['7tv'].Modifier.ZWE) === thirdparty['7tv'].Modifier.ZWE)
       continue;
      e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
     }
     return e;
    }

    async function _getUserProfile(dn, retry = true)
    {
     const slug = _usesHyphen === true ? kick.net.oAuth.auth.channel.replaceAll('_', '-') : kick.net.oAuth.auth.channel;
     const url = cURLs.api.kick.users.replaceAll(cVARs.url.channelName, encodeURIComponent(slug)).replaceAll(cVARs.url.user, encodeURIComponent(dn));
     const r = await shared.httpRequest('GET', url);
     if (!r.success)
     {
      if (r.code === 404 && _usesHyphen === 0)
      {
       _usesHyphen = true;
       return _getUserProfile(dn);
      }
      if (retry && r.code === 0 && r.data === '')
       return _getUserProfile(dn, false);
      return false;
     }
     const j = r.json;
     if (j === null)
      return false;
     if (_usesHyphen === 0)
      _usesHyphen = false;
     const ret = {
      id: 0,
      _slug: false,
      _name: false,
      ascii: false,
      follower: false
     };
     if (j.hasOwnProperty('id') && j.id !== null)
      ret.id = j.id;
     if (j.hasOwnProperty('slug') && j.slug !== null)
      ret.slug = j.slug;
     if (j.hasOwnProperty('username') && j.username !== null)
      ret.name = j.username;
     if (j.hasOwnProperty('following_since') && j.following_since !== null)
      ret.follower = j.following_since;
     const gReg = new RegExp(service.parse.uReg, 'g');
     if (!!ret._name && ret._name === ret._name.replaceAll(gReg, ''))
      ret.ascii = ret._name;
     if (!ret.ascii && !!ret._slug)
      ret.ascii = ret._slug;
     if (!ret.ascii)
      ret.ascii = anonName;
     return ret;
    }

    return {
     net: $net,
     Access: Object.freeze({
      STRANGER: 0x001,
      FOLLOWER: 0x002,
      CHEERER: 0x004,
      VERIFIED: 0x008,
      SUBSCRIBER: 0x010,
      OG: 0x040,
      VIP: 0x100,
      FOUNDER: 0x200,
      MODERATOR: 0x400,
      BROADCASTER: 0x800
     })
    };
   }();

   const lfg = function()
   {
    const $net = function()
    {
     let _lastIDCheck = 0;

     const $socket = function()
     {
      let _wsRetry = 0;
      let _ws = null;
      const _msgHistory = {};
      let _lTimeout = 5000;
      let _tTimeout = false;

      async function $c_socket()
      {
       notice.expect |= notice.Connection.LFG;
       if (lfg.net.channelID === 0)
       {
        const chR = await _getChIDs();
        if (chR === null)
        {
         notice.error(notice.Type.LFG_NETWORK);
         notice.active &= ~notice.Connection.LFG;
         notice.resetHide();
         return;
        }
        if (lfg.net.channelID === 0)
        {
         notice.error(notice.Type.LFG_NAME);
         lfg.net.dead = true;
         return;
        }
       }
       _ws = new WebSocket(cURLs.ws.lfg);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
      }

      function _wsClose()
      {
       notice.error(notice.Type.LFG_NETWORK);
       notice.active &= ~notice.Connection.LFG;
       notice.resetHide();
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (lfg.net.dead)
        return;
       const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(lfg.net.socket, wsWait);
      }

      const _wsMessage = function()
      {
       async function $c_wsMessage(ev)
       {
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_ws === null)
         return;
        if (lfg.net.dead)
        {
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         return;
        }
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        _wsRetry = 0;
        let d = ev.data;
        if (d.length === 0)
         return;
        notice.info(notice.Type.LFG_NETWORK);
        notice.active |= notice.Connection.LFG;
        notice.resetHide();
        const dA = d.slice(0, 1);
        d = d.slice(1);
        switch (dA)
        {
         case '0':
          let t = 25000;
          let u = 5000;
          if (d.length > 0)
          {
           const c = JSON.parse(d);
           if (c.hasOwnProperty('pingInterval'))
            t = c.pingInterval;
           if (c.hasOwnProperty('pingTimeout'))
            u = c.pingTimeout;
          }
          _lTimeout = t + u;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
          _ws.send('40');
          break;
         case '2':
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
          _ws.send('3');
          break;
         case '4':
          if (d.length === 0)
           return;
          const dB = d.slice(0, 1);
          d = d.slice(1);
          if (dB === '0')
          {
           await _loadEmote_channel(lfg.net.channelID);
           const cmd = [
            'join_room',
            {
             roomId: lfg.net.channelID,
             roomUsername: lfg.net.oAuth.auth.channel,
             joinerId: 'guest',
             joinerUsername: 'guest'
            }
           ];
           _ws.send('42' + JSON.stringify(cmd));
           return;
          }
          if (dB !== '2')
           return;
          const o = JSON.parse(d);
          if (!Array.isArray(o))
           return;
          if (o.length < 2)
           return;
          if (!cfg.lfg.sharedChat && o[1].hasOwnProperty('sharingWith'))
           return;
          switch (o[0])
          {
           case 'message':
            _ChatMessageEvent(o[1]);
            break;
           case 'event':
            await _Chat_Events(o[1]);
            break;
           case 'special_message':
            await _Chat_Special(o[1]);
            break;
           case 'raided_now':
            await _Chat_Raid.begin(o[1]);
            break;
           case 'user_joined_room':
            _Chat_Raid.join(o[1]);
            break;
           case 'message_deleted':
            _ChatMessageDeleted(o[1]);
            break;
          }
          break;
        }
       }

       function _ChatMessageEvent(jData)
       {
        const u = _parse.user(jData);
        if (jData.hasOwnProperty('id') && jData.id !== null && !!u._slug)
        {
         if (!_msgHistory.hasOwnProperty(u._slug))
          _msgHistory[u._slug] = new Set();
         _msgHistory[u._slug].add(jData.id);
        }
        if (document.visibilityState === 'hidden')
         return;
        _parse.line(jData);
       }

       const _Chat_Events = function()
       {
        const _fHist = new Set();

        async function $c_Chat_Events(jData)
        {
         if (!jData.hasOwnProperty('type') || jData.type === null)
          return;
         if (!jData.hasOwnProperty('payload') || jData.payload === null)
          return;
         const usesBomb = cfg.event.lfg.sub.hasOwnProperty('giftpack') && cfg.event.twitch.sub.giftpack !== false;
         switch (jData.type)
         {
          case 'following_event':
           _ChatFollowEvent(jData.payload);
           return;
          case 'tip_event':
           await _ChatTipEvent(jData.payload);
           break;
          case 'personal_subscription_event':
           _ChatSubEvent(jData.payload);
           await lfg.net.subscribers.addSub(jData.payload);
           break;
          case 'gift_subscription_event':
           _ChatGiftSubEvent(jData.payload);
           await lfg.net.subscribers.addSub(jData.payload);
           break;
          case 'pack_gift_subscription_event':
           if (usesBomb)
            _ChatPackGiftSubEvent(jData.payload);
           break;
          case 'pack_subscription_event':
           if (!usesBomb)
            _ChatGiftSubEvent(jData.payload);
           await lfg.net.subscribers.addSub(jData.payload);
           break;
         }
         if (cfg.event.lfg.hypetrain.begin === false && cfg.event.lfg.hypetrain.end === false)
          return;
         lfg.net.hypetrains();
        }

        function _ChatFollowEvent(jData)
        {
         const kList = Object.keys(jData);
         for (let i = 0; i < kList.length; i++)
         {
          switch (kList[i])
          {
           case 'broadcasterDisplayName':
           case 'broadcasterProfileImage':
           case 'broadcasterUsername':
           case 'content':
           case 'followerDisplayName':
           case 'followerProfileImage':
           case 'followerUsername':
            break;
           default:
            return;
          }
         }
         if (jData.broadcasterUsername !== lfg.net.oAuth.auth.channel)
          return;
         const u = _parse.user(jData);
         if (!u._slug)
          return;
         lfg.net.fList[u._slug] = true;
         if (_fHist.has(u._slug))
          return;
         _fHist.add(u._slug);
         if (document.visibilityState === 'hidden')
          return;
         _parse.event.follow(jData);
        }

        async function _ChatTipEvent(jData)
        {
         if (document.visibilityState === 'hidden')
          return;
         if (await _parse.event.cheer(jData))
          return;
         _parse.line(jData, 'message');
        }

        function _ChatSubEvent(jData)
        {
         if (document.visibilityState === 'hidden')
          return;
         _parse.event.sub(jData);
        }

        function _ChatGiftSubEvent(jData)
        {
         if (document.visibilityState === 'hidden')
          return;
         _parse.event.gift(jData);
        }

        function _ChatPackGiftSubEvent(jData)
        {
         if (document.visibilityState === 'hidden')
          return;
         _parse.event.giftpack(jData);
        }

        return $c_Chat_Events;
       }();

       const _Chat_Special = function()
       {
        async function $c_Chat_Special(jData)
        {
         if (!jData.hasOwnProperty('message') || jData.message === null)
          return;
         if (jData.hasOwnProperty('action') && jData.action !== null)
         {
          switch (jData.action)
          {
           case 'create':
            await _ChatCreateSpecialEvent(jData.message);
            return;
           case 'timeout':
            _ChatTimeoutSpecialEvent(jData.message);
            return;
           case 'ban':
            _ChatBanSpecialEvent(jData.message);
            return;
          }
         }
        }

        async function _ChatCreateSpecialEvent(jData)
        {
         if (document.visibilityState === 'hidden')
          return;
         if (!jData.hasOwnProperty('type') || jData.type === null)
          return;
         switch (jData.type)
         {
          case 'SHOUTOUT':
           await _parse.event.shoutoutCreate(jData);
           return;
         }
        }

        function _ChatTimeoutSpecialEvent(jData)
        {
         const u = _parse.user(jData, true);
         if (!!u._slug && _msgHistory.hasOwnProperty(u._slug))
         {
          for (const mID of _msgHistory[u._slug])
          {
           display.eraseMsg('lfg:' + mID);
          }
          delete _msgHistory[u._slug];
         }
         if (document.visibilityState === 'hidden')
          return;
         _parse.event.timeout(jData);
        }

        function _ChatBanSpecialEvent(jData)
        {
         const u = _parse.user(jData, true);
         if (!!u._slug && _msgHistory.hasOwnProperty(u._slug))
         {
          for (const mID of _msgHistory[u._slug])
          {
           display.eraseMsg('lfg:' + mID);
          }
          delete _msgHistory[u._slug];
         }
         if (document.visibilityState === 'hidden')
          return;
         _parse.event.ban(jData);
        }

        return $c_Chat_Special;
       }();

       const _Chat_Raid = function()
       {
        const _evSpan = 2000;
        let _evList = [];
        let _evU = false;
        let _evT = false;

        async function $begin(jData)
        {
         if (!jData.hasOwnProperty('raiderUser'))
          return;
         const u = _parse.user(jData.raiderUser);
         if (u.id === 0)
          return;
         if (_evU !== false)
         {
          if (_evU.id === u.id)
           return;
          if (_evT !== false)
          {
           window.clearTimeout(_evT);
           _evT = false;
          }
          if (_evList.length > 0)
          {
           if (document.visibilityState !== 'hidden')
            await _parse.event.raid(_evU, _evList.length);
          }
         }
         _evList = [];
         _evU = u;
         _evT = window.setTimeout(_done, _evSpan);
        }

        function $join(jData)
        {
         if (_evT === false)
          return;
         const u = _parse.user(jData);
         if (u.id === 0)
          return;
         if (!_evList.includes(u.id))
          _evList.push(u.id);
         window.clearTimeout(_evT);
         _evT = window.setTimeout(_done, _evSpan);
        }

        async function _done()
        {
         if (_evT === false)
          return;
         _evT = false;
         const u = _evU;
         _evU = false;
         const l = _evList.length;
         _evList = [];
         if (document.visibilityState === 'hidden')
          return;
         await _parse.event.raid(u, l);
        }

        return {
         begin: $begin,
         join: $join
        };
       }();

       function _ChatMessageDeleted(jData)
       {
        if (!jData.hasOwnProperty('messageId'))
         return;
        for (const uSlug in _msgHistory)
        {
         if (!_msgHistory.hasOwnProperty(uSlug))
          continue;
         if (!_msgHistory[uSlug].has(jData.messageId))
          continue;
         _msgHistory[uSlug].delete(jData.messageId);
         break;
        }
        const mID = 'lfg:' + jData.messageId;
        display.eraseMsg(mID);
       }

       return $c_wsMessage;
      }();

      function _wsTimeout()
      {
       if (_lTimeout === 120000)
       {
        notice.error(notice.Type.LFG_NETWORK);
        notice.active &= ~notice.Connection.LFG;
        notice.resetHide();
       }
       else
        _lTimeout = 120000;
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (lfg.net.dead === true)
        return;
       lfg.net.socket();
      }

      return $c_socket;
     }();

     async function $addEmotes(addList)
     {
      const addURLs = Object.keys(addList);
      let doUpdate = false;
      for (let i = 0; i < addURLs.length; i++)
      {
       const addU = addURLs[i];
       const addN = addList[addU];
       const r = await _submitEmote(addU, addN);
       if (!r)
        continue;
       if (r === lfg.net.channelID)
        doUpdate = true;
      }
      if (doUpdate)
       await _loadEmote_channel(lfg.net.channelID);
     }

     async function _loadEmote_channel(chID)
     {
      if (!service.emotes.hasOwnProperty('lfg'))
       service.emotes.lfg = {};
      const r = await _findEmote_channel({id: chID}, service.emotes.lfg);
      if (r.length === 0)
       return false;
      if (service.cList.length === 0)
       service.cList = r;
      else
      {
       for (const n in service.emotes.lfg)
       {
        if (!service.emotes.lfg[n].hasOwnProperty('scope'))
         continue;
        if (service.emotes.lfg[n].scope !== cSources.scope.channel)
         continue;
        for (let c = service.cList.length - 1; c >= 0; c--)
        {
         if (service.cList[c].url !== service.emotes.lfg[n].url)
          continue;
         service.cList.splice(c, 1);
         break;
        }
       }
       for (let i = 0, l = r.length; i < l; i++)
       {
        if (!service.cList.includes(r[i]))
         service.cList.push(r[i]);
       }
      }
      service.syncList();
      return true;
     }

     const $userInfo = function()
     {
      const _hist = {};

      async function $c_userInfo(slug, cache = true)
      {
       if (!!cache && _hist.hasOwnProperty(slug))
       {
        if (Number.isInteger(cache) && Math.floor((Date.now() - _hist[slug].time) / 1000) < cache)
         return _hist[slug];
       }
       const url = cURLs.api.lfg.users.replaceAll(cVARs.url.user, encodeURIComponent(slug));
       const r = await shared.httpRequest('GET', url);
       if (!r.success)
        return false;
       const j = r.json;
       if (j === null)
        return false;
       if (!j.hasOwnProperty('id') || j.id === null)
        return false;
       _hist[slug] = {data: j, time: Date.now()};
       return j;
      }

      return $c_userInfo;
     }();

     async function _getChIDs()
     {
      const jUser = await lfg.net.userInfo(lfg.net.oAuth.auth.channel);
      if (!jUser)
       return false;
      if (!jUser.hasOwnProperty('stream_url'))
       return false;
      if (!jUser.hasOwnProperty('stream_id'))
       return false;
      if (!jUser.hasOwnProperty('id') || jUser.id === null)
       return false;
      if (jUser.stream_url === null && jUser.stream_id === null)
      {
       notice.error(notice.Type.LFG_NETWORK);
       notice.error(notice.Type.LFG_ACCOUNT);
       lfg.net.oAuth.clear(true);
       lfg.net.dead = true;
       return null;
      }
      lfg.net.channelID = jUser.id;
      if (jUser.stream_id === null)
       lfg.net.streamID = 0;
      else
       lfg.net.streamID = jUser.stream_id;
      _lastIDCheck = Date.now();
      return true;
     }

     const $followers = function()
     {
      let _uLast = 0;
      const _uCache = 30000;

      async function $c_followers()
      {
       if (lfg.net.dead === true)
        return;
       if (Date.now() - _uLast < _uCache)
        return;
       const fRet = await _getChange();
       if (fRet === false)
        return;
       _uLast = Date.now();
       const aList = [];
       for (let i = 0; i < fRet.length; i++)
       {
        const u = _parse.user(fRet[i]);
        if (!u._slug)
         continue;
        aList.push(u._slug);
        if (!lfg.net.fList.hasOwnProperty(u._slug) || lfg.net.fList[u._slug] === false || typeof lfg.net.fList[u._slug] !== 'boolean')
         lfg.net.fList[u._slug] = true;
       }
       for (const slug in lfg.net.fList)
       {
        if (aList.includes(slug))
         continue;
        lfg.net.fList[slug] = false;
       }
      }

      async function _getChange(pg = 0)
      {
       const url = cURLs.api.lfg.followers.replaceAll(cVARs.url.channelName, encodeURIComponent(lfg.net.oAuth.auth.channel)).replaceAll(cVARs.url.page, encodeURIComponent(pg));
       const r = await shared.httpRequest('GET', url);
       if (!r.success)
        return false;
       const j = r.json;
       if (j === null)
        return false;
       if (!j.hasOwnProperty('data') || j.data === null)
        return false;
       if (!j.hasOwnProperty('total_rows') || j.total_rows === null)
        return false;
       if (!j.hasOwnProperty('returned_rows') || j.returned_rows === null)
        return false;
       if (pg > 0)
        return j.data;
       if (j.total_rows <= j.returned_rows)
        return j.data;
       const ret = [];
       ret.push(...j.data);
       for (let i = j.returned_rows; i < j.total_rows; i += j.returned_rows)
       {
        const rPg = await _getChange(i);
        if (rPg === false)
         return ret;
        ret.push(...rPg);
       }
       return ret;
      }

      return $c_followers;
     }();

     const $subscribers = function()
     {
      const _sCache = {};
      const _uCache = 3600000;

      async function $checkSub(u)
      {
       if (_sCache.hasOwnProperty(u._slug))
       {
        if (Date.now() < _sCache[u._slug].expires)
         return _sCache[u._slug].level;
       }
       const url = cURLs.api.lfg.subscribed.replaceAll(cVARs.url.channelName, encodeURIComponent(lfg.net.oAuth.auth.channel)).replaceAll(cVARs.url.user, encodeURIComponent(u._slug));
       const r = await shared.httpRequest('GET', url);
       if (!r.success)
       {
        _sCache[u._slug] = {created: 0, expires: 0, level: 0};
        return 0;
       }
       const j = r.json;
       if (j === null)
       {
        _sCache[u._slug] = {created: 0, expires: 0, level: 0};
        return 0;
       }
       if (!j.hasOwnProperty('is_subscribed'))
       {
        _sCache[u._slug] = {created: 0, expires: 0, level: 0};
        return 0;
       }
       let bgn = Date.now();
       let exp = Date.now() + _uCache;
       if (j.is_subscribed !== true)
       {
        _sCache[u._slug] = {created: bgn, expires: exp, level: 0};
        return 0;
       }
       if (j.hasOwnProperty('expires_datetime'))
        exp = new Date(j.expires_datetime).getTime();
       if (j.hasOwnProperty('created_datetime'))
        bgn = new Date(j.created_datetime).getTime();
       if (!j.hasOwnProperty('subscription_level') || j.subscription_level === null)
       {
        _sCache[u._slug] = {created: bgn, expires: exp, level: 0};
        return 0;
       }
       _sCache[u._slug] = {created: bgn, expires: exp, level: j.subscription_level};
       return j.subscription_level;
      }

      async function $addSub(cmd)
      {
       const u = _parse.user(cmd, true);
       if (!u._slug)
        return;
       await lfg.net.subscribers.checkSub(u);
      }

      return {
       checkSub: $checkSub,
       addSub: $addSub
      };
     }();

     const $hypetrains = function()
     {
      let _tPrev = null;
      let  _tS = false;
      const _rSC = 15000;

      function $c_hypetrains()
      {
       if (_tS !== false)
        window.clearTimeout(_tS);
       _tS = window.setTimeout(_detect, Math.floor(_rSC / 3));
      }

      async function _detect()
      {
       if (_tS === false)
        return;
       window.clearTimeout(_tS);
       _tS = false;
       if (lfg.net.dead === true)
        return;
       if (lfg.net.streamID === 0 || Date.now() - _lastIDCheck > 300000)
       {
        const chR = await _getChIDs();
        if (chR === null)
        {
         notice.error(notice.Type.LFG_NETWORK);
         notice.active &= ~notice.Connection.LFG;
         notice.resetHide();
         return;
        }
        if (lfg.net.streamID === 0)
        {
         _tS = window.setTimeout(_detect, _rSC);
         return;
        }
       }
       const tRet = await _getTrain();
       let tTick = false;
       if (tRet.ends !== false)
       {
        if (tRet.ends > 10)
         tTick = tRet.ends - 5;
        else if (tRet.ends > 5)
         tTick = tRet.ends - 2;
        else if (tRet.ends > 1)
         tTick = tRet.ends;
        else
         tTick = tRet.ends + 2;
       }
       if (_tPrev === null)
       {
        _tPrev = tRet.level;
        if (tTick !== false)
         _tS = window.setTimeout(_detect, Math.floor(tTick * 1000));
        return;
       }
       if (_tPrev !== false)
       {
        if (tRet.level === false)
        {
         _end(_tPrev);
         _tPrev = false;
        }
        else
         _tPrev = tRet.level;
        if (tTick !== false)
         _tS = window.setTimeout(_detect, tTick * 1000);
        return;
       }
       if (tRet.level !== false)
       {
        _begin();
        _tPrev = tRet.level;
       }
       if (tTick !== false)
        _tS = window.setTimeout(_detect, tTick * 1000);
      }

      async function _getTrain()
      {
       const url = cURLs.api.lfg.hypetrains.replaceAll(cVARs.url.streamID, encodeURIComponent(lfg.net.streamID));
       const r = await shared.httpRequest('GET', url);
       if (!r.success)
        return {level: false, ends: false};
       const j = r.json;
       if (j === null)
        return {level: false, ends: false};
       if (!j.hasOwnProperty('active') || j.active !== true)
        return {level: false, ends: false};
       if (!j.hasOwnProperty('hype_train') || j.hype_train === null)
        return {level: false, ends: false};
       if (!j.hype_train.hasOwnProperty('status') || j.hype_train.status !== 'active')
        return {level: false, ends: false};
       let retry = false;
       if (j.hasOwnProperty('time_remaining_seconds') && j.time_remaining_seconds !== null)
        retry = j.time_remaining_seconds;
       if (!j.hype_train.hasOwnProperty('current_level') || j.hype_train.current_level === null)
        return {level: false, ends: retry};
       if (j.hype_train.current_level === 0)
        return {level: false, ends: retry};
       if (j.hype_train.hasOwnProperty('current_progress') && j.hype_train.current_progress === 10000)
        return {level: j.hype_train.current_level, ends: retry};
       return {level: j.hype_train.current_level - 1, ends: retry};
      }

      function _begin()
      {
       if (!cfg.event.lfg.hypetrain)
        return;
       if (!cfg.event.lfg.hypetrain.begin)
        return;
       if (document.visibilityState === 'hidden')
        return;
       display.kappa.show(false, cfg.event.lfg.hypetrain.begin);
      }

      function _end(lv)
      {
       if (!cfg.event.lfg.hypetrain)
        return;
       if (!cfg.event.lfg.hypetrain.success)
        return;
       if (document.visibilityState === 'hidden')
        return;
       if (lv < 1)
        return;
       const rs = shared.findInMaybeRange(cfg.event.lfg.hypetrain.success, lv);
       if (rs === false)
        return;
       display.kappa.show(false, rs);
      }

      return $c_hypetrains;
     }();

     const $oAuth = function()
     {
      function $init()
      {
       if (cfg.lfg.hasOwnProperty('channel') && cfg.lfg.channel === null)
       {
        loginL.inUse = false;
        _populateAuth();
        return;
       }
       if (cfg.lfg.hasOwnProperty('channel') && cfg.lfg.channel !== null && cfg.lfg.channel !== false && cfg.lfg.channel !== 'CHANNEL_NAME')
       {
        loginL.inUse = false;
        _populateAuth(cfg.lfg.channel);
        return;
       }
       loginL.inUse = true;
       const lsChannel = shared.storage.getItem(loginL.path() + '.channel');
       if (lsChannel === null)
       {
        _populateAuth();
        return;
       }
       _populateAuth(lsChannel);
      }

      function $clear()
      {
       _populateAuth();
       shared.storage.removeItem(loginL.path() + '.channel');
      }

      function _populateAuth(c = null)
      {
       lfg.net.oAuth.auth.time = Date.now();
       if (c === null)
       {
        lfg.net.oAuth.auth.channel = false;
        return;
       }
       lfg.net.oAuth.auth.channel = c;
      }

      function _cfgVals()
      {
       let r = 0;
       if (lfg.net.oAuth.auth.channel !== false)
        r |= shared.cfgVal.CHANNEL;
       return r;
      }

      return {
       init: $init,
       clear: $clear,
       get hasLogin() {return (_cfgVals() & shared.cfgVal.CHANNEL) === shared.cfgVal.CHANNEL;},
       auth: {
        channel: false,
        time: 0
       }
      };
     }();

     return {
      channelID: 0,
      streamID: 0,
      sckID: false,
      fList: {},
      dead: false,
      socket: $socket,
      addEmotes: $addEmotes,
      userInfo: $userInfo,
      followers: $followers,
      subscribers: $subscribers,
      hypetrains: $hypetrains,
      oAuth: $oAuth
     };
    }();

    const _parse = function()
    {
     const $parseUser = function()
     {
      const _uuu = 'https://lfgtv-storage.nyc3.cdn.digitaloceanspaces.com/users/';
      const _uul = 36;

      function $c_parseUser(cmd, recipient = false)
      {
       const ret = {
        id: 0,
        _slug: false,
        _name: false,
        ascii: false
       };
       if (recipient)
       {
        if (!!cmd.metadata && !!cmd.metadata.targetUsername)
         _getUserFrom(ret, cmd.metadata, 'targetUsername');
       }
       else
       {
        if (!!cmd.gifterUsername)
         _getUserFrom(ret, cmd, 'gifterUsername', 'gifterDisplayName', false, 'gifterProfileImage');
       }
       if (!ret._slug && !!cmd.followerUsername)
        _getUserFrom(ret, cmd, 'followerUsername', 'followerDisplayName', false, 'followerProfileImage');
       if (!ret._slug && !!cmd.subscriberUsername)
        _getUserFrom(ret, cmd, 'subscriberUsername', 'subscriberDisplayName', false, 'subscriberProfileImage');
       if (!ret._slug && !!cmd.user && !!cmd.user.username)
        _getUserFrom(ret, cmd.user, 'username', 'display_name', 'id', 'profile_image_url');
       if (!ret._slug && !!cmd.username)
        _getUserFrom(ret, cmd, 'username', 'display_name', 'id', 'profile_image_url');
       if (!ret._slug && !!cmd.sender && typeof cmd.sender === 'string')
        _getUserFrom(ret, cmd, 'sender', 'senderDisplayName', 'senderId', 'senderImageUrl');
       if (!ret._slug && !!cmd.senderUsername)
        _getUserFrom(ret, cmd, 'senderUsername', 'senderDisplayName', false, 'senderProfileImage');
       const gReg = new RegExp(service.parse.uReg, 'g');
       if (!!ret._name && ret._name === ret._name.replaceAll(gReg, ''))
        ret.ascii = ret._name;
       if (!ret.ascii && !!ret._slug)
        ret.ascii = ret._slug;
       if (!ret.ascii)
        ret.ascii = anonName;
       return ret;
      }

      function _getUserFrom(ret, obj, slugOrName, name = false, id = false, img = false)
      {
       ret._slug = obj[slugOrName].trim().toLowerCase();
       if (!!name && !!obj[name])
        ret._name = obj[name];
       if (!ret._name)
        ret._name = obj[slugOrName].trim();
       if (!!id && !!obj[id])
        ret.id = obj[id];
       if (ret.id === 0 && !!img && !!obj[img] && obj[img].slice(0, _uuu.length) === _uuu)
        ret.id = obj[img].slice(_uuu.length, _uuu.length + _uul);
      }

      return $c_parseUser;
     }();

     const $content = function()
     {
      function $emoji(cmd, attrContent, dup = null)
      {
       if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
        return [];
       const msg = cmd[attrContent];
       return service.parse.content.emoji(msg, dup);
      }

      function $lfg(cmd, dup = null)
      {
       if (!cmd.hasOwnProperty('parsedContent') || cmd.parsedContent === null)
        return [];
       if (!cmd.parsedContent.hasOwnProperty('segments') || cmd.parsedContent.segments === null)
        return [];
       const m = cmd.parsedContent.segments;
       if (dup === null)
        dup = cfg.display.duplicates;
       if (dup === false)
        dup = 1;
       const ret = [];
       if (m.length === 0)
        return [];
       const ids = [];
       let idx = 0;
       const addList = {};
       for (let i = 0, n = m.length; i < n; i++)
       {
        if (m[i].type !== 'emote')
        {
         if (!m[i].hasOwnProperty('content'))
          continue;
         idx += m[i].content.length;
         continue;
        }
        const sName = m[i].content;
        idx += sName.length;
        if (dup !== true)
        {
         let ct = 0;
         for (let j = 0, l = ids.length; j < l; j++)
         {
          if (ids[j] === sName)
           ct++;
         }
         if (ct >= dup)
          continue;
        }
        const sURL = m[i].emoteUrl;
        addList[sURL] = sName;
        ret.push({svc: cSources.service.lfg, url: sURL, str: sName, pos: idx, scope: cSources.scope.user});
       }
       window.setTimeout(lfg.net.addEmotes, 1000, addList);
       return ret;
      }

      function $coins(cmd)
      {
       const p = [];
       if (!cmd.hasOwnProperty('tip'))
        return p;
       if (cmd.tip < 1)
        return p;
       if (!cmd.hasOwnProperty('coins'))
        return p;
       let idx = 0;
       if (cmd.hasOwnProperty('message') && cmd.message !== '')
        idx = cmd.message.length;
       for (let i = 0; i < cmd.coins.length; i++)
       {
        if (!cmd.coins[i].hasOwnProperty('denomination') || cmd.coins[i].denomination === null)
         continue;
        if (!cmd.coins[i].hasOwnProperty('quantity') || cmd.coins[i].quantity === null || cmd.coins[i].quantity < 1)
         continue;
        const cK = _k(cmd.coins[i].denomination);
        const imgPath = cURLs.cdn.lfg.coin.replace(cVARs.url.emoteID, cK);
        for (let c = 0; c < cmd.coins[i].quantity; c++)
        {
         const cName = 'C' + cK;
         p.push({svc: cSources.service.cheer, url: imgPath, str: cName, pos: idx, scope: null});
         idx += cName.length;
        }
       }
       return p;
      }

      function _k(n)
      {
       const v = parseInt(n, 10);
       if (v < 1000)
        return '' + v;
       return Math.floor(n / 1000) + 'k';
      }

      return {
       emoji: $emoji,
       lfg: $lfg,
       coins: $coins
      };
     }();

     const $line = function()
     {
      async function $c_line(cmd, attrContent = 'content', andCheers = true)
      {
       const u = _parse.user(cmd);
       if (service.parse.ignored(u))
        return;
       if (!cmd.hasOwnProperty(attrContent) || cmd[attrContent] === null || cmd[attrContent] === '')
        return;
       const lvChk = new _level(cmd);
       if (await _parseCommand(cmd, attrContent, lvChk))
        return;
       const p = _handleDuplicates(_eListFromCmd(cmd, attrContent, null, andCheers));
       if (p.length === 0)
        return;
       if (!(await lvChk.check(cfg.display.access)))
        return;
       display.emote.addToShowList(p);
       display.emote.showEmotes();
      }

      function _parseCommand(cmd, attrContent, lvChk)
      {
       const m = cmd[attrContent].toLowerCase();
       const a = _handleDuplicates(_eListFromCmd(cmd, attrContent, true));
       let mID = false;
       if (cmd.hasOwnProperty('id'))
        mID = 'lfg:' + cmd.id;
       return service.parse.line.parseCommand(m, lvChk, a, mID);
      }

      return $c_line;
     }();

     const $event = function()
     {
      async function $cheer(cmd)
      {
       if (!cfg.event.lfg.cheer)
        return false;
       if (!cfg.event.lfg.cheer.coins)
        return false;
       const u = _parse.user(cmd);
       if (service.parse.ignored(u))
        return false;
       if (!cmd.hasOwnProperty('coins'))
        return false;
       if (!cmd.hasOwnProperty('tip'))
        return false;
       if (cmd.tip < 1)
        return false;
       let p = [];
       if (cfg.event.lfg.cheer.useMsg)
       {
        const a = _eListFromCmd(cmd, 'message');
        p.push(...a);
       }
       else
       {
        const b = _parse.content.coins(cmd);
        p.push(...b);
        await _parse.line(cmd, 'message', false);
       }
       p = _handleDuplicates(p);
       if (p.length === 0)
        return false;
       const r = shared.findInMaybeRange(cfg.event.lfg.cheer.coins, cmd.tip);
       if (r === false)
       {
        display.emote.addToShowList(p);
        display.emote.showEmotes();
        return true;
       }
       display.kappa.show(p, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: cmd.tip});
       return true;
      }

      async function $raid(u, count)
      {
       if (!cfg.event.lfg.raid)
        return;
       if (!cfg.event.lfg.raid.raiders)
        return;
       if (service.parse.ignored(u))
        return;
       const r = shared.findInMaybeRange(cfg.event.lfg.raid.raiders, count);
       if (r === false)
        return;
       if (!cfg.event.lfg.raid.originEmotes)
       {
        display.kappa.show(false, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: count});
        return;
       }
       const e = await _findEmote_channel(u);
       display.kappa.show(e, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: count});
      }

      function $follow(cmd)
      {
       if (!cfg.event.lfg.follow)
        return;
       const u = _parse.user(cmd);
       if (service.parse.ignored(u))
        return;
       display.kappa.show(false, cfg.event.lfg.follow, {[cVARs.evt.user]: u.ascii});
      }

      function $sub(cmd)
      {
       if (!cfg.event.lfg.sub)
        return;
       if (!cfg.event.lfg.sub.pass)
        return;
       const u = _parse.user(cmd);
       if (service.parse.ignored(u))
        return;
       display.kappa.show(false, cfg.event.lfg.sub.pass, {[cVARs.evt.user]: u.ascii});
      }

      function $gift(cmd)
      {
       if (!cfg.event.lfg.sub)
        return;
       if (!cfg.event.lfg.sub.gift)
        return;
       const uFrom = _parse.user(cmd);
       const uTo = _parse.user(cmd, true);
       if (service.parse.ignored(uFrom))
        return;
       display.kappa.show(false, cfg.event.lfg.sub.gift, {[cVARs.evt.sender]: uFrom.ascii, [cVARs.evt.user]: uTo.ascii});
      }

      function $giftpack(cmd)
      {
       if (!cfg.event.lfg.sub)
        return;
       if (!cfg.event.lfg.sub.giftpack)
        return;
       if (!cmd.hasOwnProperty('amount') || cmd.amount === null)
        return;
       const u = _parse.user(cmd);
       if (service.parse.ignored(u))
        return;
       const gpb = shared.findInMaybeRange(cfg.event.lfg.sub.giftpack, cmd.amount);
       if (gpb === false)
        return;
       display.kappa.show(false, gpb, {[cVARs.evt.sender]: u.ascii, [cVARs.evt.amount]: cmd.amount});
      }

      function $timeout(cmd)
      {
       if (!cfg.event.lfg.timeout)
        return;
       const u = _parse.user(cmd, true);
       if (u.id === 0 && !u._slug && !u._name)
        return;
       if (service.parse.ignored(u))
        return;
       const dDur = cmd.metadata.duration;
       const r = shared.findInMaybeRange(cfg.event.lfg.timeout, dDur);
       if (r === false)
        return;
       display.kappa.show(false, r, {[cVARs.evt.user]: u.ascii, [cVARs.evt.amount]: dDur});
      }

      function $ban(cmd)
      {
       if (!cfg.event.lfg.ban)
        return;
       const u = _parse.user(cmd, true);
       if (service.parse.ignored(u))
        return;
       display.kappa.show(false, cfg.event.lfg.ban, {[cVARs.evt.user]: u.ascii});
      }

      const $shoutoutCreate = function()
      {
       const _hist = {};
       const _soLimit = 3600000;

       async function $c_shoutoutCreate(cmd)
       {
        const u = _parse.user(cmd, true);
        if (!u._slug)
         return;
        if (_hist.hasOwnProperty(u._slug))
        {
         const lastSO = _hist[u._slug];
         if (Date.now() - lastSO < _soLimit)
          return;
        }
        const jUser = await lfg.net.userInfo(u._slug, 1800);
        let dn = u.ascii;
        if (!!jUser && jUser.hasOwnProperty('display_name'))
         dn = jUser.display_name;
        if (!cfg.event.lfg.shoutout)
         return;
        if (!cfg.event.lfg.shoutout.create)
         return;
        if (!cfg.event.lfg.shoutout.create.styles)
         return;
        _hist[u._slug] = Date.now();
        if (!cfg.event.lfg.shoutout.create.targetEmotes)
        {
         display.kappa.show(false, cfg.event.lfg.shoutout.create.styles, {[cVARs.evt.user]: dn});
         return;
        }
        const e = await _findEmote_channel(u);
        display.kappa.show(e, cfg.event.lfg.shoutout.create.styles, {[cVARs.evt.user]: dn});
       }

       return $c_shoutoutCreate;
      }()

      return {
       cheer: $cheer,
       raid: $raid,
       follow: $follow,
       sub: $sub,
       gift: $gift,
       giftpack: $giftpack,
       timeout: $timeout,
       ban: $ban,
       shoutoutCreate: $shoutoutCreate
      };
     }();

     class _level
     {
      constructor(cmd)
      {
       this.cmd = cmd;
       this.rFH = 3600000;
      }

      async check(rq)
      {
       let r = lfg.Access.STRANGER;
       if (this.cmd.hasOwnProperty('role'))
       {
        switch (this.cmd.role)
        {
         case 'BROADCASTER':
          r |= lfg.Access.BROADCASTER;
          break;
         case 'MODERATOR':
          r |= lfg.Access.MODERATOR;
          break;
         case 'VIP':
          r |= lfg.Access.VIP;
          break;
        }
       }
       else
       {
        if (this.cmd.hasOwnProperty('broadcasterUsername') && this.cmd.hasOwnProperty('senderUsername') && this.cmd.broadcasterUsername === this.cmd.senderUsername)
         r |= lfg.Access.BROADCASTER;
       }
       if (this.cmd.hasOwnProperty('coins') && this.cmd.hasOwnProperty('tip'))
        r |= lfg.Access.CHEERER;
       if ((r & rq) !== 0)
        return true;
       if ((rq & lfg.Access.FOLLOWER) === 0 && (rq & lfg.Access.SUBSCRIBER) === 0)
        return false;
       const u = _parse.user(this.cmd);
       if (!u._slug)
        return false;
       /* api-heavy, only check if follower access is allowed and there's a chance it matters */
       if ((rq & lfg.Access.FOLLOWER) !== 0)
       {
        const oF = await this._checkFollower(u);
        if (oF !== false)
         return oF;
       }
       if ((rq & lfg.Access.SUBSCRIBER) !== 0)
       {
        const oS = await _level._checkSub(u);
        if ((rq & oS) !== 0)
         return true;
       }
       return false;
      }

      async _checkFollower(u)
      {
       if (lfg.net.fList.hasOwnProperty(u._slug))
       {
        const tDif = Date.now() - lfg.net.fList[u._slug].t;
        if (tDif < this.rFH)
         return lfg.net.fList[u._slug].value;
       }
       await lfg.net.followers();
       if (!lfg.net.fList.hasOwnProperty(u._slug))
        return false;
       return lfg.net.fList[u._slug].value;
      }

      static async _checkSub(u)
      {
       const sub = await lfg.net.subscribers.checkSub(u);
       if (sub === 0)
        return 0;
       return lfg.Access.SUBSCRIBER;
      }
     }

     function _handleDuplicates(a)
     {
      const lA = a.length;
      if (lA < 1)
       return a;
      const r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.url)
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.cheer)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === cSources.scope.user)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.lfg && a[i].scope === cSources.scope.channel)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let p = 0; p < cfg.display.extended.priority.length; p++)
      {
       for (let i = 0; i < lA; i++)
       {
        if (a[i].scope === cSources.scope.channel && a[i].svc === cSources.service[cfg.display.extended.priority[p]])
        {
         if (service.parse.notDupe(a[i], r))
          r.push(a[i]);
        }
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.lfg && a[i].scope === cSources.scope.global)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let p = 0; p < cfg.display.extended.priority.length; p++)
      {
       for (let i = 0; i < lA; i++)
       {
        if (a[i].scope === cSources.scope.global && a[i].svc === cSources.service[cfg.display.extended.priority[p]])
        {
         if (service.parse.notDupe(a[i], r))
          r.push(a[i]);
        }
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.emoji)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      return r;
     }

     function _eListFromCmd(cmd, attrContent = 'content', dup = null, andCheers = true)
     {
      const r = [];
      const u = _parse.user(cmd);
      if (service.parse.ignored(u))
       return r;
      if (andCheers && cmd.hasOwnProperty('tip') && cmd.tip > 0)
       r.push(..._parse.content.coins(cmd));
      r.push(..._parse.content.lfg(cmd, dup));
      if (cfg.display.useEmoji)
       r.push(..._parse.content.emoji(cmd, attrContent, dup));
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.length > 0)
      {
       for (let i = r.length - 1; i >= 0; i--)
       {
        const m = r[i].str;
        if (cfg.ignore.emotes.includes(m))
         r.splice(i, 1);
       }
      }
      const t = Date.now();
      for (let i = 0, l = r.length; i < l; i++)
      {
       r[i].timestamp = t;
       if (r[i].hasOwnProperty('width') || r[i].hasOwnProperty('height'))
        continue;
       if (!r[i].hasOwnProperty('url'))
        continue;
       const sz = shared.ec.get(r[i].url);
       if (sz === null)
        continue;
       r[i].width = sz.width;
       r[i].height = sz.height;
      }
      if (cmd.hasOwnProperty('id'))
      {
       for (let i = 0, l = r.length; i < l; i++)
       {
        r[i].origin = 'lfg:' + cmd.id;
       }
      }
      return r;
     }

     return {
      user: $parseUser,
      userRole: Object.freeze({
       sender: Symbol(),
       recipient: Symbol(),
       any: Symbol()
      }),
      content: $content,
      line: $line,
      event: $event,
      uReg: /[^A-Za-z0-9_]/
     };
    }();

    async function _findEmote_channel(u, n = false)
    {
     if (u.id === 0)
      u.id = await _getUserID(u);
     const url = cURLs.api.lfg.emotes;
     const b = 'uid=' + encodeURIComponent(u.id);
     const r = await shared.httpRequest('POST', url, {}, b, false);
     if (!r.success)
      return [];
     const j = r.json;
     if (j === null)
      return [];
     if (!Array.isArray(j))
      return [];
     const ret = [];
     for (let i = 0, l = j.length; i < l; i++)
     {
      if (!j[i].hasOwnProperty('id'))
       continue;
      if (!j[i].hasOwnProperty('name'))
       continue;
      if (!j[i].hasOwnProperty('type'))
       continue;
      if (!j[i].hasOwnProperty('uid'))
       continue;
      const ext = j[i].type;
      if (!cURLs.cdn.lfg.emote.hasOwnProperty(ext))
       continue;
      const iURL = cURLs.cdn.lfg.emote[ext].replaceAll(cVARs.url.userID, j[i].uid).replaceAll(cVARs.url.emoteID, j[i].id);
      ret.push({url: iURL});
      if (n === false)
       continue;
      n[j[i].name] = {
       scope: cSources.scope.channel,
       url: iURL,
       id: j[i].id
      };
     }
     return ret;
    }

    const _submitEmote = function()
    {
     const _hist = {};

     async function $c_submitEmote(eURL, eName)
     {
      if (_hist.hasOwnProperty(eURL) && _hist[eURL].name === eName && Date.now() - _hist[eURL].time < 21600000)
       return false;
      _hist[eURL] = {name: eName, time: Date.now()};
      const url = cURLs.api.lfg.emotes;
      const b = 'url=' + encodeURIComponent(eURL) + '&name=' + encodeURIComponent(eName);
      const r = await shared.httpRequest('POST', url, {}, b, false);
      if (!r.success)
       return false;
      if (!r.json)
       return false;
      return r.json.result;
     }

     return $c_submitEmote;
    }();

    async function _getUserID(u)
    {
     let un = false;
     if (!!u._slug)
      un = u._slug;
     if (!!u._name)
      un = u._name.toLowerCase();
     if (!un)
      return false;
     const jUser = await lfg.net.userInfo(un);
     if (!jUser)
      return false;
     return jUser.id;
    }

    return {
     net: $net,
     Access: Object.freeze({
      STRANGER: 0x001,
      FOLLOWER: 0x002,
      CHEERER: 0x004,
      SUBSCRIBER: 0x010,
      VIP: 0x100,
      MODERATOR: 0x400,
      BROADCASTER: 0x800
     })
    };
   }();

   const service = function()
   {
    const $parse = function()
    {
     let _aLast = {};

     const $content = function()
     {
      const $emoji = function()
      {
       let _lastF = 0;
       let _lastC = 0;

       function $c_emoji(msg, dup = null)
       {
        if (!service.emotes.hasOwnProperty('emoji'))
         return [];
        const emSeg = /((?:[\p{EPres}\p{ExtPict}]\ufe0f?\u200d?)+)+/gu;
        const emList = [];
        let match = null;
        while ((match = emSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        const kcSeg = /((?:[0-9#\*]\ufe0f?\u20e3)+)+/gu;
        match = null;
        while ((match = kcSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        const acSeg = /(\u0d9e)/gu;
        match = null;
        while ((match = acSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        if (emList.length === 0)
         return [];
        if (dup === null)
         dup = cfg.display.duplicates;
        const addList = {};
        const rets = [];
        for (let i = 0, l = emList.length; i < l; i++)
        {
         rets.push(..._parseEm(addList, emList[i], dup));
        }
        return rets;
       }

       function _parseEm(addList, emI, dup = null)
       {
        const ret = [];
        const cpList = [];
        for (const c of emI[0])
        {
         const p = c.codePointAt(0).toString(16).padStart(4, '0');
         if (cpList.length === 0)
         {
          cpList.push(p);
          continue;
         }
         const lL = cpList.length - 1;
         if (p === 'fe0f')
          cpList[lL] += '-' + p;
         else if (p === '200d')
          cpList[lL] += '-' + p;
         else if (p === '20e3')
          cpList[lL] += '-' + p;
         else if (p.match(/1f3f[b-f]/))
          cpList[lL] += '-' + p;
         else if (p.match(/1f9b[0-3]/))
         {
          if (cpList[lL].slice(-5) === '-200d')
           cpList[lL] += '-' + p;
          else
           cpList[lL] += '-200d-' + p;
         }
         else if (p.match(/264[0|2]/) || p.match(/26a7/))
         {
          if (cpList[lL].slice(-5) === '-200d')
           cpList[lL] += '-' + p;
          else
           cpList[lL] += '-200d-' + p;
         }
         else if (p.match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].length < 11)
          cpList[lL] += '-' + p;
         else if (p === '1f308' && cpList[lL] === '1f3f3-fe0f')
          cpList[lL] += '-200d-' + p;
         else if (p === '2620' && cpList[lL] === '1f3f4')
          cpList[lL] += '-200d-' + p;
         else if (cpList[lL].slice(-5) === '-200d')
          cpList[lL] += '-' + p;
         else
          cpList.push(p);
        }
        let pos = emI.index;
        for (let j = 0, lP = cpList.length; j < lP; j++)
        {
         const s = cpList[j];
         if (s === cCrew.id)
         {
          const rC = _showCrew(addList, pos, dup);
          if (rC !== false)
           ret.push(rC);
          pos += s.replaceAll(/[^-]/g, '').length + 1;
          continue;
         }
         const rE = _showEmoji(addList, s, pos, dup);
         if (rE !== false)
          ret.push(rE);
         pos += s.replaceAll(/[^-]/g, '').length + 1;
        }
        return ret;
       }

       function _anyFont()
       {
        let base = 30;
        if (typeof cfg.display.useEmoji === 'string' && cfg.display.useEmoji.slice(0, 7) === 'rotate:')
         base = parseInt(cfg.display.useEmoji.slice(7), 10);
        if (!Number.isInteger(base))
         base = 30;
        if (base < 1)
         base = 30;
        const rot = base * 60 * 1000;
        const tNow = Date.now();
        if (_lastC < tNow - rot)
        {
         _lastF = shared.rnd(thirdparty.emoji_fonts.length);
         _lastC = tNow;
        }
        return _lastF;
       }

       function _showEmoji(addList, c, p, dup = null)
       {
        if (!service.emotes.emoji.hasOwnProperty(c))
         return false;
        const e = service.emotes.emoji[c];
        let sURL = e.url;
        if (typeof cfg.display.useEmoji === 'string')
        {
         if (cfg.display.useEmoji === 'rotate' || cfg.display.useEmoji.slice(0, 7) === 'rotate:')
          sURL = sURL.replaceAll(cVARs.url.setID, thirdparty.emoji_fonts[_anyFont()]);
         else if (cfg.display.useEmoji === 'shuffle')
          sURL = sURL.replaceAll(cVARs.url.setID, thirdparty.emoji_fonts[shared.rnd(thirdparty.emoji_fonts.length)]);
        }
        if (!addList.hasOwnProperty(e.id))
         addList[e.id] = 0;
        else
        {
         if (dup === false)
          return false;
         if (dup !== true && addList[e.id] >= dup)
          return false;
        }
        addList[e.id]++;
        return {svc: cSources.service.emoji, url: sURL, str: String.fromCodePoint(parseInt(c, 16)), pos: p, width: e.width, height: e.height};
       }

       function _showCrew(addList, p, dup = null)
       {
        if (!addList.hasOwnProperty(cCrew.id))
         addList[cCrew.id] = 0;
        else
        {
         if (dup === false)
          return false;
         if (dup !== true && addList[cCrew.id] >= dup)
          return false;
        }
        addList[cCrew.id]++;
        const svgC = shared.rnd(cCrew.colors.length);
        const svgCSS = cCrew.css.body.replaceAll(cVARs.crew.st1, cCrew.colors[svgC][0]).replaceAll(cVARs.crew.st3, cCrew.colors[svgC][1]) + (shared.rnd(2) === 1 ? cCrew.css.flip : '');
        const crew = cCrew.prefix +
         encodeURIComponent(cCrew.svg.tag.open + cCrew.css.tag.open) +
         encodeURIComponent(svgCSS) +
         encodeURIComponent(cCrew.css.tag.close + cCrew.svg.body + cCrew.svg.tag.close);
        return {svc: cSources.service.emoji, url: crew, str: String.fromCodePoint(parseInt(cCrew.id, 16)), pos: p, width: 112, height: 112};
       }

       return $c_emoji;
      }();

      const $3rdparty = function()
      {
       const $ffz = function()
       {
        function $general(msg, chID, dup = null)
        {
         if (!service.emotes.hasOwnProperty('ffz'))
          return [];
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         const ret = [];
         const addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!service.emotes.ffz.hasOwnProperty(m[i]))
           continue;
          if (service.emotes.ffz[m[i]].scope !== cSources.scope.global && !service.emotes.ffz[m[i]].channel.includes(chID))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          ret.push({svc: cSources.service.ffz, url: service.emotes.ffz[m[i]].url, str: m[i], pos: p, scope: service.emotes.ffz[m[i]].scope, width: service.emotes.ffz[m[i]].width, height: service.emotes.ffz[m[i]].height});
         }
         return ret;
        }

        function $zwe(l, usr, chID, msg, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!service.emotes.hasOwnProperty('zwe'))
          return;
         if (!service.emotes.zwe.hasOwnProperty('ffz'))
          return;
         l.sort(_posSort);
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         const addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!service.emotes.zwe.ffz.hasOwnProperty(m[i]))
           continue;
          if (service.emotes.zwe.ffz[m[i]].scope !== cSources.scope.global && !service.emotes.zwe.ffz[m[i]].channel.includes(chID))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: cSources.service.ffz, url: service.emotes.zwe.ffz[m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.ffz[m[i]].scope, width: service.emotes.zwe.ffz[m[i]].width, height: service.emotes.zwe.ffz[m[i]].height});
          }
          else
          {
           let t = msg.slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(service.emotes.zwe.ffz);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (service.emotes.zwe.hasOwnProperty('ffzU') && service.emotes.zwe.ffzU.hasOwnProperty(usr))
           {
            z = Object.keys(service.emotes.zwe.ffzU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('bttv'))
           {
            z = Object.keys(service.emotes.zwe.bttv);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('bttvU') && service.emotes.zwe.bttvU.hasOwnProperty(usr))
           {
            z = Object.keys(service.emotes.zwe.bttvU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('7tv'))
           {
            z = Object.keys(service.emotes.zwe['7tv']);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('7tvU') && service.emotes.zwe['7tvU'].hasOwnProperty(usr))
           {
            z = Object.keys(service.emotes.zwe['7tvU'][usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: cSources.service.ffz, url: service.emotes.zwe.ffz[m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.ffz[m[i]].scope, width: service.emotes.zwe.ffz[m[i]].width, height: service.emotes.zwe.ffz[m[i]].height});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: cSources.service.ffz, url: service.emotes.zwe.ffz[m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.ffz[m[i]].scope, width: service.emotes.zwe.ffz[m[i]].width, height: service.emotes.zwe.ffz[m[i]].height});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== cSources.service.ffz)
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        const $user = function()
        {
         function $userGeneral(usr, msg, dup = null)
         {
          if (!service.emotes.hasOwnProperty('ffzU'))
           return [];
          const m = msg.split(' ');
          if (!service.emotes.ffzU.hasOwnProperty(usr))
           return [];
          if (dup === null)
           dup = cfg.display.duplicates;
          const ret = [];
          const addList = {};
          for (let i = 0, l = m.length; i < l; i++)
          {
           if (!service.emotes.ffzU[usr].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p += m[j].length + 1;
           }
           ret.push({svc: cSources.service.ffz, url: service.emotes.ffzU[usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.ffzU[usr][m[i]].scope, width: service.emotes.ffzU[usr][m[i]].width, height: service.emotes.ffzU[usr][m[i]].height});
          }
          return ret;
         }

         function $userZWE(l, usr, msg, pass, dup = null)
         {
          if (!cfg.display.extended.useZWE)
           return;
          if (!service.emotes.hasOwnProperty('zwe'))
           return;
          if (!service.emotes.zwe.hasOwnProperty('ffzU'))
           return;
          if (!service.emotes.zwe.ffzU.hasOwnProperty(usr))
           return;
          l.sort(_posSort);
          const m = msg.split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          const addList = {};
          for (let i = 0, n = m.length; i < n; i++)
          {
           if (!service.emotes.zwe.ffzU[usr].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p += m[j].length + 1;
           }
           let f = -1;
           let h = -1;
           for (let j = 0, o = l.length; j < o; j++)
           {
            if (l[j].pos > h)
             h = l[j].pos;
            else
             continue;
            if (l[j].pos < p)
             f = j;
           }
           if (f === -1)
           {
            if (pass === 1)
             l.push({svc: cSources.service.ffz, url: service.emotes.zwe.ffzU[usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.ffzU[usr][m[i]].scope, width: service.emotes.zwe.ffzU[usr][m[i]].width, height: service.emotes.zwe.ffzU[usr][m[i]].height});
           }
           else
           {
            let t = msg.slice(l[f].pos + l[f].str.length, p);
            let z = Object.keys(service.emotes.zwe.ffzU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
            if (service.emotes.zwe.hasOwnProperty('ffz'))
            {
             z = Object.keys(service.emotes.zwe.ffz);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('bttv'))
            {
             z = Object.keys(service.emotes.zwe.bttv);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('bttvU') && service.emotes.zwe.bttvU.hasOwnProperty(usr))
            {
             z = Object.keys(service.emotes.zwe.bttvU[usr]);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('7tv'))
            {
             z = Object.keys(service.emotes.zwe['7tv']);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('7tvU') && service.emotes.zwe['7tvU'].hasOwnProperty(usr))
            {
             z = Object.keys(service.emotes.zwe['7tvU'][usr]);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            t = t.trim();
            if (t.length > 0)
            {
             if (pass === 1)
              l.push({svc: cSources.service.ffz, url: service.emotes.zwe.ffzU[usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.ffzU[usr][m[i]].scope, width: service.emotes.zwe.ffzU[usr][m[i]].width, height: service.emotes.zwe.ffzU[usr][m[i]].height});
            }
            else if (pass === 2)
            {
             if (!l[f].hasOwnProperty('zwe'))
              l[f].zwe = [];
             l[f].zwe.push({svc: cSources.service.ffz, url: service.emotes.zwe.ffzU[usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.ffzU[usr][m[i]].scope, width: service.emotes.zwe.ffzU[usr][m[i]].width, height: service.emotes.zwe.ffzU[usr][m[i]].height});
             l[f].zwe.sort(_posSort);
             for (let j = 0, o = l.length; j < o; j++)
             {
              if (l[j].svc !== cSources.service.ffz)
               continue;
              if (l[j].pos !== p)
               continue;
              l.splice(j, 1);
              break;
             }
            }
           }
          }
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $bttv = function()
       {
        function $general(msg, chID, dup = null)
        {
         if (!service.emotes.hasOwnProperty('bttv'))
          return [];
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         const ret = [];
         const addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!service.emotes.bttv.hasOwnProperty(m[i]))
           continue;
          if (service.emotes.bttv[m[i]].scope !== cSources.scope.global && !service.emotes.bttv[m[i]].channel.includes(chID))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          ret.push({svc: cSources.service.bttv, url: service.emotes.bttv[m[i]].url, str: m[i], pos: p, scope: service.emotes.bttv[m[i]].scope, width: service.emotes.bttv[m[i]].width, height: service.emotes.bttv[m[i]].height});
         }
         return ret;
        }

        function $zwe(l, usr, chID, msg, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!service.emotes.hasOwnProperty('zwe'))
          return;
         if (!service.emotes.zwe.hasOwnProperty('bttv'))
          return;
         l.sort(_posSort);
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         const addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!service.emotes.zwe.bttv.hasOwnProperty(m[i]))
           continue;
          if (service.emotes.zwe.bttv[m[i]].scope !== cSources.scope.global && !service.emotes.zwe.bttv[m[i]].channel.includes(chID))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: cSources.service.bttv, url: service.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.bttv[m[i]].scope, width: service.emotes.zwe.bttv[m[i]].width, height: service.emotes.zwe.bttv[m[i]].height});
          }
          else
          {
           let t = msg.slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(service.emotes.zwe.bttv);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (service.emotes.zwe.hasOwnProperty('ffz'))
           {
            z = Object.keys(service.emotes.zwe.ffz);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('ffzU') && service.emotes.zwe.ffzU.hasOwnProperty(usr))
           {
            z = Object.keys(service.emotes.zwe.ffzU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('bttvU') && service.emotes.zwe.bttvU.hasOwnProperty(usr))
           {
            z = Object.keys(service.emotes.zwe.bttvU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('7tv'))
           {
            z = Object.keys(service.emotes.zwe['7tv']);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('7tvU') && service.emotes.zwe['7tvU'].hasOwnProperty(usr))
           {
            z = Object.keys(service.emotes.zwe['7tvU'][usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: cSources.service.bttv, url: service.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.bttv[m[i]].scope, width: service.emotes.zwe.bttv[m[i]].width, height: service.emotes.zwe.bttv[m[i]].height});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: cSources.service.bttv, url: service.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.bttv[m[i]].scope, width: service.emotes.zwe.bttv[m[i]].width, height: service.emotes.zwe.bttv[m[i]].height});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== cSources.service.bttv)
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        const $user = function()
        {
         function $userGeneral(usr, msg, dup = null)
         {
          if (!service.emotes.hasOwnProperty('bttvU'))
           return [];
          if (!service.emotes.bttvU.hasOwnProperty(usr))
           return [];
          const m = msg.split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          const ret = [];
          const addList = {};
          for (let i = 0, l = m.length; i < l; i++)
          {
           if (!service.emotes.bttvU[usr].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p += m[j].length + 1;
           }
           ret.push({svc: cSources.service.bttv, url: service.emotes.bttvU[usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.bttvU[usr][m[i]].scope, width: service.emotes.bttvU[usr][m[i]].width, height: service.emotes.bttvU[usr][m[i]].height});
          }
          return ret;
         }

         function $userZWE(l, usr, msg, pass, dup = null)
         {
          if (!cfg.display.extended.useZWE)
           return;
          if (!service.emotes.hasOwnProperty('zwe'))
           return;
          if (!service.emotes.zwe.hasOwnProperty('bttvU'))
           return;
          if (!service.emotes.zwe.bttvU.hasOwnProperty(usr))
           return;
          l.sort(_posSort);
          const m = msg.split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          const addList = {};
          for (let i = 0, n = m.length; i < n; i++)
          {
           if (!service.emotes.zwe.bttvU[usr].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p += m[j].length + 1;
           }
           let f = -1;
           let h = -1;
           for (let j = 0, o = l.length; j < o; j++)
           {
            if (l[j].pos > h)
             h = l[j].pos;
            else
             continue;
            if (l[j].pos < p)
             f = j;
           }
           if (f === -1)
           {
            if (pass === 1)
             l.push({svc: cSources.service.bttv, url: service.emotes.zwe.bttvU[usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.bttvU[usr][m[i]].scope, width: service.emotes.zwe.bttvU[usr][m[i]].width, height: service.emotes.zwe.bttvU[usr][m[i]].height});
           }
           else
           {
            let t = msg.slice(l[f].pos + l[f].str.length, p);
            let z = Object.keys(service.emotes.zwe.bttvU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
            if (service.emotes.zwe.hasOwnProperty('ffz'))
            {
             z = Object.keys(service.emotes.zwe.ffz);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('ffzU') && service.emotes.zwe.ffzU.hasOwnProperty(usr))
            {
             z = Object.keys(service.emotes.zwe.ffzU[usr]);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('bttv'))
            {
             z = Object.keys(service.emotes.zwe.bttv);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('7tv'))
            {
             z = Object.keys(service.emotes.zwe['7tv']);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('7tvU') && service.emotes.zwe['7tvU'].hasOwnProperty(usr))
            {
             z = Object.keys(service.emotes.zwe['7tvU'][usr]);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            t = t.trim();
            if (t.length > 0)
            {
             if (pass === 1)
              l.push({svc: cSources.service.bttv, url: service.emotes.zwe.bttvU[usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.bttvU[usr][m[i]].scope, width: service.emotes.zwe.bttvU[usr][m[i]].width, height: service.emotes.zwe.bttvU[usr][m[i]].height});
            }
            else if (pass === 2)
            {
             if (!l[f].hasOwnProperty('zwe'))
              l[f].zwe = [];
             l[f].zwe.push({svc: cSources.service.bttv, url: service.emotes.zwe.bttvU[usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.bttvU[usr][m[i]].scope, width: service.emotes.zwe.bttvU[usr][m[i]].width, height: service.emotes.zwe.bttvU[usr][m[i]].height});
             l[f].zwe.sort(_posSort);
             for (let j = 0, o = l.length; j < o; j++)
             {
              if (l[j].svc !== cSources.service.bttv)
               continue;
              if (l[j].pos !== p)
               continue;
              l.splice(j, 1);
              break;
             }
            }
           }
          }
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $7tv = function()
       {
        function $general(msg, chID, dup = null)
        {
         if (!service.emotes.hasOwnProperty('7tv'))
          return [];
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         const ret = [];
         const addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!service.emotes['7tv'].hasOwnProperty(m[i]))
           continue;
          if (service.emotes['7tv'][m[i]].scope !== cSources.scope.global && !service.emotes['7tv'][m[i]].channel.includes(chID))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          ret.push({svc: cSources.service['7tv'], url: service.emotes['7tv'][m[i]].url, str: m[i], pos: p, scope: service.emotes['7tv'][m[i]].scope, width: service.emotes['7tv'][m[i]].width, height: service.emotes['7tv'][m[i]].height});
         }
         return ret;
        }

        function $zwe(l, usr, chID, msg, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!service.emotes.hasOwnProperty('zwe'))
          return;
         if (!service.emotes.zwe.hasOwnProperty('7tv'))
          return;
         l.sort(_posSort);
         const m = msg.split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         const addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!service.emotes.zwe['7tv'].hasOwnProperty(m[i]))
           continue;
          if (service.emotes.zwe['7tv'][m[i]].scope !== cSources.scope.global && !service.emotes.zwe['7tv'][m[i]].channel.includes(chID))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p += m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: cSources.service['7tv'], url: service.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe['7tv'][m[i]].scope, width: service.emotes.zwe['7tv'][m[i]].width, height: service.emotes.zwe['7tv'][m[i]].height});
          }
          else
          {
           let t = msg.slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(service.emotes.zwe['7tv']);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (service.emotes.zwe.hasOwnProperty('ffz'))
           {
            z = Object.keys(service.emotes.zwe.ffz);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('ffzU') && service.emotes.zwe.ffzU.hasOwnProperty(usr))
           {
            z = Object.keys(service.emotes.zwe.ffzU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('bttv'))
           {
            z = Object.keys(service.emotes.zwe.bttv);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('bttvU') && service.emotes.zwe.bttvU.hasOwnProperty(usr))
           {
            z = Object.keys(service.emotes.zwe.bttvU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (service.emotes.zwe.hasOwnProperty('7tvU') && service.emotes.zwe['7tvU'].hasOwnProperty(usr))
           {
            z = Object.keys(service.emotes.zwe['7tvU'][usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: cSources.service['7tv'], url: service.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe['7tv'][m[i]].scope, width: service.emotes.zwe['7tv'][m[i]].width, height: service.emotes.zwe['7tv'][m[i]].height});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: cSources.service['7tv'], url: service.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe['7tv'][m[i]].scope, width: service.emotes.zwe['7tv'][m[i]].width, height: service.emotes.zwe['7tv'][m[i]].height});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== cSources.service['7tv'])
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        const $user = function()
        {
         function $userGeneral(usr, msg, dup = null)
         {
          if (!service.emotes.hasOwnProperty('7tvU'))
           return [];
          if (!service.emotes['7tvU'].hasOwnProperty(usr))
           return [];
          const m = msg.split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          const ret = [];
          const addList = {};
          for (let i = 0, l = m.length; i < l; i++)
          {
           if (!service.emotes['7tvU'][usr].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p += m[j].length + 1;
           }
           ret.push({svc: cSources.service['7tv'], url: service.emotes['7tvU'][usr][m[i]].url, str: m[i], pos: p, scope: service.emotes['7tvU'][usr][m[i]].scope, width: service.emotes['7tvU'][usr][m[i]].width, height: service.emotes['7tvU'][usr][m[i]].height});
          }
          return ret;
         }

         function $userZWE(l, usr, msg, pass, dup = null)
         {
          if (!cfg.display.extended.useZWE)
           return;
          if (!service.emotes.hasOwnProperty('zwe'))
           return;
          if (!service.emotes.zwe.hasOwnProperty('7tvU'))
           return;
          if (!service.emotes.zwe['7tvU'].hasOwnProperty(usr))
           return;
          l.sort(_posSort);
          const m = msg.split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          const addList = {};
          for (let i = 0, n = m.length; i < n; i++)
          {
           if (!service.emotes.zwe['7tvU'][usr].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p += m[j].length + 1;
           }
           let f = -1;
           let h = -1;
           for (let j = 0, o = l.length; j < o; j++)
           {
            if (l[j].pos > h)
             h = l[j].pos;
            else
             continue;
            if (l[j].pos < p)
             f = j;
           }
           if (f === -1)
           {
            if (pass === 1)
             l.push({svc: cSources.service['7tv'], url: service.emotes.zwe['7tvU'][usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe['7tvU'][usr][m[i]].scope, width: service.emotes.zwe['7tvU'][usr][m[i]].width, height: service.emotes.zwe['7tvU'][usr][m[i]].height});
           }
           else
           {
            let t = msg.slice(l[f].pos + l[f].str.length, p);
            let z = Object.keys(service.emotes.zwe.bttvU[usr]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
            if (service.emotes.zwe.hasOwnProperty('ffz'))
            {
             z = Object.keys(service.emotes.zwe.ffz);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('ffzU') && service.emotes.zwe.ffzU.hasOwnProperty(usr))
            {
             z = Object.keys(service.emotes.zwe.ffzU[usr]);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('bttv'))
            {
             z = Object.keys(service.emotes.zwe.bttv);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('bttvU') && service.emotes.zwe.bttvU.hasOwnProperty(usr))
            {
             z = Object.keys(service.emotes.zwe.bttvU[usr]);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (service.emotes.zwe.hasOwnProperty('7tv'))
            {
             z = Object.keys(service.emotes.zwe['7tv']);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            t = t.trim();
            if (t.length > 0)
            {
             if (pass === 1)
              l.push({svc: cSources.service['7tv'], url: service.emotes.zwe.bttvU[usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.bttvU[usr][m[i]].scope, width: service.emotes.zwe.bttvU[usr][m[i]].width, height: service.emotes.zwe.bttvU[usr][m[i]].height});
            }
            else if (pass === 2)
            {
             if (!l[f].hasOwnProperty('zwe'))
              l[f].zwe = [];
             l[f].zwe.push({svc: cSources.service['7tv'], url: service.emotes.zwe.bttvU[usr][m[i]].url, str: m[i], pos: p, scope: service.emotes.zwe.bttvU[usr][m[i]].scope, width: service.emotes.zwe.bttvU[usr][m[i]].width, height: service.emotes.zwe.bttvU[usr][m[i]].height});
             l[f].zwe.sort(_posSort);
             for (let j = 0, o = l.length; j < o; j++)
             {
              if (l[j].svc !== cSources.service['7tv'])
               continue;
              if (l[j].pos !== p)
               continue;
              l.splice(j, 1);
              break;
             }
            }
           }
          }
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       return {
        ffz: $ffz,
        bttv: $bttv,
        '7tv': $7tv
       };
      }();

      return {
       emoji: $emoji,
       '3rdparty': $3rdparty
      };
     }();

     const $line = function()
     {
      const $parseCommand = function()
      {
       async function $c_parseCommand(msg, lvChk, eA = false, mID = false)
       {
        const kNow = Date.now();
        let foundAdvCmd = false;
        for (const k of cfg.commands)
        {
         const r = await _adv(msg, lvChk, k, kNow, eA, mID);
         if (r.done === true)
          return r.ret;
         if (r.found)
          foundAdvCmd = true;
        }
        let foundCmd = false;
        if (cfg.display.kappa.aliases.includes(msg))
         foundCmd = msg;
        if (foundCmd === false)
        {
         for (let i = 0, l = cfg.display.kappa.aliases.length; i < l; i++)
         {
          if (msg.slice(0, cfg.display.kappa.aliases[i].length + 1) === cfg.display.kappa.aliases[i] + ' ')
          {
           foundCmd = cfg.display.kappa.aliases[i];
           break;
          }
         }
        }
        if (foundCmd === false)
         return foundAdvCmd;
        if (!(await lvChk.check(cfg.display.kappa.access)))
         return foundAdvCmd;
        const h = Symbol.for(null);
        if (!_aLast.hasOwnProperty(h))
         _aLast[h] = 0;
        if (cfg.display.kappa.cooldown > 0 && kNow - _aLast[h] < cfg.display.kappa.cooldown * 1000)
         return true;
        let a = false;
        if (mID !== false)
         a = [{url: false, origin: mID}];
        if (foundCmd.length < msg.length)
         a = eA;
        _aLast[h] = kNow;
        display.kappa.show(a);
        return true;
       }

       async function _adv(msg, lvChk, k, kNow, eA = false, mID = false)
       {
        const r = {
         done: false,
         ret: false,
         found: false
        };
        if (!k.hasOwnProperty('styles') && !k.hasOwnProperty('erase') && !k.hasOwnProperty('rave') && !k.hasOwnProperty('raveon') && !k.hasOwnProperty('raveoff'))
         return r;
        if (!k.hasOwnProperty('aliases'))
         return r;
        let foundKCmd = false;
        if (k.aliases.includes(msg))
         foundKCmd = msg;
        if (foundKCmd === false)
        {
         for (let i = 0, l = k.aliases.length; i < l; i++)
         {
          if (msg.slice(0, k.aliases[i].length + 1) === k.aliases[i] + ' ')
          {
           foundKCmd = k.aliases[i];
           break;
          }
         }
        }
        if (foundKCmd === false)
         return r;
        let kAccess = cfg.display.kappa.access;
        if (k.hasOwnProperty('access'))
         kAccess = k.access;
        if (!(await lvChk.check(kAccess)))
         return r;
        r.found = true;
        if (k.hasOwnProperty('cooldown'))
        {
         const hK = Symbol.for(JSON.stringify(k));
         if (!_aLast.hasOwnProperty(hK))
          _aLast[hK] = 0;
         if (k.cooldown !== 0 && kNow - _aLast[hK] < k.cooldown * 1000)
          return r;
        }
        r.done = true;
        if (k.hasOwnProperty('erase'))
        {
         display.eraseAll();
         r.ret = true;
         return r;
        }
        if (k.hasOwnProperty('rave'))
        {
         if (document.documentElement.classList.contains('rave'))
          document.documentElement.classList.remove('rave');
         else
          document.documentElement.classList.add('rave');
         r.ret = true;
         return r;
        }
        if (k.hasOwnProperty('raveon'))
        {
         document.documentElement.classList.add('rave');
         r.ret = true;
         return r;
        }
        if (k.hasOwnProperty('raveoff'))
        {
         if (document.documentElement.classList.contains('rave'))
          document.documentElement.classList.remove('rave');
         r.ret = true;
         return r;
        }
        const kC = {};
        let cStyles = k.styles;
        if (typeof cStyles !== 'object')
        {
         if (cStyles === false)
         {
          r.ret = r.found;
          return r;
         }
         if (cfg.display.kappa.styles.length === 0)
         {
          r.ret = r.found;
          return r;
         }
         cStyles = cfg.display.kappa.styles;
        }
        for (const kS in cStyles)
        {
         if (!cStyles.hasOwnProperty(kS))
          continue;
         kC[kS] = JSON.parse(JSON.stringify(cStyles[kS]));
         if (kC[kS] === true)
          kC[kS] = {};
         kC[kS].command = foundKCmd;
         if (foundKCmd.length === msg.length)
          kC[kS].params = null;
         else
          kC[kS].params = msg.slice(foundKCmd.length + 1);
        }
        let a = false;
        if (mID !== false)
         a = [{url: false, origin: mID}];
        if (foundKCmd.length < msg.length)
         a = eA;
        _aLast[Symbol.for(JSON.stringify(k))] = kNow;
        display.kappa.show(a, kC);
        r.ret = true;
        return r;
       }

       return $c_parseCommand;
      }();

      return {
       parseCommand: $parseCommand
      };
     }();

     function $ignored(u)
     {
      if (!cfg.ignore.users)
       return false;
      if (!!u._slug && cfg.ignore.users.includes(u._slug))
       return true;
      if (!!u._name && cfg.ignore.users.includes(u._name))
       return true;
      if (!!u.ascii && cfg.ignore.users.includes(u.ascii))
       return true;
      return false;
     }

     function _parseTwitch(msg, dup = null)
     {
      if (!service.emotes.hasOwnProperty('twitch'))
       return [];
      const m = msg.split(' ');
      if (dup === null)
       dup = cfg.display.duplicates;
      const ret = [];
      const addList = {};
      for (let i = 0, l = m.length; i < l; i++)
      {
       if (!service.emotes.twitch.hasOwnProperty(m[i]))
        continue;
       if (!addList.hasOwnProperty(m[i]))
        addList[m[i]] = 0;
       else
       {
        if (dup === false)
         continue;
        if (dup !== true && addList[m[i]] >= dup)
         continue;
       }
       addList[m[i]]++;
       let p = 0;
       for (let j = 0; j < i; j++)
       {
        p += m[j].length + 1;
       }
       const o = {
        svc: cSources.service.twitch,
        url: service.emotes.twitch[m[i]].url,
        str: m[i],
        pos: p,
        scope: service.emotes.twitch[m[i]].scope
       };
       if (service.emotes.twitch[m[i]].hasOwnProperty('width'))
        o.width = service.emotes.twitch[m[i]].width;
       if (service.emotes.twitch[m[i]].hasOwnProperty('height'))
        o.height = service.emotes.twitch[m[i]].height;
       ret.push(o);
      }
      return ret;
     }

     function $eListFromMsg(user, msg)
     {
      if (cfg.ignore.users !== false && cfg.ignore.users.includes(user))
       return false;
      const r = [];
      const chID = 'twitch:' + twitch.net.channelID;
      r.push(..._parseTwitch(msg));
      if (cfg.display.useEmoji)
       r.push(...service.parse.content.emoji(msg));
      if (cfg.display.extended.useFFZ)
      {
       r.push(...service.parse.content['3rdparty'].ffz.general(msg, chID));
       r.push(...service.parse.content['3rdparty'].ffz.user.general(msg, chID));
      }
      if (cfg.display.extended.useBTTV)
      {
       r.push(...service.parse.content['3rdparty'].bttv.general(msg, chID));
       r.push(...service.parse.content['3rdparty'].bttv.user.general(msg, chID));
      }
      if (cfg.display.extended.use7TV)
      {
       r.push(...service.parse.content['3rdparty']['7tv'].general(msg, chID));
       r.push(...service.parse.content['3rdparty']['7tv'].user.general(msg, chID));
      }
      if (cfg.display.extended.useFFZ)
      {
       service.parse.content['3rdparty'].ffz.zwe(r, false, chID, msg, 1);
       service.parse.content['3rdparty'].ffz.user.zwe(r, false, chID, msg, 1);
      }
      if (cfg.display.extended.useBTTV)
      {
       service.parse.content['3rdparty'].bttv.zwe(r, false, chID, msg, 1);
       service.parse.content['3rdparty'].bttv.user.zwe(r, false, chID, msg, 1);
      }
      if (cfg.display.extended.use7TV)
      {
       service.parse.content['3rdparty']['7tv'].zwe(r, false, chID, msg, 1);
       service.parse.content['3rdparty']['7tv'].user.zwe(r, false, chID, msg, 1);
      }
      if (cfg.display.extended.useFFZ)
      {
       service.parse.content['3rdparty'].ffz.zwe(r, false, chID, msg, 2);
       service.parse.content['3rdparty'].ffz.user.zwe(r, false, chID, msg, 2);
      }
      if (cfg.display.extended.useBTTV)
      {
       service.parse.content['3rdparty'].bttv.zwe(r, false, chID, msg, 2);
       service.parse.content['3rdparty'].bttv.user.zwe(r, false, chID, msg, 2);
      }
      if (cfg.display.extended.use7TV)
      {
       service.parse.content['3rdparty']['7tv'].zwe(r, false, chID, msg, 2);
       service.parse.content['3rdparty']['7tv'].user.zwe(r, false, chID, msg, 2);
      }
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.length > 0)
      {
       for (let i = r.length - 1; i >= 0; i--)
       {
        const m = r[i].str;
        if (cfg.ignore.emotes.includes(m))
         r.splice(i, 1);
       }
      }
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (r[i].hasOwnProperty('width') || r[i].hasOwnProperty('height'))
        continue;
       if (!r[i].hasOwnProperty('url'))
        continue;
       const sz = shared.ec.get(r[i].url);
       if (sz === null)
        continue;
       r[i].width = sz.width;
       r[i].height = sz.height;
      }
      if (r.length === 0)
       return false;
      return r;
     }

     function $handleDuplicates(a)
     {
      if (!a)
       return false;
      const lA = a.length;
      if (lA < 1)
       return a;
      const r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.url)
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.cheer)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === cSources.scope.user)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.twitch && a[i].scope === cSources.scope.channel)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let p = 0; p < cfg.display.extended.priority.length; p++)
      {
       for (let i = 0; i < lA; i++)
       {
        if (a[i].scope === cSources.scope.channel && a[i].svc === cSources.service[cfg.display.extended.priority[p]])
        {
         if (service.parse.notDupe(a[i], r))
          r.push(a[i]);
        }
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.twitch && a[i].scope === cSources.scope.global)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let p = 0; p < cfg.display.extended.priority.length; p++)
      {
       for (let i = 0; i < lA; i++)
       {
        if (a[i].scope === cSources.scope.global && a[i].svc === cSources.service[cfg.display.extended.priority[p]])
        {
         if (service.parse.notDupe(a[i], r))
          r.push(a[i]);
        }
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === cSources.service.emoji)
       {
        if (service.parse.notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      return r;
     }

     function $notDupe(add, pend)
     {
      for (let i = 0, l = pend.length; i < l; i++)
      {
       if (pend[i].str === add.str)
        return (pend[i].svc === add.svc);
       if (add.svc === cSources.service.emoji && pend[i].str.includes(add.str) && add.pos >= pend[i].pos && add.pos < pend[i].pos + pend[i].str.length)
        return false;
      }
      return true;
     }

     function $clearCooldowns()
     {
      _aLast = {};
     }

     return {
      content: $content,
      line: $line,
      ignored: $ignored,
      eListFromMsg: $eListFromMsg,
      handleDuplicates: $handleDuplicates,
      notDupe: $notDupe,
      clearCooldowns: $clearCooldowns,
      uReg: /[^A-Za-z0-9_]/
     };
    }();

    function $syncList()
    {
     service.cSafe = JSON.parse(JSON.stringify(service.cList));
    }

    return {
     parse: $parse,
     syncList: $syncList,
     emotes: {},
     cList: [],
     cSafe: []
    };
   }();

   const streamlabs = function()
   {
    async function _showStreamlabsDonations(dRet)
    {
     for (let i = 0, l = dRet.length; i < l; i++)
     {
      const n = dRet[i].name;
      const a = dRet[i].amt;
      const m = dRet[i].msg;
      const v = Math.floor(a * cfg.streamlabs.curMul);
      const r = shared.findInMaybeRange(cfg.event.tip.streamlabs.donation, v);
      if (r === false)
       continue;
      let p = false;
      if (cfg.event.tip.useMsgEmotes && m !== false)
      {
       p = service.parse.eListFromMsg(n, m);
       p = service.parse.handleDuplicates(p);
      }
      if (p === false && cfg.event.tip.useProfileImage && n !== false)
      {
       let u = false;
       if (!service.parse.uReg.test(n))
        u = await twitch.net.userInfo(n);
       if (u !== false)
       {
        if (u.hasOwnProperty('profile_image_url'))
         p = [
          {url: u.profile_image_url}
         ];
       }
      }
      let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
      if (cfg.streamlabs.dispDec > 0)
       s = s.toFixed(cfg.streamlabs.dispDec);
      else
       s = Math.floor(s);
      if (cfg.streamlabs.dispPre !== false)
       s = cfg.streamlabs.dispPre + s;
      if (cfg.streamlabs.dispSuf !== false)
       s += cfg.streamlabs.dispSuf;
      display.kappa.show(p, r, {[cVARs.evt.user]: n, [cVARs.evt.amount]: s});
     }
    }

    async function _showStreamlabsPledges(pRet)
    {
     for (let i = 0, l = pRet.length; i < l; i++)
     {
      const n = pRet[i].name;
      const a = pRet[i].amt;
      const v = Math.floor(a * cfg.streamlabs.curMul);
      const r = shared.findInMaybeRange(cfg.event.tip.streamlabs.pledge, v);
      if (r === false)
       continue;
      let p = false;
      if (cfg.event.tip.useProfileImage && n !== false)
      {
       let u = false;
       if (!service.parse.uReg.test(n))
        u = await twitch.net.userInfo(n);
       if (u !== false)
       {
        if (u.hasOwnProperty('profile_image_url'))
         p = [
          {url: u.profile_image_url}
         ];
       }
      }
      let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
      if (cfg.streamlabs.dispDec > 0)
       s = s.toFixed(cfg.streamlabs.dispDec);
      else
       s = Math.floor(s);
      if (cfg.streamlabs.dispPre !== false)
       s = cfg.streamlabs.dispPre + s;
      if (cfg.streamlabs.dispSuf !== false)
       s += cfg.streamlabs.dispSuf;
      display.kappa.show(p, r, {[cVARs.evt.user]: n, [cVARs.evt.amount]: s});
     }
    }

    const $socket = function()
    {
     let _wsRetry = 0;
     let _tPing = false;
     let _ws = null;
     let _lTimeout = 5000;
     let _tTimeout = false;

     function $c_socket()
     {
      notice.expect |= notice.Connection.STREAMLABS;
      _tPing = 0;
      _ws = new WebSocket(cURLs.ws.streamlabs.replaceAll(cVARs.url.token, cfg.streamlabs.token));
      _ws.onopen = _wsOpen;
      _ws.onclose = _wsClose;
      _ws.onmessage = _wsMessage;
     }

     function _wsOpen()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.onopen = null;
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
     }

     function _wsClose()
     {
      notice.error(notice.Type.STREAMLABS_NETWORK);
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws = null;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead && lfg.net.dead)
       return;
      const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
      if (_wsRetry < 2)
       _wsRetry += 0.2;
      window.setTimeout(streamlabs.socket, wsWait);
     }

     async function _wsMessage(ev)
     {
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_ws === null)
       return;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead && lfg.net.dead)
      {
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       return;
      }
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      _wsRetry = 0;
      const d = ev.data;
      if (d.length === 0)
       return;
      notice.info(notice.Type.STREAMLABS_NETWORK);
      notice.active |= notice.Connection.STREAMLABS;
      notice.resetHide();
      switch (d.slice(0, 1))
      {
       case '0':
        let t = 25000;
        let u = 5000;
        if (d.length > 1)
        {
         const c = JSON.parse(d.slice(1));
         if (c.hasOwnProperty('pingInterval'))
          t = c.pingInterval;
         if (c.hasOwnProperty('pingTimeout'))
          u = c.pingTimeout;
        }
        _lTimeout = t + u;
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, t);
        break;
       case '4':
        if (d.slice(1, 2) !== '2')
        {
         if (d.slice(1, 2) === '4')
         {
          notice.error(notice.Type.STREAMLABS_TOKEN);
          notice.error(notice.Type.STREAMLABS_NETWORK);
          _lTimeout = 5000;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          if (_tPing !== 0)
          {
           window.clearInterval(_tPing);
           _tPing = 0;
          }
          if (_ws === null)
           return;
          _ws.onopen = null;
          _ws.onmessage = null;
          _ws.onclose = null;
          _ws.close();
          _ws = null;
         }
         return;
        }
        if (document.visibilityState === 'hidden')
         return;
        if (d.length < 2)
         return;
        const o = JSON.parse(d.slice(2));
        if (o.length < 2)
         return;
        if (o[0] !== 'event')
         return;
        if (!o[1].hasOwnProperty('message'))
         return;
        if (!o[1].hasOwnProperty('type'))
         return;
        if (o[1].type === 'donation')
        {
         const rD = [];
         for (let i = 0, l = o[1].message.length; i < l; i++)
         {
          if (!o[1].message[i].hasOwnProperty('amount'))
           continue;
          let n = false;
          if (o[1].message[i].hasOwnProperty('name'))
           n = o[1].message[i].name;
          let m = false;
          if (o[1].message[i].hasOwnProperty('message') && o[1].message[i].message !== null && o[1].message[i].message !== '')
           m = o[1].message[i].message;
          rD.push({amt: o[1].message[i].amount, name: n, msg: m});
         }
         if (rD.length > 0)
          await _showStreamlabsDonations(rD);
        }
        if (o[1].type === 'pledge')
        {
         const rP = [];
         for (let i = 0, l = o[1].message.length; i < l; i++)
         {
          if (!o[1].message[i].hasOwnProperty('amount'))
           continue;
          let n = false;
          if (o[1].message[i].hasOwnProperty('name'))
           n = o[1].message[i].name;
          rP.push({amt: o[1].message[i].amount, name: n});
         }
         if (rP.length > 0)
          await _showStreamlabsPledges(rP);
        }
        break;
      }
     }

     function _wsPing()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.send('2');
     }

     function _wsTimeout()
     {
      if (_lTimeout === 5000)
       notice.error(notice.Type.STREAMLABS_NETWORK);
      else
       _lTimeout = 5000;
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws.close();
      _ws = null;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead && lfg.net.dead)
       return;
      streamlabs.socket();
     }

     return $c_socket;
    }();

    function _cfgVals()
    {
     if (!cfg.hasOwnProperty('streamlabs'))
      return 0;
     let r = 0;
     if (cfg.streamlabs.hasOwnProperty('token') && cfg.streamlabs.token !== false && cfg.streamlabs.token !== null && cfg.streamlabs.token !== 'JWT_TOKEN')
      r |= shared.cfgVal.ACCESS_TOKEN;
     return r;
    }

    return {
     socket: $socket,
     get hasLogin() {return (_cfgVals() & shared.cfgVal.ACCESS_TOKEN) === shared.cfgVal.ACCESS_TOKEN;}
    };
   }();

   const streamelements = function()
   {
    async function _showStreamElementsTip(dAmt, dName, dMsg = false)
    {
     const v = Math.floor(dAmt * cfg.streamelements.curMul);
     if (v < 1)
      return;
     const r = shared.findInMaybeRange(cfg.event.tip.streamelements, v);
     if (r === false)
      return;
     let p = false;
     if (cfg.event.tip.useMsgEmotes && dMsg !== false)
     {
      p = service.parse.eListFromMsg(dName, dMsg);
      p = service.parse.handleDuplicates(p);
     }
     if (p === false && cfg.event.tip.useProfileImage && dName !== false)
     {
      let u = false;
      if (!service.parse.uReg.test(dName))
       u = await twitch.net.userInfo(dName);
      if (u !== false)
      {
       if (u.hasOwnProperty('profile_image_url'))
        p = [
         {url: u.profile_image_url}
        ];
      }
     }
     let s = Number.parseFloat(dAmt * cfg.streamelements.dispMul);
     if (cfg.streamelements.dispDec > 0)
      s = s.toFixed(cfg.streamelements.dispDec);
     else
      s = Math.floor(s);
     if (cfg.streamelements.dispPre !== false)
      s = cfg.streamelements.dispPre + s;
     if (cfg.streamelements.dispSuf !== false)
      s += cfg.streamelements.dispSuf;
     display.kappa.show(p, r, {[cVARs.evt.user]: dName, [cVARs.evt.amount]: s});
    }

    const $socket = function()
    {
     let _wsRetry = 0;
     let _tPing = 0;
     let _ws = null;
     let _lTimeout = 5000;
     let _tTimeout = false;

     function $c_socket()
     {
      notice.expect |= notice.Connection.STREAMELEMENTS;
      _tPing = 0;
      _ws = new WebSocket(cURLs.ws.streamelements);
      _ws.onopen = _wsOpen;
      _ws.onclose = _wsClose;
      _ws.onmessage = _wsMessage;
     }

     function _wsOpen()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.onopen = null;
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
     }

     function _wsClose()
     {
      notice.error(notice.Type.STREAMELEMENTS_NETWORK);
      notice.active &= ~notice.Connection.STREAMELEMENTS;
      notice.resetHide();
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws = null;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead && lfg.net.dead)
       return;
      const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
      if (_wsRetry < 2)
       _wsRetry += 0.2;
      window.setTimeout(streamelements.socket, wsWait);
     }

     async function _wsMessage(ev)
     {
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_ws === null)
       return;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead && lfg.net.dead)
      {
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       return;
      }
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      _wsRetry = 0;
      const d = ev.data;
      if (d.length === 0)
       return;
      notice.info(notice.Type.STREAMELEMENTS_NETWORK);
      notice.active |= notice.Connection.STREAMELEMENTS;
      notice.resetHide();
      switch (d.slice(0, 1))
      {
       case '0':
        let t = 25000;
        let u = 20000;
        if (d.length > 1)
        {
         const c = JSON.parse(d.slice(1));
         if (c.hasOwnProperty('pingInterval'))
          t = c.pingInterval;
         if (c.hasOwnProperty('pingTimeout'))
          u = c.pingTimeout;
        }
        _lTimeout = t + u;
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, t);
        break;
       case '4':
        if (d.slice(1, 2) === '0')
        {
         let a;
         if (streamelements.oAuth.usesJWT)
          a = JSON.stringify(['authenticate', {'method': 'jwt', 'token': streamelements.oAuth.auth.jwt_token}]);
         else
          a = JSON.stringify(['authenticate', {'method': 'oauth2', 'token': streamelements.oAuth.auth.access_token}]);
         if (_ws.readyState === 1)
          _ws.send('42' + a);
         return;
        }
        if (d.slice(1, 2) !== '2')
         return;
        if (d.length < 2)
         return;
        const o = JSON.parse(d.slice(2));
        if (o.length < 2)
         return;
        if (o[0] === 'unauthorized')
        {
         notice.error(notice.Type.STREAMELEMENTS_TOKEN);
         notice.error(notice.Type.STREAMELEMENTS_NETWORK);
         _lTimeout = 5000;
         if (_tTimeout !== false)
         {
          window.clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         if (_tPing !== 0)
         {
          window.clearInterval(_tPing);
          _tPing = 0;
         }
         if (_ws === null)
          return;
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         return;
        }
        if (document.visibilityState === 'hidden')
         return;
        if (o[0] !== 'event:update')
         return;
        if (!o[1].hasOwnProperty('name'))
         return;
        if (o[1].name !== 'tip-latest')
         return;
        if (!o[1].hasOwnProperty('data'))
         return;
        if (!o[1].data.hasOwnProperty('amount'))
         return;
        let n = false;
        if (o[1].data.hasOwnProperty('name'))
         n = o[1].data.name;
        let m = false;
        if (o[1].data.hasOwnProperty('message'))
         m = o[1].data.message;
        await _showStreamElementsTip(o[1].data.amount, n, m);
        break;
      }
     }

     function _wsPing()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.send('2');
     }

     function _wsTimeout()
     {
      if (_lTimeout === 5000)
      {
       notice.error(notice.Type.STREAMELEMENTS_NETWORK);
       notice.active &= ~notice.Connection.STREAMELEMENTS;
       notice.resetHide();
      }
      else
       _lTimeout = 5000;
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws.close();
      _ws = null;
      if (twitch.net.dead && youtube.net.dead && kick.net.dead && lfg.net.dead)
       return;
      streamelements.socket();
     }

     return $c_socket;
    }();

    function _path()
    {
     if (streamelements.cfgHash !== false)
      return 'streamelements.' + streamelements.cfgHash;
     return shared.cfgHash + '.streamelements';
    }

    const $oAuth = function()
    {
     const _pathRefresh = '.refresh';

     async function $init()
     {
      if (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== null && cfg.streamelements.token !== 'JWT_TOKEN')
      {
       streamelements.cfgHash = false;
       _genJWT(cfg.streamelements.token);
       return;
      }
      if (cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== null && cfg.streamelements.oauth !== 'OAUTH_ID')
      {
       streamelements.cfgHash = shared.hashCode(cfg.streamelements.oauth);
       _genAccess(cfg.streamelements.oauth);
       return;
      }
      if (cfg.streamelements.hasOwnProperty('oauth_refresh') && cfg.streamelements.oauth_refresh !== null && cfg.streamelements.oauth_refresh !== false && cfg.streamelements.oauth_refresh !== 'OAUTH_REFRESH')
      {
       let sRef = cfg.streamelements.oauth_refresh;
       streamelements.cfgHash = shared.hashCode(sRef);
       const lsRef = shared.storage.getItem(_path() + _pathRefresh);
       if (lsRef !== null)
        sRef = lsRef;
       const sRet = await _genRefresh(sRef);
       if (sRet !== false)
        shared.storage.setItem(_path() + _pathRefresh, sRet);
       else
        shared.storage.removeItem(_path() + _pathRefresh);
       return;
      }
      streamelements.cfgHash = false;
      const lsRefresh = shared.storage.getItem(_path() + _pathRefresh);
      if (lsRefresh === null)
      {
       _populateAuth();
       return;
      }
      const sLRet = await _genRefresh(lsRefresh);
      if (sLRet !== false)
       shared.storage.setItem(_path() + _pathRefresh, sLRet);
      else
       shared.storage.removeItem(_path() + _pathRefresh);
     }

     function _genJWT(t)
     {
      streamelements.oAuth.auth.jwt_token = t;
      streamelements.oAuth.auth.client_id = false;
      streamelements.oAuth.auth.channel = false;
      streamelements.oAuth.auth.access_token = false;
      streamelements.oAuth.auth.refresh_token = false;
      streamelements.oAuth.auth.scope = [];
      streamelements.oAuth.auth.expires = 0;
      return t;
     }

     async function _genAccess(a)
     {
      const oV = await _validate(a);
      if (oV === false)
      {
       _populateAuth();
       return false;
      }
      streamelements.oAuth.auth.jwt_token = false;
      streamelements.oAuth.auth.client_id = oV.client_id;
      streamelements.oAuth.auth.channel = oV.channel_id;
      streamelements.oAuth.auth.access_token = a;
      streamelements.oAuth.auth.refresh_token = false;
      streamelements.oAuth.auth.scope = oV.scopes;
      streamelements.oAuth.auth.expires = oV.expires_in;
      return a;
     }

     async function _genRefresh(r)
     {
      const oR = await _refresh(r);
      if (oR === false)
      {
       _populateAuth();
       return false;
      }
      const a = oR.access_token;
      const r2 = oR.refresh_token;
      const oV = await _validate(a);
      if (oV === false)
      {
       _populateAuth();
       return false;
      }
      _populateAuth(a, r2, oV);
      return r2;
     }

     function _populateAuth(a = null, r = null, j = null)
     {
      streamelements.oAuth.auth.time = Date.now();
      if (a !== null && r !== null && j !== null)
      {
       streamelements.oAuth.auth.jwt_token = false;
       streamelements.oAuth.auth.client_id = j.client_id;
       streamelements.oAuth.auth.channel = j.channel_id;
       streamelements.oAuth.auth.scope = j.scopes;
       streamelements.oAuth.auth.access_token = a;
       streamelements.oAuth.auth.refresh_token = r;
       streamelements.oAuth.auth.expires = j.expires_in;
       return;
      }
      streamelements.oAuth.auth.jwt_token = false;
      streamelements.oAuth.auth.client_id = false;
      streamelements.oAuth.auth.channel = false;
      streamelements.oAuth.auth.access_token = false;
      streamelements.oAuth.auth.refresh_token = false;
      streamelements.oAuth.auth.scope = [];
      streamelements.oAuth.auth.expires = 0;
     }

     async function _refresh(t)
     {
      const url = cURLs.api.rr.refresh.se;
      const b = 'refresh=' + encodeURIComponent(t);
      const r = await shared.httpRequest('POST', url, {}, b, false);
      if (!r.success)
      {
       notice.error(notice.Type.STREAMELEMENTS_TOKEN);
       return false;
      }
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('access_token'))
       return false;
      if (!j.hasOwnProperty('refresh_token'))
       return false;
      if (!j.hasOwnProperty('expires_in'))
       return false;
      return j;
     }

     async function _validate(t)
     {
      const url = cURLs.api.streamelements.validate;
      const h = {'Authorization': 'Bearer ' + t};
      const r = await shared.httpRequest('GET', url, h, null, false);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('channel_id'))
       return false;
      if (!j.hasOwnProperty('client_id'))
       return false;
      if (!j.hasOwnProperty('scopes'))
       return false;
      if (!j.hasOwnProperty('expires_in'))
       return false;
      return j;
     }

     async function $update()
     {
      if (streamelements.oAuth.auth.expires > 0)
      {
       const nowTime = Date.now();
       const exTime = streamelements.oAuth.auth.time + (streamelements.oAuth.auth.expires * 1000 * 0.75);
       if (nowTime < exTime)
        return;
      }
      const r = await _refresh(streamelements.oAuth.auth.refresh_token);
      if (r === false)
      {
       _populateAuth();
       return;
      }
      const sAccess = r.access_token;
      const sRefresh = r.refresh_token;
      const v = await _validate(sAccess);
      if (v === false)
      {
       _populateAuth();
       return;
      }
      _populateAuth(sAccess, sRefresh, v);
      if (sRefresh !== streamelements.oAuth.auth.refresh_token)
       shared.storage.setItem(_path() + _pathRefresh, sRefresh);
     }

     function _cfgVals()
     {
      let r = 0;
      const lsRefresh = shared.storage.getItem(_path() + _pathRefresh);
      if (lsRefresh !== null)
       r |= shared.cfgVal.REFRESH_TOKEN;
      if (streamelements.oAuth.auth.jwt_token !== false)
       r |= shared.cfgVal.JWT_TOKEN;
      if (streamelements.oAuth.auth.refresh_token !== false)
       r |= shared.cfgVal.REFRESH_TOKEN;
      if (streamelements.oAuth.auth.access_token !== false)
       r |= shared.cfgVal.ACCESS_TOKEN;
      return r;
     }

     return {
      init: $init,
      update: $update,
      get hasRefresh() {return (_cfgVals() & shared.cfgVal.REFRESH_TOKEN) === shared.cfgVal.REFRESH_TOKEN;},
      get hasLogin()
      {
       if ((_cfgVals() & shared.cfgVal.JWT_TOKEN) === shared.cfgVal.JWT_TOKEN)
        return true;
       return (_cfgVals() & shared.cfgVal.ACCESS_TOKEN) === shared.cfgVal.ACCESS_TOKEN;
      },
      get usesJWT()
      {
       if ((_cfgVals() & shared.cfgVal.ACCESS_TOKEN) === shared.cfgVal.ACCESS_TOKEN)
        return false;
       return (_cfgVals() & shared.cfgVal.JWT_TOKEN) === shared.cfgVal.JWT_TOKEN;
      },
      auth: {
       client_id: false,
       channel: false,
       jwt_token: false,
       access_token: false,
       refresh_token: false,
       scope: [],
       time: 0,
       expires: 0
      }
     };
    }();

    return {
     socket: $socket,
     oAuth: $oAuth,
     cfgHash: false
    };
   }();

   const thirdparty = function()
   {
    const _defSize = 28;

    function _addEmote(list, scope, code, id, url, ch = false, w = false, h = false, zwe = false)
    {
     if (typeof list === 'undefined')
      return;
     if (cfg.ignore.emotes !== false && cfg.ignore.emotes.includes(code))
      return;
     if (w === false)
      w = _defSize;
     if (h === false)
      h = _defSize;
     if (list.hasOwnProperty(code))
     {
      if (scope === cSources.scope.global && list[code].scope === cSources.scope.channel)
       return;
      if (ch !== false)
      {
       if (list[code].channel.includes(ch))
        _removeEmote(list, scope, code, ch);
       else
       {
        list[code].channel.push(ch);
        return;
       }
      }
      else
       _removeEmote(list, scope, code, ch);
     }
     list[code] = {scope: scope, url: url, channel: [], id: id, width: w, height: h};
     if (ch !== false)
      list[code].channel.push(ch);
     if (scope === cSources.scope.channel && !zwe)
      service.cList.push({url: url, width: w, height: h});
    }

    function _removeEmote(list, scope, code, ch = false)
    {
     if (typeof list === 'undefined')
      return;
     if (!list.hasOwnProperty(code))
      return;
     if (list[code].scope !== scope)
      return;
     if (ch !== false)
     {
      if (!list[code].channel.includes(ch))
       return;
      list[code].channel = list[code].channel.filter(function(v){return v !== ch;});
      if (list[code].channel.length > 0)
       return;
     }
     if (scope === cSources.scope.channel)
     {
      for (let c = service.cList.length - 1; c >= 0; c--)
      {
       if (service.cList[c].url !== list[code].url)
        continue;
       service.cList.splice(c, 1);
       break;
      }
     }
     delete list[code];
    }

    function _removeEmoteByID(list, scope, id, ch = false)
    {
     if (typeof list === 'undefined')
      return;
     for (let i = Object.keys(list).length - 1; i >= 0; i--)
     {
      const k = Object.keys(list)[i];
      if (list[k].scope !== scope)
       continue;
      if (list[k].id !== id)
       continue;
      _removeEmote(list, scope, k, ch);
      break;
     }
    }

    const $ffz = function()
    {
     function _readFFZ_URL(entry)
     {
      const g = entry.animated ?? entry.urls ?? false;
      if (g === false)
       return false;
      const find = ['4', '2', '1'];
      for (let i = 0, l = find.length; i < l; i++)
      {
       if (!g.hasOwnProperty(find[i]))
        continue;
       return g[find[i]];
      }
      return false;
     }

     async function $global()
     {
      if (!service.emotes.hasOwnProperty('ffz'))
       service.emotes.ffz = {};
      if (!service.emotes.hasOwnProperty('zwe'))
       service.emotes.zwe = {};
      if (!service.emotes.zwe.hasOwnProperty('ffz'))
       service.emotes.zwe.ffz = {};
      const url = cURLs.api.ffz.set.global;
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('sets'))
       return false;
      const usedSets = new Set(j.default_sets);
      for (const set in j.sets)
      {
       if (!j.sets.hasOwnProperty(set))
        continue;
       if (!usedSets.has(j.sets[set].id))
        continue;
       if (!j.sets[set].hasOwnProperty('emoticons'))
        continue;
       for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
       {
        if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
         continue;
        const u = _readFFZ_URL(j.sets[set].emoticons[i]);
        if (u === false)
         continue;
        let w = false;
        let h = false;
        if (j.sets[set].emoticons[i].hasOwnProperty('width'))
         w = j.sets[set].emoticons[i].width;
        if (j.sets[set].emoticons[i].hasOwnProperty('height'))
         h = j.sets[set].emoticons[i].height;
        if (j.sets[set].emoticons[i].hasOwnProperty('modifier') && j.sets[set].emoticons[i].modifier === true)
        {
         if (j.sets[set].emoticons[i].hasOwnProperty('modifier_flags') && (j.sets[set].emoticons[i].modifier_flags & thirdparty.ffz.Modifier.HIDDEN) === thirdparty.ffz.Modifier.HIDDEN)
          continue;
         if (cfg.display.extended.useZWE)
          _addEmote(service.emotes.zwe.ffz, cSources.scope.global, j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, false, w, h, true);
         continue;
        }
        _addEmote(service.emotes.ffz, cSources.scope.global, j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, false, w, h);
       }
      }
      if (!j.hasOwnProperty('user_ids'))
      {
       service.syncList();
       return true;
      }
      for (const setID in j.user_ids)
      {
       if (!j.user_ids.hasOwnProperty(setID))
        continue;
       const aList = j.user_ids[setID];
       if (!Array.isArray(aList))
        continue;
       for (const set in j.sets)
       {
        if (!j.sets.hasOwnProperty(set))
         continue;
        if (setID !== set)
         continue;
        if (!j.sets[set].hasOwnProperty('emoticons'))
         continue;
        for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
        {
         if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
          continue;
         const u = _readFFZ_URL(j.sets[set].emoticons[i]);
         if (u === false)
          continue;
         let w = false;
         let h = false;
         if (j.sets[set].emoticons[i].hasOwnProperty('width'))
          w = j.sets[set].emoticons[i].width;
         if (j.sets[set].emoticons[i].hasOwnProperty('height'))
          h = j.sets[set].emoticons[i].height;
         if (j.sets[set].emoticons[i].hasOwnProperty('modifier') && j.sets[set].emoticons[i].modifier === true)
         {
          if (j.sets[set].emoticons[i].hasOwnProperty('modifier_flags') && (j.sets[set].emoticons[i].modifier_flags & thirdparty.ffz.Modifier.HIDDEN) === thirdparty.ffz.Modifier.HIDDEN)
           continue;
          if (cfg.display.extended.useZWE)
          {
           if (!service.emotes.zwe.hasOwnProperty('ffzU'))
            service.emotes.zwe.ffzU = {};
           for (let k = 0, m = aList.length; k < m; k++)
           {
            if (!service.emotes.zwe.ffzU.hasOwnProperty('twitch:' + aList[k]))
             service.emotes.zwe.ffzU['twitch:' + aList[k]] = {};
            _addEmote(service.emotes.zwe.ffzU['twitch:' + aList[k]], cSources.scope.user, j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, false, w, h, true);
           }
          }
          continue;
         }
         if (!service.emotes.hasOwnProperty('ffzU'))
          service.emotes.ffzU = {};
         for (let k = 0, m = aList.length; k < m; k++)
         {
          if (!service.emotes.ffzU.hasOwnProperty('twitch:' + aList[k]))
           service.emotes.ffzU['twitch:' + aList[k]] = {};
          _addEmote(service.emotes.ffzU['twitch:' + aList[k]], cSources.scope.user, j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, false, w, h);
         }
        }
       }
      }
      service.syncList();
      return true;
     }

     async function $channelEx(svcName, chID)
     {
      const url = cURLs.api.ffz.room[svcName].replaceAll(cVARs.url.channelID, chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('sets'))
       return false;
      const ret = [];
      for (const set in j.sets)
      {
       if (!j.sets[set].hasOwnProperty('emoticons'))
        continue;
       for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
       {
        if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
         continue;
        let m = false;
        if (j.sets[set].emoticons[i].hasOwnProperty('modifier') && j.sets[set].emoticons[i].modifier === true)
        {
         if (j.sets[set].emoticons[i].hasOwnProperty('modifier_flags'))
          m = j.sets[set].emoticons[i].modifier_flags;
         else
          m = 0;
        }
        const u = _readFFZ_URL(j.sets[set].emoticons[i]);
        if (u === false)
         continue;
        let w = false;
        let h = false;
        if (j.sets[set].emoticons[i].hasOwnProperty('width'))
         w = j.sets[set].emoticons[i].width;
        if (j.sets[set].emoticons[i].hasOwnProperty('height'))
         h = j.sets[set].emoticons[i].height;
        ret.push({name: j.sets[set].emoticons[i].name, id: j.sets[set].emoticons[i].id, url: u, modifier: m, width: w, height: h});
       }
      }
      return ret;
     }

     async function $channel(svcName, chID, andClr = false)
     {
      if (!service.emotes.hasOwnProperty('ffz'))
       service.emotes.ffz = {};
      if (!service.emotes.hasOwnProperty('zwe'))
       service.emotes.zwe = {};
      if (!service.emotes.zwe.hasOwnProperty('ffz'))
       service.emotes.zwe.ffz = {};
      const r = await thirdparty.ffz.channelEx(svcName, chID);
      if (r === false)
       return false;
      if (andClr)
       _channelClr(svcName, chID);
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (r[i].modifier !== false)
       {
        if ((r[i].modifier & thirdparty.ffz.Modifier.HIDDEN) === thirdparty.ffz.Modifier.HIDDEN)
         continue;
        if (cfg.display.extended.useZWE)
         _addEmote(service.emotes.zwe.ffz, cSources.scope.channel, r[i].name, r[i].id, r[i].url, svcName + ':' + chID, r[i].width, r[i].height, true);
        continue;
       }
       _addEmote(service.emotes.ffz, cSources.scope.channel, r[i].name, r[i].id, r[i].url, svcName + ':' + chID, r[i].width, r[i].height);
      }
      service.syncList();
      return true;
     }

     function _channelClr(svcName, chID)
     {
      for (const e in service.emotes.ffz)
      {
       if (!service.emotes.ffz.hasOwnProperty(e))
        continue;
       if (service.emotes.ffz[e].scope !== cSources.scope.channel)
        continue;
       _removeEmote(service.emotes.ffz, cSources.scope.channel, e, svcName + ':' + chID);
      }
      if (service.emotes.hasOwnProperty('zwe'))
      {
       for (const e in service.emotes.zwe.ffz)
       {
        if (!service.emotes.zwe.ffz.hasOwnProperty(e))
         continue;
        if (service.emotes.zwe.ffz[e].scope !== cSources.scope.channel)
         continue;
        _removeEmote(service.emotes.zwe.ffz, cSources.scope.channel, e, svcName + ':' + chID);
       }
      }
     }

     return {
      global: $global,
      channel: $channel,
      channelEx: $channelEx,
      Modifier: Object.freeze({
       HIDDEN: 0x01
      })
     };
    }();

    const $bttv = function()
    {
     const _rBE = 600000;

     function $reloadB()
     {
      if (thirdparty.bttv.timer === false)
       return;
      window.clearTimeout(thirdparty.bttv.timer);
      thirdparty.bttv.timer = false;
      if (cfg.display.extended.useBTTV)
      {
       if (!twitch.net.dead && twitch.net.channelID !== 0)
        thirdparty.bttv.channel('twitch', twitch.net.channelID);
       const lCt = youtube.net.channelIDs.length;
       if (!youtube.net.dead && lCt > 0)
       {
        for (let i = 0; i < lCt; i++)
        {
         thirdparty.bttv.channel('youtube', youtube.net.channelIDs[i]);
        }
       }
      }
      thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, thirdparty.interval);
     }

     async function $global()
     {
      if (!service.emotes.hasOwnProperty('bttv'))
       service.emotes.bttv = {};
      if (!service.emotes.hasOwnProperty('zwe'))
       service.emotes.zwe = {};
      if (!service.emotes.zwe.hasOwnProperty('bttv'))
       service.emotes.zwe.bttv = {};
      const url = cURLs.api.bttv.emotes.global;
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!Array.isArray(j))
       return false;
      const hasList = JSON.parse(JSON.stringify(bttvHoliday));
      for (const hID in hasList)
      {
       if (!hasList.hasOwnProperty(hID))
        continue;
       hasList[hID].found = false;
      }
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('code'))
        continue;
       if (!j[i].hasOwnProperty('id'))
        continue;
       if (j[i].hasOwnProperty('modifier') && j[i].modifier === true)
        continue;
       if (hasList.hasOwnProperty(j[i].id))
        hasList[j[i].id].found = true;
       const eURL = cURLs.cdn.bttv.emote.replaceAll(cVARs.url.emoteID, j[i].id);
       let w = _defSize;
       let h = _defSize;
       if (j[i].hasOwnProperty('width'))
        w = j[i].width;
       if (j[i].hasOwnProperty('height'))
        h = j[i].height;
       if (bttvZWE.hasOwnProperty(j[i].id))
       {
        if (cfg.display.extended.useZWE)
         _addEmote(service.emotes.zwe.bttv, cSources.scope.global, j[i].code, j[i].id, eURL, false, w, h, true);
        continue;
       }
       _addEmote(service.emotes.bttv, cSources.scope.global, j[i].code, j[i].id, eURL, false, w, h);
      }
      if (cfg.display.extended.useZWE && cfg.display.extended.holidayZWE)
      {
       const nowM = new Date().getMonth() + 1;
       const nowD = new Date().getDate();
       for (const hID in hasList)
       {
        if (!hasList.hasOwnProperty(hID))
         continue;
        if (hasList[hID].found)
         continue;
        if (hasList[hID].min.month > nowM)
         continue;
        if (hasList[hID].min.month === nowM && hasList[hID].min.day > nowD)
         continue;
        if (hasList[hID].max.month < nowM)
         continue;
        if (hasList[hID].max.month === nowM && hasList[hID].max.day < nowD)
         continue;
        _addEmote(service.emotes.zwe.bttv, cSources.scope.global, hasList[hID].code, hID, cURLs.cdn.bttv.emote.replaceAll(cVARs.url.emoteID, hID), false, hasList[hID].width, hasList[hID].height, true);
       }
      }
      service.syncList();
      return true;
     }

     async function $channelEx(svcName, chID)
     {
      if (!cURLs.api.bttv.users.hasOwnProperty(svcName))
       return [];
      const url = cURLs.api.bttv.users[svcName].replaceAll(cVARs.url.channelID, chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      const ret = [];
      if (j.hasOwnProperty('channelEmotes'))
      {
       for (let i = 0, l = j.channelEmotes.length; i < l; i++)
       {
        if (!j.channelEmotes[i].hasOwnProperty('code'))
         continue;
        if (!j.channelEmotes[i].hasOwnProperty('id'))
         continue;
        let w = _defSize;
        let h = _defSize;
        if (j.channelEmotes[i].hasOwnProperty('width'))
         w = j.channelEmotes[i].width;
        if (j.channelEmotes[i].hasOwnProperty('height'))
         h = j.channelEmotes[i].height;
        ret.push({name: j.channelEmotes[i].code, id: j.channelEmotes[i].id, url: cURLs.cdn.bttv.emote.replaceAll(cVARs.url.emoteID, j.channelEmotes[i].id), width: w, height: h});
       }
      }
      if (j.hasOwnProperty('sharedEmotes'))
      {
       for (let i = 0, l = j.sharedEmotes.length; i < l; i++)
       {
        if (!j.sharedEmotes[i].hasOwnProperty('code'))
         continue;
        if (!j.sharedEmotes[i].hasOwnProperty('id'))
         continue;
        let w = _defSize;
        let h = _defSize;
        if (j.sharedEmotes[i].hasOwnProperty('width'))
         w = j.sharedEmotes[i].width;
        if (j.sharedEmotes[i].hasOwnProperty('height'))
         h = j.sharedEmotes[i].height;
        ret.push({name: j.sharedEmotes[i].code, id: j.sharedEmotes[i].id, url: cURLs.cdn.bttv.emote.replaceAll(cVARs.url.emoteID, j.sharedEmotes[i].id), width: w, height: h});
       }
      }
      return ret;
     }

     async function $channel(svcName, chID)
     {
      if (!service.emotes.hasOwnProperty('bttv'))
       service.emotes.bttv = {};
      const r = await thirdparty.bttv.channelEx(svcName, chID);
      if (r === false)
       return false;
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (bttvZWE.hasOwnProperty(r[i].id))
       {
        if (cfg.display.extended.useZWE)
         _addEmote(service.emotes.zwe.bttv, cSources.scope.channel, r[i].name, r[i].id, r[i].url, svcName + ':' + chID, r[i].width, r[i].height, true);
        continue;
       }
       _addEmote(service.emotes.bttv, cSources.scope.channel, r[i].name, r[i].id, r[i].url, svcName + ':' + chID, r[i].width, r[i].height);
      }
      service.syncList();
      return true;
     }

     const $socket = function()
     {
      let _wsRetry = 0;
      const _chList = {};
      let _ws = null;

      function $init()
      {
       notice.expect |= notice.Connection.BTTV;
       _ws = new WebSocket(cURLs.ws.bttv);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       notice.info(notice.Type.BTTV_NETWORK);
       notice.active |= notice.Connection.BTTV;
       notice.resetHide();
       _ws.onopen = null;
       for (const svc in _chList)
       {
        if (!_chList.hasOwnProperty(svc))
         continue;
        for (const ch of _chList[svc])
        {
         _wsJoin(svc, ch);
        }
       }
      }

      function _wsClose()
      {
       notice.error(notice.Type.BTTV_NETWORK);
       notice.active &= ~notice.Connection.BTTV;
       notice.resetHide();
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead && youtube.net.dead)
        return;
       const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(thirdparty.bttv.socket.init, wsWait);
      }

      function _wsMessage(ev)
      {
       if (_ws === null)
        return;
       if (twitch.net.dead && youtube.net.dead)
       {
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        return;
       }
       _wsRetry = 0;
       const d = JSON.parse(ev.data);
       if (!d.hasOwnProperty('name'))
        return;
       if (!d.hasOwnProperty('data'))
        return;
       switch (d.name)
       {
        case 'lookup_user':
         if (!d.data.hasOwnProperty('providerId'))
          return;
         if (!d.data.hasOwnProperty('channel') || !d.data.channel.includes(':'))
          return;
         const usr = d.data.channel.slice(0, d.data.channel.indexOf(':') + 1) + d.data.providerId;
         if (!d.data.hasOwnProperty('emotes') || !Array.isArray(d.data.emotes) || d.data.emotes.length === 0)
          return;
         if (!service.emotes.hasOwnProperty('bttvU'))
          service.emotes.bttvU = {};
         service.emotes.bttvU[usr] = {};
         if (!service.emotes.zwe.hasOwnProperty('bttvU'))
          service.emotes.zwe.bttvU = {};
         service.emotes.zwe.bttvU[usr] = {};
         for (let i = 0, l = d.data.emotes.length; i < l; i++)
         {
          if (!d.data.emotes[i].hasOwnProperty('code'))
           continue;
          if (!d.data.emotes[i].hasOwnProperty('id'))
           continue;
          let w = _defSize;
          let h = _defSize;
          if (d.data.emotes[i].hasOwnProperty('width'))
           w = d.data.emotes[i].width;
          if (d.data.emotes[i].hasOwnProperty('height'))
           h = d.data.emotes[i].height;
          if (bttvZWE.hasOwnProperty(d.data.emotes[i].id))
          {
           if (cfg.display.extended.useZWE)
            _addEmote(service.emotes.zwe.bttvU[usr], cSources.scope.user, d.data.emotes[i].code, d.data.emotes[i].id, cURLs.cdn.bttv.emote.replaceAll(cVARs.url.emoteID, d.data.emotes[i].id), false, w, h, true);
           continue;
          }
          _addEmote(service.emotes.bttvU[usr], cSources.scope.user, d.data.emotes[i].code, d.data.emotes[i].id, cURLs.cdn.bttv.emote.replaceAll(cVARs.url.emoteID, d.data.emotes[i].id), false, w, h);
         }
         service.syncList();
         break;
        case 'emote_create':
         if (!d.data.hasOwnProperty('channel'))
          return;
         if (!d.data.hasOwnProperty('emote'))
          return;
         if (!d.data.emote.hasOwnProperty('id'))
          return;
         if (!d.data.emote.hasOwnProperty('code'))
          return;
         let wC = _defSize;
         let hC = _defSize;
         if (d.data.emote.hasOwnProperty('width'))
          wC = d.data.emote.width;
         if (d.data.emote.hasOwnProperty('height'))
          hC = d.data.emote.height;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _addEmote(service.emotes.bttv, cSources.scope.channel, d.data.emote.code, d.data.emote.id, cURLs.cdn.bttv.emote.replaceAll(cVARs.url.emoteID, d.data.emote.id), d.data.channel, wC, hC);
         service.syncList();
         thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, _rBE);
         break;
        case 'emote_delete':
         if (!d.data.hasOwnProperty('channel'))
          return;
         if (!d.data.hasOwnProperty('emoteId'))
          return;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _removeEmoteByID(service.emotes.bttv, cSources.scope.channel, d.data.emoteId, d.data.channel);
         service.syncList();
         thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, _rBE);
         break;
        case 'emote_update':
         if (!d.data.hasOwnProperty('channel'))
          return;
         if (!d.data.hasOwnProperty('emote'))
          return;
         if (!d.data.emote.hasOwnProperty('id'))
          return;
         if (!d.data.emote.hasOwnProperty('code'))
          return;
         let wU = _defSize;
         let hU = _defSize;
         if (d.data.emote.hasOwnProperty('width'))
          wU = d.data.emote.width;
         if (d.data.emote.hasOwnProperty('height'))
          hU = d.data.emote.height;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _removeEmoteByID(service.emotes.bttv, cSources.scope.channel, d.data.emote.id, d.data.channel);
         _addEmote(service.emotes.bttv, cSources.scope.channel, d.data.emote.code, d.data.emote.id, cURLs.cdn.bttv.emote.replaceAll(cVARs.url.emoteID, d.data.emote.id), d.data.channel, wU, hU);
         service.syncList();
         thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, _rBE);
         break;
       }
      }

      function $join(svcName, chID)
      {
       if (!_chList.hasOwnProperty(svcName))
        _chList[svcName] = new Set();
       if (_chList[svcName].has(chID))
        return;
       _chList[svcName].add(chID);
       _wsJoin(svcName, chID);
      }

      function _wsJoin(s, c)
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send(JSON.stringify({name: 'join_channel', data: {name: s + ':' + c}}));
      }

      return {
       init: $init,
       join: $join
      };
     }();

     return {
      timer: {},
      global: $global,
      channel: $channel,
      channelEx: $channelEx,
      socket: $socket,
      reload: $reloadB
     };
    }();

    const $7tv = function()
    {
     function _read7tv_URL(entry)
     {
      if (!entry.hasOwnProperty('host') || entry.host === null)
       return false;
      if (!entry.host.hasOwnProperty('url') || entry.host.url === null)
       return false;
      if (!entry.host.hasOwnProperty('files') || entry.host.files === null)
       return false;
      if (!Array.isArray(entry.host.files))
       return false;
      const g = [];
      let findFormat = 'WEBP';
      if (typeof cfg.display.extended.use7TV === 'string')
       findFormat = cfg.display.extended.use7TV.toUpperCase();
      for (let i = 0, l = entry.host.files.length; i < l; i++)
      {
       if (!entry.host.files[i].hasOwnProperty('format') || entry.host.files[i].format === null)
        continue;
       if (!entry.host.files[i].hasOwnProperty('name') || entry.host.files[i].name === null)
        continue;
       if (entry.host.files[i].format !== findFormat)
        continue;
       const dpp = entry.host.files[i].name.slice(0, 1);
       const addr = 'https:' + entry.host.url + '/' + entry.host.files[i].name;
       let w = false;
       let h = false;
       if (entry.host.files[i].hasOwnProperty('width') && entry.host.files[i].width !== null)
        w = entry.host.files[i].width;
       if (entry.host.files[i].hasOwnProperty('height') && entry.host.files[i].height !== null)
        h = entry.host.files[i].height;
       g.push({dpp: dpp, url: addr, width: w, height: h});
      }
      if (g.length === 0)
       return false;
      const find = ['4', '3', '2', '1'];
      for (let i = 0, l = find.length; i < l; i++)
      {
       const m = g.find(function(e){return e.dpp === find[i];});
       if (m)
        return m;
      }
      return false;
     }

     async function $global()
     {
      if (!service.emotes.hasOwnProperty('7tv'))
       service.emotes['7tv'] = {};
      if (!service.emotes.hasOwnProperty('zwe'))
       service.emotes.zwe = {};
      if (!service.emotes.zwe.hasOwnProperty('7tv'))
       service.emotes.zwe['7tv'] = {};
      const url = cURLs.api['7tv'].emotes.global;
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('emotes') || j.emotes === null)
       return false;
      if (!Array.isArray(j.emotes))
       return false;
      for (let i = 0, l = j.emotes.length; i < l; i++)
      {
       if (!j.emotes[i].hasOwnProperty('data') || j.emotes[i].data === null)
        continue;
       if (!j.emotes[i].data.hasOwnProperty('id') || j.emotes[i].data.id === null)
        continue;
       if (!j.emotes[i].hasOwnProperty('name') || j.emotes[i].name === null)
        continue;
       const jInf = _read7tv_URL(j.emotes[i].data);
       if (jInf === false)
        continue;
       if (j.emotes[i].data.hasOwnProperty('flags') && j.emotes[i].data.flags !== null && (j.emotes[i].data.flags & thirdparty['7tv'].Modifier.ZWE) === thirdparty['7tv'].Modifier.ZWE)
       {
        if (cfg.display.extended.useZWE)
         _addEmote(service.emotes.zwe['7tv'], cSources.scope.global, j.emotes[i].name, j.emotes[i].data.id, jInf.url, false, jInf.width, jInf.height, true);
        continue;
       }
       _addEmote(service.emotes['7tv'], cSources.scope.global, j.emotes[i].name, j.emotes[i].data.id, jInf.url, false, jInf.width, jInf.height);
      }
      service.syncList();
      return true;
     }

     async function $channelEx(svcName, chID, listedOnly)
     {
      const url = cURLs.api['7tv'].users[svcName].replaceAll(cVARs.url.channelID, chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('emote_set') || j.emote_set === null)
       return false;
      if (!j.emote_set.hasOwnProperty('emotes') || j.emote_set.emotes === null)
       return false;
      if (!Array.isArray(j.emote_set.emotes))
       return false;
      const ret = [];
      for (let i = 0, l = j.emote_set.emotes.length; i < l; i++)
      {
       if (!j.emote_set.emotes[i].hasOwnProperty('data') || j.emote_set.emotes[i].data === null)
        continue;
       if (listedOnly && j.emote_set.emotes[i].data.hasOwnProperty('listed') && j.emote_set.emotes[i].data.listed !== true)
        continue;
       if (!j.emote_set.emotes[i].data.hasOwnProperty('id') || j.emote_set.emotes[i].data.id === null)
        continue;
       if (!j.emote_set.emotes[i].hasOwnProperty('name') || j.emote_set.emotes[i].name === null)
        continue;
       const jInf = _read7tv_URL(j.emote_set.emotes[i].data);
       if (jInf === false)
        continue;
       let vis = 0;
       if (j.emote_set.emotes[i].data.hasOwnProperty('flags') && j.emote_set.emotes[i].data.flags !== null)
        vis = j.emote_set.emotes[i].data.flags;
       ret.push({name: j.emote_set.emotes[i].name, id: j.emote_set.emotes[i].data.id, url: jInf.url, vis: vis, width: jInf.width, height: jInf.height});
      }
      return ret;
     }

     async function $channel(svcName, chID, andClr = false)
     {
      if (!service.emotes.hasOwnProperty('7tv'))
       service.emotes['7tv'] = {};
      if (!service.emotes.hasOwnProperty('zwe'))
       service.emotes.zwe = {};
      if (!service.emotes.zwe.hasOwnProperty('7tv'))
       service.emotes.zwe['7tv'] = {};
      const r = await thirdparty['7tv'].channelEx(svcName, chID, false);
      if (r === false)
       return false;
      if (andClr)
       _channelClr(svcName, chID);
      for (let i = 0, l = r.length; i < l; i++)
      {
       if ((r[i].vis & thirdparty['7tv'].Modifier.ZWE) === thirdparty['7tv'].Modifier.ZWE)
       {
        if (cfg.display.extended.useZWE)
         _addEmote(service.emotes.zwe['7tv'], cSources.scope.channel, r[i].name, r[i].id, r[i].url, svcName + ':' + chID, r[i].width, r[i].height, true);
        continue;
       }
       _addEmote(service.emotes['7tv'], cSources.scope.channel, r[i].name, r[i].id, r[i].url, svcName + ':' + chID, r[i].width, r[i].height);
      }
      service.syncList();
      return true;
     }

     function _channelClr(svcName, chID)
     {
      for (const e in service.emotes['7tv'])
      {
       if (!service.emotes['7tv'].hasOwnProperty(e))
        continue;
       if (service.emotes['7tv'][e].scope !== cSources.scope.channel)
        continue;
       _removeEmote(service.emotes['7tv'], cSources.scope.channel, e, svcName + ':' + chID);
      }
      if (service.emotes.hasOwnProperty('zwe'))
      {
       for (const e in service.emotes.zwe['7tv'])
       {
        if (!service.emotes.zwe['7tv'].hasOwnProperty(e))
         continue;
        if (service.emotes.zwe['7tv'][e].scope !== cSources.scope.channel)
         continue;
        _removeEmote(service.emotes.zwe['7tv'], cSources.scope.channel, e, svcName + ':' + chID);
       }
      }
     }

     async function _load7TV_channelID(svcName, chID)
     {
      const url = cURLs.api['7tv'].users[svcName].replaceAll(cVARs.url.channelID, chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('user') || j.user === null)
       return false;
      if (!j.user.hasOwnProperty('id') || j.user.id === null)
       return false;
      return j.user.id;
     }

     function _load7TV_userID(svcName, uID, setData)
     {
      if (!service.emotes.hasOwnProperty('7tvU'))
       service.emotes['7tvU'] = {};
      service.emotes['7tvU'][svcName + ':' + uID] = {};
      if (!service.emotes.hasOwnProperty('zwe'))
       service.emotes.zwe = {};
      if (!service.emotes.zwe.hasOwnProperty('7tvU'))
       service.emotes.zwe['7tvU'] = {};
      service.emotes.zwe['7tvU'][svcName + ':' + uID] = {};
      for (let i = 0, l = setData.length; i < l; i++)
      {
       if ((setData[i].vis & thirdparty['7tv'].Modifier.ZWE) === thirdparty['7tv'].Modifier.ZWE)
       {
        if (cfg.display.extended.useZWE)
         _addEmote(service.emotes.zwe['7tvU'][svcName + ':' + uID], cSources.scope.user, setData[i].name, setData[i].id, setData[i].url, false, setData[i].width, setData[i].height, true);
        continue;
       }
       _addEmote(service.emotes['7tvU'][svcName + ':' + uID], cSources.scope.user, setData[i].name, setData[i].id, setData[i].url, false, setData[i].width, setData[i].height);
      }
     }

     async function _load7TV_set(setID)
     {
      const url = cURLs.api['7tv'].emotes.set.replaceAll(cVARs.url.setID, setID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('emotes') || j.emotes === null)
       return false;
      if (!Array.isArray(j.emotes))
       return false;
      const ret = [];
      for (let i = 0, l = j.emotes.length; i < l; i++)
      {
       if (!j.emotes[i].hasOwnProperty('data') || j.emotes[i].data === null)
        continue;
       if (!j.emotes[i].data.hasOwnProperty('id') || j.emotes[i].data.id === null)
        continue;
       if (!j.emotes[i].hasOwnProperty('name') || j.emotes[i].name === null)
        continue;
       const jInf = _read7tv_URL(j.emotes[i].data);
       if (jInf === false)
        continue;
       let vis = 0;
       if (j.emotes[i].data.hasOwnProperty('flags') && j.emotes[i].data.flags !== null)
        vis = j.emotes[i].data.flags;
       ret.push({name: j.emotes[i].name, id: j.emotes[i].data.id, url: jInf.url, vis: vis, width: jInf.width, height: jInf.height});
      }
      return ret;
     }

     const $socketEx = function()
     {
      const appID = 'emote-wall';
      const appVer = '1.5';
      const _lDelay = 3000;
      const _chList = {};
      let _statusWS = null;
      let _statusSSE = null;
      const _noAcct = Symbol();

      function $init()
      {
       notice.expect |= notice.Connection['7TV'];
       _socket.init();
      }

      function _noteActive(src)
      {
       if (src === _socket.ref)
        _statusWS = true;
       if (src === _events.ref)
        _statusSSE = true;
       if (_statusWS !== true && _statusSSE !== true)
        return;
       notice.info(notice.Type['7TV_NETWORK']);
       notice.active |= notice.Connection['7TV'];
       notice.resetHide();
      }

      function _noteError(src)
      {
       if (src === _socket.ref)
        _statusWS = false;
       if (src === _events.ref)
        _statusSSE = false;
       if (_statusWS !== false)
        return;
       if (_statusSSE !== false)
        return;
       notice.error(notice.Type['7TV_NETWORK']);
       notice.active &= ~notice.Connection['7TV'];
       notice.resetHide();
      }

      const _socket = function()
      {
       let _wsRetry = 0;
       let _wsR_RL = 0;
       let _wsR_M = 0;
       let _ws = null;
       let _sess = null;
       let _oldSess = false;
       let _lTimeout = 5000;
       let _tTimeout = false;
       let _okCt = 0;

       function $sckInit()
       {
        _ws = new WebSocket(cURLs.ws['7tv'] + '?app=' + encodeURIComponent(appID) + '&version=' + encodeURIComponent(appVer));
        _ws.onopen = _wsOpen;
        _ws.onclose = _wsClose;
        _ws.onmessage = _wsMessage;
       }

       function _wsOpen()
       {
        if (_ws === null)
         return;
        if (_ws.readyState !== 1)
         return;
        _ws.onopen = null;
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
       }

       function _wsClose()
       {
        _noteError(_socket.ref);
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_ws === null)
         return;
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws = null;
        if (twitch.net.dead && youtube.net.dead && kick.net.dead)
         return;
        const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
        if (_wsRetry < 2)
         _wsRetry += 0.2;
        window.setTimeout(_socket.init, wsWait);
       }

       function _wsMessage(ev)
       {
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_ws === null)
         return;
        if (twitch.net.dead && youtube.net.dead && kick.net.dead)
        {
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         return;
        }
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        const d = JSON.parse(ev.data);
        if (!d.hasOwnProperty('op') || d.op === null)
         return;
        if (!d.hasOwnProperty('d'))
         return;
        _noteActive(_socket.ref);
        switch (d.op)
        {
         case 0:
          if (thirdparty.timer !== false)
           window.clearTimeout(thirdparty.timer);
          thirdparty.timer = window.setTimeout(thirdparty.reload, _lDelay);
          break;
         case 1:
          if (d.d === null)
           return;
          _okCt = 0;
          if (_sess !== null && !_oldSess)
          {
           if (_ws.readyState === 1)
           {
            _oldSess = true;
            _ws.send(JSON.stringify({'op': 34, 'd': {'session_id': _sess}}));
           }
          }
          else
          {
           _oldSess = false;
           _sess = null;
           for (const acct in _chList)
           {
            if (!_chList.hasOwnProperty(acct))
             continue;
            _wsSub(acct);
            _wsAddChSubs(acct);
           }
           if (_chList.hasOwnProperty(_noAcct))
            _wsAddChSubs(_noAcct);
          }
          if (d.d.hasOwnProperty('session_id') && d.d.session_id !== null)
           _sess = d.d.session_id;
          if (d.d.hasOwnProperty('heartbeat_interval') && d.d.heartbeat_interval !== null)
          {
           _lTimeout = parseInt(d.d.heartbeat_interval, 10) * 3;
           if (_tTimeout !== false)
           {
            window.clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
          }
          break;
         case 2:
          if (d.d !== null && d.d.hasOwnProperty('count') && d.d.count === 0)
           return;
          if (_okCt !== _needCt())
          {
           if (_tTimeout !== false)
           {
            window.clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           _ws.onopen = null;
           _ws.onmessage = null;
           _ws.onclose = null;
           _ws.close();
           _ws = null;
           const wsRedo = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
           if (_wsRetry < 2)
            _wsRetry += 0.2;
           window.setTimeout(_socket.init, wsRedo);
           return;
          }
          _wsRetry = 0;
          _wsR_RL = 0;
          _wsR_M = 0;
          break;
         case 5:
          if (d.d === null)
           return;
          if (!d.d.hasOwnProperty('command') || d.d.command === null)
           return;
          switch (d.d.command)
          {
           case 'RESUME':
            if (!d.d.hasOwnProperty('data') || d.d.data === null)
             return;
            if (!d.d.data.hasOwnProperty('success'))
             return;
            if (d.d.data.success === false || d.d.data.success === null)
            {
             for (const acct in _chList)
             {
              if (!_chList.hasOwnProperty(acct))
               continue;
              _wsSub(acct);
              _wsAddChSubs(acct);
             }
             if (_chList.hasOwnProperty(_noAcct))
              _wsAddChSubs(_noAcct);
            }
            else
            {
             if (!d.d.data.hasOwnProperty('subscriptions_restored') || d.d.data.subscriptions_restored === null)
              return;
             if (d.d.data.subscriptions_restored !== _needCt())
             {
              if (d.d.data.subscriptions_restored > 0)
              {
               for (const acct in _chList)
               {
                if (!_chList.hasOwnProperty(acct))
                 continue;
                _wsUnsub(acct);
                _wsRemChSubs(acct);
               }
               if (_chList.hasOwnProperty(_noAcct))
                _wsRemChSubs(_noAcct);
              }
              for (const acct in _chList)
              {
               if (!_chList.hasOwnProperty(acct))
                continue;
               _wsSub(acct);
               _wsAddChSubs(acct);
              }
              if (_chList.hasOwnProperty(_noAcct))
               _wsAddChSubs(_noAcct);
             }
             else
              _okCt = d.d.data.subscriptions_restored;
            }
            break;
           case 'SUBSCRIBE':
            _okCt++;
            break;
          }
          break;
         case 7:
          if (d.d === null)
           return;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _ws.onopen = null;
          _ws.onmessage = null;
          _ws.onclose = null;
          _ws.close();
          _ws = null;
          let wsWait = _lDelay;
          if (d.d.hasOwnProperty('code') && d.d.code !== null)
          {
           switch (d.d.code)
           {
            case 4001:
            case 4002:
            case 4003:
            case 4004:
            case 4009:
            case 4010:
            case 4011:
             _sess = null;
             _oldSess = false;
             return;
            case 4005:
             wsWait = Math.floor((5 ** (1 + _wsR_RL) / 5) * 60 * 1000);
             if (_wsR_RL < 2.6)
              _wsR_RL += 0.2;
             break;
            case 4006:
             wsWait = Math.max(wsWait, 5 * 60 * 1000);
             break;
            case 4007:
             wsWait = 5 * 60 * 1000 + Math.floor(wsRetryBase ** (1 + _wsR_M) * 1000) - 5000;
             if (_wsR_M < 2)
              _wsR_M += 0.2;
             break;
            case 4000:
            case 4008:
             wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
             if (_wsRetry < 2)
              _wsRetry += 0.2;
             break;
           }
          }
          window.setTimeout(_socket.init, wsWait);
          break;
        }
       }

       function _wsAddChSubs(acct)
       {
        for (const svc in _chList[acct])
        {
         if (!_chList[acct].hasOwnProperty(svc))
          continue;
         for (const ch of _chList[acct][svc])
         {
          _wsSubCh(svc, ch);
         }
        }
       }

       function _wsRemChSubs(acct)
       {
        for (const svc in _chList[acct])
        {
         if (!_chList[acct].hasOwnProperty(svc))
          continue;
         for (const ch of _chList[acct][svc])
         {
          _wsUnsubCh(svc, ch);
         }
        }
       }

       function _wsUnsub(accID)
       {
        if (_ws === null)
         return;
        if (_ws.readyState !== 1)
         return;
        _ws.send(JSON.stringify({'op': 36, 'd': {'type': 'user.*', 'condition': {'object_id': accID}}}));
        _ws.send(JSON.stringify({'op': 36, 'd': {'type': 'emote.*', 'condition': {'object_id': accID}}}));
        _ws.send(JSON.stringify({'op': 36, 'd': {'type': 'emote_set.*', 'condition': {'object_id': accID}}}));
       }

       function _wsUnsubCh(svcName, chID)
       {
        if (_ws === null)
         return;
        if (_ws.readyState !== 1)
         return;
        _ws.send(JSON.stringify({'op': 36, 'd': {'type': 'entitlement.*', 'condition': {'ctx': 'channel', 'platform': svcName.toUpperCase(), 'id': chID.toString()}}}));
       }

       function _wsSub(accID)
       {
        if (_ws === null)
         return;
        if (_ws.readyState !== 1)
         return;
        _ws.send(JSON.stringify({'op': 35, 'd': {'type': 'user.*', 'condition': {'object_id': accID}}}));
        _ws.send(JSON.stringify({'op': 35, 'd': {'type': 'emote.*', 'condition': {'object_id': accID}}}));
        _ws.send(JSON.stringify({'op': 35, 'd': {'type': 'emote_set.*', 'condition': {'object_id': accID}}}));
       }

       function _wsSubCh(svcName, chID)
       {
        if (_ws === null)
         return;
        if (_ws.readyState !== 1)
         return;
        _ws.send(JSON.stringify({'op': 35, 'd': {'type': 'entitlement.*', 'condition': {'ctx': 'channel', 'platform': svcName.toUpperCase(), 'id': chID.toString()}}}));
       }

       function _wsTimeout()
       {
        if (_lTimeout === 5000)
         _noteError(_socket.ref);
        else
         _lTimeout = 5000;
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_ws === null)
         return;
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        if (twitch.net.dead && youtube.net.dead && kick.net.dead)
         return;
        _socket.init();
       }

       function $joinA(accID)
       {
        if (_ws === null)
         return;
        if (_ws.readyState !== 1)
         return;
        _wsSub(accID);
       }

       function $joinS(svcName, chID)
       {
        if (_ws === null)
         return;
        if (_ws.readyState !== 1)
         return;
        _wsSubCh(svcName, chID);
       }

       return {
        init: $sckInit,
        joinA: $joinA,
        joinS: $joinS,
        ref: Symbol()
       };
      }();

      const _events = function()
      {
       let _wsRetry = 0;
       let _wsR_RL = 0;
       let _wsR_M = 0;
       let _sse = null;
       let _lTimeout = 5000;
       let _tTimeout = false;
       let _tInit = false;
       let _okCt = 0;

       function _init()
       {
        if (_tInit !== false)
         window.clearTimeout(_tInit);
        _tInit = false;
        let p = '';
        for (const acct in _chList)
        {
         if (!_chList.hasOwnProperty(acct))
          continue;
         if (p !== '')
          p += ',';
         p += 'user.*<object_id=' + acct + '>,emote.*<object_id=' + acct + '>,emote_set.*<object_id=' + acct + '>';
         for (const svc in _chList[acct])
         {
          if (!_chList[acct].hasOwnProperty(svc))
           continue;
          for (const ch of _chList[acct][svc])
          {
           if (p !== '')
            p += ',';
           p += 'entitlement.*<ctx=channel;platform=' + svc.toUpperCase() + ';id=' + ch + '>';
          }
         }
        }
        if (_chList.hasOwnProperty(_noAcct))
        {
         if (p !== '')
          p += ',';
         for (const svc in _chList[_noAcct])
         {
          if (!_chList[_noAcct].hasOwnProperty(svc))
           continue;
          for (const ch of _chList[_noAcct][svc])
          {
           if (p !== '')
            p += ',';
           p += 'entitlement.*<ctx=channel;platform=' + svc.toUpperCase() + ';id=' + ch + '>';
          }
         }
        }
        if (p.length === 0)
         return;
        const uri = cURLs.sse['7tv'] + '@' + encodeURIComponent(p) + '?app=' + encodeURIComponent(appID) + '&version=' + encodeURIComponent(appVer);
        if (_sse !== null)
        {
         _sse.close();
         _sse.removeEventListener('open', _sseOpen);
         _sse.removeEventListener('error', _sseError);
         _sse.removeEventListener('dispatch', _sseMessage);
         _sse.removeEventListener('hello', _sseMessage);
         _sse.removeEventListener('heartbeat', _sseMessage);
         _sse.removeEventListener('reconnect', _sseMessage);
         _sse.removeEventListener('ack', _sseMessage);
         _sse.removeEventListener('end of stream', _sseMessage);
         _sse = null;
        }
        _sse = new EventSource(uri);
        _sse.addEventListener('open', _sseOpen);
        _sse.addEventListener('error', _sseError);
        _sse.addEventListener('dispatch', _sseMessage);
        _sse.addEventListener('hello', _sseMessage);
        _sse.addEventListener('heartbeat', _sseMessage);
        _sse.addEventListener('reconnect', _sseMessage);
        _sse.addEventListener('ack', _sseMessage);
        _sse.addEventListener('end of stream', _sseMessage);
       }

       function _sseOpen()
       {
        if (_sse === null)
         return;
        if (_sse.readyState !== 1)
         return;
        _sse.removeEventListener('open', _sseOpen);
        _tTimeout = window.setTimeout(_sseTimeout, _lTimeout);
       }

       function _sseError()
       {
        _noteError(_events.ref);
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_sse === null)
         return;
        _sse.removeEventListener('open', _sseOpen);
        _sse.removeEventListener('error', _sseError);
        _sse.removeEventListener('dispatch', _sseMessage);
        _sse.removeEventListener('hello', _sseMessage);
        _sse.removeEventListener('heartbeat', _sseMessage);
        _sse.removeEventListener('reconnect', _sseMessage);
        _sse.removeEventListener('ack', _sseMessage);
        _sse.removeEventListener('end of stream', _sseMessage);
        _sse.close();
        _sse = null;
        if (twitch.net.dead && youtube.net.dead && kick.net.dead)
         return;
        const wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
        if (_wsRetry < 2)
         _wsRetry += 0.2;
        if (_tInit !== false)
         window.clearTimeout(_tInit);
        _tInit = window.setTimeout(_init, wsWait);
       }

       async function _sseMessage(ev)
       {
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_sse === null)
         return;
        if (twitch.net.dead && youtube.net.dead && kick.net.dead)
        {
         _sse.removeEventListener('open', _sseOpen);
         _sse.removeEventListener('error', _sseError);
         _sse.removeEventListener('dispatch', _sseMessage);
         _sse.removeEventListener('hello', _sseMessage);
         _sse.removeEventListener('heartbeat', _sseMessage);
         _sse.removeEventListener('reconnect', _sseMessage);
         _sse.removeEventListener('ack', _sseMessage);
         _sse.removeEventListener('end of stream', _sseMessage);
         _sse.close();
         _sse = null;
         return;
        }
        _tTimeout = window.setTimeout(_sseTimeout, _lTimeout);
        const d = ('data' in ev) ? JSON.parse(ev.data) : null;
        if (!('type' in ev))
         return;
        _noteActive(_events.ref);
        switch (ev.type)
        {
         case 'dispatch':
          if (d.hasOwnProperty('type') && d.type.includes('.') && d.type.slice(0, d.type.indexOf('.')) === 'entitlement')
          {
           if (d.hasOwnProperty('body') && d.body.hasOwnProperty('object') && d.body.object.hasOwnProperty('kind') && d.body.object.kind === 'EMOTE_SET' && d.body.object.hasOwnProperty('ref_id') && d.body.object.hasOwnProperty('user') && d.body.object.user.hasOwnProperty('connections') && Array.isArray(d.body.object.user.connections))
           {
            const setID = d.body.object.ref_id;
            let setData = null;
            for (let i = 0, l = d.body.object.user.connections.length; i < l; i++)
            {
             if (!d.body.object.user.connections[i].hasOwnProperty('platform'))
              continue;
             const pID = d.body.object.user.connections[i].platform.toLowerCase();
             if (!(pID === 'twitch' || pID === 'youtube' || pID === 'kick'))
              continue;
             if (!d.body.object.user.connections[i].hasOwnProperty('id'))
              continue;
             if (setData === null)
              setData = await _load7TV_set(setID);
             if (setData === false)
              return;
             const uID = d.body.object.user.connections[i].id;
             _load7TV_userID(pID, uID, setData);
            }
           }
           return;
          }
          if (thirdparty.timer !== false)
           window.clearTimeout(thirdparty.timer);
          thirdparty.timer = window.setTimeout(thirdparty.reload, _lDelay);
          break;
         case 'hello':
          if (d === null)
           return;
          _okCt = 0;
          if (d.hasOwnProperty('heartbeat_interval') && d.heartbeat_interval !== null)
          {
           _lTimeout = parseInt(d.heartbeat_interval, 10) * 3;
           if (_tTimeout !== false)
           {
            window.clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           _tTimeout = window.setTimeout(_sseTimeout, _lTimeout);
          }
          break;
         case 'heartbeat':
          if (_okCt !== _needCt())
          {
           if (_tTimeout !== false)
           {
            window.clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           _sse.removeEventListener('open', _sseOpen);
           _sse.removeEventListener('error', _sseError);
           _sse.removeEventListener('dispatch', _sseMessage);
           _sse.removeEventListener('hello', _sseMessage);
           _sse.removeEventListener('heartbeat', _sseMessage);
           _sse.removeEventListener('reconnect', _sseMessage);
           _sse.removeEventListener('ack', _sseMessage);
           _sse.removeEventListener('end of stream', _sseMessage);
           _sse.close();
           _sse = null;
           const wsRedo = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
           if (_wsRetry < 2)
            _wsRetry += 0.2;
           if (_tInit !== false)
            window.clearTimeout(_tInit);
           _tInit = window.setTimeout(_init, wsRedo);
           return;
          }
          _wsRetry = 0;
          _wsR_RL = 0;
          _wsR_M = 0;
          break;
         case 'ack':
          if (d === null)
           return;
          if (!d.hasOwnProperty('command') || d.command === null)
           return;
          switch (d.command)
          {
           case 'SUBSCRIBE':
            _okCt++;
            break;
          }
          break;
         case 'reconnect':
          if (d === null)
           return;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _sse.removeEventListener('open', _sseOpen);
          _sse.removeEventListener('error', _sseError);
          _sse.removeEventListener('dispatch', _sseMessage);
          _sse.removeEventListener('hello', _sseMessage);
          _sse.removeEventListener('heartbeat', _sseMessage);
          _sse.removeEventListener('reconnect', _sseMessage);
          _sse.removeEventListener('ack', _sseMessage);
          _sse.removeEventListener('end of stream', _sseMessage);
          _sse.close();
          _sse = null;
          if (_tInit !== false)
           window.clearTimeout(_tInit);
          _tInit = window.setTimeout(_init, _lDelay);
          break;
         case 'end of stream':
          if (d === null)
           return;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _sse.removeEventListener('open', _sseOpen);
          _sse.removeEventListener('error', _sseError);
          _sse.removeEventListener('dispatch', _sseMessage);
          _sse.removeEventListener('hello', _sseMessage);
          _sse.removeEventListener('heartbeat', _sseMessage);
          _sse.removeEventListener('reconnect', _sseMessage);
          _sse.removeEventListener('ack', _sseMessage);
          _sse.removeEventListener('end of stream', _sseMessage);
          _sse.close();
          _sse = null;
          let wsWait = _lDelay;
          if (d.hasOwnProperty('code') && d.code !== null)
          {
           switch (d.code)
           {
            case 4001:
            case 4002:
            case 4003:
            case 4004:
            case 4009:
            case 4010:
            case 4011:
             return;
            case 4005:
             wsWait = Math.floor((5 ** (1 + _wsR_RL) / 5) * 60 * 1000);
             if (_wsR_RL < 2.6)
              _wsR_RL += 0.2;
             break;
            case 4006:
             wsWait = Math.max(wsWait, 5 * 60 * 1000);
             break;
            case 4007:
             wsWait = 5 * 60 * 1000 + Math.floor(wsRetryBase ** (1 + _wsR_M) * 1000) - 5000;
             if (_wsR_M < 2)
              _wsR_M += 0.2;
             break;
            case 4000:
            case 4008:
             wsWait = Math.floor(wsRetryBase ** (1 + _wsRetry) * 1000);
             if (_wsRetry < 2)
              _wsRetry += 0.2;
             break;
           }
          }
          if (_tInit !== false)
           window.clearTimeout(_tInit);
          _tInit = window.setTimeout(_init, wsWait);
          break;
        }
       }

       function _sseTimeout()
       {
        if (_lTimeout === 5000)
         _noteError(_events.ref);
        else
         _lTimeout = 5000;
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        if (_sse === null)
         return;
        _sse.removeEventListener('open', _sseOpen);
        _sse.removeEventListener('error', _sseError);
        _sse.removeEventListener('dispatch', _sseMessage);
        _sse.removeEventListener('hello', _sseMessage);
        _sse.removeEventListener('heartbeat', _sseMessage);
        _sse.removeEventListener('reconnect', _sseMessage);
        _sse.removeEventListener('ack', _sseMessage);
        _sse.removeEventListener('end of stream', _sseMessage);
        _sse.close();
        _sse = null;
        if (twitch.net.dead && youtube.net.dead && kick.net.dead)
         return;
        if (_tInit !== false)
         window.clearTimeout(_tInit);
        _tInit = window.setTimeout(_init, _lDelay);
       }

       function $sseJoin()
       {
        if (_tInit !== false)
         window.clearTimeout(_tInit);
        _tInit = window.setTimeout(_init, _lDelay);
       }

       return {
        join: $sseJoin,
        ref: Symbol()
       };
      }();

      async function $join(svcName, chID)
      {
       let accID = await _load7TV_channelID(svcName, chID);
       if (accID === false)
        accID = _noAcct;
       if (_chList.hasOwnProperty(accID))
       {
        if (!_chList[accID].hasOwnProperty(svcName))
         _chList[accID][svcName] = new Set();
        if (!_chList[accID][svcName].has(chID))
         _chList[accID][svcName].add(chID);
        _socket.joinS(svcName, chID);
        _events.join();
        return;
       }
       _chList[accID] = {};
       _chList[accID][svcName] = new Set();
       _chList[accID][svcName].add(chID);
       if (accID !== _noAcct)
        _socket.joinA(accID);
       _socket.joinS(svcName, chID);
       _events.join();
      }

      function _needCt()
      {
       let c = 0;
       for (const acct in _chList)
       {
        if (!_chList.hasOwnProperty(acct))
         continue;
        if (acct !== _noAcct)
         c += 3;
        for (const svc in _chList[acct])
        {
         if (!_chList[acct].hasOwnProperty(svc))
          continue;
         c += _chList[acct][svc].size;
        }
       }
       if (_chList.hasOwnProperty(_noAcct))
       {
        for (const svc in _chList[_noAcct])
        {
         if (!_chList[_noAcct].hasOwnProperty(svc))
          continue;
         c += _chList[_noAcct][svc].size;
        }
       }
       return c;
      }

      return {
       init: $init,
       join: $join
      };
     }();

     return {
      global: $global,
      channel: $channel,
      channelEx: $channelEx,
      socketEx: $socketEx,
      Modifier: Object.freeze({
       ZWE: 0x100
      })
     };
    }();

    async function $emoji(set)
    {
     const unqSkip = ['00a9', '00ae', '2122', '24c2'];
     const fRet = await shared.httpRequest('GET', cURLs.cdn.emoji.fonts, {}, null, false);
     if (!fRet.success)
      thirdparty.emoji_fonts = ['twemoji', 'openmoji', 'noto', 'blob', 'facebook', 'apple', 'joypixels', 'tossface', 'whatsapp', 'oneui'];
     else
      thirdparty.emoji_fonts = fRet.json;
     if (set === true)
      set = thirdparty.emoji_fonts[0];
     else if (typeof set === 'string' && set.slice(0, 6) === 'rotate')
      set = false;
     else if (set === 'shuffle')
      set = false;
     else if (!thirdparty.emoji_fonts.includes(set))
      set = thirdparty.emoji_fonts[0];
     const r = await shared.httpRequest('GET', cURLs.cdn.emoji.list, {}, null, false);
     if (!r.success)
      return;
     const j = r.json;
     if (j === null)
      return;
     if (!service.emotes.hasOwnProperty('emoji'))
      service.emotes.emoji = {};
     for (const id in j)
     {
      if (!j.hasOwnProperty(id))
       continue;
      let u = cURLs.cdn.emoji.image;
      if (!!set)
       u = u.replaceAll(cVARs.url.setID, set);
      if (j[id].hasOwnProperty('t'))
      {
       if (j[id].hasOwnProperty('s') && j[id].s === -1 && unqSkip.includes(id))
        continue;
       u = u.replaceAll(cVARs.url.emojiID, j[id].t);
       _addEmote(service.emotes.emoji, cSources.scope.global, id, j[id].t, u, false, 112, 112);
       continue;
      }
      u = u.replaceAll(cVARs.url.emojiID, id);
      _addEmote(service.emotes.emoji, cSources.scope.global, id, id, u, false, 112, 112);
     }
    }

    function $reload()
    {
     if (thirdparty.timer === false)
      return;
     window.clearTimeout(thirdparty.timer);
     thirdparty.timer = false;
     if (cfg.display.extended.useFFZ)
     {
      if (!twitch.net.dead && twitch.net.channelID !== 0)
       thirdparty.ffz.channel('twitch', twitch.net.channelID, true);
      if (!youtube.net.dead && youtube.net.channelIDs.length > 0)
      {
       for (let i = 0, l = youtube.net.channelIDs.length; i < l; i++)
       {
        thirdparty.ffz.channel('youtube', youtube.net.channelIDs[i], true);
       }
      }
     }
     if (cfg.display.extended.use7TV)
     {
      if (!twitch.net.dead && twitch.net.channelID !== 0)
       thirdparty['7tv'].channel('twitch', twitch.net.channelID, true);
      if (!youtube.net.dead && youtube.net.channelIDs.length > 0)
      {
       for (let i = 0, l = youtube.net.channelIDs.length; i < l; i++)
       {
        thirdparty['7tv'].channel('youtube', youtube.net.channelIDs[i], true);
       }
      }
      if (!kick.net.dead && kick.net.userID !== 0)
       thirdparty['7tv'].channel('kick', kick.net.userID, true);
     }
     thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval);
    }

    return {
     timer: false,
     interval: 60000,
     emoji_fonts: [],
     ffz: $ffz,
     bttv: $bttv,
     '7tv': $7tv,
     emoji: $emoji,
     reload: $reload
    };
   }();

   const shared = function()
   {
    let _tHue = false;

    function $inputBox(txt, dVal = false, bVal = true)
    {
     const p = new Promise(
      function(resolve)
      {
       const dlgInput = document.createElement('dialog');
       const divText = document.createElement('div');
       divText.textContent = txt;
       dlgInput.appendChild(divText);
       const divInput = document.createElement('div');
       const txtInput = document.createElement('input');
       txtInput.setAttribute('type', 'text');
       if (dVal !== false)
        txtInput.setAttribute('value', dVal);
       if (bVal === false)
       {
        txtInput.setAttribute('readonly', 'readonly');
        txtInput.onfocus = txtInput.select;
       }
       divInput.appendChild(txtInput);
       dlgInput.appendChild(divInput);
       const divButtons = document.createElement('div');
       let cmdOK = null;
       if (bVal)
       {
        cmdOK = document.createElement('button');
        cmdOK.setAttribute('type', 'button');
        cmdOK.setAttribute('class', 'yes');
        cmdOK.setAttribute('disabled', 'disabled');
        cmdOK.textContent = 'OK';
        cmdOK.onclick = function()
        {
         if (txtInput.value.length > 0)
          resolve(txtInput.value);
         else
          resolve(false);
         dlgInput.close();
         txtInput.onkeyup = null;
         cmdOK.onclick = null;
         cmdCancel.onclick = null;
         document.body.removeChild(dlgInput);
        };
        divButtons.appendChild(cmdOK);
        txtInput.onkeyup = function(ev)
        {
         if (txtInput.value.length === 0)
          cmdOK.setAttribute('disabled', 'disabled');
         else
          cmdOK.removeAttribute('disabled');
         if (ev.key === 'Enter')
          cmdOK.click();
        };
       }
       const cmdCancel = document.createElement('button');
       cmdCancel.setAttribute('type', 'button');
       cmdCancel.setAttribute('class', 'no');
       if (bVal)
        cmdCancel.textContent = 'Cancel';
       else
       {
        cmdCancel.textContent = 'Close';
        txtInput.onkeypress = function(ev)
        {
         if (ev.key === 'Enter')
          cmdCancel.click();
        };
       }
       cmdCancel.onclick = function()
       {
        resolve(false);
        dlgInput.close();
        txtInput.onfocus = null;
        if (bVal)
        {
         txtInput.onkeyup = null;
         cmdOK.onclick = null;
        }
        else
        {
         txtInput.onfocus = null;
         txtInput.onkeypress = null;
        }
        cmdCancel.onclick = null;
        document.body.removeChild(dlgInput);
       };
       divButtons.appendChild(cmdCancel);
       dlgInput.appendChild(divButtons);
       document.body.appendChild(dlgInput);
       dlgInput.showModal();
       txtInput.focus();
      }
     );
     return p;
    }

    function $rnd(m)
    {
     const r = new Uint32Array(1);
     window.crypto.getRandomValues(r);
     const f = r[0] / 4294967295;
     if (typeof m === 'undefined')
      return f;
     if (m < 1)
      return f * m;
     return Math.floor(f * m);
    }

    const $hashCode = function()
    {
     /* RadioGatun[32]
      * Copyright (c) 2010-2020 Sam Trenholme
      *
      * TERMS
      *
      * Redistribution and use in source and binary forms, with or without
      * modification, are permitted provided that the following conditions
      * are met:
      *
      * 1. Redistributions of source code must retain the above copyright
      *    notice, this list of conditions and the following disclaimer.
      * 2. Redistributions in binary form must reproduce the above copyright
      *    notice, this list of conditions and the following disclaimer in the
      *    documentation and/or other materials provided with the distribution.
      *
      * This software is provided 'as is' with no guarantees of correctness or
      * fitness for purpose.
      */

     function $c_hashCode(o)
     {
      const input = JSON.stringify(o);
      const ab = {a: [], b: [], p: 1};
      for (let c = 0; c < 19; c++)
      {
       ab.a[c] = 0;
      }
      for (let c = 0; c < 39; c++)
      {
       ab.b[c] = 0;
      }
      const s = [];
      for (let v = 0; v <= input.length;)
      {
       for (let c = 0; c < 3; c++)
       {
        s[c] = 0;
       }
       for (let r = 0; r < 3; r++)
       {
        for (let q = 0; q < 4; q++)
        {
         if (v >= input.length)
         {
          s[r] |= 1 << (q * 8);
          for (let c = 0; c < 3; c++)
          {
           ab.b[c * 13] ^= s[c];
           ab.a[16 + c] ^= s[c];
          }
          for (let c = 0; c < 18; c++)
          {
           _beltmill(ab);
          }
          return _fmt64(ab);
         }
         let x = input.charCodeAt(v);
         x &= 0xff;
         v++;
         s[r] |= x << (q * 8);
        }
       }
       for (let c = 0; c < 3; c++)
       {
        ab.b[c * 13] ^= s[c];
        ab.a[16 + c] ^= s[c];
       }
       _beltmill(ab);
      }
      for (let c = 0; c < 16; c++)
      {
       _beltmill(ab);
      }
      return _fmt64(ab);
     }

     function _beltmill(ab)
     {
      const q = [];
      for (let c = 0; c < 3; c++)
      {
       q[c] = ab.b[c * 13 + 12];
      }
      for (let i = 12; i > 0; i--)
      {
       for (let c = 0; c < 3; c++)
       {
        ab.b[c * 13 + i] = ab.b[c * 13 + i - 1];
       }
      }
      for (let c = 0; c < 3; c++)
      {
       ab.b[c * 13] = q[c];
      }
      for (let c = 0; c < 12; c++)
      {
       const n = c + 1 + ((c % 3) * 13);
       ab.b[n] ^= ab.a[c + 1];
      }
      const ap = [];
      for (let c = 0; c < 19; c++)
      {
       const y = (c * 7) % 19;
       const r = (((c * c) + c) / 2) % 32;
       const x = ab.a[y] ^ (ab.a[(y + 1) % 19] | (ab.a[(y + 2) % 19] ^ 0xffffffff));
       ap[c] = (x >>> r) | (x << (32 - r));
      }
      for (let c = 0; c < 19; c++)
      {
       ab.a[c] = ap[c] ^ ap[(c + 1) % 19] ^ ap[(c + 4) % 19];
      }
      ab.a[0] ^= 1;
      for (let c = 0; c < 3; c++)
      {
       ab.a[c + 13] ^= q[c];
      }
     }

     function _nextword(ab)
     {
      let z = ab.a[ab.p];
      if (z < 0)
       z += 0x100000000;
      ab.p++;
      if (ab.p > 2)
      {
       ab.p = 1;
       _beltmill(ab);
      }
      return z;
     }

     function _rng(ab)
     {
      const r = _nextword(ab);
      return ((r & 0xff000000) >>> 24) |
             ((r & 0x00ff0000) >>>  8) |
             ((r & 0x0000ff00) <<   8) |
             ((r & 0x000000ff) <<  24);
     }

     function _u8ToBase64(bytes)
     {
      let binary = '';
      for (let i = 0, l = bytes.byteLength; i < l; i++)
      {
       binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary).replaceAll('/', '_').replaceAll('+', '-').replaceAll('=', '');
     }

     function _fmt64(ab)
     {
      const a = [];
      for (let i = 0; i < 8; i++)
      {
       let z = _rng(ab);
       if (z < 0)
        z += 0x100000000;
       a.push(z);
      }
      const b32 = new Uint32Array(a);
      const b8 = new Uint8Array(b32.buffer);
      return _u8ToBase64(b8);
     }

     return $c_hashCode;
    }();

    function $getHashParams()
    {
     const d = function(s)
     {
      const a = /\+/g;
      return decodeURIComponent(s.replace(a, ' '));
     };
     const hashParams = {};
     const r = /([^&;=]+)=?([^&;]*)/g;
     const q = window.location.hash.substring(1);
     let e;
     while ((e = r.exec(q)) !== null)
     {
      hashParams[d(e[1])] = d(e[2]);
     }
     return hashParams;
    }

    const $httpRequest = function()
    {
     const _stack = {};
     const _lQueue = 250;
     let _tQueue = false;

     function $c_httpRequest(type, url, hdrs = {}, body = null, nocache = true, ret = true)
     {
      const p = new Promise(
       function(resolve)
       {
        const h = _host(url);
        if (!_stack.hasOwnProperty(h))
         _stack[h] = {queries: [], time: 0};
        const r = {
         req: [type, url, hdrs, body, nocache, ret],
         ret: resolve
        };
        _stack[h].queries.push(r);
        if (_tQueue !== false)
         return;
        const dif = Date.now() - _stack[h].time;
        if (dif < _lQueue)
        {
         _tQueue = window.setTimeout(_tick, _lQueue - dif);
        }
        else
        {
         _tQueue = true;
         shared.doNextFrame(_tick);
        }
       }
      );
      return p;
     }

     function _host(u)
     {
      try
      {
       const h = new URL(u);
       if (!h.hostname)
        return 'null';
       return h.hostname;
      }
      catch
      {
       return 'null';
      }
     }

     function _req(type, url, hdrs = {}, body = null, nocache = true, ret = true)
     {
      const p = new Promise(
       function(resolve)
       {
        const x = new XMLHttpRequest();
        if (nocache)
        {
         if (url.includes('?'))
          url += '&';
         else
          url += '?';
         url += '_=' + (0xFFFFFFFF + shared.rnd(0xFFFFFFFF));
        }
        if (type === 'POST' && !hdrs.hasOwnProperty('Content-Type'))
         hdrs['Content-Type'] = 'application/x-www-form-urlencoded';
        x.open(type, url);
        x.timeout = 10000;
        for (const hK in hdrs)
        {
         if (!hdrs.hasOwnProperty(hK))
          continue;
         x.setRequestHeader(hK, hdrs[hK]);
        }
        x.onreadystatechange = function()
        {
         if (ret === false)
         {
          if (x.readyState < 2)
           return;
          x.ontimeout = null;
          x.onreadystatechange = null;
          resolve(Math.floor(x.status / 100) === 2);
          return;
         }
         if (x.readyState !== 4)
          return;
         x.ontimeout = null;
         x.onreadystatechange = null;
         const h = _parseHeaders(x.getAllResponseHeaders());
         resolve({code: x.status, data: x.responseText, headers: h, get success(){return Math.floor(this.code / 100) === 2;}, get json(){try {return JSON.parse(this.data);} catch {return null;}}});
        };
        x.ontimeout = function()
        {
         x.ontimeout = null;
         x.onreadystatechange = null;
         if (ret === false)
          resolve(false);
         else
          resolve({code: 408, data: shared.errTimeout, get success(){return false;}, get json(){return null;}});
        };
        if (body === null)
         x.send();
        else
         x.send(body);
       }
      );
      return p;
     }

     async function _tick()
     {
      _tQueue = true;
      _cleanup();
      const hList = Object.keys(_stack);
      const reqs = [];
      const rets = [];
      for (let i = 0; i < hList.length; i++)
      {
       const h = hList[i];
       if (_stack[h].queries.length === 0)
        continue;
       const dif = Date.now() - _stack[h].time;
       if (dif < _lQueue)
        continue;
       _stack[h].time = Date.now();
       const r = _stack[h].queries.shift();
       reqs.push(_req(...r.req));
       rets.push(r.ret);
      }
      if (reqs.length > 0)
      {
       const ret = await Promise.allSettled(reqs);
       for (let i = 0; i < ret.length; i++)
       {
        _stack[hList[i]].time = Date.now();
        if (ret[i].status !== 'fulfilled')
        {
         rets[i]({code: 0, data: '', get success(){return false;}, get json(){return null;}});
         continue;
        }
        rets[i](ret[i].value);
       }
      }
      _cleanup();
      if (Object.keys(_stack).length === 0)
       _tQueue = false;
      else
       _tQueue = window.setTimeout(_tick, _lQueue);
     }

     function _cleanup()
     {
      const hList = Object.keys(_stack);
      for (let i = 0; i < hList.length; i++)
      {
       const h = hList[i];
       if (_stack[h].queries.length === 0)
        delete _stack[h];
      }
     }

     return $c_httpRequest;
    }();

    function _parseHeaders(s)
    {
     const a = {};
     if (s === null)
      return a;
     if (s.indexOf('\r\n') === -1)
      return a;
     const h = s.split('\r\n');
     for (let i = 0, l = h.length; i < l; i++)
     {
      if (h[i].indexOf(': ') === -1)
       continue;
      const kv = h[i].split(': ', 2);
      a[kv[0].toLowerCase()] = kv[1];
     }
     return a;
    }

    function $findInMaybeRange(r, v)
    {
     const t = typeof r;
     switch (t)
     {
      case 'undefined':
       return false;
      case 'boolean':
       return r === true;
      case 'number':
       if (r > 0 && v >= r)
        return true;
       return false;
      case 'object':
       if (r === null)
        return false;
       for (const k in r)
       {
        if (!r.hasOwnProperty(k))
         continue;
        let lower, upper;
        if (k.slice(-1) === '+')
        {
         lower = parseInt(k.slice(0, -1), 10);
         upper = Number.MAX_SAFE_INTEGER;
        }
        else if (k.indexOf('-') !== -1)
        {
         lower = parseInt(k.slice(0, k.indexOf('-')), 10);
         upper = parseInt(k.slice(k.indexOf('-') + 1), 10);
        }
        else
        {
         lower = parseInt(k, 10);
         upper = parseInt(k, 10);
        }
        if (v >= lower && v <= upper)
         return r[k];
       }
     }
     return false;
    }

    function $clearAddr()
    {
     const o = window.location.toString();
     let u = o;
     if (u.indexOf('#') > -1)
      u = u.slice(0, u.indexOf('#'));
     if (u !== o)
      window.history.replaceState(null, '', u);
    }

    function $doNextFrame(cb, ...a)
    {
     let n = false;
     function _next()
     {
      if (n === false)
      {
       n = true;
       window.requestAnimationFrame(_next);
       return;
      }
      cb(...a);
     }
     window.requestAnimationFrame(_next);
    }

    function $unIndent(h, r)
    {
     if (typeof r !== 'object' || r === null)
      r = {indent: 0};
     if (!r.hasOwnProperty('indent'))
      r = {indent: 0};
     while (h.slice(0, 1) === '\n' || h.slice(0, 1) === '\r')
      h = h.slice(1);
     let spc = 0;
     while (h.slice(0, 1) === ' ' || h.slice(0, 1) === '\t')
     {
      spc++;
      h = h.slice(1);
     }
     if (spc > 0)
      h = h.replaceAll('\n' + ' '.repeat(spc), '\n');
     while (h.slice(-1) === '\n' || h.slice(-1) === '\r' || h.slice(-1) === ' ' || h.slice(-1) === '\t')
      h = h.slice(0, -1);
     r.indent = spc;
     return h;
    }

    function $reIndent(h, r)
    {
     if (typeof r !== 'object' || r === null)
      r = {indent: 0};
     if (!r.hasOwnProperty('indent'))
      return h;
     if (r.indent < 1)
      return h;
     return '\n' + ' '.repeat(r.indent) + h.replaceAll('\n', '\n' + ' '.repeat(r.indent)) + '\n  ';
    }

    function $shadowCSS(o)
    {
     let s = '';
     if (o.hasOwnProperty('offset') && o.offset !== false)
     {
      if (o.offset.hasOwnProperty('x') && Number.isInteger(o.offset.x))
      {
       if (o.offset.x > 4)
        s += '4px ';
       else if (o.offset.x < -4)
        s += '-4px ';
       else
        s += o.offset.x + 'px ';
      }
      else
       s += '0px ';
      if (o.offset.hasOwnProperty('y') && Number.isInteger(o.offset.y))
      {
       if (o.offset.y > 4)
        s += '4px ';
       else if (o.offset.y < -4)
        s += '-4px ';
       else
        s += o.offset.y + 'px ';
      }
      else
       s += '0px ';
     }
     else
      s += '0px 0px ';
     if (o.hasOwnProperty('blur') && Number.isInteger(o.blur))
     {
      if (o.blur > 4)
       s += '4px ';
      else if (o.blur < 0)
       s += '0px ';
      else
       s += o.blur + 'px ';
     }
     else
      s += '0px ';
     if (s === '0px 0px 0px ')
      return false;
     if (o.hasOwnProperty('color') && o.color !== false)
      s += o.color;
     else
      s += '#000000';
     return 'filter: drop-shadow(' + s + ');';
    }

    function $hueSync()
    {
     if (_tHue !== false)
     {
      window.clearTimeout(_tHue);
      _tHue = false;
     }
     if (cfg.display.hue === 'rave')
      _tHue = window.setTimeout(_hueSync, 100);
    }

    function _hueSync()
    {
     const anims = document.getAnimations();
     if (anims.length === 0)
      return;
     let rIdx = -1;
     for (let i = 0; i < anims.length; i++)
     {
      if (anims[i].animationName !== 'rave')
       continue;
      if (anims[i].currentTime === null)
       continue;
      rIdx = i;
      break;
     }
     if (rIdx === -1)
      return;
     for (let i = 0; i < anims.length; i++)
     {
      if (anims[i].animationName !== 'antirave')
       continue;
      if (anims[i].currentTime === anims[rIdx].currentTime)
       continue;
      anims[i].currentTime = anims[rIdx].currentTime;
     }
    }

    const $mspf = function()
    {
     let _init = 0;
     const _avg = [];

     function $init()
     {
      if (shared.mspf.value !== 0)
       return;
      window.requestAnimationFrame(_test);
     }

     function _test(ms)
     {
      if (_init !== 0)
       _avg.push(ms - _init);
      if (_avg.length > 2)
       shared.mspf.value = _avg.reduce((a, b) => (a+b)) / _avg.length;
      if (_avg.length > 300)
      {
       shared.mspf.value = Math.round(shared.mspf.value * 1000) / 1000;
       return;
      }
      _init = ms;
      window.requestAnimationFrame(_test);
     }

     return {
      init: $init,
      value: 0
     };
    }();

    const $ec = function()
    {
     const _tmpEC = {};
     const _iHalt = 15000;
     const _iTDef = 2000;
     const _iTMin = 500;
     const _iTStep = 50;
     const _iPre = 16;
     let _iTmr = _iTDef;
     let _bActive = false;
     let _tCache = false;
     let _tNext = false;

     function $init()
     {
      _bActive = true;
      _tNext = false;
      _nextTick();
     }

     function $save(url, w, h)
     {
      if (w === h)
       _tmpEC[url] = null;
      else
       _tmpEC[url] = {width: w, height: h};
     }

     function $get(url)
     {
      if (!_tmpEC.hasOwnProperty(url))
       return null;
      return _tmpEC[url];
     }

     function $halt()
     {
      _iTmr = _iTDef;
      _bActive = false;
      if (_tCache !== false)
      {
       window.clearTimeout(_tCache);
       _tCache = false;
      }
      if (_tNext !== false)
       window.clearTimeout(_tNext);
      _tNext = window.setTimeout(_resume, _iHalt);
     }

     function _resume()
     {
      if (_bActive)
       return;
      _bActive = true;
      if (_tNext !== false)
      {
       window.clearTimeout(_tNext);
       _tNext = false;
      }
      if (_tCache !== false)
       window.clearTimeout(_tCache);
      _tCache = window.setTimeout(_tick, _iTmr);
     }

     function _tick()
     {
      if (!_bActive)
       return;
      if (service.cSafe.length === 0)
      {
       _iTmr = _iTDef;
       _nextTick();
       return;
      }
      const toCache = [];
      for (let i = 0, l = service.cSafe.length; i < l; i++)
      {
       if (_tmpEC.hasOwnProperty(service.cSafe[i].url))
        continue;
       if (toCache.includes(service.cSafe[i].url))
        continue;
       toCache.push(service.cSafe[i].url);
      }
      if (toCache.length === 0)
      {
       _iTmr = _iTDef;
       _nextTick();
       return;
      }
      const uNext = toCache[shared.rnd(toCache.length)];
      _doCache(uNext);
     }

     function _doCache(url)
     {
      const img = new Image();
      const tStart = Date.now();
      img.onload = function()
      {
       img.onload = null;
       img.onerror = null;
       const tDur = Date.now() - tStart;
       shared.ec.save(url, img.naturalWidth, img.naturalHeight);
       if (tDur < _iPre)
       {
        _tick();
        return;
       }
       _iTmr -= _iTStep;
       if (_iTmr < _iTMin)
        _iTmr = _iTMin;
       _nextTick();
      };
      img.onerror = function()
      {
       img.onload = null;
       img.onerror = null;
       _iTmr = _iTDef;
       _nextTick();
      };
      img.src = url;
     }

     function _nextTick()
     {
      if (!_bActive)
       return;
      if (_tCache !== false)
       window.clearTimeout(_tCache);
      _tCache = window.setTimeout(_tick, _iTmr);
     }

     return {
      init: $init,
      save: $save,
      get: $get,
      halt: $halt
     };
    }();

    const $storage = function()
    {
     function $getItem(key)
     {
      if (_ls.has())
       return _ls.getItem(key);
      if (_cookie.has())
       return _cookie.getItem(key);
      return null;
     }

     function $setItem(key, value)
     {
      if (_ls.has())
       _ls.setItem(key, value);
      else if (_cookie.has())
       _cookie.setItem(key, value);
     }

     function $removeItem(key)
     {
      if (_ls.has())
       _ls.removeItem(key);
      else if (_cookie.has())
       _cookie.removeItem(key);
     }

     const _ls = function()
     {
      let _has = null;

      function $has()
      {
       if (_has !== null)
        return _has;
       if (!window.hasOwnProperty('localStorage'))
       {
        _has = false;
        return false;
       }
       if (typeof window.localStorage === 'undefined')
       {
        _has = false;
        return false;
       }
       if (window.localStorage === null)
       {
        _has = false;
        return false;
       }
       const testK = 'testing.key';
       const testV = 'testing.val';
       window.localStorage.setItem(testK, testV);
       const retV = window.localStorage.getItem(testK);
       window.localStorage.removeItem(testK);
       if (testV !== retV)
       {
        _has = false;
        return false;
       }
       _has = true;
       return true;
      }

      function $get(key)
      {
       if (!_ls.has())
        return null;
       return window.localStorage.getItem(key);
      }

      function $set(key, value)
      {
       if (!_ls.has())
        return;
       window.localStorage.setItem(key, value);
      }

      function $remove(key)
      {
       if (!_ls.has())
        return;
       window.localStorage.removeItem(key);
      }

      return {
       has: $has,
       getItem: $get,
       setItem: $set,
       removeItem: $remove
      };
     }();

     const _cookie = function()
     {
      let _has = null;

      function $has()
      {
       if (_has !== null)
        return _has;
       if (!('cookie' in document))
       {
        _has = false;
        return false;
       }
       if (typeof document.cookie !== 'string')
       {
        _has = false;
        return false;
       }
       const testK = 'testing.key';
       const testV = 'testing.val';
       document.cookie = testK + '=' + encodeURIComponent(testV) + ';max-age=10';
       let retV = null;
       const cTrimmed = document.cookie.replaceAll(/\s*;\s*/g, ';');
       const cCookies = cTrimmed.split(';');
       for (let i = 0, l = cCookies.length; i < l; i++)
       {
        const kv = cCookies[i].split('=');
        if (kv[0] === testK)
        {
         retV = decodeURIComponent(kv[1]);
         break;
        }
       }
       document.cookie = testK + '=;max-age=0';
       if (testV !== retV)
       {
        _has = false;
        return false;
       }
       _has = true;
       return true;
      }

      function $get(key)
      {
       if (!_cookie.has())
        return null;
       let r = null;
       const cTrimmed = document.cookie.replaceAll(/\s*;\s*/g, ';');
       const cCookies = cTrimmed.split(';');
       for (let i = 0, l = cCookies.length; i < l; i++)
       {
        const kv = cCookies[i].split('=');
        if (kv[0] === key)
         r = decodeURIComponent(kv[1]);
        _cookie.setItem(kv[0], decodeURIComponent(kv[1]));
       }
       return r;
      }

      function $set(key, value, age = 34560000)
      {
       if (!_cookie.has())
        return;
       document.cookie = key + '=' + encodeURIComponent(value) + ';max-age=' + age;
      }

      function $remove(key)
      {
       if (!_cookie.has())
        return;
       const cTrimmed = document.cookie.replaceAll(/\s*;\s*/g, ';');
       const cCookies = cTrimmed.split(';');
       for (let i = 0, l = cCookies.length; i < l; i++)
       {
        const kv = cCookies[i].split('=');
        if (kv[0] === key)
        {
         _cookie.setItem(kv[0], '', 0);
         break;
        }
       }
      }

      return {
       has: $has,
       getItem: $get,
       setItem: $set,
       removeItem: $remove
      };
     }();

     return {
      getItem: $getItem,
      setItem: $setItem,
      removeItem: $removeItem
     };
    }();

    return {
     inputBox: $inputBox,
     rnd: $rnd,
     hashCode: $hashCode,
     getHashParams: $getHashParams,
     httpRequest: $httpRequest,
     errTimeout: Symbol(),
     findInMaybeRange: $findInMaybeRange,
     clearAddr: $clearAddr,
     doNextFrame: $doNextFrame,
     unIndent: $unIndent,
     reIndent: $reIndent,
     shadowCSS: $shadowCSS,
     hueSync: $hueSync,
     mspf: $mspf,
     ec: $ec,
     storage: $storage,
     cfgHash: false,
     cfgVal: Object.freeze({
      CHANNEL: 0x01,
      REFRESH_TOKEN: 0x02,
      ACCESS_TOKEN: 0x04,
      JWT_TOKEN: 0x08
     }),
     nReg: {
      i: /^\d+$/,
      f: /^[\d.-]+$/
     }
    };
   }();

   const loginT = function()
   {
    let _tL = false;
    const _visTime = 5000;
    const _idLogin = 'cmdTLogin';
    const _idLogout = 'cmdTLogout';

    function _activeScope()
    {
     const r = [];
     r.push(cScopes.twitch.read);
     for (const k of cfg.commands)
     {
      if (!k.hasOwnProperty('redeem') || !Array.isArray(k.redeem) || k.redeem.length === 0)
       continue;
      r.push(cScopes.twitch.redemptions);
      break;
     }
     let needF = false;
     if (cfg.event.twitch.follow !== false)
      needF = true;
     else
     {
      if ((cfg.display.access & twitch.Access.FOLLOWER) === twitch.Access.FOLLOWER && (cfg.display.access & twitch.Access.STRANGER) !== twitch.Access.STRANGER)
       needF = true;
      else if ((cfg.display.kappa.access & twitch.Access.FOLLOWER) === twitch.Access.FOLLOWER && (cfg.display.kappa.access & twitch.Access.STRANGER) !== twitch.Access.STRANGER)
       needF = true;
      else
      {
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('styles'))
         continue;
        if (!k.hasOwnProperty('access'))
         continue;
        if ((k.access & twitch.Access.FOLLOWER) === twitch.Access.FOLLOWER && (k.access & twitch.Access.STRANGER) !== twitch.Access.STRANGER)
        {
         needF = true;
         break;
        }
       }
      }
     }
     if (needF)
      r.push(cScopes.twitch.followers);
     if (cfg.event.twitch.hypetrain !== false && ((cfg.event.twitch.hypetrain.hasOwnProperty('begin') && cfg.event.twitch.hypetrain.begin !== false) || (cfg.event.twitch.hypetrain.hasOwnProperty('success') && cfg.event.twitch.hypetrain.success !== false)))
      r.push(cScopes.twitch.hypetrains);
     else if (cfg.event.twitch.kappatrain !== false && ((cfg.event.twitch.kappatrain.hasOwnProperty('begin') && cfg.event.twitch.kappatrain.begin !== false) || (cfg.event.twitch.kappatrain.hasOwnProperty('success') && cfg.event.twitch.kappatrain.success !== false)))
      r.push(cScopes.twitch.hypetrains);
     else if (cfg.event.twitch.treasuretrain !== false && ((cfg.event.twitch.treasuretrain.hasOwnProperty('begin') && cfg.event.twitch.treasuretrain.begin !== false) || (cfg.event.twitch.treasuretrain.hasOwnProperty('success') && cfg.event.twitch.treasuretrain.success !== false)))
      r.push(cScopes.twitch.hypetrains);
     if (cfg.event.twitch.goal !== false && ((cfg.event.twitch.goal.hasOwnProperty('begin') && cfg.event.twitch.goal.begin !== false) || (cfg.event.twitch.goal.hasOwnProperty('achieved') && cfg.event.twitch.goal.achieved !== false)))
      r.push(cScopes.twitch.goals);
     if (cfg.event.twitch.poll !== false && ((cfg.event.twitch.poll.hasOwnProperty('begin') && cfg.event.twitch.poll.begin !== false) || (cfg.event.twitch.poll.hasOwnProperty('end') && cfg.event.twitch.poll.end !== false)))
      r.push(cScopes.twitch.polls);
     if (cfg.event.twitch.prediction !== false && ((cfg.event.twitch.prediction.hasOwnProperty('begin') && cfg.event.twitch.prediction.begin !== false) || (cfg.event.twitch.prediction.hasOwnProperty('resolved') && cfg.event.twitch.prediction.resolved !== false)))
      r.push(cScopes.twitch.predictions);
     if (cfg.event.twitch.charity !== false)
      r.push(cScopes.twitch.charity);
     if (cfg.event.twitch.shoutout !== false && ((cfg.event.twitch.shoutout.hasOwnProperty('create') && cfg.event.twitch.shoutout.create !== false && cfg.event.twitch.shoutout.create.hasOwnProperty('styles') && cfg.event.twitch.shoutout.create.styles !== false) || (cfg.event.twitch.shoutout.hasOwnProperty('receive') && cfg.event.twitch.shoutout.receive !== false && cfg.event.twitch.shoutout.receive.hasOwnProperty('styles') && cfg.event.twitch.shoutout.receive.styles !== false)))
      r.push(cScopes.twitch.shoutouts);
     return r;
    }

    function _uScope()
    {
     return encodeURIComponent(_activeScope().join(' '));
    }

    function $path()
    {
     if (loginT.cfgHash !== false)
      return 'twitch.' + loginT.cfgHash;
     return shared.cfgHash + '.twitch';
    }

    function $use()
    {
     if (loginT.inUse === false)
      return false;
     if (twitch.net.oAuth.hasLogin)
     {
      loginT.showOut();
      return false;
     }
     loginT.showIn(true);
     return true;
    }

    function $begin()
    {
     twitch.net.oAuth.clear();
     let loc = window.location.toString();
     if (window.location.hash.length > 1)
      loc = loc.slice(0, -1 * window.location.hash.length);
     const o = encodeURIComponent(window.btoa(loc));
     const c = encodeURIComponent(oauthClient.t);
     const r = encodeURIComponent(cURLs.html.rr.auth.t);
     const u = cURLs.html.twitch.replaceAll(cVARs.url.clientID, c).replaceAll(cVARs.url.uri, r).replaceAll(cVARs.url.scope, _uScope()).replaceAll(cVARs.url.origin, o);
     if (u.length < 1500)
     {
      window.location = u;
      return;
     }
     const f = document.createElement('form');
     f.setAttribute('method', 'POST');
     f.setAttribute('action', cURLs.html.rr.redir);
     const ft = document.createElement('input');
     ft.setAttribute('type', 'hidden');
     ft.setAttribute('name', 't');
     ft.setAttribute('value', 'code');
     f.appendChild(ft);
     const fv = document.createElement('input');
     fv.setAttribute('type', 'hidden');
     fv.setAttribute('name', 'v');
     fv.setAttribute('value', 'twitch');
     f.appendChild(fv);
     const fc = document.createElement('input');
     fc.setAttribute('type', 'hidden');
     fc.setAttribute('name', 'c');
     fc.setAttribute('value', oauthClient.t);
     f.appendChild(fc);
     const fr = document.createElement('input');
     fr.setAttribute('type', 'hidden');
     fr.setAttribute('name', 'r');
     fr.setAttribute('value', cURLs.html.rr.auth.t);
     f.appendChild(fr);
     const fs = document.createElement('input');
     fs.setAttribute('type', 'hidden');
     fs.setAttribute('name', 's');
     fs.setAttribute('value', _activeScope().join(' '));
     f.appendChild(fs);
     const fu = document.createElement('input');
     fu.setAttribute('type', 'hidden');
     fu.setAttribute('name', 'u');
     fu.setAttribute('value', loc);
     f.appendChild(fu);
     document.body.appendChild(f);
     f.submit();
    }

    function $showIn(auto = false)
    {
     if (document.getElementById(_idLogout))
      document.body.removeChild(document.getElementById(_idLogout));
     twitch.net.oAuth.clear();
     const cmdLogin = document.createElement('button');
     cmdLogin.setAttribute('id', _idLogin);
     cmdLogin.setAttribute('type', 'button');
     cmdLogin.classList.add('twitch');
     cmdLogin.classList.add('auth');
     cmdLogin.classList.add('unauthorized');
     document.addEventListener('mouseover', _fadeInLogin);
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
     cmdLogin.setAttribute('onclick', 'loginT.begin();');
     cmdLogin.innerHTML = 'Twitch<br><span>Log In</span>';
     if (auto && (youtube.net.oAuth.hasLogin || kick.net.oAuth.hasLogin || lfg.net.oAuth.hasLogin))
      cmdLogin.classList.add('hidden');
     document.body.appendChild(cmdLogin);
     shared.hueSync();
    }

    function _fadeInLogin()
    {
     if (document.getElementById(_idLogin) && document.getElementById(_idLogin).classList.contains('hidden'))
     {
      document.getElementById(_idLogin).classList.remove('hidden');
      shared.hueSync();
     }
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
    }

    function _fadeOutLogin()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById(_idLogin))
      document.getElementById(_idLogin).classList.add('hidden');
    }

    function $showOut(v = false)
    {
     if (document.getElementById(_idLogout))
      document.body.removeChild(document.getElementById(_idLogout));
     const cmdLogout = document.createElement('button');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     cmdLogout.setAttribute('id', _idLogout);
     cmdLogout.setAttribute('type', 'button');
     cmdLogout.classList.add('twitch');
     cmdLogout.classList.add('auth');
     document.addEventListener('mousemove', _fadeInLogout);
     if (v)
     {
      cmdLogout.classList.add('unauthorized');
      cmdLogout.setAttribute('onclick', 'loginT.begin();');
      cmdLogout.innerHTML = 'Twitch<br><span>Re-Auth</span>';
      _tL = window.setTimeout(_fadeOutLogout, _visTime);
     }
     else
     {
      cmdLogout.classList.add('authorized');
      cmdLogout.setAttribute('onclick', 'loginT.logOut();');
      cmdLogout.innerHTML = 'Twitch<br><span>Log Out</span>';
      cmdLogout.classList.add('hidden');
     }
     document.body.appendChild(cmdLogout);
     shared.hueSync();
    }

    function $logOut()
    {
     twitch.net.oAuth.clear();
     if (window.location.hash.length < 2)
      window.location.reload();
     else
      window.location = window.location.href.slice(0, -1 * window.location.hash.length);
    }

    function _fadeInLogout()
    {
     if (document.getElementById(_idLogout) && document.getElementById(_idLogout).classList.contains('hidden'))
     {
      document.getElementById(_idLogout).classList.remove('hidden');
      shared.hueSync();
     }
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogout, _visTime);
    }

    function _fadeOutLogout()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById(_idLogout))
      document.getElementById(_idLogout).classList.add('hidden');
    }

    return {
     inUse: false,
     use: $use,
     begin: $begin,
     showIn: $showIn,
     showOut: $showOut,
     logOut: $logOut,
     path: $path,
     cfgHash: false
    };
   }();

   const loginYT = function()
   {
    let _tL = false;
    const _visTime = 5000;
    const _idLogin = 'cmdYTLogin';
    const _idLogout = 'cmdYTLogout';

    function _activeScope()
    {
     const r = [];
     r.push(cScopes.youtube.readonly);
     let hasM = false;
     if ((cfg.event.youtube.member.first === true) || (Array.isArray(cfg.event.youtube.member.first) && cfg.event.youtube.member.first.length > 0))
      hasM = true;
     if ((cfg.event.youtube.member.milestone === true) || (typeof cfg.event.youtube.member.milestone === 'object' && cfg.event.youtube.member.milestone !== null && Object.keys(cfg.event.youtube.member.milestone).length > 0))
      hasM = true;
     if ((cfg.event.youtube.member.giftbomb === true) || (typeof cfg.event.youtube.member.giftbomb === 'object' && cfg.event.youtube.member.giftbomb !== null && Object.keys(cfg.event.youtube.member.giftbomb).length > 0))
      hasM = true;
     if (hasM)
      r.push(cScopes.youtube.memberships);
     return r;
    }

    function _uScope()
    {
     return encodeURIComponent(_activeScope().join(' '));
    }

    function $path()
    {
     if (loginYT.cfgHash !== false)
      return 'youtube.' + loginYT.cfgHash;
     return shared.cfgHash + '.youtube';
    }

    function $use()
    {
     if (loginYT.inUse === false)
      return false;
     if (youtube.net.oAuth.hasLogin)
     {
      loginYT.showOut();
      return false;
     }
     loginYT.showIn(true);
     return true;
    }

    function $begin()
    {
     youtube.net.oAuth.clear(true);
     let loc = window.location.toString();
     if (window.location.hash.length > 1)
      loc = loc.slice(0, -1 * window.location.hash.length);
     const o = encodeURIComponent(btoa(loc));
     const c = encodeURIComponent(oauthClient.yt);
     const r = encodeURIComponent(cURLs.html.rr.auth.yt);
     const u = cURLs.html.youtube.replaceAll(cVARs.url.clientID, c).replaceAll(cVARs.url.uri, r).replaceAll(cVARs.url.scope, _uScope()).replaceAll(cVARs.url.origin, o);
     if (u.length < 1500)
     {
      window.location = u;
      return;
     }
     const f = document.createElement('form');
     f.setAttribute('method', 'POST');
     f.setAttribute('action', cURLs.html.rr.redir);
     const ft = document.createElement('input');
     ft.setAttribute('type', 'hidden');
     ft.setAttribute('name', 't');
     ft.setAttribute('value', 'code');
     f.appendChild(ft);
     const fv = document.createElement('input');
     fv.setAttribute('type', 'hidden');
     fv.setAttribute('name', 'v');
     fv.setAttribute('value', 'youtube');
     f.appendChild(fv);
     const fc = document.createElement('input');
     fc.setAttribute('type', 'hidden');
     fc.setAttribute('name', 'c');
     fc.setAttribute('value', oauthClient.yt);
     f.appendChild(fc);
     const fr = document.createElement('input');
     fr.setAttribute('type', 'hidden');
     fr.setAttribute('name', 'r');
     fr.setAttribute('value', cURLs.html.rr.auth.yt);
     f.appendChild(fr);
     const fs = document.createElement('input');
     fs.setAttribute('type', 'hidden');
     fs.setAttribute('name', 's');
     fs.setAttribute('value', _activeScope().join(' '));
     f.appendChild(fs);
     const fu = document.createElement('input');
     fu.setAttribute('type', 'hidden');
     fu.setAttribute('name', 'u');
     fu.setAttribute('value', loc);
     f.appendChild(fu);
     document.body.appendChild(f);
     f.submit();
    }

    function $showIn(auto = false)
    {
     if (document.getElementById(_idLogout))
      document.body.removeChild(document.getElementById(_idLogout));
     youtube.net.oAuth.clear(true);
     const cmdLogin = document.createElement('button');
     cmdLogin.setAttribute('id', _idLogin);
     cmdLogin.setAttribute('type', 'button');
     cmdLogin.classList.add('youtube');
     cmdLogin.classList.add('auth');
     cmdLogin.classList.add('unauthorized');
     document.addEventListener('mouseover', _fadeInLogin);
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
     cmdLogin.setAttribute('onclick', 'loginYT.begin();');
     cmdLogin.innerHTML = 'YouTube<br><span>Log In</span>';
     if (auto && (twitch.net.oAuth.hasLogin || kick.net.oAuth.hasLogin || lfg.net.oAuth.hasLogin))
      cmdLogin.classList.add('hidden');
     document.body.appendChild(cmdLogin);
     shared.hueSync();
    }

    function _fadeInLogin()
    {
     if (document.getElementById(_idLogin) && document.getElementById(_idLogin).classList.contains('hidden'))
     {
      document.getElementById(_idLogin).classList.remove('hidden');
      shared.hueSync();
     }
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
    }

    function _fadeOutLogin()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById(_idLogin))
      document.getElementById(_idLogin).classList.add('hidden');
    }

    function $showOut(v = false)
    {
     if (document.getElementById(_idLogout))
      document.body.removeChild(document.getElementById(_idLogout));
     const cmdLogout = document.createElement('button');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     cmdLogout.setAttribute('id', _idLogout);
     cmdLogout.setAttribute('type', 'button');
     cmdLogout.classList.add('youtube');
     cmdLogout.classList.add('auth');
     document.addEventListener('mouseover', _fadeInLogout);
     if (v)
     {
      cmdLogout.classList.add('unauthorized');
      cmdLogout.setAttribute('onclick', 'loginYT.begin();');
      cmdLogout.innerHTML = 'YouTube<br><span>Re-Auth</span>';
      _tL = window.setTimeout(_fadeOutLogout, _visTime);
     }
     else
     {
      cmdLogout.classList.add('authorized');
      cmdLogout.setAttribute('onclick', 'loginYT.logOut();');
      cmdLogout.innerHTML = 'YouTube<br><span>Log Out</span>';
      cmdLogout.classList.add('hidden');
     }
     document.body.appendChild(cmdLogout);
     shared.hueSync();
    }

    function $logOut()
    {
     youtube.net.oAuth.clear(true);
     if (window.location.hash.length < 2)
      window.location.reload();
     else
      window.location = window.location.href.slice(0, -1 * window.location.hash.length);
    }

    function _fadeInLogout()
    {
     if (document.getElementById(_idLogout) && document.getElementById(_idLogout).classList.contains('hidden'))
     {
      document.getElementById(_idLogout).classList.remove('hidden');
      shared.hueSync();
     }
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogout, _visTime);
    }

    function _fadeOutLogout()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById(_idLogout))
      document.getElementById(_idLogout).classList.add('hidden');
    }

    return {
     inUse: false,
     use: $use,
     begin: $begin,
     showIn: $showIn,
     showOut: $showOut,
     logOut: $logOut,
     path: $path,
     cfgHash: false
    };
   }();

   const loginK = function()
   {
    let _tL = false;
    const _visTime = 5000;
    const _idLogin = 'cmdKLogin';
    const _idLogout = 'cmdKLogout';

    function $path()
    {
     return shared.cfgHash + '.kick';
    }

    function $use()
    {
     if (loginK.inUse === false)
      return false;
     if (kick.net.oAuth.hasLogin)
     {
      loginK.showOut();
      return false;
     }
     loginK.showIn(true);
     return true;
    }

    async function $begin()
    {
     let r = await shared.inputBox('Enter your Kick Channel:');
     if (r === '' || r === false || r === null)
      return;
     r = r.toLowerCase();
     if (r.indexOf('kick.com/') > -1)
      r = r.slice(r.indexOf('kick.com/') + 9);
     shared.storage.setItem(loginK.path() + '.channel', r);
     if (window.location.hash.length < 2)
      window.location.reload();
     else
      window.location = window.location.href.slice(0, -1 * window.location.hash.length);
    }

    function $showIn(auto = false)
    {
     if (document.getElementById(_idLogout))
      document.body.removeChild(document.getElementById(_idLogout));
     const cmdLogin = document.createElement('button');
     cmdLogin.setAttribute('id', _idLogin);
     cmdLogin.setAttribute('type', 'button');
     cmdLogin.classList.add('kick');
     cmdLogin.classList.add('auth');
     cmdLogin.classList.add('unauthorized');
     document.addEventListener('mouseover', _fadeInLogin);
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
     cmdLogin.setAttribute('onclick', 'loginK.begin();');
     cmdLogin.innerHTML = 'Kick<br><span>Log In</span>';
     if (auto && (youtube.net.oAuth.hasLogin || twitch.net.oAuth.hasLogin || lfg.net.oAuth.hasLogin))
      cmdLogin.classList.add('hidden');
     document.body.appendChild(cmdLogin);
     shared.hueSync();
    }

    function _fadeInLogin()
    {
     if (document.getElementById(_idLogin) && document.getElementById(_idLogin).classList.contains('hidden'))
     {
      document.getElementById(_idLogin).classList.remove('hidden');
      shared.hueSync();
     }
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
    }

    function _fadeOutLogin()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById(_idLogin))
      document.getElementById(_idLogin).classList.add('hidden');
    }

    function $showOut(v = false)
    {
     if (document.getElementById(_idLogin))
      document.body.removeChild(document.getElementById(_idLogin));
     if (document.getElementById(_idLogout))
      document.body.removeChild(document.getElementById(_idLogout));
     const cmdLogout = document.createElement('button');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     cmdLogout.setAttribute('id', _idLogout);
     cmdLogout.setAttribute('type', 'button');
     cmdLogout.classList.add('kick');
     cmdLogout.classList.add('auth');
     document.addEventListener('mousemove', _fadeInLogout);
     if (v)
     {
      cmdLogout.classList.add('unauthorized');
      cmdLogout.setAttribute('onclick', 'loginK.begin();');
      cmdLogout.innerHTML = 'Kick<br><span>Re-Auth</span>';
      _tL = window.setTimeout(_fadeOutLogout, _visTime);
     }
     else
     {
      cmdLogout.classList.add('authorized');
      cmdLogout.setAttribute('onclick', 'loginK.logOut();');
      cmdLogout.innerHTML = 'Kick<br><span>Log Out</span>';
      cmdLogout.classList.add('hidden');
     }
     document.body.appendChild(cmdLogout);
     shared.hueSync();
    }

    function $logOut()
    {
     shared.storage.removeItem(loginK.path() + '.channel');
     if (window.location.hash.length < 2)
      window.location.reload();
     else
      window.location = window.location.href.slice(0, -1 * window.location.hash.length);
    }

    function _fadeInLogout()
    {
     if (document.getElementById(_idLogout) && document.getElementById(_idLogout).classList.contains('hidden'))
     {
      document.getElementById(_idLogout).classList.remove('hidden');
      shared.hueSync();
     }
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogout, _visTime);
    }

    function _fadeOutLogout()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById(_idLogout))
      document.getElementById(_idLogout).classList.add('hidden');
    }

    return {
     inUse: false,
     use: $use,
     begin: $begin,
     showIn: $showIn,
     showOut: $showOut,
     logOut: $logOut,
     path: $path
    };
   }();

   const loginL = function()
   {
    let _tL = false;
    const _visTime = 5000;
    const _idLogin = 'cmdLLogin';
    const _idLogout = 'cmdLLogout';

    function $path()
    {
     return shared.cfgHash + '.lfg';
    }

    function $use()
    {
     if (loginL.inUse === false)
      return false;
     if (lfg.net.oAuth.hasLogin)
     {
      loginL.showOut();
      return false;
     }
     loginL.showIn(true);
     return true;
    }

    async function $begin()
    {
     let r = await shared.inputBox('Enter your LFG Channel:');
     if (r === '' || r === false || r === null)
      return;
     r = r.toLowerCase();
     if (r.indexOf('lfg.tv/') > -1)
      r = r.slice(r.indexOf('lfg.tv/') + 7);
     shared.storage.setItem(loginL.path() + '.channel', r);
     if (window.location.hash.length < 2)
      window.location.reload();
     else
      window.location = window.location.href.slice(0, -1 * window.location.hash.length);
    }

    function $showIn(auto = false)
    {
     if (document.getElementById(_idLogout))
      document.body.removeChild(document.getElementById(_idLogout));
     const cmdLogin = document.createElement('button');
     cmdLogin.setAttribute('id', _idLogin);
     cmdLogin.setAttribute('type', 'button');
     cmdLogin.classList.add('lfg');
     cmdLogin.classList.add('auth');
     cmdLogin.classList.add('unauthorized');
     document.addEventListener('mouseover', _fadeInLogin);
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
     cmdLogin.setAttribute('onclick', 'loginL.begin();');
     cmdLogin.innerHTML = 'LFG<br><span>Log In</span>';
     if (auto && (youtube.net.oAuth.hasLogin || twitch.net.oAuth.hasLogin || kick.net.oAuth.hasLogin))
      cmdLogin.classList.add('hidden');
     document.body.appendChild(cmdLogin);
     shared.hueSync();
    }

    function _fadeInLogin()
    {
     if (document.getElementById(_idLogin) && document.getElementById(_idLogin).classList.contains('hidden'))
     {
      document.getElementById(_idLogin).classList.remove('hidden');
      shared.hueSync();
     }
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogin, _visTime);
    }

    function _fadeOutLogin()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById(_idLogin))
      document.getElementById(_idLogin).classList.add('hidden');
    }

    function $showOut(v = false)
    {
     if (document.getElementById(_idLogin))
      document.body.removeChild(document.getElementById(_idLogin));
     if (document.getElementById(_idLogout))
      document.body.removeChild(document.getElementById(_idLogout));
     const cmdLogout = document.createElement('button');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     cmdLogout.setAttribute('id', _idLogout);
     cmdLogout.setAttribute('type', 'button');
     cmdLogout.classList.add('lfg');
     cmdLogout.classList.add('auth');
     document.addEventListener('mousemove', _fadeInLogout);
     if (v)
     {
      cmdLogout.classList.add('unauthorized');
      cmdLogout.setAttribute('onclick', 'loginL.begin();');
      cmdLogout.innerHTML = 'LFG<br><span>Re-Auth</span>';
      _tL = window.setTimeout(_fadeOutLogout, _visTime);
     }
     else
     {
      cmdLogout.classList.add('authorized');
      cmdLogout.setAttribute('onclick', 'loginL.logOut();');
      cmdLogout.innerHTML = 'LFG<br><span>Log Out</span>';
      cmdLogout.classList.add('hidden');
     }
     document.body.appendChild(cmdLogout);
     shared.hueSync();
    }

    function $logOut()
    {
     shared.storage.removeItem(loginL.path() + '.channel');
     if (window.location.hash.length < 2)
      window.location.reload();
     else
      window.location = window.location.href.slice(0, -1 * window.location.hash.length);
    }

    function _fadeInLogout()
    {
     if (document.getElementById(_idLogout) && document.getElementById(_idLogout).classList.contains('hidden'))
     {
      document.getElementById(_idLogout).classList.remove('hidden');
      shared.hueSync();
     }
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogout, _visTime);
    }

    function _fadeOutLogout()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById(_idLogout))
      document.getElementById(_idLogout).classList.add('hidden');
    }

    return {
     inUse: false,
     use: $use,
     begin: $begin,
     showIn: $showIn,
     showOut: $showOut,
     logOut: $logOut,
     path: $path
    };
   }();

   const startup = function()
   {
    async function $c_startup()
    {
     shared.cfgHash = shared.hashCode(cfg);
     if (shared.storage.getItem('emotewall.oobe') !== '0' && !window.hasOwnProperty('obsstudio') && !window.hasOwnProperty('hostApp') && !window.hasOwnProperty('CefSharp') && navigator.userAgent.indexOf(' XSplitBroadcaster/') === -1)
      await _inBrowser(window.location.protocol === 'file:');
     await _isOnline();
     await _hashRefreshes();
     await twitch.net.oAuth.init();
     await youtube.net.oAuth.init();
     kick.net.oAuth.init();
     lfg.net.oAuth.init();
     await streamelements.oAuth.init();
     shared.mspf.init();
     if (cfg.display.hasOwnProperty('hue') && cfg.display.hue === 'rave' && !_hasRaveToggle())
      document.documentElement.classList.add('rave');
     _css();
     if (cfg.display.hasOwnProperty('statuses') && cfg.display.statuses === 'init')
      notice.initHide();
     if (!shared.storage.getItem('emotewall.obs_notfound') && !window.hasOwnProperty('obsstudio') && !window.hasOwnProperty('hostApp') && !window.hasOwnProperty('CefSharp') && navigator.userAgent.indexOf(' XSplitBroadcaster/') === -1)
     {
      shared.storage.setItem('emotewall.obs_notfound', '1');
      notice.error(notice.Type.GLOBAL_OBS);
     }
     loginT.use();
     loginYT.use();
     loginK.use();
     loginL.use();
     const bT = twitch.net.oAuth.hasLogin;
     const bYT = youtube.net.oAuth.hasLogin;
     const bK = kick.net.oAuth.hasLogin;
     const bL = lfg.net.oAuth.hasLogin;
     const scks = [];
     if (bT | bYT | bK | bL)
      scks.push(_emoji());
     if (bT | bYT | bK)
     {
      scks.push(_streamlabs());
      scks.push(_streamelements());
      scks.push(_7tv());
     }
     if (bT | bYT)
     {
      scks.push(_ffz());
      scks.push(_bttv());
     }
     if (scks.length > 0)
      await Promise.allSettled(scks);
     shared.ec.init();
     const svcs = [];
     if (bT)
      svcs.push(_twitch());
     else
      twitch.net.dead = true;
     if (bYT)
      svcs.push(_youtube());
     else
      youtube.net.dead = true;
     if (bK)
      svcs.push(_kick());
     else
      kick.net.dead = true;
     if (bL)
      svcs.push(_lfg());
     else
      lfg.net.dead = true;
     if (svcs.length === 0)
      return;
     const rets = await Promise.allSettled(svcs);
     if (bT)
     {
      const rT = rets.shift();
      if (rT.status !== 'fulfilled' || rT.value === false)
       twitch.net.dead = true;
     }
     if (bYT)
     {
      const rYT = rets.shift();
      if (rYT.status !== 'fulfilled' || rYT.value === false)
       youtube.net.dead = true;
     }
     if (bK)
     {
      const rK = rets.shift();
      if (rK.status !== 'fulfilled' || rK.value === false)
       kick.net.dead = true;
     }
     if (bL)
     {
      const rL = rets.shift();
      if (rL.status !== 'fulfilled' || rL.value === false)
       lfg.net.dead = true;
     }
    }

    function _inBrowser(local)
    {
     return new Promise(
      function(resolve)
      {
       const divOOBE = document.createElement('div');
       divOOBE.setAttribute('id', 'oobe');
       const lblPre = document.createElement('h2');
       if (local)
        lblPre.textContent = 'Thank you for downloading';
       else
        lblPre.textContent = 'Thank you for configuring';
       divOOBE.appendChild(lblPre);
       const lblTitle = document.createElement('h1');
       lblTitle.textContent = 'RealityRipple\'s Home-Made Emote Wall';
       divOOBE.appendChild(lblTitle);
       const nsSVG = 'http://www.w3.org/2000/svg';
       const sGlobe = 'a8,8 0 1 0 .1,0z' +
        'm-2,2.5c.3,0 .5,.1 .5,.4 0,.2-.1,.4-.3,.4-.3,0-.4,.2-.4,.4v1.2c0,.4-.4,.8-.8,.8-.5,0-.8,.3-.8,.8 0,.4-.4,.8-.8,.8a.8,.8 0 1 0 0,1.6c.4,0 .8,.3.8,.8v2.8a6,6 0 0 1-.5,-8.5l.8,-.7a6,6 0 0 1 1.6,-.8z' +
        'm4.6,.4h.6l1.3,1h-1.9a.5,.5 0 0 1-.6,-.5c0,-.3.3,-.5.6,-.5z' +
        'm-2,.9c.2,0 .5,.2.5,.5v.7a.6,.6 0 1 1-1.2,0v-.7c0,-.3.3,-.5.6,-.5z' +
        'm2.2,.6h2a6,6 0 0 1 1.3,3.6l-.4,.2h-1.2c-.6,0-1.2,.5-1.2,1.2v1.3c0,.5-.3,.8-.8,.8a.8,.8 0 0 1-.8,-.8v-.8c.1,-.3 0,-.7-.4,-.8a.7,.7 0 0 1-.7,-.7v-1.3c0,-.5 .3,-1 .8,-1 .4,0 .7,-.3.7,-.7v-.3c0,-.3.3,-.7.7,-.7z';
       const pctOBS = document.createElementNS(nsSVG, 'svg');
       pctOBS.setAttribute('id', 'pctOBS');
       pctOBS.setAttribute('viewBox', '0 0 1024 768');
       const rectTitle = document.createElementNS(nsSVG, 'rect');
       rectTitle.setAttribute('x', 0);
       rectTitle.setAttribute('y', 0);
       rectTitle.setAttribute('width', 1024);
       rectTitle.setAttribute('height', 24);
       rectTitle.setAttribute('style', 'fill:#2b2b2b');
       pctOBS.appendChild(rectTitle);
       const rectBG = document.createElementNS(nsSVG, 'rect');
       rectBG.setAttribute('x', 0);
       rectBG.setAttribute('y', 23);
       rectBG.setAttribute('width', 1024);
       rectBG.setAttribute('height', 745);
       rectBG.setAttribute('style', 'fill:#3a393a');
       pctOBS.appendChild(rectBG);
       const rectLHead = document.createElementNS(nsSVG, 'rect');
       rectLHead.setAttribute('x', 0);
       rectLHead.setAttribute('y', 48);
       rectLHead.setAttribute('width', 250);
       rectLHead.setAttribute('height', 32);
       rectLHead.setAttribute('style', 'fill:#464546');
       pctOBS.appendChild(rectLHead);
       const rectL = document.createElementNS(nsSVG, 'rect');
       rectL.setAttribute('x', 0);
       rectL.setAttribute('y', 80);
       rectL.setAttribute('width', 250);
       rectL.setAttribute('height', 506);
       rectL.setAttribute('style', 'fill:#26262c');
       pctOBS.appendChild(rectL);
       const rectPreview = document.createElementNS(nsSVG, 'rect');
       rectPreview.setAttribute('x', 256);
       rectPreview.setAttribute('y', 48);
       rectPreview.setAttribute('width', 576);
       rectPreview.setAttribute('height', 538);
       rectPreview.setAttribute('style', 'fill:#4c4c4c');
       pctOBS.appendChild(rectPreview);
       const rectPreDrop = document.createElementNS(nsSVG, 'rect');
       rectPreDrop.setAttribute('x', 264);
       rectPreDrop.setAttribute('y', 112);
       rectPreDrop.setAttribute('width', 560);
       rectPreDrop.setAttribute('height', 400);
       rectPreDrop.setAttribute('style', 'fill:#000000;stroke:#ffffff;stroke-width:2;stroke-dasharray:6,3');
       pctOBS.appendChild(rectPreDrop);
       const rectRHead = document.createElementNS(nsSVG, 'rect');
       rectRHead.setAttribute('x', 838);
       rectRHead.setAttribute('y', 48);
       rectRHead.setAttribute('width', 186);
       rectRHead.setAttribute('height', 32);
       rectRHead.setAttribute('style', 'fill:#464546');
       pctOBS.appendChild(rectRHead);
       const rectR = document.createElementNS(nsSVG, 'rect');
       rectR.setAttribute('x', 838);
       rectR.setAttribute('y', 80);
       rectR.setAttribute('width', 186);
       rectR.setAttribute('height', 506);
       rectR.setAttribute('style', 'fill:#18181b');
       pctOBS.appendChild(rectR);
       const rectLowLHead = document.createElementNS(nsSVG, 'rect');
       rectLowLHead.setAttribute('x', 0);
       rectLowLHead.setAttribute('y', 592);
       rectLowLHead.setAttribute('width', 250);
       rectLowLHead.setAttribute('height', 32);
       rectLowLHead.setAttribute('style', 'fill:#464546');
       pctOBS.appendChild(rectLowLHead);
       const rectLowL = document.createElementNS(nsSVG, 'rect');
       rectLowL.setAttribute('x', 0);
       rectLowL.setAttribute('y', 624);
       rectLowL.setAttribute('width', 250);
       rectLowL.setAttribute('height', 120);
       rectLowL.setAttribute('style', 'fill:#1f1e1f');
       pctOBS.appendChild(rectLowL);
       const rectLowMHead = document.createElementNS(nsSVG, 'rect');
       rectLowMHead.setAttribute('x', 256);
       rectLowMHead.setAttribute('y', 592);
       rectLowMHead.setAttribute('width', 576);
       rectLowMHead.setAttribute('height', 32);
       rectLowMHead.setAttribute('style', 'fill:#464546');
       pctOBS.appendChild(rectLowMHead);
       const txtLowMTitle = document.createElementNS(nsSVG, 'text');
       txtLowMTitle.setAttribute('x', 520);
       txtLowMTitle.setAttribute('y', 612);
       txtLowMTitle.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:14px');
       txtLowMTitle.textContent = 'Sources';
       pctOBS.appendChild(txtLowMTitle);
       const rectLowM = document.createElementNS(nsSVG, 'rect');
       rectLowM.setAttribute('x', 256);
       rectLowM.setAttribute('y', 624);
       rectLowM.setAttribute('width', 576);
       rectLowM.setAttribute('height', 120);
       rectLowM.setAttribute('style', 'fill:#1f1e1f');
       pctOBS.appendChild(rectLowM);
       const rectSel = document.createElementNS(nsSVG, 'rect');
       rectSel.setAttribute('x', 257);
       rectSel.setAttribute('y', 648);
       rectSel.setAttribute('width', 574);
       rectSel.setAttribute('height', 24);
       rectSel.setAttribute('style', 'fill:#19344c');
       pctOBS.appendChild(rectSel);
       const icoGlobe = document.createElementNS(nsSVG, 'path');
       icoGlobe.setAttribute('d', 'm274,652' + sGlobe);
       icoGlobe.setAttribute('style', 'fill:#fefefe');
       pctOBS.appendChild(icoGlobe);
       const txtLabel = document.createElementNS(nsSVG, 'text');
       txtLabel.setAttribute('x', 290);
       txtLabel.setAttribute('y', 665);
       txtLabel.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:14px');
       txtLabel.textContent = 'EmoteWall.html';
       pctOBS.appendChild(txtLabel);
       const rectLowRHead = document.createElementNS(nsSVG, 'rect');
       rectLowRHead.setAttribute('x', 838);
       rectLowRHead.setAttribute('y', 592);
       rectLowRHead.setAttribute('width', 186);
       rectLowRHead.setAttribute('height', 32);
       rectLowRHead.setAttribute('style', 'fill:#464546');
       pctOBS.appendChild(rectLowRHead);
       const rectLowR = document.createElementNS(nsSVG, 'rect');
       rectLowR.setAttribute('x', 838);
       rectLowR.setAttribute('y', 624);
       rectLowR.setAttribute('width', 186);
       rectLowR.setAttribute('height', 120);
       rectLowR.setAttribute('style', 'fill:#1f1e1f');
       pctOBS.appendChild(rectLowR);
       divOOBE.appendChild(pctOBS);
       if (local)
       {
        rectLowM.setAttribute('id', 'svgSourceRect');
        rectSel.setAttribute('id', 'svgSelRect');
        const pctIcon = document.createElementNS(nsSVG, 'svg');
        pctIcon.setAttribute('id', 'pctIcon');
        pctIcon.setAttribute('viewBox', '0 0 68 64');
        const rectIcon = document.createElementNS(nsSVG, 'rect');
        rectIcon.setAttribute('x', 15);
        rectIcon.setAttribute('y', 0);
        rectIcon.setAttribute('width', 38);
        rectIcon.setAttribute('height', 48);
        rectIcon.setAttribute('style', 'fill:#FFFFFF;stroke:#000000;stroke-opacity:0.5');
        pctIcon.appendChild(rectIcon);
        const onIon = document.createElementNS(nsSVG, 'text');
        onIon.setAttribute('x', '34');
        onIon.setAttribute('y', '32');
        onIon.setAttribute('style', 'text-anchor:middle;font-size: 24px;text-shadow: 1px 1px 4px #000000');
        onIon.innerHTML = '&#x1f9c5;';
        pctIcon.appendChild(onIon);
        const txtIcon = document.createElementNS(nsSVG, 'text');
        txtIcon.setAttribute('x', 0);
        txtIcon.setAttribute('y', 62);
        txtIcon.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:9px;text-shadow:1px 1px 1px #000000');
        txtIcon.textContent = 'EmoteWall.html';
        pctIcon.appendChild(txtIcon);
        divOOBE.appendChild(pctIcon);
       }
       else
       {
        rectLowM.setAttribute('height', 94);
        const rectLowTools = document.createElementNS(nsSVG, 'rect');
        rectLowTools.setAttribute('x', 257);
        rectLowTools.setAttribute('y', 719);
        rectLowTools.setAttribute('width', 574);
        rectLowTools.setAttribute('height', 24);
        rectLowTools.setAttribute('style', 'fill:#3a393a;stroke:#000000;stroke-width:1;');
        pctOBS.appendChild(rectLowTools);
        const rectLowAdd = document.createElementNS(nsSVG, 'rect');
        rectLowAdd.setAttribute('id', 'rectLowAdd');
        rectLowAdd.setAttribute('x', 258);
        rectLowAdd.setAttribute('y', 720);
        rectLowAdd.setAttribute('width', 22);
        rectLowAdd.setAttribute('height', 22);
        rectLowAdd.setAttribute('style', 'fill:#464546');
        pctOBS.appendChild(rectLowAdd);
        const cmdLowAdd = document.createElementNS(nsSVG, 'text');
        cmdLowAdd.setAttribute('x', 269);
        cmdLowAdd.setAttribute('y', 738);
        cmdLowAdd.setAttribute('style', 'text-anchor:middle;fill:#ffffff;font-family:monospace;font-size:24px');
        cmdLowAdd.textContent = '+';
        pctOBS.appendChild(cmdLowAdd);

        const rectToolsMenu = document.createElementNS(nsSVG, 'rect');
        rectToolsMenu.setAttribute('id', 'mnuTools');
        rectToolsMenu.setAttribute('x', 275);
        rectToolsMenu.setAttribute('y', 230);
        rectToolsMenu.setAttribute('width', 256);
        rectToolsMenu.setAttribute('height', 500);
        rectToolsMenu.setAttribute('style', 'fill:#3a393a;stroke:#000000;stroke-width:1;');
        pctOBS.appendChild(rectToolsMenu);

        const rectToolsMenuSel = document.createElementNS(nsSVG, 'rect');
        rectToolsMenuSel.setAttribute('id', 'mnuToolsSel');
        rectToolsMenuSel.setAttribute('x', 276);
        rectToolsMenuSel.setAttribute('y', 302);
        rectToolsMenuSel.setAttribute('width', 254);
        rectToolsMenuSel.setAttribute('height', 24);
        rectToolsMenuSel.setAttribute('style', 'fill:#19344c');
        pctOBS.appendChild(rectToolsMenuSel);

        const icoToolsMenuItem = document.createElementNS(nsSVG, 'path');
        icoToolsMenuItem.setAttribute('id', 'mnuToolsIcon');
        icoToolsMenuItem.setAttribute('d', 'm292,306' + sGlobe);
        icoToolsMenuItem.setAttribute('style', 'fill:#fefefe');
        pctOBS.appendChild(icoToolsMenuItem);

        const txtToolsMenuItem = document.createElementNS(nsSVG, 'text');
        txtToolsMenuItem.setAttribute('id', 'mnuToolsText');
        txtToolsMenuItem.setAttribute('x', 310);
        txtToolsMenuItem.setAttribute('y', 320);
        txtToolsMenuItem.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:16px');
        txtToolsMenuItem.textContent = 'Browser';
        pctOBS.appendChild(txtToolsMenuItem);

        const pctPref = document.createElementNS(nsSVG, 'svg');
        pctPref.setAttribute('id', 'pctPref');
        pctPref.setAttribute('viewBox', '0 0 700 800');
        const clipPrefURLVal = document.createElementNS(nsSVG, 'clipPath');
        clipPrefURLVal.setAttribute('id', 'urlClip');
        const rectPrefURLVal = document.createElementNS(nsSVG, 'rect');
        rectPrefURLVal.setAttribute('x', 128);
        rectPrefURLVal.setAttribute('y', 470);
        rectPrefURLVal.setAttribute('width', 553);
        rectPrefURLVal.setAttribute('height', 32);
        clipPrefURLVal.appendChild(rectPrefURLVal);
        pctPref.appendChild(clipPrefURLVal);
        const rectPrefTitle = document.createElementNS(nsSVG, 'rect');
        rectPrefTitle.setAttribute('x', 0);
        rectPrefTitle.setAttribute('y', 0);
        rectPrefTitle.setAttribute('width', 700);
        rectPrefTitle.setAttribute('height', 24);
        rectPrefTitle.setAttribute('style', 'fill:#2b2b2b');
        pctPref.appendChild(rectPrefTitle);
        const rectPrefBG = document.createElementNS(nsSVG, 'rect');
        rectPrefBG.setAttribute('x', 0);
        rectPrefBG.setAttribute('y', 23);
        rectPrefBG.setAttribute('width', 700);
        rectPrefBG.setAttribute('height', 776);
        rectPrefBG.setAttribute('style', 'fill:#3a393a');
        pctPref.appendChild(rectPrefBG);
        const rectPrefPre = document.createElementNS(nsSVG, 'rect');
        rectPrefPre.setAttribute('x', 6);
        rectPrefPre.setAttribute('y', 29);
        rectPrefPre.setAttribute('width', 688);
        rectPrefPre.setAttribute('height', 400);
        rectPrefPre.setAttribute('style', 'fill:#4c4c4c');
        pctPref.appendChild(rectPrefPre);
        const rectPrefLocal = document.createElementNS(nsSVG, 'rect');
        rectPrefLocal.setAttribute('x', 128);
        rectPrefLocal.setAttribute('y', 440);
        rectPrefLocal.setAttribute('width', 16);
        rectPrefLocal.setAttribute('height', 16);
        rectPrefLocal.setAttribute('style', 'fill:#4c4c4c;stroke:#FFFFFF;stroke-width:1');
        pctPref.appendChild(rectPrefLocal);
        const txtPrefLocal = document.createElementNS(nsSVG, 'text');
        txtPrefLocal.setAttribute('x', 152);
        txtPrefLocal.setAttribute('y', 454);
        txtPrefLocal.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:18px');
        txtPrefLocal.textContent = 'Local file';
        pctPref.appendChild(txtPrefLocal);
        const txtPrefURL = document.createElementNS(nsSVG, 'text');
        txtPrefURL.setAttribute('x', 85);
        txtPrefURL.setAttribute('y', 491);
        txtPrefURL.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:18px');
        txtPrefURL.textContent = 'URL';
        pctPref.appendChild(txtPrefURL);
        const rectPrefURL = document.createElementNS(nsSVG, 'rect');
        rectPrefURL.setAttribute('x', 128);
        rectPrefURL.setAttribute('y', 470);
        rectPrefURL.setAttribute('width', 560);
        rectPrefURL.setAttribute('height', 32);
        rectPrefURL.setAttribute('style', 'fill:#1f1e1f');
        pctPref.appendChild(rectPrefURL);
        const txtPrefURLVal = document.createElementNS(nsSVG, 'text');
        txtPrefURLVal.setAttribute('x', 135);
        txtPrefURLVal.setAttribute('y', 492);
        txtPrefURLVal.setAttribute('clip-path', 'url(#urlClip)');
        txtPrefURLVal.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:16px;user-select:all;cursor:initial');
        txtPrefURLVal.textContent = window.location;
        pctPref.appendChild(txtPrefURLVal);
        const txtPrefWidth = document.createElementNS(nsSVG, 'text');
        txtPrefWidth.setAttribute('x', 75);
        txtPrefWidth.setAttribute('y', 531);
        txtPrefWidth.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:18px');
        txtPrefWidth.textContent = 'Width';
        pctPref.appendChild(txtPrefWidth);
        const rectPrefWidth = document.createElementNS(nsSVG, 'rect');
        rectPrefWidth.setAttribute('x', 128);
        rectPrefWidth.setAttribute('y', 510);
        rectPrefWidth.setAttribute('width', 560);
        rectPrefWidth.setAttribute('height', 32);
        rectPrefWidth.setAttribute('style', 'fill:#1f1e1f');
        pctPref.appendChild(rectPrefWidth);
        const txtPrefWidthVal = document.createElementNS(nsSVG, 'text');
        txtPrefWidthVal.setAttribute('x', 135);
        txtPrefWidthVal.setAttribute('y', 532);
        txtPrefWidthVal.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:16px');
        txtPrefWidthVal.textContent = Math.min(screen.width, 1920);
        pctPref.appendChild(txtPrefWidthVal);
        const txtPrefHeight = document.createElementNS(nsSVG, 'text');
        txtPrefHeight.setAttribute('x', 70);
        txtPrefHeight.setAttribute('y', 571);
        txtPrefHeight.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:18px');
        txtPrefHeight.textContent = 'Height';
        pctPref.appendChild(txtPrefHeight);
        const rectPrefHeight = document.createElementNS(nsSVG, 'rect');
        rectPrefHeight.setAttribute('x', 128);
        rectPrefHeight.setAttribute('y', 550);
        rectPrefHeight.setAttribute('width', 560);
        rectPrefHeight.setAttribute('height', 32);
        rectPrefHeight.setAttribute('style', 'fill:#1f1e1f');
        pctPref.appendChild(rectPrefHeight);
        const txtPrefHeightVal = document.createElementNS(nsSVG, 'text');
        txtPrefHeightVal.setAttribute('x', 135);
        txtPrefHeightVal.setAttribute('y', 572);
        txtPrefHeightVal.setAttribute('style', 'fill:#ffffff;font-family:sans-serif;font-size:16px');
        txtPrefHeightVal.textContent = Math.min(screen.height, 1080);
        pctPref.appendChild(txtPrefHeightVal);
        const rectPrefExtra = document.createElementNS(nsSVG, 'rect');
        rectPrefExtra.setAttribute('x', 128);
        rectPrefExtra.setAttribute('y', 590);
        rectPrefExtra.setAttribute('width', 560);
        rectPrefExtra.setAttribute('height', 150);
        rectPrefExtra.setAttribute('style', 'fill:#1f1e1f');
        pctPref.appendChild(rectPrefExtra);
        const rectPrefOK = document.createElementNS(nsSVG, 'rect');
        rectPrefOK.setAttribute('x', 525);
        rectPrefOK.setAttribute('y', 756);
        rectPrefOK.setAttribute('width', 60);
        rectPrefOK.setAttribute('height', 32);
        rectPrefOK.setAttribute('style', 'fill:#4c4c4c');
        pctPref.appendChild(rectPrefOK);
        const rectPrefCancel = document.createElementNS(nsSVG, 'rect');
        rectPrefCancel.setAttribute('x', 595);
        rectPrefCancel.setAttribute('y', 756);
        rectPrefCancel.setAttribute('width', 90);
        rectPrefCancel.setAttribute('height', 32);
        rectPrefCancel.setAttribute('style', 'fill:#4c4c4c');
        pctPref.appendChild(rectPrefCancel);
        divOOBE.appendChild(pctPref);
       }
       const divNext = document.createElement('div');
       divNext.setAttribute('id', 'oobeNext');
       const lblNext = document.createElement('h3');
       lblNext.textContent = 'What Next?';
       divNext.appendChild(lblNext);
       const lblHelp = document.createElement('div');
       let sHelp = 'Now that you\'ve got your URL for RealityRipple\'s Home-Made Emote Wall, add a new Browser source to your broadcasting software and paste this page\'s address in the source\'s URL bar.';
       if (local)
        sHelp = 'Now that you\'ve downloaded RealityRipple\'s Home-Made Emote Wall, all you have to do is drag this HTML file into your broadcasting software.';
       lblHelp.innerHTML = sHelp + '<br><br>You can make advanced adjustments to the Emote Wall\'s resolution and frame rate through the source Properties window.';
       divNext.appendChild(lblHelp);
       divOOBE.appendChild(divNext);
       const divButtons = document.createElement('div');
       divButtons.setAttribute('id', 'oobeButtons');
       const cmdTest = document.createElement('button');
       cmdTest.textContent = 'Test Emote Wall';
       cmdTest.addEventListener('click',
        function()
        {
         divOOBE.remove();
         resolve(true);
        }
       );
       divButtons.appendChild(cmdTest);
       divButtons.appendChild(document.createElement('br'));
       divButtons.append('in your current browser');
       divButtons.appendChild(document.createElement('br'));
       divButtons.appendChild(document.createElement('br'));
       const chkOOBE = document.createElement('input');
       chkOOBE.setAttribute('type', 'checkbox');
       chkOOBE.setAttribute('checked', 'checked');
       chkOOBE.setAttribute('id', 'chkOOBE');
       chkOOBE.addEventListener('change',
        function()
        {
         if (chkOOBE.checked)
          shared.storage.removeItem('emotewall.oobe');
         else
          shared.storage.setItem('emotewall.oobe', '0');
        }
       );
       divButtons.appendChild(chkOOBE);
       const lblOOBE = document.createElement('label');
       lblOOBE.setAttribute('for', 'chkOOBE');
       lblOOBE.textContent = ' Show this dialog when loaded in browser';
       divButtons.appendChild(lblOOBE);
       divOOBE.appendChild(divButtons);
       document.body.appendChild(divOOBE);
      }
     );
    }

    function _isOnline()
    {
     return new Promise(
      function(resolve)
      {
       if (navigator.onLine)
       {
        resolve(true);
        return;
       }
       const _evTemp = function()
       {
        notice.info(notice.Type.GLOBAL_NET);
        window.removeEventListener('online', _evTemp);
        resolve(true);
       };
       window.addEventListener('online', _evTemp);
       notice.error(notice.Type.GLOBAL_NET);
      }
     );
    }

    const _hashRefreshes = function()
    {
     const _alg = 'AES-GCM';
     const _jalg = 'A128GCM';
     const _preKey = 'enc=';
     const _preIV = '&iv=';
     const _lKey = 128;
     const _lIV = 96;

     async function $c_hasRefreshes()
     {
      const h = shared.getHashParams();
      if (!h.hasOwnProperty('key'))
      {
       _hasNoKey(notice.DecryptType.KEY_MISSING);
       return;
      }
      const dK = _b64AB(h.key.replaceAll('-', '+').replaceAll('_', '/'));
      if (dK === false || dK.byteLength * 8 !== _lKey)
      {
       _hasNoKey(notice.DecryptType.KEY_INVALID);
       return;
      }
      const k = await _importKey(h.key);
      if (!k)
      {
       _hasNoKey(notice.DecryptType.KEY_INVALID);
       return;
      }
      await _handleT(k);
      await _handleY(k);
      await _handleSEO(k);
      await _handleSET(k);
      await _handleSL(k);
     }

     function _hasNoKey(e)
     {
      if (!!cfg.twitch.oauth_refresh && cfg.twitch.oauth_refresh.slice(0, _preKey.length) === _preKey)
      {
       cfg.twitch.oauth_refresh = null;
       notice.error(notice.Type.GLOBAL_DECRYPT, e);
      }
      if (!!cfg.youtube.oauth_refresh && cfg.youtube.oauth_refresh.slice(0, _preKey.length) === _preKey)
      {
       cfg.youtube.oauth_refresh = null;
       notice.error(notice.Type.GLOBAL_DECRYPT, e);
      }
      if (!!cfg.streamelements.oauth_refresh && cfg.streamelements.oauth_refresh.slice(0, _preKey.length) === _preKey)
      {
       cfg.streamelements.oauth_refresh = null;
       notice.error(notice.Type.GLOBAL_DECRYPT, e);
      }
      if (!!cfg.streamelements.token && cfg.streamelements.token.slice(0, _preKey.length) === _preKey)
      {
       cfg.streamelements.token = null;
       notice.error(notice.Type.GLOBAL_DECRYPT, e);
      }
      if (!!cfg.streamlabs.token && cfg.streamlabs.token.slice(0, _preKey.length) === _preKey)
      {
       cfg.streamlabs.token = null;
       notice.error(notice.Type.GLOBAL_DECRYPT, e);
      }
     }

     async function _handleT(k)
     {
      if (!cfg.twitch.oauth_refresh)
       return;
      if (cfg.twitch.oauth_refresh.slice(0, _preKey.length) !== _preKey)
       return;
      if (cfg.twitch.oauth_refresh.indexOf(_preIV) === -1)
      {
       cfg.twitch.oauth_refresh = null;
       notice.error(notice.Type.TWITCH_DECRYPT, notice.DecryptType.IV_MISSING);
       return;
      }
      const p = cfg.twitch.oauth_refresh.slice(_preKey.length).split(_preIV, 2);
      const d = _b64AB(p[0]);
      const iv = _b64AB(p[1]);
      if (d === false || iv === false || iv.byteLength * 8 !== _lIV)
      {
       cfg.twitch.oauth_refresh = null;
       notice.error(notice.Type.TWITCH_DECRYPT, notice.DecryptType.B64_INVALID);
       return;
      }
      const r = await _decryptData(k, d, iv);
      if (r === false)
      {
       cfg.twitch.oauth_refresh = null;
       notice.error(notice.Type.TWITCH_DECRYPT, notice.DecryptType.DATA_INVALID);
       return;
      }
      cfg.twitch.oauth_refresh = r;
     }

     async function _handleY(k)
     {
      if (!cfg.youtube.oauth_refresh)
       return;
      if (cfg.youtube.oauth_refresh.slice(0, _preKey.length) !== _preKey)
       return;
      if (cfg.youtube.oauth_refresh.indexOf(_preIV) === -1)
      {
       cfg.youtube.oauth_refresh = null;
       notice.error(notice.Type.YOUTUBE_DECRYPT, notice.DecryptType.IV_MISSING);
       return;
      }
      const p = cfg.youtube.oauth_refresh.slice(_preKey.length).split(_preIV, 2);
      const d = _b64AB(p[0]);
      const iv = _b64AB(p[1]);
      if (d === false || iv === false || iv.byteLength * 8 !== _lIV)
      {
       cfg.youtube.oauth_refresh = null;
       notice.error(notice.Type.YOUTUBE_DECRYPT, notice.DecryptType.B64_INVALID);
       return;
      }
      const r = await _decryptData(k, d, iv);
      if (r === false)
      {
       cfg.youtube.oauth_refresh = null;
       notice.error(notice.Type.YOUTUBE_DECRYPT, notice.DecryptType.DATA_INVALID);
       return;
      }
      cfg.youtube.oauth_refresh = r;
     }

     async function _handleSEO(k)
     {
      if (!cfg.streamelements.oauth_refresh)
       return;
      if (cfg.streamelements.oauth_refresh.slice(0, _preKey.length) !== _preKey)
       return;
      if (cfg.streamelements.oauth_refresh.indexOf(_preIV) === -1)
      {
       cfg.streamelements.oauth_refresh = null;
       notice.error(notice.Type.STREAMELEMENTS_DECRYPT_OAUTH, notice.DecryptType.IV_MISSING);
       return;
      }
      const p = cfg.streamelements.oauth_refresh.slice(_preKey.length).split(_preIV, 2);
      const d = _b64AB(p[0]);
      const iv = _b64AB(p[1]);
      if (d === false || iv === false || iv.byteLength * 8 !== _lIV)
      {
       cfg.streamelements.oauth_refresh = null;
       notice.error(notice.Type.STREAMELEMENTS_DECRYPT_OAUTH, notice.DecryptType.B64_INVALID);
       return;
      }
      const r = await _decryptData(k, d, iv);
      if (r === false)
      {
       cfg.streamelements.oauth_refresh = null;
       notice.error(notice.Type.STREAMELEMENTS_DECRYPT_OAUTH, notice.DecryptType.DATA_INVALID);
       return;
      }
      cfg.streamelements.oauth_refresh = r;
     }

     async function _handleSET(k)
     {
      if (!cfg.streamelements.token)
       return;
      if (cfg.streamelements.token.slice(0, _preKey.length) !== _preKey)
       return;
      if (cfg.streamelements.token.indexOf(_preIV) === -1)
      {
       cfg.streamelements.token = null;
       notice.error(notice.Type.STREAMELEMENTS_DECRYPT_JWT, notice.DecryptType.IV_MISSING);
       return;
      }
      const p = cfg.streamelements.token.slice(_preKey.length).split(_preIV, 2);
      const d = _b64AB(p[0]);
      const iv = _b64AB(p[1]);
      if (d === false || iv === false || iv.byteLength * 8 !== _lIV)
      {
       cfg.streamelements.token = null;
       notice.error(notice.Type.STREAMELEMENTS_DECRYPT_JWT, notice.DecryptType.B64_INVALID);
       return;
      }
      const r = await _decryptData(k, d, iv);
      if (r === false)
      {
       cfg.streamelements.token = null;
       notice.error(notice.Type.STREAMELEMENTS_DECRYPT_JWT, notice.DecryptType.DATA_INVALID);
       return;
      }
      cfg.streamelements.token = r;
     }

     async function _handleSL(k)
     {
      if (!cfg.streamlabs.token)
       return;
      if (cfg.streamlabs.token.slice(0, _preKey.length) !== _preKey)
       return;
      if (cfg.streamlabs.token.indexOf(_preIV) === -1)
      {
       cfg.streamlabs.token = null;
       notice.error(notice.Type.STREAMLABS_DECRYPT, notice.DecryptType.IV_MISSING);
       return;
      }
      const p = cfg.streamlabs.token.slice(_preKey.length).split(_preIV, 2);
      const d = _b64AB(p[0]);
      const iv = _b64AB(p[1]);
      if (d === false || iv === false || iv.byteLength * 8 !== _lIV)
      {
       cfg.streamlabs.token = null;
       notice.error(notice.Type.STREAMLABS_DECRYPT, notice.DecryptType.B64_INVALID);
       return;
      }
      const r = await _decryptData(k, d, iv);
      if (r === false)
      {
       cfg.streamlabs.token = null;
       notice.error(notice.Type.STREAMLABS_DECRYPT, notice.DecryptType.DATA_INVALID);
       return;
      }
      cfg.streamlabs.token = r;
     }

     async function _importKey(s)
     {
      try
      {
       const k = {alg: _jalg, ext: true, k: s, key_ops: ['encrypt', 'decrypt'], kty: 'oct'};
       return await window.crypto.subtle.importKey('jwk', k, _alg, false, ['decrypt']);
      }
      catch
      {
       return false;
      }
     }

     function _b64AB(d)
     {
      try
      {
       const s = window.atob(d);
       const l = s.length;
       const r = new Uint8Array(l);
       for (let i = 0; i < l; i++)
       {
        r[i] = s.charCodeAt(i);
       }
       return r.buffer;
      }
      catch
      {
       return false;
      }
     }

     async function _decryptData(k, d, iv)
     {
      try
      {
       const r = await window.crypto.subtle.decrypt({name: _alg, iv: iv}, k, d);
       return new TextDecoder().decode(r);
      }
      catch
      {
       return false;
      }
     }

     return $c_hasRefreshes;
    }();

    async function _twitch()
    {
     if (!twitch.net.oAuth.hasLogin)
      return false;
     if (await twitch.global() === false)
      return false;
     twitch.net.irc();
     return true;
    }

    async function _youtube()
    {
     if (!youtube.net.oAuth.hasLogin)
      return false;
     if (await youtube.global() === false)
      return false;
     await youtube.stickers();
     if (!!cfg.youtube.cdn)
      youtube.net.cdnTest();
     notice.expect |= notice.Connection.YOUTUBE;
     if (cfg.event.youtube.sub !== false)
      youtube.net.subscribers.init();
     youtube.net.broadcasts.updateStream();
     return true;
    }

    async function _kick()
    {
     if (!kick.net.oAuth.hasLogin)
      return false;
     await kick.net.socket();
     kick.net.followers();
     return true;
    }

    async function _lfg()
    {
     if (!lfg.net.oAuth.hasLogin)
      return false;
     await lfg.net.socket();
     if (cfg.event.lfg.hypetrain.begin !== false || cfg.event.lfg.hypetrain.end !== false)
      lfg.net.hypetrains();
     return true;
    }

    function _streamlabs()
    {
     if (!streamlabs.hasLogin)
      return;
     streamlabs.socket();
    }

    async function _streamelements()
    {
     if (streamelements.oAuth.hasRefresh)
      await streamelements.oAuth.update();
     if (!streamelements.oAuth.hasLogin)
      return;
     streamelements.socket();
    }

    async function _ffz()
    {
     if (!cfg.display.extended.useFFZ)
      return;
     await thirdparty.ffz.global();
    }

    async function _bttv()
    {
     if (!cfg.display.extended.useBTTV)
      return;
     thirdparty.bttv.socket.init();
     await thirdparty.bttv.global();
    }

    async function _7tv()
    {
     if (!cfg.display.extended.use7TV)
      return;
     thirdparty['7tv'].socketEx.init();
     await thirdparty['7tv'].global();
    }

    async function _emoji()
    {
     if (!cfg.display.useEmoji)
      return;
     await thirdparty.emoji(cfg.display.useEmoji);
    }

    const _css = function()
    {
     const _unShadow = new RegExp(/\n[^\n]+\/\* {DELETE:SHADOW} \*\/\s*\n/, 'g');
     const _zPad = new RegExp(/padding:\s*([^;]+)\s+0;\s*\/\* {REPLACE:ZWE_PAD} \*\//, 'g');

     function $c_css()
     {
      const css = document.getElementsByTagName('STYLE')[0];
      let spc = {indent: 0};
      let h = shared.unIndent(css.innerHTML, spc);
      h = _hue(h);
      h = _shadow(h);
      h = _zwe(h);
      h = _anim(h);
      h = _gui(h);
      h = _variations(h);
      h = shared.reIndent(h, spc);
      css.innerHTML = h;
     }

     function _hue(h)
     {
      if (cfg.display.hasOwnProperty('hue') && cfg.display.hue !== false)
      {
       if (cfg.display.hue === 'rave')
       {
        let r = 'html.rave\n' +
         '{\n' +
         ' animation: rave 3s linear infinite;\n' +
         '}\n';
        let ar = 'html.rave button.auth, html.rave div#notices\n' +
         '{\n' +
         ' animation: antirave 3s linear infinite;\n' +
         '}\n';

        r += '@keyframes rave\n';
        r += '{\n';
        ar += '@keyframes antirave\n';
        ar += '{\n';
        for (let i = 0; i <= 100; i += 10)
        {
         r += ' ' + i + '%\n' +
          ' {\n' +
          '  filter: hue-rotate(' + i * 3.6 + 'deg);\n' +
          ' }\n';
         ar += ' ' + i + '%\n' +
          ' {\n' +
          '  filter: hue-rotate(' + (360 - i * 3.6) + 'deg);\n' +
          ' }\n';
        }
        r += '}\n';
        ar += '}\n';

        h = r + ar + h;

        shared.hueSync();
       }
       else if (Number.isInteger(cfg.display.hue))
       {
        const iHue = parseInt(cfg.display.hue, 10);
        if (iHue > 0 && iHue < 360)
        {
         const f = 'html\n' +
          '{\n' +
          ' filter: hue-rotate(' + iHue + 'deg);\n' +
          '}\n' +
          'button.auth, div#notices\n' +
          '{\n' +
          ' filter: hue-rotate(' + (360 - iHue) + 'deg);\n' +
          '}\n';

         h = f + h;
        }
       }
      }
      return h;
     }

     function _shadow(h)
     {
      if (cfg.display.hasOwnProperty('shadow') && cfg.display.shadow !== false)
      {
       const sF = shared.shadowCSS(cfg.display.shadow);
       if (sF !== false)
       {
        h = h.replaceAll('/* {INSERT:SHADOW} *\/', sF);

        h = h.replaceAll(_unShadow, '\n');
       }
      }
      return h;
     }

     function _zwe(h)
     {
      if (cfg.display.extended.useZWE && cfg.display.extended.hasOwnProperty('fillZWE') && cfg.display.extended.fillZWE)
      {
       h = h.replaceAll(_zPad, function(m, m1){return 'padding: ' + m1 + ' ' + m1.replaceAll('--zoom-height', '--zoom-width') + ';';});

       const z = 'img.zwe\n' +
        '{\n' +
        ' object-fit: fill;\n' +
        '}';
       h = h.replaceAll('/* {INSERT:ZWE} *\/', z);
      }
      return h;
     }

     function _anim(h)
     {
      const tMS = cfg.emote.time * 1000;
      let t = '.' + display.emote.clsID.StraightLine + '\n' +
       '{\n' +
       ' transition: transform linear ' + Math.floor(tMS * timing.display.StraightLine.time) + 'ms;\n' +
       '}\n';

      t += '.' + display.emote.clsID.Throw.Twist + '\n' +
       '{\n' +
       ' transition: transform cubic-bezier(0.32, 0, 0.67, 0) ' + Math.floor(tMS * timing.display.Throw.time * timing.display.Throw.twist) + 'ms;\n' +
       '}\n';

      t += '.' + display.emote.clsID.Throw.Drop + '\n' +
       '{\n' +
       ' transition: transform cubic-bezier(0.5, 0, 0.75, 0) ' + Math.floor(tMS * timing.display.Throw.time * timing.display.Throw.drop) + 'ms;\n' +
       '}\n';

      t += '.' + display.emote.clsID.Pop.PeekUp + '\n' +
       '{\n' +
       ' transition: transform ease-in-out ' + Math.floor(tMS * timing.display.Pop.peek.up) + 'ms;\n' +
       '}\n';

      t += '.' + display.emote.clsID.Pop.PeekDown + '\n' +
       '{\n' +
       ' transition: transform ease-out ' + Math.floor(tMS * timing.display.Pop.peek.down) + 'ms;\n' +
       '}\n';

      t += '.' + display.emote.clsID.Pop.JumpUp + '\n' +
       '{\n' +
       ' transition: transform ease-out ' + Math.floor(tMS * timing.display.Pop.jump.up) + 'ms;\n' +
       '}\n';

      t += '.' + display.emote.clsID.Pop.JumpDown + '\n' +
       '{\n' +
       ' transition: transform ease-in ' + Math.floor(tMS * timing.display.Pop.jump.down) + 'ms;\n' +
       '}\n';

      t += '.' + display.emote.clsID.Fountain + '\n' +
       '{\n' +
       ' transition: transform cubic-bezier(0, 0, 0.58, 1) ' + Math.floor(tMS * timing.display.Fountain.time) + 'ms;\n' +
       '}\n';

      t += 'div.scene.cube:not(.kappa),\n' +
       'div.scene.cube:not(.kappa) div.cube\n' +
       '{\n' +
       ' transition: transform linear ' + Math.floor(tMS * timing.display.TheCube.time) + 'ms;\n' +
       '}\n';

      t += '.' + display.kappa.clsID.Firework.Rocket + '\n' +
       '{\n' +
       ' transition: transform linear ' + Math.floor(tMS * timing.kappa.Fireworks.time * timing.kappa.Fireworks.speed.rocket) + 'ms;\n' +
       '}\n';

      t += '.' + display.kappa.clsID.Firework.Sparkler + '\n' +
       '{\n' +
       ' transition: transform ease-out ' + Math.floor(tMS * timing.kappa.Fireworks.time) + 'ms;\n' +
       '}\n';

      t += '.' + display.kappa.clsID.Spiral + '\n' +
       '{\n' +
       ' transition: transform ease-out ' + Math.floor(tMS * timing.kappa.Spiral.time) + 'ms;\n' +
       '}\n';

      let ctP = 0;
      const lP = pyramidDist.length;
      for (let i = 0; i < lP; i++)
      {
       ctP += pyramidDist[i];
      }

      const tP = Math.floor(tMS * timing.kappa.Pyramid.time * timing.kappa.Pyramid.show.total);
      const tPerB = Math.max(Math.floor(tP / ctP), timing.kappa.Pyramid.show.min);
      t += '.' + display.kappa.clsID.Pyramid.Show + '\n' +
       '{\n' +
       ' transition: transform ease-in ' + tPerB + 'ms;\n' +
       '}\n' +
       '.' + display.kappa.clsID.Pyramid.Drop + '\n' +
       '{\n' +
       ' transition: transform ease-in ' + Math.floor(tMS * timing.kappa.Pyramid.time * timing.kappa.Pyramid.hide) + 'ms;\n' +
       '}\n';

      const tSP = Math.floor(tMS * timing.kappa.SmallPyramid.time * timing.kappa.SmallPyramid.show.total);
      const tPerSB = Math.max(Math.floor(tSP / ctP), timing.kappa.SmallPyramid.show.min);
      t += '.' + display.kappa.clsID.SmallPyramid.Show + '\n' +
       '{\n' +
       ' transition: transform ease-in ' + tPerSB + 'ms;\n' +
       '}\n' +
       '.' + display.kappa.clsID.SmallPyramid.Drop + '\n' +
       '{\n' +
       ' transition: transform ease-in ' + Math.floor(tMS * timing.kappa.SmallPyramid.time * timing.kappa.SmallPyramid.hide) + 'ms;\n' +
       '}\n';

      t += '.' + display.kappa.clsID.CodeLine.show + '\n' +
       '{\n' +
       ' transition: opacity linear ' + shared.mspf.value + 'ms;\n' +
       '}\n';
      const tCL = Math.floor(tMS * timing.kappa.CodeLines.time * timing.kappa.CodeLines.fade);
      t += '.' + display.kappa.clsID.CodeLine.hide + '\n' +
       '{\n' +
       ' transition: opacity ease-out ' + tCL + 'ms;\n' +
       '}\n';

      t += '.' + display.kappa.clsID.Stampede + '\n' +
       '{\n' +
       ' transition: transform linear ' + Math.floor(tMS * timing.kappa.Stampede.time * timing.kappa.Stampede.speed) + 'ms;\n' +
       '}\n';

      const congaShowMS = Math.floor(tMS * timing.kappa.Conga.time.show);
      const congaHideMS = Math.floor(tMS * timing.kappa.Conga.time.hide);
      t += '.' + display.kappa.clsID.Conga.In + '\n' +
       '{\n' +
       ' transition: transform linear ' + congaShowMS + 'ms;\n' +
       '}\n' +
       '.' + display.kappa.clsID.Conga.Out + '\n' +
       '{\n' +
       ' transition: transform ease-in ' + congaHideMS + 'ms;\n' +
       '}\n';

      t += 'div.scene.cube.kappa,\n' +
       'div.scene.cube.kappa div.cube\n' +
       '{\n' +
       ' transition: transform linear ' + Math.floor(tMS * timing.kappa.TheCube.time) + 'ms;\n' +
       '}\n';

      t += '\n';

      t += '[data-squash="vertical"]\n' +
       '{\n' +
       ' transform: scale(' + timing.display.Crazy.squash.width + ', ' + timing.display.Crazy.squash.height + ');\n' +
       '}\n' +
       '[data-squash="horizontal"]\n' +
       '{\n' +
       ' transform: scale(' + timing.display.Crazy.squash.height + ', ' + timing.display.Crazy.squash.width + ');\n' +
       '}';

      h = h.replaceAll('/* {INSERT:ANIM} *\/', t);
      return h;
     }

     function _gui(h)
     {
      if (cfg.display.hasOwnProperty('statuses') && cfg.display.statuses === false)
       h = h.replaceAll('/* {INSERT:NOTICE_OFF} *\/', 'display: none;');

      if (cfg.hasOwnProperty('twitch') && cfg.twitch.hasOwnProperty('oauth_refresh') && cfg.twitch.oauth_refresh === null)
       h = h.replaceAll('/* {INSERT:TWITCH_OFF} *\/', 'display: none;');

      if (cfg.hasOwnProperty('youtube') && cfg.youtube.hasOwnProperty('oauth_refresh') && cfg.youtube.oauth_refresh === null)
       h = h.replaceAll('/* {INSERT:YOUTUBE_OFF} *\/', 'display: none;');

      if (cfg.hasOwnProperty('kick') && cfg.kick.hasOwnProperty('channel') && cfg.kick.channel === null)
       h = h.replaceAll('/* {INSERT:KICK_OFF} *\/', 'display: none;');

      if (cfg.hasOwnProperty('lfg') && cfg.lfg.hasOwnProperty('channel') && cfg.lfg.channel === null)
       h = h.replaceAll('/* {INSERT:LFG_OFF} *\/', 'display: none;');

      return h;
     }

     function _variations(h)
     {
      let v = '.eSize-1_000\n' +
       '{\n' +
       ' --zoom-height: var(--emote-height);\n' +
       ' --zoom-width: var(--emote-width);\n' +
       '}\n';

      if (cfg.emote.size.variation !== false && typeof cfg.emote.size.variation === 'object' && cfg.emote.size.variation.hasOwnProperty('range') && Array.isArray(cfg.emote.size.variation.range))
      {
       for (let i = 0, l = cfg.emote.size.variation.range.length; i < l; i++)
       {
        const rV = cfg.emote.size.variation.range[i].toFixed(3);
        v += '.eSize-' + rV.replace('.', '_') + '\n' +
         '{\n' +
         ' --zoom-height: calc(var(--emote-height) * ' + rV + ');\n' +
         ' --zoom-width: calc(var(--emote-width) * ' + rV + ');\n' +
         '}\n';
       }
      }
      else
      {
       v += '.eSize-0_500\n' +
        '{\n' +
        ' --zoom-height: calc(var(--emote-height) / 2);\n' +
        ' --zoom-width: calc(var(--emote-width) / 2);\n' +
        '}\n';

       v += '.eSize-2_000\n' +
        '{\n' +
        ' --zoom-height: calc(var(--emote-height) * 2);\n' +
        ' --zoom-width: calc(var(--emote-width) * 2);\n' +
        '}\n';
      }

      h = h.replaceAll('/* {INSERT:ESIZE} *\/', v);
      return h;
     }

     return $c_css;
    }();

    function _hasRaveToggle()
    {
     for (const k of cfg.commands)
     {
      if (k.hasOwnProperty('rave'))
       return true;
      if (k.hasOwnProperty('raveon'))
       return true;
     }
     return false;
    }

    return $c_startup;
   }();

   window.addEventListener('load', startup);
  </script>
  <style>
   :root
   {
    --height: 0px;
    --width: 0px;
    --emote-height: 0px;
    --emote-width: 0px;
    --zoom-height: var(--emote-height);
    --zoom-width: var(--emote-width);
   }
   body
   {
    margin: 0;
    overflow: hidden;
   }
   img
   {
    box-sizing: border-box;
    height: var(--emote-height);
    width: var(--emote-width);
    object-fit: contain;
    object-position: 50% 50%;
   }
   img.emote
   {
    position: fixed;
    border: 0;
    margin: 0;
    padding: 0;
    offset-rotate: 0deg;
    /* {INSERT:SHADOW} */
   }
   /* {INSERT:ZWE} */

   div.scene
   {
    position: fixed;
    border: 0;
    margin: 0;
    padding: 0;
   }
   div.scene.cube
   {
    height: var(--emote-height);
    width: var(--emote-width);
   }
   div.scene div.cube
   {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
   }
   div.scene div.cube div[data-face]
   {
    height: var(--emote-height);
    width: var(--emote-width);
   }
   div.scene div.cube div[data-face] img
   {
    position: absolute;
    transform: translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face]
   {
    background-color: rgba(255, 255, 255, 0.2); /* {DELETE:SHADOW} */
    position: absolute;
    /* {INSERT:SHADOW} */
   }
   div.scene div.cube [data-face="front"]
   {
    transform: translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="back"]
   {
    transform: rotateY(90deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="right"]
   {
    transform: rotateY(180deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="left"]
   {
    transform: rotateY(-90deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="top"]
   {
    transform: rotateX(90deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="bottom"]
   {
    transform: rotateX(-90deg) translateZ(var(--cube-depth));
   }

   div.scene img.dancer
   {
    text-align: center;
    position: relative;
    animation: dance 4s linear infinite;
    /* {INSERT:SHADOW} */
   }

   @keyframes dance
   {
    0%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    6%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    13%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    19%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    25%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    31%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    38%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    44%
    {
     transform: translate(20%, 10%) rotate(-30deg);
    }
    50%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    56%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    63%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    69%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    75%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    81%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    88%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    94%
    {
     transform: translate(80%, 10%) rotate(30deg);
    }
    100%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
   }

   @keyframes wiggleL
   {
    33%
    {
     transform: translateX(-50%);
    }
    66%
    {
     transform: translateX(50%);
    }
   }
   @keyframes wiggleR
   {
    33%
    {
     transform: translateX(50%);
    }
    66%
    {
     transform: translateX(-50%);
    }
   }

   @keyframes speedL
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(-1 * var(--width) * 4), 0);
    }
   }
   @keyframes speedR
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(var(--width) * 4), 0);
    }
   }

   @keyframes dropL
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(350deg);
    }
   }
   @keyframes dropR
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(-35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(-350deg);
    }
   }

   @keyframes confettiA
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0.5, 0, -4500deg);
    }
   }

   @keyframes confettiB
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0, 0, -4500deg);
    }
   }

   @keyframes confettiC
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, -0.5, 0, -4500deg);
    }
   }

   @keyframes offsetPath
   {
    0%
    {
     offset-distance: 0%;
    }
    100%
    {
     offset-distance: 100%;
    }
   }

   /* {INSERT:ESIZE} */
   /* {INSERT:ANIM} */
   [data-squash="no"]
   {
    transform: scale(1, 1);
   }

   [data-origin="center"]
   {
    transform-origin: center center;
   }
   [data-origin="topleft"]
   {
    transform-origin: left top;
   }
   [data-origin="topright"]
   {
    transform-origin: right top;
   }
   [data-origin="top"]
   {
    transform-origin: center top;
   }
   [data-origin="bottom"]
   {
    transform-origin: center bottom;
   }
   [data-origin="left"]
   {
    transform-origin: left center;
   }
   [data-origin="right"]
   {
    transform-origin: right center;
   }

   @keyframes fadeIn
   {
    0%
    {
     opacity: 0;
    }
    100% /* 8% */
    {
     opacity: 1;
    }
   }

   @keyframes fadeOut
   {
    0% /* 95% */
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes noFadeOut
   {
    99%
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes zoomIn
   {
    0%
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) 0; /* {REPLACE:ZWE_PAD} */
    }
    24% /* 4% */
    {
     padding: 0;
    }
    47% /* 8% */
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.8)) / 2) 0; /* {REPLACE:ZWE_PAD} */
    }
    71% /* 12% */
    {
     padding: 0;
    }
    88% /* 15% */
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.95)) / 2) 0; /* {REPLACE:ZWE_PAD} */
    }
    100% /* 17% */
    {
     padding: 0;
    }
   }

   @keyframes zoomOut
   {
    0% /* 95% */
    {
     padding: 0;
    }
    100%
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) 0; /* {REPLACE:ZWE_PAD} */
    }
   }

   .zweFramed.zweLPad.zweHat img, img.zweFramed.zweLPad.zweHat
   {
    border-width: calc(var(--emote-height) * 0.35) 
                  calc(var(--emote-width)  * 0.05)
                  calc(var(--emote-height) * 0.05)
                  calc(var(--emote-width)  * 0.15);
   }

   .zweLPad.zweHat img, img.zweLPad.zweHat
   {
    border-width: calc(var(--emote-height) * 0.35)
                  0
                  0
                  calc(var(--emote-width) * 0.15)
   }

   .zweFramed.zweHat img, img.zweFramed.zweHat
   {
    border-width: calc(var(--emote-height) * 0.35)
                  calc(var(--emote-width)  * 0.05)
                  calc(var(--emote-height) * 0.05)
                  calc(var(--emote-width)  * 0.05);
   }

   .zweFramed.zweLPad img, img.zweFramed.zweLPad
   {
    border-width: calc(var(--emote-height) * 0.05)
                  calc(var(--emote-width)  * 0.05)
                  calc(var(--emote-height) * 0.05)
                  calc(var(--emote-width)  * 0.15);
   }

   .zweFramed img, img.zweFramed
   {
    border-color: transparent;
    border-style: solid;
    border-width: calc(var(--emote-height) * 0.05)
                  calc(var(--emote-width)  * 0.05)
                  calc(var(--emote-height) * 0.05)
                  calc(var(--emote-width)  * 0.05);
   }

   .zweLPad img, img.zweLPad
   {
    border-color: transparent;
    border-style: solid;
    border-width: 0
                  0
                  0
                  calc(var(--emote-width)  * 0.10);
   }

   .zweHat img, img.zweHat
   {
    border-color: transparent;
    border-style: solid;
    border-width: calc(var(--emote-height) * 0.35)
                  0
                  0
                  0;
   }

   dialog
   {
    min-width: 16em;
    font-size: 4vmin;
    background-color: #000000;
    color: #FFFFFF;
    overflow: hidden;
    padding-bottom: 2.5em;
    border-radius: 0.5em;
    box-shadow: 3px 3px 5px #000000;
   }
   dialog::backdrop
   {
    background-color: #000000;
    opacity: 0.5;
   }
   dialog div
   {
    margin-bottom: 1em;
   }
   dialog input
   {
    background-color: #000000;
    color: #FFFFFF;
    border: 1px solid #FFFFFF;
    border-radius: 3px;
    width: 100%;
    font-size: 3.5vmin;
   }
   dialog input:read-only
   {
    background-color: #282828;
   }
   dialog button
   {
    background-color: #505050;
    transition: opacity 0.5s;
    width: 7em;
    font-size: 3.5vmin;
    padding: 0.3em;
   }
   dialog button.yes
   {
    left: 1em;
   }
   dialog button.yes:focus:not([disabled]), dialog button.yes:hover:not([disabled])
   {
    background-color: #007000;
   }
   dialog button.yes:active:not([disabled])
   {
    background-color: #009000;
   }
   dialog button.no
   {
    right: 1em;
   }
   dialog button.no:focus:not([disabled]), dialog button.no:hover:not([disabled])
   {
    background-color: #700000;
   }
   dialog button.no:active:not([disabled])
   {
    background-color: #900000;
   }
   dialog button[disabled]
   {
    background-color: #303030;
    color: #808080;
   }

   #notices
   {
    /* {INSERT:NOTICE_OFF} */
    position: absolute;
    top: 8px;
    left: 8px;
    width: 35em;
   }
   #notices #badge
   {
    position: fixed;
    font-family: sans-serif;
    font-size: 14px;
    left: 8px;
    width: 16px;
    height: 16px;
    display: inline-block;
    border: 1.5px solid #000000;
    border-radius: 8px;
    text-align: center;
    background-color: #E0E0E0;
    color: #000000;
    opacity: 0.75;
    transition: opacity 1s ease-in;
    cursor: default;
   }
   #notices #badge[data-alerts="0"]
   {
    opacity: 0;
   }
   #notices #badge.fader
   {
    transition: all 300ms ease-out;
   }
   #notices #badge.fade
   {
    opacity: 0;
   }
   #notices .noticeLine
   {
    position: relative;
    font-family: sans-serif;
    font-size: 14px;
    border: 1.5px solid #000000;
    border-radius: 8px;
    padding-left: 24px;
    padding-right: 8px;
    margin-left: 24px;
    margin-bottom: 4px;
    white-space: nowrap;
    max-width: fit-content;
    width: 100%;
    transition: all 300ms ease-out;
    opacity: 0.75;
    cursor: default;
   }
   #notices .noticeLine:hover
   {
    opacity: 1;
   }
   #notices .noticeLine.hide
   {
    width: 0%;
    overflow: hidden;
   }
   #notices .noticeLine.fader
   {
    transition: opacity 0.5s;
    opacity: 0.75;
   }
   #notices .noticeLine.fader:hover
   {
    opacity: 1;
   }
   #notices .noticeLine.fader.fade
   {
    opacity: 0;
   }
   #notices .noticeLine.fader.faded
   {
    height: 0;
    margin: 0;
    padding: 0;
    border: 0;
   }
   #notices .noticeInfo
   {
    background-image: linear-gradient(to right, transparent 0, transparent 20px, #E0E0E0 24px);
   }
   #notices .noticeWarning
   {
    background-image: linear-gradient(to right, transparent 0, transparent 20px, #FFFF00 24px);
   }
   #notices .noticeError
   {
    color: #FFFFFF;
    background-image: linear-gradient(to right, transparent 0, transparent 20px, #FF0000 24px);
   }
   #notices .noticeError a
   {
    color: #FFFF00;
    text-decoration: none;
   }
   #notices .noticeError a:hover
   {
    color: #FFFFC0;
   }
   #notices .global
   {
    background-color: #FFFFFF;
   }
   #notices .sTwitch
   {
    background-color: #7D5BBE;
   }
   #notices .sTwitch:after
   {
    position: absolute;
    top: 0;
    left: 7px;
    content: 'T';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .sYouTube
   {
    background-color: #E93223;
   }
   #notices .sYouTube:after
   {
    position: absolute;
    top: 0;
    left: 2px;
    content: 'YT';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .sKick
   {
    background-color: #53FC18;
   }
   #notices .sKick:after
   {
    position: absolute;
    top: 0;
    left: 7px;
    content: 'K';
    color: #000000;
    font-size: 14px;
   }
   #notices .sLFG
   {
    background-color: #1C78E6;
   }
   #notices .sLFG:after
   {
    position: absolute;
    top: 0;
    left: 7px;
    content: 'L';
    color: #000000;
    font-size: 14px;
   }
   #notices .tStreamElements
   {
    background-color: #0000FF;
   }
   #notices .tStreamElements:after
   {
    position: absolute;
    top: 0;
    left: 2px;
    content: 'SE';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .tStreamlabs
   {
    background-color: #80F5D2;
   }
   #notices .tStreamlabs:after
   {
    position: absolute;
    top: 0;
    left: 3px;
    content: 'SL';
    color: #000000;
    font-size: 14px;
   }
   #notices .eBTTV
   {
    background-color: #FF0000;
   }
   #notices .eBTTV:after
   {
    position: absolute;
    top: 0;
    left: 7px;
    content: 'B';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .e7TV
   {
    background-color: #00FFFF;
   }
   #notices .e7TV:after
   {
    position: absolute;
    top: 0;
    left: 8px;
    content: '7';
    color: #000000;
    font-size: 14px;
   }

   button
   {
    transition: background 0.12s ease-in, color 0.12s ease-in;
    white-space: nowrap;
    cursor: pointer;
    color: #FFFFFF;
    border-radius: 4px;
    border: none;
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    z-index: 1000;
    opacity: 1;
    position: absolute;
    user-select: none;
   }
   button.hidden
   {
    opacity: 0;
   }
   button:focus
   {
    outline: none;
   }

   button.twitch
   {
    /* {INSERT:TWITCH_OFF} */
    background-color: #7D5BBE;
   }
   button.twitch:focus, button.twitch:hover
   {
    background-color: #772CE8;
   }
   button.twitch:active
   {
    background-color: #5C16C5;
   }

   button.kick
   {
    /* {INSERT:KICK_OFF} */
    background-color: #00FF00;
    color: #000000;
   }
   button.kick:focus, button.kick:hover
   {
    background-color: #00D000;
   }
   button.kick:active
   {
    background-color: #60FF60;
   }

   button.lfg
   {
    /* {INSERT:LFG_OFF} */
    background-color: #2080E0;
   }
   button.lfg:focus, button.lfg:hover
   {
    background-color: #0050A0;
   }
   button.lfg:active
   {
    background-color: #6080E0;
   }

   button.youtube
   {
    /* {INSERT:YOUTUBE_OFF} */
    background-color: #E93223;
   }
   button.youtube:focus, button.youtube:hover
   {
    background-color: #D00000;
   }
   button.youtube:active
   {
    background-color: #FF0000;
   }

   button.auth
   {
    transition: opacity 0.5s;
    right: 0.5em;
    width: 7em;
    font-size: 3.5vmin;
    padding: 0.3em 0.5em 0.5em 2em;
   }
   button.auth span
   {
    font-size: 40%;
    padding: 0;
    position: absolute;
    bottom: 0.25em;
    right: 0.5em;
   }
   button.auth.twitch
   {
    top: 0.5em;
   }
   button.auth.kick
   {
    top: 2.75em;
   }
   button.auth.youtube
   {
    top: 5em;
   }
   button.auth.lfg
   {
    top: 7.25em;
   }
   button.auth::before
   {
    content: '\1f9c5';
    position: absolute;
    left: 0.5em;
   }
   button.auth.unauthorized::before
   {
    filter: grayscale(1);
   }
   button.auth.authorized::after
   {
    content: '\1f440';
    position: absolute;
    left: 1.6em;
    top: 1.3em;
    font-size: 50%;
   }

   #oobe
   {
    position: absolute;
    top: 15vh;
    left: 10vw;
    width: 80vw;
    height: 70vh;
    border: 1px solid #000000;
    box-shadow: 2px 2px 4px #000000;
    background-color: #000050;
    color: #FFFFFF;
    z-index: -2;
    border-radius: 5px;
    overflow: hidden;
   }
   #oobe h1
   {
    margin: 0.25em 0 0.25em 40%;
    width: 55%;
    text-align: center;
    text-shadow: 0 0 4px #000000;
    font-family: monospace;
    font-size: 4vmin;
   }
   #oobe h2
   {
    margin: 0.25em 0 0.25em 40%;
    width: 55%;
    text-align: center;
    text-shadow: 1px 1px 4px #000000;
    font-family: sans-serif;
    font-size: 3vmin;
   }
   #oobe svg
   {
    cursor: default;
    user-select: none;
   }
   #oobe #pctOBS
   {
    position: absolute;
    top: 3px;
    left: 3px;
    max-height: calc(100% - 6px);
    max-width: calc(100% - 6px);
    z-index: -1;
    box-shadow: 2px 2px 4px #000000;
   }
   #oobe #pctOBS #mnuTools
   {
    opacity: 0;
    transition: opacity 0s;
   }
   #oobe:hover #pctOBS #mnuTools
   {
    transition: opacity 0s 1s;
    opacity: 1;
   }
   #oobe #pctOBS #mnuToolsIcon
   {
    opacity: 0;
    transition: opacity 0s;
   }
   #oobe:hover #pctOBS #mnuToolsIcon
   {
    transition: opacity 0s 1s;
    opacity: 1;
   }
   #oobe #pctOBS #mnuToolsText
   {
    opacity: 0;
    transition: opacity 0s;
   }
   #oobe:hover #pctOBS #mnuToolsText
   {
    transition: opacity 0s 1s;
    opacity: 1;
   }
   #oobe #pctOBS #mnuToolsSel
   {
    opacity: 0;
    transition: opacity 0s;
   }
   #oobe:hover #pctOBS #mnuToolsSel
   {
    transition: opacity 0s 2s;
    opacity: 1;
   }
   #oobe #pctPref
   {
    position: absolute;
    top: 5%;
    left: 16%;
    max-width: 70%;
    max-height: 70%;
    opacity: 0;
    z-index: -1;
    transition: opacity 0s;
    box-shadow: 2px 2px 4px #000000;
   }
   #oobe:hover #pctPref
   {
    transition: opacity 0.5s 4s linear;
    opacity: 1;
   }
   #oobe #pctIcon
   {
    font-size: 3vmin;
    position: absolute;
    width: 68px;
    height: 64px;
    z-index: 1;
   }
   #oobe:hover #pctIcon
   {
    transition: all 3s ease-in-out;
   }
   #oobe:hover #pctOBS #svgSourceRect
   {
    stroke: #808080;
    stroke-width: 2;
   }
   #oobe:hover #pctOBS #svgSelRect
   {
    fill: #21476d !important;
    stroke: #ffffff;
    stroke-width: 1;
    stroke-dasharray: 1,3;
   }
   #oobe:hover #pctOBS #rectLowAdd
   {
    fill: #7a797a !important;
   }
   #pctIcon{left: -70px; top: 40vh;}
   #oobe:hover #pctIcon{left: 23vw; top: 56vh;}
   @media only screen and (min-aspect-ratio: 47/36)
   {
    #pctIcon{left: 95vh; bottom: 17vmin; top: unset;}
    #oobe:hover #pctIcon{left: 25vh; bottom: 5vmin; top: unset;}
   }
   @media only screen and (max-aspect-ratio: 51/49)
   {
    #pctIcon{left: 5vh; top: calc(70vh - 64px);}
    #oobe:hover #pctIcon{left: 25vmin; top: 50vmin;}
   }
   #oobeNext
   {
    float: right;
    margin-right: 1em;
    padding: 0 1em 1em;
    width: 40%;
    min-width: 12em;
    background-color: #000000C0;
    border-radius: 12px;
   }
   #oobeNext h3
   {
    margin-left: 1em;
    margin-right: 1em;
    border-bottom: 1px solid blue;
    font-family: sans-serif;
    font-size: 2.5vmin;
   }
   #oobeNext div
   {
    font-size: 2vmin;
    text-align: justify;
   }
   #oobeButtons
   {
    position: absolute;
    bottom: 0;
    right: 0;
    padding: 1em;
    border-top-left-radius: 6px;
    border-bottom-right-radius: 6px;
    text-align: right;
    background-color: #00000060;
    font-size: 2vmin;
   }
   #oobeButtons button
   {
    background-color: #505050;
    width: 9em;
    font-size: 3vmin;
    padding: 0.3em;
    position: unset;
   }
   #oobeButtons button:focus, #oobeButtons button:hover
   {
    background-color: #707070;
   }
   #oobeButtons button:active
   {
    background-color: #303030;
   }
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="referrer" content="no-referrer" />
 </head>
</html>