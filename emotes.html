<!doctype html>
<html lang="en">
 <head>
  <meta charset="utf-8" />
  <title>Loading Emote Wall...</title>
  <script>
   'use strict';
   /* RealityRipple's Home-Made Emote Wall
    * ====================================
    *
    * v0.7.9.5 BETA
    *
    *  <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *
    *
    * Help
    * ----
    *
    *  Please contact RealityRipple for assistance, bug reports, or questions.
    *
    *   <https://realityripple.com>
    *   <https://twitch.tv/realityripple>
    *   <https://discord.gg/fcxJ9tq3XS>
    *
    *
    * Configuration Information
    * -------------------------
    *
    * channel     The name of the channel to join. Also used to choose an IRC nickname.
    *             If FALSE, the interactive login process will be enabled.
    *
    * login       Settings related to the login process.
    *
    *             NOTE: OAuth refresh tokens expire automatically (usually after around half a year).
    *                   If you don't use the Emote Wall for around this long, you may have to log in again.
    *                   Regular OAuth tokens expire much sooner (usually after 60 days). If you use the manual oauth
    *                   method, please make sure to update these values on a regular basis.
    *
    *  client     The Client ID value is used to track which third-party project is accessing your account.
    *             This emote wall does not require a constant ID, and will work with whatever tool you use to
    *             get an OAuth ID (see below).
    *
    *  oauth      The OAuth ID value is used in lieu of a password to access the Twitch API.
    *             By default, this value is not required.
    *             If you do not wish to use the oauth_refresh method, which relies on a file on my webserver,
    *             you can generate your own OAuth2 token manually using a third-party Twitch Token Generator, and set
    *             this value to the token you receive. However, it will expire and require updating manually.
    *
    *  oauth_refresh  A refresh token to get a new Twitch OAuth ID when the current one expires.
    *                This value is used instead of the oauth value above, by default. Using a refresh token allows the
    *             emote wall to stay logged in for a much longer period of time. Please note that this feature makes
    *             use of the browser's Local Storage to store new OAuth Tokens and Refresh Tokens as they're generated.
    *             New OAuth Tokens are generated every 60 minutes, and Twitch may or may not send a new Refresh Token
    *             at the same time. If the token expires, the Local Storage values will be erased on the next refesh
    *             attempt automatically.
    *             Please generate an OAuth ID and matching Client ID:
    *             - Visit <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *             - Click the "Authenticate on Twitch" button under "Do-it-Yourself" and log in
    *             - Fill out the captcha prompt, if necessary
    *             - Copy the Client ID value and paste it into "client:"
    *             - Copy the OAuth Refresh value and paste it into "oauth_refresh:"
    *             If you ever stop using this emote wall, please log into Twitch and visit
    *             <https://www.twitch.tv/settings/connections>. Under "Other Connections", click the "Disconnect" button
    *             next to "RealityRipple's Home-Made Emote Wall".
    *
    *             If both oauth and oauth_refresh are FALSE (or missing), the interactive login process will be enabled.
    *
    *  scope      A list of scopes which the OAuth ID provides access to. Please make sure this list reflects
    *             any scope selections you made while creating the token above.
    *
    *  share      Share your channel on the Emote Wall home page!
    *
    * streamlabs  Settings related to Streamlabs tips.
    *
    *  token      The Socket Token is used in lieu of a password to access the Streamlabs API.
    *             Please generate a Socket Token:
    *             - Visit <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *             - Click the "Streamlabs Tip Support" button and log in
    *             - Copy the Token value and paste it into "token:"
    *             If you ever stop using this emote wall, please log into Streamlabs and visit
    *             <https://streamlabs.com/dashboard#/settings/api-settings>. Under "Connected Apps", click the
    *             "Revoke Access" button next to "RealityRipple's Home-Made Emote Wall". If you want to use a different
    *             Streamlabs OAuth generator (or do it yourself), feel free.
    *
    *  curMul     This value is the currency multiplier. The ranges of Streamlabs tip entries (see below) will
    *             match against this multiplier. For example, if you use USD and want to set ranges by penny amount,
    *             then set this value to 100. If you want to use dollar amounts, set the value to 1.
    *             Note: Any decimal amount will be rounded down after multiplying, so $3.95 will be handled as "395"
    *                   pennies when multiplied by 100, or "3" dollars when multiplied by 1.
    *
    *  dispMul    This value is the currency multiplier when the currency is being displayed. For kappagen events such
    *             as Text, the Streamlabs tip amount will be multiplied by this number before being displayed.
    *             For example, if you use USD and want to display the value as cents, then set this value to 100. If
    *             you want to show dollar amounts, set this value to 1.
    *
    *  dispDec    This value is the decimal count when the currency is being displayed. After being multiplied by the
    *             dispMul value above, the Streamlabs tip amount will be rounded to this many decimal places.
    *             For example, an amount of $3.95 rounded to "0" decimal places will be "3", to "1" would be "3.9", and
    *             to "2" would be "3.95".
    *
    *  dispPre    This value should be added before any currency amount as a prefix, such as a dollar sign '$'.
    *
    *  dispSuf    This value should be added after any currency amount as a suffix, such as the word " dollars". Usually
    *             only the prefix or the suffix should be used, not both at the same time.
    *
    * streamelements  Settings related to StreamElements tips.
    *
    *  oauth_refresh  A refresh token to get a new StreamElements OAuth ID when the current one expires.
    *                The OAuth ID value is used in lieu of a password to access the StreamElements API.
    *             Please generate an OAuth ID:
    *             - Visit <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *             - Click the "StreamElements Tip Support" button and log in
    *             - Copy the Token value and paste it into "oauth_refresh:"
    *             If you ever stop using this emote wall, please log into StreamElements and visit
    *             <https://streamelements.com/dashboard/account/security>. Click the "Reset my Personal Access Token"
    *             button. If you want to use a different StreamElements OAuth generator (or do it yourself), feel free.
    *             Please only use oauth_refresh or token, not both. Token does not expire, but is also less secure.
    *             OAuth is recommended, if possible.
    *
    *  token      The JWT Token is used in lieu of a password to access the StreamElements API.
    *             Please grab your JWT Token from the StreamElements Dashboard:
    *             - Visit <https://streamelements.com/dashboard/account/channels>
    *             - Click the "Show secrets" button
    *             - Copy the JWT Token value and paste it into "token:"
    *             Please only use refresh or token, not both. Token does not expire, but is also less secure. OAuth is
    *             recommended, if possible.
    *
    *  curMul     This value is the currency multiplier. The ranges of StreamElements tip entries (see below) will
    *             match against this multiplier. For example, if you use USD and want to set ranges by penny amount,
    *             then set this value to 100. If you want to use dollar amounts, set the value to 1.
    *             Note: Any decimal amount will be rounded down after multiplying, so $3.95 will be handled as "395"
    *                   pennies when multiplied by 100, or "3" dollars when multiplied by 1.
    *
    *  dispMul    This value is the currency multiplier when the currency is being displayed. For kappagen events such
    *             as Text, the StreamElements tip amount will be multiplied by this number before being displayed.
    *             For example, if you use USD and want to display the value as cents, then set this value to 100. If
    *             you want to show dollar amounts, set this value to 1.
    *
    *  dispDec    This value is the decimal count when the currency is being displayed. After being multiplied by the
    *             dispMul value above, the StreamElements tip amount will be rounded to this many decimal places.
    *             For example, an amount of $3.95 rounded to "0" decimal places will be "3", to "1" would be "3.9", and
    *             to "2" would be "3.95".
    *
    *  dispPre    This value should be added before any currency amount as a prefix, such as a dollar sign '$'.
    *
    *  dispSuf    This value should be added after any currency amount as a suffix, such as the word " dollars". Usually
    *             only the prefix or the suffix should be used, not both at the same time.
    *
    * display     Settings related to the animation of the emote wall.
    *
    *  styles     An array of animation styles which individual emotes randomly perform. You may turn on and off
    *             elements in this array by "commenting out" a style, by putting two slashes before the name:
    *              // 'Still',        < disabled
    *                 'StraightLine', < allowed
    *
    *  access     A bitwise flag representing which users' messages show up on the emote wall. Account types are
    *             represented by the following values:
    *
    *              0x800 = broadcaster
    *              0x400 = moderator badge
    *              0x200 = founder badge
    *              0x100 = vip badge
    *              0x080 = artist badge
    *              0x040 = tier 3 subscriber badge
    *              0x020 = tier 2 subscriber badge
    *              0x010 = tier 1 subscriber badge
    *              0x004 = cheer badge
    *              0x002 = follower
    *              0x001 = stranger
    *
    *             Just put a vertical pipe " | " in between each of the values representing levels of access:
    *
    *              ACCESS                                 MEANING
    *             0x800 | 0x400                           broadcaster and moderator only
    *             0x800 | 0x400 | 0x100 | 0x040 | 0x020   broadcasters, mods, VIPs, and tier 2 and 3 subscribers
    *             0x800 | 0x010 | 0x002                   boradcaster, tier 1 subscribers, and followers
    *
    *             If you know how bitwise flags work, you can also use them
    *             in more complicated ways:
    *               ACCESS           MEANING
    *             0xFF7             all users from the broadcaster to strangers
    *             0xFF7 ^ 0x003     all users except followers and strangers
    *             0x070             all subscribers
    *
    *  duplicates  A boolean or integer to toggle duplicate emotes per message.
    *             If TRUE, every emote posted in chat will be shown.
    *             If FALSE, only one of each emote per message will be shown.
    *             If greater than 1, sets the maximum number of identical emotes shown from any message.
    *
    *  useEmoji   Toggles display of emojis on the emote wall, and lets you choose an emoji font style.
    *             If TRUE, emojis will be shown using the "twemoji" font.
    *             If FALSE, emojis will not be shown on the emote wall.
    *             If 'twemoji', emojis will be shown using the "twemoji" font.
    *             If 'openmoji', emojis will be shown using the "openmoji" font.
    *             If 'noto', emojis will be shown using the "noto" font.
    *             If 'blob', emojis will be shown using the "blobmoji" font.
    *
    *  extended   Settings related to third-party emotes.
    *
    *   useFFZ    Toggles display of FrankerFaceZ emotes.
    *
    *   useBTTV   Toggles display of BetterTTV emotes.
    *
    *   use7TV    Toggles display of 7TV emotes.
    *
    *   useZWE    Toggles display of Zero-Width (overlapping) emotes. If disabled, this will hide ZWEs entirely.
    *             Note: ZWE display requires more objects on-screen, which can be process-intensive, and precise
    *                   timing is required for accurate overlay.
    *                   CHAOS MAY ENSUE.
    *
    *   fillZWE   Toggles the fill style of Zero-Width (overlapping) emotes.
    *             If TRUE, ZWEs will be stretched or squashed to fit non-square emotes.
    *             If FALSE, ZWEs will be placed in the center of non-square emotes.
    *
    *  hue        Rotate the hue of all emotes.
    *             If a number between 1 and 359, all colors will be rotated by that many degrees.
    *             If 'rave', all colors will constantly rotate.
    *             Otherwise, no color rotation will occur.
    *             Note: If a command to toggle rave or turn rave on exists, rave will be off at startup.
    *
    *  kappa      Settings related to emote-splosions and the !kappagen command.
    *
    *   count     The number of emotes to display per kappagen. This value should be less than the "emote max" value
    *             seen below (best would be 1/4th or less), if "emote max" is used, or it will be truncated to match.
    *
    *   styles    Similar to the array of styles for normal emotes, but this one lists emote-splosion types.
    *             Please do not try to add normal styles to the kappa list or vice versa. This is an associative array
    *             which can have custom settings for certain styles (namely The Cube and Text - see below).
    *
    *    [ALL]    Settings related to multiple kappagens. These settings will be the default for all instances of their
    *             respective kappagens. Each setting below may or may not apply to a specific kappagen style.
    *
    *     count   The number of emotes to display for this specific kappagen. This value should be less than the
    *             "emote max" value seen below (best would be 1/4th or less), if "emote max" is used, or it will be
    *             truncated to match. If unset, this will default to the global kappa count preference listed above.
    *             Note: If this preference is in an event below (not in this general kappa context), then an additional
    *                   value is possible: -1, which will refer to the AMOUNT value present in the event. This can be
    *                   the number of raiders, bits cheered, dollars tipped, subs gifted, or months subscribed.
    *
    *    Conga    Settings related to Conga kappagen. These settings will be the default for all instances of
    *             Conga kappagen.
    *
    *     avoidMiddle  If TRUE, conga lines will only show up on the top or bottom three rows to avoid the middle off
    *                 the screen.
    *             If FALSE, conga lines will show up on any row of the screen.
    *
    *    TheCube  Settings related to The Cube kappagen. These settings will be the default for all instances of
    *             TheCube kappagen.
    *
    *     size    A decimal value representing the height of The Cube kappagen, relative to the smallest
    *             screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "8 / 10" (80%).
    *
    *     center  If TRUE, The Cube will show up in the exact center of the screen.
    *             If FALSE, The Cube will show up in a random location.
    *
    *     rotations  The maximum number of rotations a kappa cube might spin while on screen. This effectively controls
    *               the maximum possible speed at which cubes will rotate.
    *
    *    Text     Settings related to Text kappagen. These settings will be the default for all instances of Text
    *             kappagen.
    *
    *     message  An array of alphanumeric strings (letters, numbers, and spaces), one of which will randomly be used.
    *
    *     time    The number of seconds the Text kappagen should show the final result for.
    *             This value should be adjusted depending on the average message length, for readability.
    *
    *   access    Similar to the access flag for normal emotes, but controls which users can use the !kappagen command.
    *
    *   aliases   An array of kappagen command aliases which can be used to force-trigger kappagens.
    *
    *   cooldown  The number of seconds between force-triggered kappagens using an above alias. Any commands sent before
    *             the cooldown will be ignored, unless the another command shares the same alias.
    *
    *   conga     Settings related to Conga kappagen.
    *
    *    contagious  If TRUE, while one Conga kappagen is visible, all additional kappagens will also be Conga.
    *               If FALSE, Conga kappagns will behave like any other kappagen.
    *
    *    time     The number of seconds the Conga kappagen should show up on the screen for.
    *             This value lets you increase or decrease the chances of keeping a "contagious" Conga line going.
    *
    *    avoidMiddle  If TRUE, conga lines will only show up on the top or bottom three rows to avoid the middle off
    *                the screen globally.
    *             If FALSE, the setting will default to any more specific avoidMiddle Conga settings.
    *
    * emote       Settings related to individual emote display.
    *
    *  time       The number of seconds an emote should show up on the screen for.
    *
    *  max        The maximum nuber of emotes to show on the screen at one time. Set this value to 0 for
    *             infinite emotes. This value should be greater than any "kappa count" values seen above or below
    *             (best would be 4x or more), as it will limit any single kappagen events to this maximum.
    *
    *  queue      The maximum number of emotes to save in queue. Set this value to 0 for an infinite queue.
    *             This value will be ignored if the previous value (cfg.emote.max) is infinite (0).
    *
    *  size       Settings related to the size of emotes.
    *
    *   ratio     Emotes show up in multiple sizes due to the kappagen feature. There are a total of four sizes
    *             that an emote can be:
    *              - The Cube kappagen's faces are squares equal to 80% of the smaller screen dimension
    *                (usually height on PC).
    *              - Pyramid kappagen emotes have a height equal to 1/19th of the screen's width.
    *              - Fireworks, Spiral, and Confetti kappagen emotes have a height equal to the small ratio (see below).
    *              - All standard emotes and kappagens not listed above will use the normal ratio (see below).
    *                Most normal emotes will limit by height, except The Cube, which fits in the center of every side.
    *
    *    normal   A decimal value representing the height of each emote, relative to the smallest screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "1 / n" where n is greater than 10.
    *
    *    small    A decimal value representing the height of small emotes, relative to the smallest screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "1 / n" where n is greater than 20.
    *
    *   min       The minimum height of an emote, in pixels.
    *
    *   max       The maximum height of an emote, in pixels.
    *
    *   variation  An integer variable that determines how often occasional random large or small emotes show up.
    *             If FALSE, no variations will occur.
    *
    *  cube      Settings related to The Cube emote.
    *
    *   rotations  The maximum number of rotations a cube might spin while on screen. This effectively controls the
    *             maximum possible speed at which cubes will rotate.
    *
    *  in         Settings related to the showing of an emote.
    *             Note: Some kappagen styles do not use these. See the notes next to each kappagen style name.
    *
    *   fade      A boolean to toggle the "fade in" style.
    *
    *   zoom      A boolean to toggle the "zoom in" style.
    *
    *  out        Settings related to the hiding of an emote.
    *             Note: Some kappagen styles do not use these. See the notes next to each kappagen style name.
    *
    *   fade      A boolean to toggle the "fade out" style.
    *
    *   zoom      A boolean to toggle the "zoom out" style.
    *
    * event       Settings related to channel events which trigger emote-splosions (kappagen).
    *
    *  clear      A boolean to toggle clearing the screen when chat is cleared.
    *              If TRUE, the emote wall will be cleared when the /clear command is used.
    *              If FALSE, the emote wall will ignore the /clear command.
    *
    *  raid       Settings related to kappagens when being raided.
    *
    *   raiders   A streamer raids the channel with viewers. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all raids.
    *              If FALSE, no kappagen will occur on raids.
    *              If Integer, the value is the minimum raiders required for a raid to trigger a kappagen.
    *               If 0, no kappagen will occur on raid.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   originEmotes  A boolean to toggle the use of the raiding streamer's channel emotes for raid kappagens.
    *                If TRUE, raid kappagens will use channel emotes from the raider's channel.
    *               If FALSE, raid kappagens will use your channel's emotes.
    *
    *   originExtendedEmotes  A boolean to toggle third-party emotes, if originEmotes is enabled.
    *
    *  follow     A user follows the channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  shoutout   Settings related to kappagens on a shoutout event. Requires "moderator:read:shoutouts" scope.
    *             Note: Shoutout event booleans can also be arrays of kappa styles. This will override the default list
    *                   of kappa styles for the particular event in question.
    *
    *   create    Settings related to kappagens when you shout another channel out.
    *
    *    styles   You shout another channel out. This value can be a boolean or array.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   targetEmotes  A boolean to toggle the use of the target channel's emotes for shoutout kappagens.
    *                If TRUE, shoutout kappagens will use channel emotes from the target's channel.
    *               If FALSE, shoutout kappagens will use your channel's emotes.
    *
    *   targetExtendedEmotes  A boolean to toggle third-party emotes, if targetEmotes is enabled.
    *
    *   receive    Settings related to kappagens when another channel shouts you out.
    *
    *    styles   You are shouted out by another channel. This value can be a boolean or array.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   originEmotes  A boolean to toggle the use of the source channel's emotes for shoutout kappagens.
    *                If TRUE, shoutout kappagens will use channel emotes from the source's channel.
    *               If FALSE, shoutout kappagens will use your channel's emotes.
    *
    *   originExtendedEmotes  A boolean to toggle third-party emotes, if originEmotes is enabled.
    *
    *  tag        Settings related to kappagens when users tag a channel you've tagged in your stream title.
    *
    *   styles     A user posts a message that starts with '@user'. This value can be a boolean or array.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   access    A bitwise flag representing which users can trigger this kappagen with a command.
    *             This value will fall back to the general kappagen access value if missing or less than 0.
    *
    *   targetEmotes  A boolean to toggle the use of the target channel's emotes for tag kappagens.
    *                If TRUE, tag kappagens will use channel emotes from the target's channel.
    *               If FALSE, tag kappagens will use your channel's emotes.
    *
    *   targetExtendedEmotes  A boolean to toggle third-party emotes, if targetEmotes is enabled.
    *
    *  sub        Settings related to kappagens on a subscribe event.
    *             Note: Sub event booleans can also be arrays of kappa styles. This will override the default list
    *                   of kappa styles for the particular event in question.
    *
    *   useMsg    If TRUE, any emotes in resub messages will be used for the kappagen.
    *             If FALSE, any emotes in resub messages will show up like normal emotes.
    *
    *   t1        Settings related to kappagens on a tier 1 subscribe event.
    *
    *    first    A user subscribes at Tier 1 for the first time.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    resub    A user resubscribes at Tier 1. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Tier 1 resubs.
    *              If FALSE, no kappagen will occur on T1 resubs.
    *              If Integer, the value is the minimum months required for a Tier 1 resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    upgrade  Settings related to "converted" subscriptions.
    *
    *     gift     A user upgrades a gift sub to Tier 1.
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     prime    A user upgrades a Prime sub to Tier 1.
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    gift     Settings related to tier 1 gifts.
    *
    *     first   A user gifts another user their first Tier 1 subscription.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     resub   A user gifts another user a Tier 1 resubscription. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Tier 1 gift resubs.
    *              If FALSE, no kappagen will occur on T1 gift resubs.
    *              If Integer, the value is the minimum months required for a Tier 1 gift resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     bomb    A user gifts multiple Tier 1 subscriptions. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on any random gift.
    *              If FALSE, no kappagen will occur on giftbombs.
    *              If Integer, the value is the minimum gifts required for a gift bomb to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur on any random gift.
    *               If greater than 1, the number of gifted users in a Tier 1 giftbomb must be greater than or equal to
    *               this number to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   t2        Identical to t1, but for Tier 2 subscriptions.
    *
    *   t3        Identical to t1, but for Tier 3 subscriptions.
    *
    *   prime     Settings related to kappagens on an Amazon Prime subscribe event.
    *
    *    first    A user subscribes with Prime for the first time.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    resub    A user resubscribes with Prime. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Prime resubs.
    *              If FALSE, no kappagen will occur on Prime resubs.
    *              If Integer, the value is the minimum months required for a Prime resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  cheer      Settings related to kappagens on a cheer event.
    *
    *   useMsg    If TRUE, any emotes in cheer messages will also be included in the kappagen.
    *             If FALSE, any emotes in cheer messages will show up like normal emotes.
    *
    *   bits       Minimum number of bits for a kappagen. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all cheers.
    *              If FALSE, no kappagen will occur on cheers.
    *              If Integer, the value is the minimum bits required for a cheer to trigger a kappagen.
    *               If 0, no kappagen will occur on cheer.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-499' or '2500-4999', or an open-maximum range such as '7500+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  badge      Settings related to users earning bits badges.
    *             This section is more "fluid" than other sections.
    *             Each entry is a number representing a bits badge and a kappa boolean value.
    *             For example:
    *   '1'        If TRUE, a kappagen will occur when a user gets their 1 bit badge.
    *              If FALSE, no kappagen will occur for 1 bit badges.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *             If a user earns a bits badge for a number not listed in the array, the system will find the number
    *             which is closest to the badge, favoring the lower number in case of a tie.
    *             For example:
    *   '100': false
    *   '5000': true
    *              If a user earns their 1000 bits badge, no kappagen will occur because 1000 is closer to 100
    *              than 5000.
    *              If a user earns their 10000 bits badge, a kappagen will occur because 5000 is the closest
    *              listed number.
    *             Note: The numbers must be strings (in 'single quotes') to function properly.
    *
    *  hypetrain  Settings related to hype trains.
    *
    *   begin     A hype train begins in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   success   Minimum level for a kappagen on hype train completion. This value can be a boolean, integer, or
    *              array:
    *              If TRUE, a kappagen will occur on all hype train completions.
    *              If FALSE, no kappagen will occur on hype train completions.
    *              If Integer, the value is the minimum level required for a hype train to trigger a kappagen.
    *               If 0, no kappagen will occur on hype train success.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-5' or '6-10', or an open-maximum range such as '11+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  poll       Settings related to polls.
    *
    *   begin     A poll begins in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   end       A poll ends in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  prediction  Settings related to predictions.
    *
    *   begin     A prediction begins in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   resolved  A prediction ends in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  goal       Settings related to goals.
    *
    *   begin     A goal begins in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   achieved  A goal ends in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  charity    A charity donation is made in the channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  timeout    Minimum time for a kappagen when a user is timed out. This value can be a boolean, integer, or
    *              array:
    *              If TRUE, a kappagen will occur on all timeouts.
    *              If FALSE, no kappagen will occur on timeouts.
    *              If Integer, the value is the minimum seconds required for a timeout to trigger a kappagen.
    *               If 0, no kappagen will occur on timeouts.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '5-30' or '60-180', or an open-maximum range such as '300+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  ban        A user is banned in the channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  tip        Settings related to third-party tip systems.
    *
    *   useProfileImage  If TRUE, tips will use the tipper's profile image instead of emotes.
    *                   If FALSE, tips will use your standard kappagen emotes.
    *
    *   streamlabs  Settings related to Streamlabs payment events.
    *
    *    donation  Minimum tip amount through Streamlabs for a kappagen. This value can be a boolean, integer,
    *              or array:
    *              If TRUE, a kappagen will occur on all Streamlabs tips.
    *              If FALSE, no kappagen will occur on tips.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on tips through Streamlabs.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamlabs.curMul setting (see above)
    *              based on your default currency in Streamlabs.
    *
    *    pledge   Minimum pledge amount through Streamlabs for a kappagen. This value can be a boolean, integer,
    *             or array:
    *              If TRUE, a kappagen will occur on all Streamlabs pledges.
    *              If FALSE, no kappagen will occur on pledges.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on pledges through Streamlabs.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamlabs.curMul setting (see above)
    *              based on your default currency in Streamlabs.
    *
    *   streamelements  Minimum tip amount through StreamElements for a kappagen. This value can be a boolean,
    *                  integer, or array:
    *              If TRUE, a kappagen will occur on all StreamElements tips.
    *              If FALSE, no kappagen will occur on tips.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on tips through StreamElements.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamelements.curMul setting (see above)
    *              based on your default currency in StreamElements.
    *
    * commands    An array of commands which can trigger one or more kappagens, or clear the screen.
    *             Each command is an object with the following properties:
    *
    *  aliases    An array of kappa command aliases which can be used to force-trigger this kappagen.
    *
    *  access     A bitwise flag representing which users can trigger this kappagen with a command.
    *             This value will fall back to the general kappagen access value.
    *
    *  cooldown   The number of seconds between force-triggered kappagens using an above alias. Any commands sent before
    *             the cooldown will be ignored, unless the another command shares the same alias.
    *             This value is optional; no value is the same as a value of 0, which is, no cooldown.
    *
    *  redeem     An array of style-specific channel point reward names which can be used to force-trigger this kappagen.
    *
    *  erase      If this property exists, the command will erase the screen rather than showing a style. Any 'styles',
    *             'rave', 'raveon', or 'raveoff' properties will be ignored, regardless of the value of erase.
    *
    *  rave       If this property exists, the command will toggle the 'rave' hue rotation, if enabled, rather than
    *             showing a style. Any 'styles', 'raveon', or 'raveoff' properties will be ignored, regardless of the
    *             value of rave. If hue rotation is not set to 'rave', this command will do nothing.
    *
    *  raveon     If this property exists, the command will turn on the 'rave' hue rotation, if enabled, rather than
    *             showing a style. Any 'styles' or 'raveoff' properties will be ignored, regardless of the value of
    *             rave. If hue rotation is not set to 'rave', this command will do nothing.
    *
    *  raveoff    If this property exists, the command will turn off the 'rave' hue rotation, if enabled, rather than
    *             showing a style. Any 'styles' property will be ignored, regardless of the value of rave.  If hue
    *             rotation is not set to 'rave', this command will do nothing.
    *
    *  styles     A kappagen of one of the listed styles will occur upon command. This value can be a boolean or array.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    * ignore      Ignore Lists
    *
    *  users      Users who should be ignored.
    *              If FALSE, no users will be ignored.
    *              If an array of strings, these user names will not be able to make emotes show up.
    *
    *  emotes     Emotes which should be ignored.
    *              If FALSE, no emotes will be ignored.
    *              If an array of strings, these emotes will not show up.
    *               (You can also use \u{XXXXX} escape'd emojis)
    *
    *
    * Note on Event and Command Kappagen Entries
    * ------------------------------------------
    *
    * Keep in mind that kappagen arrays are also associative, and may have independent settings for kappas such as
    * TheCube and Text. The kappagen style can also contain the following values:
    *
    *  count      The number of emotes to show for this kappagen. This can be an integer or an object.
    *              If this property does not exist, it will fall back to the count setting for the kappagen style.
    *               If the kappagen style has no count property, then the global kappagen count will be used.
    *              If Integer, this is the number of emotes that will be shown in this kappagen.
    *              If Object:
    *
    *   default   The number of emotes to show for this kappagen by default. This must be an integer.
    *              If this property does not exist, it will fall back as the parent count would.
    *              If Integer, this is the number of emotes that will be shown in this kappagen.
    *
    *   dynamic   This is a boolean value to determine if the count can be changed by users.
    *              If this property does not exist, it will fall back to FALSE.
    *              If TRUE, a user may include a number in the command's parameters, and that number will be used.
    *              If FALSE, the default count will be used exclusively.
    *
    *   maximum   The maximum number of emotes to show for this kappagen if dynamic is set to TRUE. This must be
    *             an integer.
    *              If this property does not exist, it will fall back to the maximum number of emotes allowed on screen.
    *              If Integer, this is the maximum number of emotes this kappagen style can display.
    *
    * emotes      A list of emotes that will be used for this kappagen. This can be an array or an object.
    *              If Array, each entry must be a string containing the name or URL of an emote, or an emoji.
    *               Please note that only your channel or global emotes can be named (including 3rd-party).
    *              If object:
    *
    *  list       This must be an array of strings, the same as the Array entry of the parent emotes property above.
    *
    *  dynamic    This is a boolean value to determine if the displayed emotes can be set by the user.
    *              If this property does not exist, it will fall back to TRUE.
    *              If TRUE, a user may include emotes in the command's parameters, and those emotes will be used.
    *              If FALSE, only the emotes in the list property above will be used.
    *
    *
    * Additional Notes and Caveats
    * ============================
    *
    * Update Procedure
    * ----------------
    *
    *  To update this emote wall, simply use the Wizard to import and download it.
    *   1) Visit the official page <https://realityripple.com/Tools/Twitch/EmoteWall/>.
    *   2) Under "Config Wizard", click "Authorize on Twitch".
    *   3) Import this HTML file by clicking Import.
    *   4) Make any changes you need to make on each page.
    *   5) At the end of your configuration, hit "Download".
    *  You will receive a new version of this HTML file with your previous settings.
    *
    *
    * Emojis
    * ------
    *
    *  Twitch filters out the ZWJ (Zero-Width Joiner) character which is used for merging many emojis.
    *  This system makes use of basic character detection to correctly parse many standard ZWJ-style emojis even without
    *  the ZWJ character, however more complicated sets such as the "family units" are not possible to correctly handle.
    *  The alternative character 0xE0002 used by some third-party Twitch chat projects will be correctly parsed as a
    *  ZWJ according to the rules laid out in the RFC:
    *   <https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f>
    *
    *
    * Emote Dimensions
    * ----------------
    *
    *  Emotes that are not square will be shrunk to fit while maintaining the original aspect ratio.
    *
    *
    * Cheers
    * ------
    *
    *  The cheer style will be used for kappagens. If a user cheers 1000 bits in a single 1000 bit emote, then the
    *  kappagen will be made of the 1000-bit cheers. However, if the user cheers 1000 bits using multiple smaller cheer
    *  emotes, those emotes will be used for the kappagen instead.
    *
    *
    * Kappagen
    * --------
    *
    *  Each emote-splosion uses the number of emotes defined in the kappa count preference mentioned above, except
    *  Pyramid, which uses a constant number based on the pyramidDist array (below). If the trigger includes specific
    *  emotes (via kappagen, cheer, or resub message), the ratio of one emote to another will be maintained.
    *  If a user with kappa access posts "!kappagen PunchTrees PunchTrees SSSsss" then two thirds of the emotes in
    *  the emote-splosion will be "PunchTrees", and one third will be "SSSsss".
    *
    *
    * OBS
    * ---
    *
    *  This emote wall may do better if the browser source has a frame rate limit of 30 or 60.
    *  If you use your GPU while streaming, you may wish to disable Browser Source Hardware Acceleration.
    *  It may also work better using a smaller screen resolution (such as 720p on a 1080p screen) and then stretching
    *  the browser source to fit to the screen using the OBS Transform feature.
    *
    *
    * Inefficiencies
    * --------------
    *
    *  This emote wall uses normal <img> objects rather than a HTML Canvas. While this lowers efficiency, it also adds
    *  better GIF file support and allows easier user manipulation.
    *
    *  At present, the "zoom in" and "zoom out" feature uses a resource-heavy design. I had hoped the new CSS directive
    *  "scale: " would have helped, however it's useless without a "scale-origin" directive to accompany it.
    *
    *  The Bounce animation uses specific position-based drawing rather than actually being animated.
    *
    *  The Cube animation uses eight objects on screen for every image, making it a particularly resource-heavy drawing.
    *
    *  If your computer has trouble with this emote wall, please try disabling these options.
    *
    */

   /* jshint esversion: 11, bitwise: false, eqeqeq: true, loopfunc: true, forin: true, freeze: true, futurehostile: true, leanswitch: true, noarg: true, nocomma: true, nonbsp: true, nonew: true, noreturnawait: true, quotmark: single, shadow: outer, singleGroups: false, strict: global, trailingcomma: false, undef: true, unused: true, varstmt: true */

   var cfg = {
    channel: 'CHANNEL_NAME',
    login: {
     client: '4umzcpmjkg6ar78b81s7302jlj33t8',
     oauth_refresh: 'OAUTH_REFRESH',
     scope: [
      'chat:read',                 // required
    //'moderator:read:followers',  // optional. only required if you use follow events or access
    //'channel:read:redemptions',  // optional. only required if you use channel point redeem commands
    //'channel:read:hype_train',   // optional. only required if you use hype train events
    //'channel:read:goals',        // optional. only required if you use goal events
    //'channel:read:polls',        // optional. only required if you use poll events
    //'channel:read:predictions',  // optional. only required if you use prediction events
    //'channel:read:charity',      // optional. only required if you use Twitch charity events
    //'moderator:read:shoutouts'   // optional. only required if you use shoutout events
     ],
     share: false
    },
    streamlabs: {
     token: 'SOCKET_TOKEN', //Requires socket.token
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    streamelements: {
     oauth_refresh: 'OAUTH_REFRESH', //Requires tips:read
     token: 'JWT_TOKEN',
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    display: {
     styles: [
    //'Still',        // No movement
      'StraightLine', // Gentle movement in a random straight line
      'Rise',         // Slowly rise to top while wobbling back and forth
      'Bounce',       // Fall from the top at an angle and bounce along the bottom (Windows Solitaire style)
      'Speed',        // Zoom across the screen
      'Drop',         // Get stuck at the top and tumble down (no fade/zoom in, only out)
      'Crazy',        // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
      'Confetti',     // Fall like confetti                   (no zoom, no fade in, only fade out)
      'Throw',        // Toss at the middle and tumble down   (no fade/zoom in, only out)
      'TheCube'       // Rotate a 3D cube of an emote         (no zoom, only fade)
     ],
     access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x004 | 0x002 | 0x001,
     duplicates: true,
     useEmoji: true,
     extended: {
      useFFZ: true,
      useBTTV: true,
      use7TV: true,
      useZWE: true,
      fillZWE: false
     },
     hue: false,
     kappa: {
      count: 150,
      styles: {
       'Rise': {},        // Slowly rise to top while wobbling back and forth
       'Speed': {},       // Zoom across the screen
       'Crazy': {},       // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
       'Burst': {},       // Expand from a center point
       'Fireworks': {},   // Burst out from a single emote (no fade/zoom; small emotes)
       'Spiral': {},      // Burst out from a single emote in a spiral (no fade/zoom; small emotes)
       'Pyramid': {},     // Build a pyramid        (no fade/zoom; specific-size emotes)
       'SmallPyramid': {},// Build a small pyramid  (no fade/zoom; small emotes)
       'Fountain': {},    // Spout from a fountain  (no fade/zoom)
       'Stampede': {},    // Stampede of emotes     (no fade/zoom)
       'Confetti': {},    // Fall like confetti     (no zoom, no fade in, only fade out; small emotes)
       'Conga': {},       // Start a conga line     (no fade/zoom)
       'TheCube': {       // Rotate a 3D cube of an emote (no zoom, only fade)
        size: 8/10,
        center: true,
        rotations: 5
       },
       'Text': {          // Show a message         (no fade/zoom; specific-size emotes)
        message: ['HYPE!'],
        time: 3
       }
      },
      access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x004 | 0x002,
      aliases: [      // !kappagen command aliases (must be lower-case)
       '!kappagen',
       '-kappagen'
      ],
      cooldown: 0,
      conga: {
       contagious: false,
       time: 5,
       avoidMiddle: false
      }
     }
    },
    emote: {
     time: 5,
     max: 0,
     queue: 0,
     size: {
      ratio: {
       normal: 1/12,
       small: 1/24
      },
      min: 16,
      max: 256,
      variation: false
     },
     cube: {
      rotations: 5
     },
     in: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     },
     out: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     }
    },
    event: {
     clear: true,
     raid: {
      raiders: 2,
      originEmotes: true,
      originExtendedEmotes: false
     },
     follow: true,
     shoutout: {
      create: {
       styles: false,
       targetEmotes: true,
       targetExtendedEmotes: false
      },
      receive: {
       styles: false,
       originEmotes: true,
       originExtendedEmotes: false
      }
     },
     tag: {
      styles: true,
      access: -1,
      targetEmotes: true,
      targetExtendedEmotes: false
     },
     sub: {
      useMsg: true,
      t1: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      t2: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      t3: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      prime: {
       first: true,
       resub: true
      }
     },
     cheer: {
      useMsg: true,
      bits: 50
     },
     badge: {
      '1': false,
      '100': true
     },
     hypetrain: {
      begin: false,
      success: false
     },
     poll: {
      begin: false,
      end: false
     },
     prediction: {
      begin: false,
      resolved: false
     },
     goal: {
      begin: false,
      achieved: false
     },
     charity: false,
     timeout: false,
     ban: false,
     tip: {
      useProfileImage: false,
      streamlabs: {
       donation: false,
       pledge: false
      },
      streamelements: false
     }
    },
    commands: [],
    ignore: {
     users: false,
     emotes: false
    }
   };

   /* fractions (or decimal percentages) of the emote time configuration value */

   const timing = {
    display: {
     'Still': {
      time: 1
     },
     'StraightLine': {
      time: 1
     },
     'Rise': {
      origin: {      /* percentages of the screen height */
       min: 0.8,
       max: 1.1
      },
      time: 1,
      wiggle: {      /* percentages of the above time percentage */
       delay: {
        min: 0,
        max: 3/25
       },
       min: 2/5,
       max: 1
      }
     },
     'Bounce': {
      origin: {      /* percentages of the screen height */
       min: 0,
       max: 0.2
      },
      time: 1,
      velocity: {    /* pixels per 300th of display time */
       h: {
        min: 3,
        max: 9
       },
       v: {
        min: 4,
        max: 7
       },
       loss: 0.3     /* velocity percentage lost per bounce */
      },
      gravity: 1     /* pixels added to vertical velocity per increment */
     },
     'Speed': {
      origin: {      /* percentages of the screen height */
       min: 0.3,
       max: 0.7
      },
      time: 1,
      delay: 0.1
     },
     'Drop': {
      time: 1
     },
     'Crazy': {
      time: 1,
      distance: 7000,  /* max pixels to travel */
      squash: {
       width: 2,     /* squashed wide dimension */
       height: 0.7,  /* squashed tall dimension */
       time: 1/50
      }
     },
     'Confetti': {
      time: 1
     },
     'Throw': {
      time: 1,
      twist: 7/50,
      toss: 1/5,
      drop: 4/5,
      dest: {
       h: {          /* percentages of the screen width */
        min: 0.3,
        max: 0.7
       },
       v: {          /* percentages of the screen height */
        min: 0.3,
        max: 0.7
       }
      }
     },
     'TheCube': {
      time: 1
     },
     'Fountain': {
      time: 1/2,
     }
    },
    kappa: {
     'Rise': {
      time: 2
     },
     'Speed': {
      time: 2
     },
     'Crazy': {
      time: 2
     },
     'Burst': {
      time: 1.5,
      top: {         /* top and bottom margin of the origin point */
       min: 1/4,
       max: 3/4
      },             /* left and right margin of the origin point */
      left: {
       min: 1/4,
       max: 3/4
      }
     },
     'Fireworks': {
      time: 1,
      origin: {      /* origin point(s) of the firework's rocket */
       x: [1/2],
       y: [1]
      },
      dest: {        /* destination point(s) of the firework's rocket */
       x: [1/4, 1/2, 3/4],
       y: [1/3]
      },
      speed: {
       rocket: 2/5,  /* speed of rocket */
       burst: 1/50   /* speed of initial burst */
      },
      quantity: {    /* number of emotes per burst */
       small: 1/8,
       medium: 3/4,
       large: 1/8
      },
      radius: {      /* firework burst radii */
       base: 2/3,    /* screen's smaller dimension */
       small: 1/3,
       medium: 2/3,
       large: 1
      },
      spread: 12,    /* how much more frequently to pause during medium burst */
      delays: {      /* pause between bursts */
       small: 2/25,
       large: 1/10
      }
     },
     'Spiral': {
      time: 1,
      bulk: 8,       /* max number of emotes to send in bulk (>1 can end up looking chunked) */
      vectors: {     /* number of emote vectors per circle */
       min: 40,
       max: 60
      }
     },
     'Pyramid': {
      time: 1,
      show: {
       total: 0.8,   /* percentage of time to spend showing the pyramid */
       min: 75       /* minimum animation speed per block (in ms) */
      },
      pause: 0.2,
      hide: 0.01
     },
     'SmallPyramid': {
      time: 1,
      show: {
       total: 0.8,   /* percentage of time to spend showing the pyramid */
       min: 100      /* minimum animation speed per block (in ms) */
      },
      pause: 0.2,
      hide: 0.01
     },
     'Fountain': {
      time: 1.5,
      top: {         /* peak of the fountain, as a percent of the screen height */
       min: 3/20,
       max: 2/5
      },             /* left and right margin of the origin point */
      left: {
       min: 1/3,
       max: 2/3
      }
     },
     'Stampede': {
      time: 1,
      speed: 2/5,     /* travel time across the screen for each emote */
      maxdensity: 6,  /* maximum emotes to show at once */
      top: {
       min: 0.5,      /* top of stampede relative to top of screen, in emote heights */
       max: 0.5       /* bottom of stampede relative to bottom of screen, in emote heights */
      },
      height: 3,      /* height of stampede in emote heights */
      bunch: {
       '1': {
        min: 1,
        max: 5
       },
       '2': 8,        /* this number minus the value of 1 */
       '4': {
        min: 0,
        max: 3
       }
      },
      pause: {
       '1': 4/5,
       '2': 2/5
      },
      smallSleep: {
       min: 90,
       max: 100
      }
     },
     'Confetti': {
      time: 1
     },
     'Conga': {
      time: {
       show: 2,
       hide: 2
      },
      size: 5/3,      /* height of animation space for row in emote heights */
      height: 5/6,    /* height of each row of dancers in emote heights (padding) */
      avoidMiddle: 6  /* rows to use when avoiding the middle (half top, half bottom; please use even numbers) */
     },
     'TheCube': {
      time: 1
     },
     'Text': {
      time: 1,
      show: {
       total: 0.8,   /* percentage of time to spend showing the pyramid */
       min: 75       /* minimum animation speed per block (in ms) */
      },
      hide: 0.01
     }
    }
   };

   /* potentially alterable arrays */

   // list of default images to use if your channel has no emotes
   const bareList = [
    {url: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAHv0lEQVRIx52Xa6xdRRXHf2vN7L3Puff29ra37yfQaCPGkPIwoCLVhEQEDaCngaAGo8FErZCI1gTweD6QKIiBEkyKhoBSwXtDwEaKhkQKJmKLgIRCebbIoy19nnse9+zHPPzQNBSwIbjm02Stmd9kzays/wjHsQgiEO+84YoVRcyWTHUPLo7en7Hn9d033Lzx73tiRESIfEjT4zkmGw0F6HTanyh7B7dU/emNVsJVs+bOu/eW5mWja9Y0tNlsagT5MED5AF9srv3CaNUfXOyD+eycRfO/MWfuAtPrTl+79qcbrj8a2Gw2FbYorA6tViv8v0AAaTabptVquesuP/2MkdkLtg7NXhBdOXi12L39osolnVQXtdfdsan7DhyFJscDHw8oExMNXbNm0h+dX3vpqptr1v/A1lI/OjZmYrRtlZpIUj8coj5RVINHyqr/t3W3/PVFgEajYSYmJ4Pw7nt+H7DZbOrR023YsCEx+5+6rMx738q7Bz4diq6kSUY2YzyabEQEQQVwJSE6Bnk5IPjNkNz4/Zvu2/re/d4HPOpsNpvp4uzgV9T7q+qZ/WReDBj0exByYvCEqkAkRqInEWJEYlSDijEKDArnPOY2V0+vW3fjpu6xUHkvbP013z7RSnF3lphPeVeSD6ZDWQwioTTiSkIxQDRijCAmJbGGrJYRAkznVQw+hBiCSW2Kk/RpOzr7krU//+NLR/eXd14ZzMkOzDKDzqM18R+f6rS9K3MJZaExBvAFKhCrkqRex0gkhIhNE9IsJQbPdKdHnjti8DFGfH1k1Gpt1i4dqp975S8feLXZbKoAxGZTpdUK6398ye+GEv/1TrdbRV8mrsiJVUHwnsREgnfEqkSzYWr1FOcqVBQ1hhADMrScUJ9HXnm06BP6b7skdq1kM5+gPvOczuhkIRONhlkzOelvW3f5l6Kb2pRPt31wTkNVSAweO3M5YXgJQRLU9Um6O/G93ST1YQieGCMiEbPkcwxGV1J5jw+RsshJ80PY/U+7WjhsQ33mD6++7aFfydFaG+88uw0/WDXdPeQlOCOSYJaeTTW0hLRWx3tP5Rwz6inujX/C1AvYJCV4j5m9gmL8TLpFiarBZgndTg8rih56JWbt5zCm3Lv0rHNWKRAXFS+vTjSsKnpTIVbO4D31E84mH17KvLkZr778DK+99gpWhW4/p5x1CmZ0OWmWktWGiPVllN5TGxqiDCV/uHMD9917B/94/BGKoXniagshxIWHdz5/lgK4qrzQ+AJX5pEqx44s5LCO85cH72Fy8m42P/Qn7r9/I/9+5kmSJGVs3nx05knYbBg1lsGgwBrlwP79PLjpPt54fSeHD+3n8cce5l9PPYEdWxSNSaj6vfMVILr8hKoYQAhI8ITaHJ58eht552127XoTH47Uz7ZtjzHVbVNVJWXMqFwgEul326hJeev1nex88XlUFR8CWVbjhR3b6RVObGKJMZ6hExPNNPq4ILoSE5wokW63x7639+Ax1LIUawVjDVVZ0p1qUwwGFNN9Ovvfoju1j+rQfyA4EqOIRIL3BOfwztHvdfFugOIBRrX/XHtIcKORgEhEgkPKNmoMg8LRy3NAjgwxZFl2pBH295J3DpBP96kO7KDzxvOsWLGS8bExfDiSEmst8+YvoB7auGIKCRQ6zNi0TbSfWINai1dDVh5gzoyMaFJUDd57ut0OH/3IShYvWkwYdHDt7ZAIqGNoCDrPbSarpjjv/Is56cQTmTtvPguXLef0lQuYUe6KagRR7QjA7T+6cJN17Qum2p1QDXLjfUFX5/DkoWH27DtACBXLlp7E6tXnYQn0Xvoz9HagmqAGEEsxqJguhBlLzySPNQ4c3EtNpliYTmHwYWR4ljozdLsA/HbdV9da311/uH3QV4PChBjwxTSuvoCpZCn1WUsZHx+nnNpLvnsr6vZiswwJDrUGxEBUnHPk/QKT1KgN10mtx1cOIY1JUkeTkfME4NfNi+ZxqLMjuulZea8fXai0Kkq8c2AMPiZ4PInkpImgWR2xigaPGIMYS3AeNQbBEqNDjYVoCJXzNZsap7WttfCxs3Wi0TDfbd2/z1X+plqSCqJBRTFqscagGkniNMOppz5Ux6Y1VARrDUYVjWCNYo2gRlAFq4qiiA+RKsYYFbG11nduv72SCPKzZlN4bUs6XgsPJ7H8TK/XcYhYV5SgEQFEFbGgakBBU4uEAD5gspToPRgDGHAeURt8XvnMDiXTpvaLq3/z6E8ajYbRoxKgddejeWHs14pod9VrIxaxTkwSBIOogSgQDTFAqCAWgRjAOwiVJ4RIqAKUPgQnXoLRWjqcDKjfs+zc713TbKKTRyTHuxvw9d/8/MnDkv9ecae6qqIoyigaQqyCSGJEjYD3ICAWYhmipvZIGkLURFNRW6fw+mYgual/wpb1rZbEeKTbx/dIDLTVIjQvOG1odIxLQ2Stip5iTcSVBa7yaGII3kMI2FSJHowx2EQpKsGRbMekGwc6887WXZv3His5jyOijkABmo1zRkbq8YsR/+UY3Mm+KBcgMiwabXAxGkMeQjwUot1rUvNsCMkDI3NPfezKW28tAI722g+UiRFkstHQY4OvuOK0ZFl/zpxAOWqMZD4vRGxou2rJwdbkZO/Y9RONhmlMTIb/9RX4Ly/EQPT2tQstAAAAAElFTkSuQmCC'}
   ];

   // distribution of emotes for Pyramid and SmallPyramid kappagen
   const pyramidDist = [1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1];

   // treat these BTTV emotes as zero-width (overlapping) emotes
   const bttvZWE = [
    '567b5b520e984428652809b6', //SoSnowy
    '5849c9a4f52be01a7ee5f79d', //IceCold
    '58487cc6f52be01a7ee5f205', //SantaHat
    '5849c9c8f52be01a7ee5f79e', //TopHat
    '567b5dc00e984428652809bd', //ReinDeer
    '567b5c080e984428652809ba', //CandyCane
    '5e76d399d6581c3724c0f0b8', //cvMask
    '5e76d338d6581c3724c0f0b2'  //cvHazmat
   ];

   // distribution of emotes for letters in message kappagens
   const alnumDist = {
    'A': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'a': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'B': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    'b': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'C': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0]
    ],
    'c': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'D': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'd': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'E': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'e': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'F': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'f': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    'G': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 1, 0, 0]
    ],
    'g': [
     [1, 0, 0, 1, 1, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'H': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'h': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0]
    ],
    'I': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'i': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'J': [
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'j': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0]
    ],
    'K': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'k': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'L': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'l': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'M': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'm': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'N': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'n': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'O': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'o': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'P': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    'p': [
     [1, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 1, 0, 0, 0, 0]
    ],
    'Q': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [1, 1, 0, 1, 1, 1, 1, 0, 0]
    ],
    'q': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'R': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 1, 0, 0]
    ],
    'r': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'S': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    's': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    'T': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    't': [
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0]
    ],
    'U': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'u': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'V': [
     [0, 0, 0, 0, 1, 1, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 1, 1, 0]
    ],
    'v': [
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0]
    ],
    'W': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'w': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 0, 0, 0]
    ],
    'X': [
     [0, 1, 1, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 0, 1, 1, 0]
    ],
    'x': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'Y': [
     [0, 0, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    'y': [
     [1, 0, 0, 1, 1, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'Z': [
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0]
    ],
    'z': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '1': [
     [0, 1, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '2': [
     [0, 1, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '3': [
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '4': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0]
    ],
    '5': [
     [0, 0, 1, 0, 0, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 0, 1, 0]
    ],
    '6': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0]
    ],
    '7': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    '8': [
     [0, 0, 1, 1, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '9': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 1, 1, 0, 0]
    ],
    '0': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    ':': [
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    '.': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    ',': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '\'': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 1]
    ],
    '-': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '_': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '+': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '=': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0]
    ],
    '!': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    '@': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 1, 1, 0, 0]
    ],
    '#': [
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    '$': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [1, 1, 1, 1, 1, 1, 1, 1, 1],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    '\u00a2': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '\u20ac': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    '\u00a3': [
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '\u00a5': [
     [0, 0, 0, 0, 1, 0, 1, 1, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 1, 0]
    ],
    '%': [
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0]
    ],
    '?': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ]
   };

   //////////////////////////////////////////////////////////////////////////////
   // don't mess with things below this line without knowing what you're doing //
   //////////////////////////////////////////////////////////////////////////////

   let cList = [];
   let cSafe = [];
   const wWS = 5;
   const oauthClient = '4umzcpmjkg6ar78b81s7302jlj33t8';
   const cURLs = {
    ws: {
     twitch: {
      irc: 'wss://irc-ws.chat.twitch.tv',
      eventSub: 'wss://eventsub.wss.twitch.tv/ws'
     },
     streamlabs: 'wss://sockets.streamlabs.com/socket.io/?transport=websocket&token=%TOKEN%',
     streamelements: 'wss://realtime.streamelements.com/socket.io/?transport=websocket',
     bttv: 'wss://sockets.betterttv.net/ws',
     '7tv': 'wss://events.7tv.io/v3'
    },
    api: {
     twitch: {
      users: {
       name: 'https://api.twitch.tv/helix/users?login=%USER%',
       id: 'https://api.twitch.tv/helix/users?id=%USER_ID%',
      },
      bits: {
       cheermotes: 'https://api.twitch.tv/helix/bits/cheermotes?broadcaster_id=%CHANNEL_ID%'
      },
      channels: {
       root: 'https://api.twitch.tv/helix/channels?broadcaster_id=%CHANNEL_ID%',
       followers: 'https://api.twitch.tv/helix/channels/followers?user_id=%USER_ID%&broadcaster_id=%CHANNEL_ID%'
      },
      chat: {
       emotes: {
        root: 'https://api.twitch.tv/helix/chat/emotes?broadcaster_id=%CHANNEL_ID%',
        global: 'https://api.twitch.tv/helix/chat/emotes/global'
       }
      },
      eventSub: {
       get: 'https://api.twitch.tv/helix/eventsub/subscriptions',
       delete: 'https://api.twitch.tv/helix/eventsub/subscriptions?id=%ID%'
      }
     },
     ffz: {
      set: {
       global: 'https://api.frankerfacez.com/v1/set/global'
      },
      room: 'https://api.frankerfacez.com/v1/room/id/%CHANNEL_ID%'
     },
     bttv: {
      emotes: {
       global: 'https://api.betterttv.net/3/cached/emotes/global'
      },
      users: {
       twitch: 'https://api.betterttv.net/3/cached/users/twitch/%CHANNEL_ID%'
      }
     },
     '7tv': {
      emotes: {
       global: 'https://7tv.io/v3/emote-sets/global'
      },
      users: {
       root: 'https://7tv.io/v3/users/twitch/%CHANNEL_ID%'
      }
     },
     rr: {
      refresh: {
       t: 'https://realityripple.com/Tools/Twitch/EmoteWall/oauth2t.php',
       se: 'https://realityripple.com/Tools/Twitch/EmoteWall/oauth2se.php'
      },
      feedback: {
       eventsub: 'https://realityripple.com/Tools/Twitch/EmoteWall/dangling-eventsub.php'
      }
     }
    },
    cdn: {
     twitch: {
      emote: 'https://static-cdn.jtvnw.net/emoticons/v2/%EMOTE_ID%/default/dark/3.0'
     },
     ffz: {
      emoji: 'https://cdn.frankerfacez.com/static/emoji/images/%SET_ID%/'
     },
     bttv: {
      emote: 'https://cdn.betterttv.net/emote/%EMOTE_ID%/3x'
     },
     crew: 'https://uploads.realityripple.com/Pictures/crew/%DIRECTION%/%COLOR%.png'
    },
    html: {
     rr: {
      auth: 'https://realityripple.com/Tools/Twitch/EmoteWall/twitch.php',
      redir: 'https://realityripple.com/Tools/Twitch/tempRedir.php'
     },
     twitch: 'https://id.twitch.tv/oauth2/authorize?client_id=%CLIENT_ID%&redirect_uri=%URL%&response_type=code&scope=%SCOPE%&state=redirto_%ORIGIN%&force_verify=true'
    }
   };

   const notice = function()
   {
    const _visTime = 5000;
    const _errTime = 15000;
    let _states = {};
    let _timers = {};

    function $info(i)
    {
     if (_states.hasOwnProperty(i) && _states[i] === 'i')
      return;
     _states[i] = 'i';
     if (!_timers.hasOwnProperty(i))
      _timers[i] = false;
     _buildNotices();
     switch (i)
     {
      case 0x12:
       _setNotice(i, 'noticeInfo sTwitch', 'IRC Connected', 5);
       break;
      case 0x1A:
       _setNotice(i, 'noticeInfo sTwitch', 'EventSub Connected', 5);
       break;
      case 0x72:
       _setNotice(i, 'noticeInfo tStreamElements', 'Connected', 5);
       break;
      case 0x82:
       _setNotice(i, 'noticeInfo tStreamlabs', 'Connected', 5);
       break;
      case 0xB2:
       _setNotice(i, 'noticeInfo eBTTV', 'Connected', 5);
       break;
      case 0xC2:
       _setNotice(i, 'noticeInfo e7TV', 'Connected', 5);
       break;
     }
    }

    function $warning(w)
    {
     if (_states.hasOwnProperty(w) && _states[w] === 'w')
      return;
     _states[w] = 'w';
     if (!_timers.hasOwnProperty(w))
      _timers[w] = false;
     _buildNotices();
     switch (w)
     {
      case 0x1A:
       _setNotice(w, 'noticeWarning sTwitch', 'Too Many Instances<br>Please use existing (reference) copies wherever possible.', 20);
       break;
     }
    }

    function $error(e)
    {
     if (_states.hasOwnProperty(e) && _states[e] === 'e')
      return;
     _states[e] = 'e';
     if (!_timers.hasOwnProperty(e))
      _timers[e] = false;
     _buildNotices();
     switch (e)
     {
      case 0x01:
       _setNotice(e, 'noticeError global', 'Corrupted Configuration');
       break;
      case 0x09:
       _setNotice(e, 'noticeError global', 'OBS Not Detected<br>Please see <a href="https://www.twitch.tv/videos/1784099954" target="_blank" title="Adding Emote Wall to OBS">this &quot;How to&quot; video</a> on adding the Emote Wall to OBS.');
       break;
      case 0x11:
       if (typeof login !== 'undefined' && login.inUse)
       {
        _setNotice(e, 'noticeError sTwitch', 'OAuth Token Rejected<br>Please click &quot;Re-Auth&quot; to get a new Token.');
        login.showOut(true);
        window.setTimeout(function(){login.showIn();}, 15500);
       }
       else
        _setNotice(e, 'noticeError sTwitch', 'OAuth Token Rejected<br>Please update your OAuth Refresh token.');
       break;
      case 0x12:
       _setNotice(e, 'noticeError sTwitch', 'IRC Disconnected');
       break;
      case 0x1A:
       _setNotice(e, 'noticeError sTwitch', 'EventSub Disconnected');
       break;
      case 0x71:
       _setNotice(e, 'noticeError tStreamElements', 'OAuth Token Rejected<br>Please update your StreamElements OAuth Token.');
       break;
      case 0x72:
       _setNotice(e, 'noticeError tStreamElements', 'Disconnected');
       break;
      case 0x81:
       _setNotice(e, 'noticeError tStreamlabs', 'Socket Token Rejected<br>Please update your StreamLabs Socket Token.');
       break;
      case 0x82:
       _setNotice(e, 'noticeError tStreamlabs', 'Disconnected');
       break;
      case 0xB2:
       _setNotice(e, 'noticeError eBTTV', 'Disconnected');
       break;
      case 0xC2:
       _setNotice(e, 'noticeError e7TV', 'Disconnected');
       break;
     }
    }

    function _buildNotices()
    {
     if (document.getElementById('notices'))
      return;
     let n = document.createElement('div');
     n.setAttribute('id', 'notices');
     let b = document.createElement('div');
     b.setAttribute('id', 'badge');
     b.dataset.alerts = 0;
     b.innerHTML = b.dataset.alerts;
     n.appendChild(b);
     document.body.prepend(n);
    }

    function _setNotice(id, state, msg, t = 0)
    {
     let n = document.getElementById('notices');
     if (!n)
      return;
     let b = document.getElementById('badge');
     if (!b)
      return;
     b.classList.remove('fade');
     let hasFader = false;
     const lines = n.getElementsByClassName('noticeLine');
     for (let i = 0; i < lines.length; i++)
     {
      if (!lines[i].classList.contains('fader'))
      {
       hasFader = true;
       break;
      }
     }
     if (!hasFader)
      b.classList.remove('fader');
     let nID = document.getElementById('notice' + id);
     if (!nID)
     {
      b.dataset.alerts++;
      b.innerHTML = b.dataset.alerts;
      nID = document.createElement('div');
      nID.setAttribute('id', 'notice' + id);
      n.appendChild(nID);
     }
     nID.setAttribute('class', 'noticeLine ' + state);
     nID.innerHTML = msg;
     if (t > 0)
     {
      document.removeEventListener('mousemove', _triggerFadeInNotice(id));
      if (_timers[id] !== false)
       window.clearTimeout(_timers[id]);
      _timers[id] = window.setTimeout(_clearNoticeBegin, t * 1000, id);
     }
     else
     {
      if (_timers[id] !== false)
       window.clearTimeout(_timers[id]);
      _timers[id] = window.setTimeout(_hideNotice, _errTime, id);
     }
    }

    function _clearNoticeBegin(id)
    {
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     nID.classList.add('hide');
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     _timers[id] = window.setTimeout(_clearNoticeEnd, 300, id);
    }

    function _clearNoticeEnd(id)
    {
     if (_timers[id] !== false)
     {
      window.clearTimeout(_timers[id]);
      _timers[id] = false;
     }
     let n = document.getElementById('notices');
     if (!n)
      return;
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     n.removeChild(nID);
     let b = document.getElementById('badge');
     if (!b)
      return;
     b.dataset.alerts--;
     b.innerHTML = b.dataset.alerts;
    }

    function _hideNotice(id)
    {
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     nID.classList.add('fader');
     nID.classList.add('fade');
     document.addEventListener('mousemove', _triggerFadeInNotice(id));
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     _timers[id] = window.setTimeout(_fadeOutEnd, 500, id);
     let n = document.getElementById('notices');
     if (!n)
      return;
     let hasVis = false;
     const lines = n.getElementsByClassName('noticeLine');
     for (let i = 0; i < lines.length; i++)
     {
      if (!lines[i].classList.contains('fade'))
      {
       hasVis = true;
       break;
      }
     }
     if (!hasVis)
     {
      let b = document.getElementById('badge');
      if (!b)
       return;
      b.classList.add('fader');
      b.classList.add('fade');
     }
    }

    const _triggerFadeInNotice = function(id)
    {
     return function()
     {
      _fadeInNotice(id);
     };
    };

    function _fadeInNotice(id)
    {
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     nID.classList.remove('faded');
     nID.classList.remove('fade');
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     if (!nID.classList.contains('fader'))
      return;
     _timers[id] = window.setTimeout(_fadeOutNotice, _visTime, id);
     let b = document.getElementById('badge');
     if (!b)
      return;
     b.classList.remove('fade');
    }

    function _fadeOutNotice(id)
    {
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     if (_timers[id] !== false)
      window.clearTimeout(_timers[id]);
     if (!nID.classList.contains('fader'))
      return;
     _timers[id] = window.setTimeout(_fadeOutEnd, 500, id);
     nID.classList.add('fade');
     let n = document.getElementById('notices');
     if (!n)
      return;
     let hasVis = false;
     const lines = n.getElementsByClassName('noticeLine');
     for (let i = 0; i < lines.length; i++)
     {
      if (!lines[i].classList.contains('fade'))
      {
       hasVis = true;
       break;
      }
     }
     if (!hasVis)
     {
      let b = document.getElementById('badge');
      if (!b)
       return;
      b.classList.add('fade');
     }
    }

    function _fadeOutEnd(id)
    {
     let nID = document.getElementById('notice' + id);
     if (!nID)
      return;
     if (_timers[id] !== false)
     {
      window.clearTimeout(_timers[id]);
      _timers[id] = false;
     }
     if (!nID.classList.contains('fader'))
      return;
     nID.classList.add('faded');
    }

    return {
     info: $info,
     warning: $warning,
     error: $error
    };
   }();

   if (typeof cfg === 'undefined')
   {
    document.title = 'Emote Wall Configuration Error';
    window.addEventListener('load', function(){notice.error(0x01);});
    throw new Error('Corrupted Configuration detected.');
   }
   document.title = 'RealityRipple\'s Home-Made Emote Wall';

   const display = function()
   {
    let _eActive = 0;
    let _iTitanic = 0;
    const _cRadius = Math.PI * 2;
    const _tAnim = {
     fade: {
      in: 8,
      out: 8
     },
     zoom: {
      in: 17,
      out: 8
     }
    };

    const $emote = function()
    {
     let _toShow = [];

     let _tEmote = false;

     const $list = function()
     {
      function $Still(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const h = shared.rnd(sW - eW);
       const v = shared.rnd(sH - eH);
       let s = 'top: ' + v + 'px;';
       s += ' left: ' + h + 'px;';
       s += ' --emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Still.time);
       s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s}, false, {space: false, time: tMS});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s}, false, {space: false, time: tMS});
        }
       }
      }

      function $StraightLine(eInf, sW, sH, eH, x = false, y = false, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eHh = Math.ceil(eH / 2);
       const eWh = Math.ceil(eW / 2);
       let h = x;
       if (h === false)
        h = shared.rnd(sW) - eWh;
       let v = y;
       if (v === false)
        v = shared.rnd(sH) - eHh;
       const r = Math.min(sW, sH) * (shared.rnd() + 1);
       let th = shared.rnd() * _cRadius;
       if (!x && !y)
       {
        const nH = eH * -1;
        const nW = eW * -1;
        while (!_safePoints(h, v, th, r, nW, nH, sW, sH))
        {
         th = shared.rnd() * _cRadius;
        }
       }
       let hD = Math.floor(h + r * Math.cos(th));
       let vD = Math.floor(v + r * Math.sin(th));
       let s = '--emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.StraightLine.time);
       s += ' transform: translate(' + h + 'px, ' + v + 'px);';
       s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s, classes: ['etStraightLine']}, false, {time: tMS}, {x: hD, y: vD});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s, classes: ['etStraightLine']}, false, {time: tMS}, {x: hD, y: vD});
        }
       }
      }

      function $Rise(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const h = shared.rnd(sW) - eWh;
       const v = Math.floor(sH * _rndFromRange(timing.display.Rise.origin));
       let s = 'left: ' + h + 'px;';
       s += ' --emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       if (cfg.emote.out.fade || cfg.emote.out.zoom)
        s += ' offset-path: path("M 0 ' + v + ' L 0 ' + Math.floor(v * 0.05) + '") ;';
       else
        s += ' offset-path: path("M 0 ' + v + ' L 0 -' + eH + '") ;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       if (shared.rnd(2) === 0)
        aNames.push('wiggleL');
       else
        aNames.push('wiggleR');
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Rise.time);
       const d = Math.floor(tMS * _rndFromRange(timing.display.Rise.wiggle.delay));
       aDelays.push(d + 'ms');
       const w = Math.floor(tMS * _rndFromRange(timing.display.Rise.wiggle));
       aDurs.push(w + 'ms');
       aTimings.push('ease-in-out');
       aFills.push('both');
       aIters.push('infinite');
       aNames.push('offsetPath');
       aDelays.push('0s');
       aDurs.push(tMS + 'ms');
       aTimings.push('linear');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s}, false, {space: false, time: tMS});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s}, false, {space: false, time: tMS});
        }
       }
      }

      const $Bounce = function()
      {
       function task(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         eH = Math.ceil(eH / 2);
        else if (variationSize === 2)
         eH = eH * 2;
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const eWh = Math.ceil(eW / 2);
        const sWm = Math.ceil(sW / 2);
        const h = Math.floor(shared.rnd(sW) - eWh);
        const v = Math.floor(sH * _rndFromRange(timing.display.Bounce.origin));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Bounce.time);
        const vMS = (tMS / 300 / (16 + 2 / 3));
        let velH = _rndFromRange(timing.display.Bounce.velocity.h);
        const velV = _rndFromRange(timing.display.Bounce.velocity.v);
        if (h + eWh > sWm)
         velH = -1 * velH;
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        let bX = h;
        let bY = v;
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, eInf.url, variationSize, {style: s}, true, {time: tMS}));
        if (eInf.hasOwnProperty('zwe'))
        {
         for (let i = 0, l = eInf.zwe.length; i < l; i++)
         {
          iArr.push(_addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s}, true, {time: tMS}));
         }
        }
        window.requestAnimationFrame(function(ts){_tLoop(tInit, iArr, bX, bY, velH, velV, vMS, sH, eH, ts, ts);});
       }

       function _tLoop(tInit, iArr, bX, bY, velH, velV, vMS, sH, eH, myT, ts)
       {
        if (_iTitanic > tInit)
         return;
        if (iArr[0].parentElement === null)
         return;
        let steps = 1;
        if (myT === 0)
         myT = ts;
        else
        {
         steps = Math.max(1, Math.floor((ts - myT) / 16));
         myT = ts;
        }
        for (let i = 0; i < steps; i++)
        {
         bX += velH / vMS;
         bY += velV / vMS;
         velV += timing.display.Bounce.gravity / vMS;
         const sB = sH - eH;
         if (bY >= sB)
         {
          bY = sB;
          velV *= -1 * (1 - timing.display.Bounce.velocity.loss);
          velV = Math.floor(velV);
         }
        }
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].style.transform = 'translate(' + bX + 'px, ' + bY + 'px)';
        }
        window.requestAnimationFrame(function(fTS){_tLoop(tInit, iArr, bX, bY, velH, velV, vMS, sH, eH, myT, fTS);});
       }

       return task;
      }();

      function $Speed(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const sWm = Math.ceil(sW / 2);
       const h = shared.rnd(sW) - eWh;
       const v = Math.floor(sH * _rndFromRange(timing.display.Speed.origin));
       let s = 'top: ' + v + 'px;';
       s += ' left: ' + h + 'px;';
       s += ' --emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       let dsO = {};
       if (h + eWh > sWm)
       {
        dsO.origin = 'right';
        aNames.push('speedL');
       }
       else
       {
        dsO.origin = 'left';
        aNames.push('speedR');
       }
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Speed.time);
       const d = Math.floor(tMS * timing.display.Speed.delay);
       aDelays.push(d + 'ms');
       aDurs.push((tMS - d) + 'ms');
       aTimings.push('ease-in');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s, dataset: dsO}, false, {time: tMS});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s, dataset: dsO}, false, {time: tMS});
        }
       }
      }

      function $Drop(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const h = shared.rnd(sW) - eWh;
       let s = 'left: ' + h + 'px;';
       s += ' --emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       let dsO = {};
       if (shared.rnd(2) === 0)
       {
        dsO.origin = 'topleft';
        aNames.push('dropL');
       }
       else
       {
        dsO.origin = 'topright';
        aNames.push('dropR');
       }
       aDelays.push('0s');
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Drop.time);
       aDurs.push(tMS + 'ms');
       aTimings.push('ease-in');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s, dataset: dsO}, false, {space: false, time: tMS});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s, dataset: dsO}, false, {space: false, time: tMS});
        }
       }
      }

      const $Crazy = function()
      {
       /* LAYOUT SHIFTS
        * =============
        * squashes via scale
        * offset-path requires support for offset-anchor/offset-position
        * due to transform-origin changes during squash
        */

       function task(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         eH = Math.ceil(eH / 2);
        else if (variationSize === 2)
         eH = eH * 2;
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const sR = sW - eW;
        const sB = sH - eH;
        const h = shared.rnd(sR - 5) + 10;
        const v = shared.rnd(sB - 5) + 10;
        let s = 'top: ' + v + 'px;';
        s += ' left: ' + h + 'px;';
        s += ' --emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        let dests = [];
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time);
        const rate = Math.sqrt(timing.display.Crazy.distance ** 2 / 2) / tMS;
        let traj = {x: 0, y: 0};
        while (traj.x === 0 && traj.y === 0)
        {
         traj.x = shared.rnd() * (rate * 2) - rate;
         traj.y = shared.rnd() * (rate * 2) - rate;
        }
        let pos = {x: h, y: v, t: 0};
        let lastT = 0;
        let bCt = 0;
        const sqTime = Math.floor(tMS * timing.display.Crazy.squash.time * 2);
        while (bCt * sqTime + pos.t < tMS)
        {
         pos.x += traj.x;
         pos.y += traj.y;
         pos.t += 1;
         let wall = false;
         if (pos.x <= 0)
         {
          pos.x = 0;
          traj.x *= -1;
          wall = 1;
         }
         else if (pos.x >= sR)
         {
          pos.x = sR;
          traj.x *= -1;
          wall = 3;
         }
         if (pos.y <= 0)
         {
          pos.y = 0;
          traj.y *= -1;
          wall = 2;
         }
         else if (pos.y >= sB)
         {
          pos.y = sB;
          traj.y *= -1;
          wall = 4;
         }
         if (wall !== false)
         {
          bCt++;
          dests.push({x: Math.floor(pos.x), y: Math.floor(pos.y), t: pos.t - lastT, w: wall});
          lastT = pos.t;
         }
        }
        dests.push({x: pos.x, y: pos.y, t: pos.t - lastT, w: 0});
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, tMS);
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, eInf.url, variationSize, {style: s}, true, {space: false, time: tMS}));
        if (eInf.hasOwnProperty('zwe'))
        {
         for (let i = 0, l = eInf.zwe.length; i < l; i++)
         {
          iArr.push(_addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s}, true, {space: false, time: tMS}));
         }
        }
        let d = 0;
        const lA = iArr.length;
        const lD = dests.length;
        shared.doNextFrame(_tLoop, tInit, lA, iArr, lD, dests, d);
       }

       function _tLoop(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        if (d >= lD)
         return;
        const squashT = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time * timing.display.Crazy.squash.time);
        for (let i = 0; i < lA; i++)
        {
         iArr[i].dataset.origin = 'center';
         iArr[i].dataset.squash = 'no';
         iArr[i].style.top = dests[d].y + 'px';
         iArr[i].style.left = dests[d].x + 'px';
         iArr[i].style.transition = 'top ' + dests[d].t + 'ms linear, left ' + dests[d].t + 'ms linear, transform ' + squashT + 'ms linear';
        }
        d++;
        window.setTimeout(_tSquash, dests[d - 1].t, tInit, lA, iArr, lD, dests, d);
       }

       function _tSquash(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        const squashT = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time * timing.display.Crazy.squash.time);
        for (let i = 0; i < lA; i++)
        {
         switch (dests[d - 1].w)
         {
          case 1:
           iArr[i].dataset.origin = 'left';
           iArr[i].dataset.squash = 'horizontal';
           break;
          case 2:
           iArr[i].dataset.origin = 'top';
           iArr[i].dataset.squash = 'vertical';
           break;
          case 3:
           iArr[i].dataset.origin = 'right';
           iArr[i].dataset.squash = 'horizontal';
           break;
          case 4:
           iArr[i].dataset.origin = 'bottom';
           iArr[i].dataset.squash = 'vertical';
           break;
         }
        }
        window.setTimeout(_tUnsquash, squashT, tInit, lA, iArr, lD, dests, d);
       }

       function _tUnsquash(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        const squashT = Math.floor(cfg.emote.time * 1000 * timing.display.Crazy.time * timing.display.Crazy.squash.time);
        for (let i = 0; i < lA; i++)
        {
         iArr[i].dataset.squash = 'no';
        }
        window.setTimeout(_tLoop, squashT, tInit, lA, iArr, lD, dests, d);
       }

       return task;
      }();

      function $Confetti(eInf, sW, sH, eH, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const eWh = Math.ceil(eW / 2);
       const h = shared.rnd(sW) - eWh;
       let s = 'left: ' + h + 'px;';
       s += ' --emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       switch (shared.rnd(3))
       {
        case 0:
         aNames.push('confettiA');
         break;
        case 1:
         aNames.push('confettiB');
         break;
        case 2:
         aNames.push('confettiC');
         break;
       }
       aDelays.push('0s');
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Confetti.time);
       aDurs.push(tMS + 'ms');
       aTimings.push('linear');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, false, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s}, false, {space: false, time: tMS});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s}, false, {space: false, time: tMS});
        }
       }
      }

      const $Throw = function()
      {
       function task(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         eH = Math.ceil(eH / 2);
        else if (variationSize === 2)
         eH = eH * 2;
        let eW = eH;
        if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
         eW = eInf.width / eInf.height * eH;
        const sR = sW - eW;
        const sB = sH - eH;
        const h = shared.rnd(2) === 0 ? eW * -1 : sW;
        const v = shared.rnd(sH + eH) - eH;
        const hD = Math.floor(sR * _rndFromRange(timing.display.Throw.dest.h));
        const vD = Math.floor(sB * _rndFromRange(timing.display.Throw.dest.v));
        const dH = shared.rnd() * eH;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Throw.time);
        const t2 = Math.floor(tMS * timing.display.Throw.toss);
        const t3 = Math.floor(tMS * timing.display.Throw.drop);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        let s2 = '--emote-height: ' + eH + 'px;';
        s2 += ' --emote-width: ' + eW + 'px;';
        let r = '360';
        if (h > 0)
         r = '-360';
        s2 += ' transform: translate(' + hD + 'px, ' + (sH - dH) + 'px) rotate(' + r + 'deg);';
        let aNames = [];
        let aDelays = [];
        let aDurs = [];
        let aTimings = [];
        let aFills = [];
        let aIters = [];
        if (cfg.emote.out.fade)
        {
         const fOut = _tAnim.fade.out / 100;
         const t3F = t3 * fOut;
         aNames.push('fadeOut');
         aDelays.push(Math.floor(t3 - t3F) + 'ms');
         aDurs.push(Math.floor(t3F) + 'ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        else
        {
         aNames.push('noFadeOut');
         aDelays.push(t3 - 50 + 'ms');
         aDurs.push('50ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        if (cfg.emote.out.zoom)
        {
         const zOut = _tAnim.zoom.out / 100;
         const t3Z = t3 * zOut;
         aNames.push('zoomOut');
         aDelays.push(Math.floor(t3 - t3Z) + 'ms');
         aDurs.push(Math.floor(t3Z) + 'ms');
         aTimings.push('linear');
         aFills.push('forwards');
         aIters.push('1');
        }
        s2 += _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters, tMS);
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, eInf.url, variationSize, {style: s, classes: ['etThrowTwist']}, true, {space: false, time: tMS}));
        if (eInf.hasOwnProperty('zwe'))
        {
         for (let i = 0, l = eInf.zwe.length; i < l; i++)
         {
          iArr.push(_addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s, classes: ['etThrowTwist']}, true, {space: false, time: tMS}));
         }
        }
        shared.doNextFrame(_tMove, tInit, iArr, hD, vD);
        window.setTimeout(_tDrop, t2, tInit, iArr, s2);
       }

       function _tMove(tInit, iArr, hD, vD)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
        }
       }

       function _tDrop(tInit, iArr, s2)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].classList.replace('etThrowTwist', 'etThrowDrop');
         iArr[i].setAttribute('style', s2);
        }
       }

       return task;
      }();

      const $TheCube = function()
      {
       function task(eInf, sW, sH, eH, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let scene = document.createElement('div');
        scene.setAttribute('class', 'scene fit cube');
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         eH = Math.ceil(eH / 2);
        else if (variationSize === 2)
         eH = eH * 2;
        const eHh = Math.ceil(eH / 2);
        const nHh = eHh * -1;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.TheCube.time);
        let cube = document.createElement('div');
        cube.setAttribute('class', 'cube');
        cube.setAttribute('style', 'transform: translateZ(' + nHh + 'px);');
        if (!eInf.hasOwnProperty('zwe') || eInf.zwe.length === 0)
        {
         let cubeF = document.createElement('img');
         _setImgSrc(cubeF, eInf.url);
         cubeF.dataset.face = 'front';
         cube.appendChild(cubeF);
         let cubeB = document.createElement('img');
         _setImgSrc(cubeB, eInf.url);
         cubeB.dataset.face = 'back';
         cube.appendChild(cubeB);
         let cubeR = document.createElement('img');
         _setImgSrc(cubeR, eInf.url);
         cubeR.dataset.face = 'right';
         cube.appendChild(cubeR);
         let cubeL = document.createElement('img');
         _setImgSrc(cubeL, eInf.url);
         cubeL.dataset.face = 'left';
         cube.appendChild(cubeL);
         let cubeT = document.createElement('img');
         _setImgSrc(cubeT, eInf.url);
         cubeT.dataset.face = 'top';
         cube.appendChild(cubeT);
         let cubeU = document.createElement('img');
         _setImgSrc(cubeU, eInf.url);
         cubeU.dataset.face = 'bottom';
         cube.appendChild(cubeU);
        }
        else
        {
         const lZ = eInf.zwe.length;
         let cubeF = document.createElement('div');
         cubeF.dataset.face = 'front';
         let pctF = document.createElement('img');
         _setImgSrc(pctF, eInf.url);
         cubeF.appendChild(pctF);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeF.appendChild(pctZ);
         }
         cube.appendChild(cubeF);
         let cubeB = document.createElement('div');
         cubeB.dataset.face = 'back';
         let pctB = document.createElement('img');
         _setImgSrc(pctB, eInf.url);
         cubeB.appendChild(pctB);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeB.appendChild(pctZ);
         }
         cube.appendChild(cubeB);
         let cubeR = document.createElement('div');
         cubeR.dataset.face = 'right';
         let pctR = document.createElement('img');
         _setImgSrc(pctR, eInf.url);
         cubeR.appendChild(pctR);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeR.appendChild(pctZ);
         }
         cube.appendChild(cubeR);
         let cubeL = document.createElement('div');
         cubeL.dataset.face = 'left';
         let pctL = document.createElement('img');
         _setImgSrc(pctL, eInf.url);
         cubeL.appendChild(pctL);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeL.appendChild(pctZ);
         }
         cube.appendChild(cubeL);
         let cubeT = document.createElement('div');
         cubeT.dataset.face = 'top';
         let pctT = document.createElement('img');
         _setImgSrc(pctT, eInf.url);
         cubeT.appendChild(pctT);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeT.appendChild(pctZ);
         }
         cube.appendChild(cubeT);
         let cubeU = document.createElement('div');
         cubeU.dataset.face = 'bottom';
         let pctU = document.createElement('img');
         _setImgSrc(pctU, eInf.url);
         cubeU.appendChild(pctU);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeU.appendChild(pctZ);
         }
         cube.appendChild(cubeU);
        }
        scene.appendChild(cube);
        const h = shared.rnd(sW) - eHh;
        const v = shared.rnd(sH) - eHh;
        const r = Math.min(sW, sH) * (shared.rnd() + 1);
        let th = shared.rnd() * _cRadius;
        const nH = eH * -1;
        while (!_safePoints(h, v, th, r, nH, nH, sW, sH))
        {
         th = shared.rnd() * _cRadius;
        }
        let hD = Math.floor(h + r * Math.cos(th));
        let vD = Math.floor(v + r * Math.sin(th));
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        s += ' --cube-depth: ' + eHh + 'px;';
        s += ' perspective: ' + eH * 3 + 'px;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false, tMS);
        scene.setAttribute('style', s);
        _eActive++;
        document.body.appendChild(scene);
        _gc.hook(scene, true, true, tMS);
        shared.doNextFrame(_tMove, tInit, cube, scene, hD, vD, eH);
       }

       function _tMove(tInit, cube, scene, hD, vD, eH)
       {
        if (_iTitanic > tInit)
         return;
        const nHh = Math.ceil(eH / 2) * -1;
        let rX = 0;
        let rY = 0;
        while (Math.abs(rX) + Math.abs(rY) < 45)
        {
         rX = (360 - shared.rnd() * 720) * cfg.emote.cube.rotations;
         rY = (360 - shared.rnd() * 720) * cfg.emote.cube.rotations;
        }
        cube.style.transform = 'translateZ(' + nHh + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
        scene.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
       }

       return task;
      }();

      function $Fountain(eInf, sW, sH, eH, fX, fY, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       const tMS = Math.floor(cfg.emote.time * 1000 * timing.display.Fountain.time);
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        eH = Math.ceil(eH / 2);
       else if (variationSize === 2)
        eH = eH * 2;
       let eW = eH;
       if (eInf.hasOwnProperty('width') && eInf.hasOwnProperty('height'))
        eW = eInf.width / eInf.height * eH;
       const sR = sW - eH;
       const sB = sH - eW;
       let h = fX;
       if (h === false)
        h = Math.floor(shared.rnd() * (sR * 0.33) + sR * 0.33);
       let hD;
       if (shared.rnd(2) === 0)
        hD = h - shared.rnd(sR * 0.2);
       else
        hD = h + shared.rnd(sR * 0.2);
       let s = '--emote-height: ' + eH + 'px;';
       s += ' --emote-width: ' + eW + 'px;';
       s += ' transform: translateX(' + h + 'px);';
       s += ' offset-path: path("M 0 ' + sH + ' L 0 ' + Math.floor(fY * sH + shared.rnd(sB / 2)) + ' L 0 ' + (sH + eH) + '");';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       aNames.push('offsetPath');
       aDelays.push('0s');
       aDurs.push(tMS + 'ms');
       aTimings.push('cubic-bezier(0, 0.9, 1, 0.15)');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters, tMS);
       _addEmoteToDoc(tInit, eInf.url, variationSize, {style: s, classes: ['etFountain']}, false, {time: tMS, space: false}, {x: hD});
       if (eInf.hasOwnProperty('zwe'))
       {
        for (let i = 0, l = eInf.zwe.length; i < l; i++)
        {
         _addEmoteToDoc(tInit, eInf.zwe[i].url, variationSize, {style: s, classes: ['etFountain']}, false, {time: tMS, space: false}, {x: hD});
        }
       }
      }

      return {
       Still: $Still,
       StraightLine: $StraightLine,
       Rise: $Rise,
       Bounce: $Bounce,
       Speed: $Speed,
       Drop: $Drop,
       Crazy: $Crazy,
       Confetti: $Confetti,
       Throw: $Throw,
       TheCube: $TheCube,
       Fountain: $Fountain
      };
     }();

     function _queueEmote(e)
     {
      const sW = window.innerWidth;
      const sH = window.innerHeight;
      const eH = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
      document.documentElement.style.setProperty('--height', sH + 'px');
      document.documentElement.style.setProperty('--width', sW + 'px');
      let style = cfg.display.styles[shared.rnd(cfg.display.styles.length)];
      if (style === undefined)
       return;
      display.emote.list[style](e, sW, sH, eH);
     }

     function $showEmotes()
     {
      if (_tEmote !== false)
      {
       window.clearTimeout(_tEmote);
       _tEmote = false;
      }
      if (cfg.emote.max > 0 && _eActive >= cfg.emote.max)
      {
       _tEmote = window.setTimeout(display.emote.showEmotes, 500);
       return;
      }
      let e = null;
      while ((e = _toShow.shift()) !== undefined)
      {
       _queueEmote(e);
       if (cfg.emote.max > 0 && _eActive > cfg.emote.max)
       {
        if (cfg.emote.queue > 0 && _toShow.length > cfg.emote.queue)
         _toShow.splice(0, _toShow.length - cfg.emote.queue);
        _tEmote = window.setTimeout(display.emote.showEmotes, 500);
        return;
       }
      }
     }

     function $addToShowList(p)
     {
      _toShow = _toShow.concat(p);
     }

     return {
      showEmotes: $showEmotes,
      addToShowList: $addToShowList,
      list: $list
     };
    }();

    const $kappa = function()
    {
     let _toKappa = [];
     let _conga = [];
     const _dKappa = 500;

     let _tKappa = false;

     const _list = function()
     {
      const $Fireworks = function()
      {
       function task(kList, sW, sH, eH, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const oK = kList[shared.rnd(kList.length)];
        let eW = eH;
        if (oK.hasOwnProperty('width') && oK.hasOwnProperty('height'))
         eW = oK.width / oK.height * eH;
        const eWh = Math.ceil(eW / 2);
        const oX = sW * timing.kappa.Fireworks.origin.x[shared.rnd(timing.kappa.Fireworks.origin.x.length)] - eWh;
        const oY = sH * timing.kappa.Fireworks.origin.y[shared.rnd(timing.kappa.Fireworks.origin.y.length)];
        const cX = sW * timing.kappa.Fireworks.dest.x[shared.rnd(timing.kappa.Fireworks.dest.x.length)];
        const cY = sH * timing.kappa.Fireworks.dest.y[shared.rnd(timing.kappa.Fireworks.dest.y.length)];
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time);
        const sendUp = Math.floor(tMS * timing.kappa.Fireworks.speed.rocket);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, oK.url, 1, {style: s, classes: ['ktFireworkRocket']}, true, false, {x: cX - eWh, y: cY}));
        if (oK.hasOwnProperty('zwe'))
        {
         for (let i = 0, l = oK.zwe.length; i < l; i++)
         {
          _eActive++;
          iArr.push(_addEmoteToDoc(tInit, oK.zwe[i].url, 1, {style: s, classes: ['ktFireworkRocket']}, true, false, {x: cX - eWh, y: cY}));
         }
        }
        window.setTimeout(_explode, sendUp, tInit, kList, iArr, cX, cY, eH, sW, sH, iKC);
       }

       async function _explode(tInit, kList, iArr, cX, cY, eH, sW, sH, iKC)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         document.body.removeChild(iArr[i]);
         _eActive--;
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time);
        const kTime = Math.floor(tMS * timing.kappa.Fireworks.speed.burst);
        const fA = _kAcTime(iKC, kTime);
        const r = Math.min(sW, sH) * timing.kappa.Fireworks.radius.base;
        const inner = Math.max(3, Math.floor(iKC * timing.kappa.Fireworks.quantity.small));
        const core = Math.floor(iKC * timing.kappa.Fireworks.quantity.medium);
        const outer = Math.max(3, Math.floor(iKC * timing.kappa.Fireworks.quantity.large));
        const lK = kList.length;
        const sR = r * timing.kappa.Fireworks.radius.small;
        for (let v = 0; v < inner; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         let eW = eH;
         if (sK.hasOwnProperty('width') && sK.hasOwnProperty('height'))
          eW = sK.width / sK.height * eH;
         const sA = shared.rnd();
         _sparkler(tInit, sK.url, cX, cY, eW, eH, sR, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, eW, eH, sR, sA);
          }
         }
         if (v % fA.ct === fA.ct - 1)
          await _fPause(fA.f);
        }
        await _sleep(Math.floor(tMS * timing.kappa.Fireworks.delays.small));
        const mR = r * timing.kappa.Fireworks.radius.medium;
        const dT = Math.ceil(fA.ct / timing.kappa.Fireworks.spread);
        for (let v = 0; v < core; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         let eW = eH;
         if (sK.hasOwnProperty('width') && sK.hasOwnProperty('height'))
          eW = sK.width / sK.height * eH;
         const sA = shared.rnd();
         _sparkler(tInit, sK.url, cX, cY, eW, eH, mR, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, eW, eH, mR, sA);
          }
         }
         if (v % dT === dT - 1)
          await _fPause();
        }
        await _sleep(Math.floor(tMS * timing.kappa.Fireworks.delays.large));
        const lR = r * timing.kappa.Fireworks.radius.large;
        for (let v = 0; v < outer; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         let eW = eH;
         if (sK.hasOwnProperty('width') && sK.hasOwnProperty('height'))
          eW = sK.width / sK.height * eH;
         const sA = shared.rnd();
         _sparkler(tInit, sK.url, cX, cY, eW, eH, lR, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, eW, eH, lR, sA);
          }
         }
         if (v % fA.ct === fA.ct - 1)
          await _fPause(fA.f);
        }
       }

       function _sparkler(tInit, url, cX, cY, eW, eH, r, a)
       {
        if (_iTitanic > tInit)
         return;
        const th = a * _cRadius;
        const eWh = Math.ceil(eW / 2);
        const eX = cX - eWh;
        const hD = Math.floor(eX + r * Math.cos(th));
        const vD = Math.floor(cY + r * Math.sin(th));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        s += ' transform: translate(' + eX + 'px, ' + cY + 'px);';
        s += _styleEmote([], [], [], [], [], [], true, false, true, false, tMS);
        _addEmoteToDoc(tInit, url, 1, {style: s, classes: ['ktFireworkSparkler']}, false, {space: false, time: tMS}, {x: hD, y: vD});
       }

       return task;
      }();

      const $Spiral = function()
      {
       function task(kList, sW, sH, eH, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const oX = shared.rnd() * sW;
        const oY = shared.rnd(sH - eH);
        const r = Math.min(sW, sH);
        shared.doNextFrame(_init, tInit, kList, oX, oY, eH, r, iKC);
       }

       async function _init(tInit, kList, oX, oY, eH, r, iKC)
       {
        if (_iTitanic > tInit)
         return;
        const c = _cRadius / (_rndFromRange(timing.kappa.Spiral.vectors) + (shared.rnd() * 2));
        let th = shared.rnd() * _cRadius;
        const o = shared.rnd(2) === 0;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Spiral.time);
        let sA = _kAcTime(iKC, tMS);
        if (sA.ct > timing.kappa.Spiral.bulk)
         sA.ct = timing.kappa.Spiral.bulk;
        for (let i = 0; i < iKC; i++)
        {
         if (_iTitanic > tInit)
          return;
         if (o)
         {
          th-= c;
          if (th <= 0)
           th+= _cRadius;
         }
         else
         {
          th+= c;
          if (th >= _cRadius)
           th-= _cRadius;
         }
         const oK = kList[shared.rnd(kList.length)];
         let eW = eH;
         if (oK.hasOwnProperty('width') && oK.hasOwnProperty('height'))
          eW = oK.width / oK.height * eH;
         const eWh = Math.ceil(eW / 2);
         _sparkler(tInit, oK.url, oX - eWh, oY, eW, eH, r, th);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, m = oK.zwe.length; j < m; j++)
          {
           _eActive++;
           _sparkler(tInit, oK.zwe[j].url, oX - eWh, oY, eW, eH, r, th);
          }
         }
         if (i % sA.ct === sA.ct - 1)
          await _fPause(sA.f);
        }
       }

       function _sparkler(tInit, url, oX, oY, eW, eH, r, th)
       {
        if (_iTitanic > tInit)
         return;
        const hD = Math.floor(oX + r * Math.cos(th));
        const vD = Math.floor(oY + r * Math.sin(th));
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Spiral.time);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
        s += _styleEmote([], [], [], [], [], [], true, false, true, false, tMS);
        _addEmoteToDoc(tInit, url, 1, {style: s, classes: ['ktSpiral']}, false, {space: false, time: tMS}, {x: hD, y: vD});
       }

       return task;
      }();

      const $Pyramid = function()
      {
       function task(kList, sW, sH)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let drawn = [];
        let ct = 0;
        const lP = pyramidDist.length;
        const eH = sW / lP;
        for (let i = 0; i < lP; i++)
        {
         drawn.push(0);
         ct += pyramidDist[i];
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Pyramid.time);
        const sT = tMS * timing.kappa.Pyramid.show.total;
        const tPerB = Math.max(Math.floor(sT / ct), timing.kappa.Pyramid.show.min);
        const eT = tPerB * ct;
        const dT = Math.floor(tMS * timing.kappa.Pyramid.pause);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lP);
         while (drawn[x] >= pyramidDist[x]);
         const oK = kList[shared.rnd(kList.length)];
         _block(tInit, oK.url, x, t, eH, sH, drawn[x] + 1, eT + dT);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _eActive++;
           _block(tInit, oK.zwe[j].url, x, t, eH, sH, drawn[x] + 1, eT + dT);
          }
         }
         drawn[x]++;
         t += tPerB;
        }
       }

       function _block(tInit, url, x, t, eH, sH, dX, aT)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote fit ktPyramid');
        _setImgSrc(img, url);
        const h = Math.floor(eH * x);
        const v = -1 * eH;
        const vD = sH - eH * dX;
        let s = 'top: 0px;';
        s += ' left: ' + h + 'px;';
        s += ' --emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        s += ' transform: translateY(' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tDrop, Math.floor(t / 10 + aT), tInit, img, sH);
        window.setTimeout(_tMove, t, tInit, img, vD);
       }

       function _tMove(tInit, img, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translateY(' + vD + 'px)';
       }

       function _tDrop(tInit, img, sH)
       {
        if (_iTitanic > tInit)
         return;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Pyramid.time);
        const pT = Math.floor(tMS * timing.kappa.Pyramid.hide);
        img.classList.replace('ktPyramid', 'ktPyramidDrop');
        img.style.transform = 'translateY(' + sH + 'px)';
        _gc.hook(img, false, true, pT);
       }

       return task;
      }();

      const $SmallPyramid = function()
      {
       function task(kList, sW, sH)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let drawn = [];
        let ct = 0;
        const lP = pyramidDist.length;
        const eH = Math.min(sW / lP, Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small));
        for (let i = 0; i < lP; i++)
        {
         drawn.push(0);
         ct += pyramidDist[i];
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.SmallPyramid.time);
        const sT = tMS * timing.kappa.SmallPyramid.show.total;
        const tPerB = Math.max(Math.floor(sT / ct), timing.kappa.SmallPyramid.show.min);
        const eT = tPerB * ct;
        const dT = Math.floor(tMS * timing.kappa.SmallPyramid.pause);
        const oX = shared.rnd(sW - eH * lP);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lP);
         while (drawn[x] >= pyramidDist[x]);
         const oK = kList[shared.rnd(kList.length)];
         _block(tInit, oK.url, oX, x, t, eH, sH, drawn[x] + 1, eT + dT);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _eActive++;
           _block(tInit, oK.zwe[j].url, oX, x, t, eH, sH, drawn[x] + 1, eT + dT);
          }
         }
         drawn[x]++;
         t += tPerB;
        }
       }

       function _block(tInit, url, oX, x, t, eH, sH, dX, aT)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote fit ktSmallPyramid');
        _setImgSrc(img, url);
        const h = oX + eH * x;
        const v = -1 * eH;
        const vD = sH - eH * dX;
        let s = 'top: 0px;';
        s += ' left: ' + h + 'px;';
        s += ' --emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        s += ' transform: translateY(' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tDrop, Math.floor(t / 10 + aT), tInit, img, sH);
        window.setTimeout(_tMove, t, tInit, img, vD);
       }

       function _tMove(tInit, img, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translateY(' + vD + 'px)';
       }

       function _tDrop(tInit, img, sH)
       {
        if (_iTitanic > tInit)
         return;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.SmallPyramid.time);
        const pT = Math.floor(tMS * timing.kappa.SmallPyramid.hide);
        img.classList.replace('ktSmallPyramid', 'ktSmallPyramidDrop');
        img.style.transform = 'translateY(' + sH + 'px)';
        _gc.hook(img, false, true, pT);
       }

       return task;
      }();

      const $Stampede = function()
      {
       async function task(kList, sW, sH, eH, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const bandHeight = eH * timing.kappa.Stampede.height;
        const d = shared.rnd(2) === 0;
        const bandTop = shared.rnd(sH - bandHeight + (eH * timing.kappa.Stampede.top.min) + (eH * timing.kappa.Stampede.top.max)) + (eH * (-1 * timing.kappa.Stampede.top.min));
        const b1 = _rndFromRange(timing.kappa.Stampede.bunch[1]);
        const b2 = shared.rnd(timing.kappa.Stampede.bunch[2] - b1) + b1;
        const b4 = _rndFromRange(timing.kappa.Stampede.bunch[4]);
        const hasB4 = b4 > 0;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Stampede.time);
        const tSpeed = Math.floor(tMS * timing.kappa.Stampede.speed);
        const t1 = Math.floor(tSpeed * timing.kappa.Stampede.pause['1']);
        let maxW = 0;
        for (let i = 0; i < kList.length; i++)
        {
         let eW = eH;
         if (kList[i].hasOwnProperty('width') && kList[i].hasOwnProperty('height'))
          eW = kList[i].width / kList[i].height * eH;
         if (eW > maxW)
          maxW = eW;
        }
        await _stampede(tInit, kList, b1, t1, false, bandTop, bandHeight, d, sW, eH, maxW);
        if (_iTitanic > tInit)
         return;
        const t2 = Math.floor(tSpeed * timing.kappa.Stampede.pause['2']);
        await _stampede(tInit, kList, b2, t2, false, bandTop, bandHeight, d, sW, eH, maxW);
        if (_iTitanic > tInit)
         return;
        let sA = _kAcTime(iKC, tMS);
        if (sA.ct > timing.kappa.Stampede.maxdensity)
         sA.ct = timing.kappa.Stampede.maxdensity;
        await _stampede(tInit, kList, iKC, hasB4, sA, bandTop, bandHeight, d, sW, eH, maxW);
        if (_iTitanic > tInit)
         return;
        if (hasB4)
         await _stampede(tInit, kList, b4, false, false, bandTop, bandHeight, d, sW, eH, maxW);
       }

       async function _stampede(tInit, kList, ct, pause, sA, bandTop, bandHeight, d, sW, eH, maxW)
       {
        if (_iTitanic > tInit)
         return;
        let imgs = [];
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         const oK = kList[shared.rnd(kList.length)];
         let eW = eH;
         if (oK.hasOwnProperty('width') && oK.hasOwnProperty('height'))
          eW = oK.width / oK.height * eH;
         const y = bandTop + shared.rnd(bandHeight);
         imgs.push(_run(tInit, oK.url, y, d, sW, eW, eH, maxW));
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _run(tInit, oK.zwe[j].url, y, d, sW, eW, eH, maxW);
          }
         }
         if (sA === false)
          await _sleep(_rndFromRange(timing.kappa.Stampede.smallSleep));
         else
         {
          if (i % sA.ct === sA.ct - 1)
          {
           let wF = sA.f;
           if (wF === 1)
            wF = shared.rnd(3);
           else
            wF *= (shared.rnd() * 3) / 2;
           if (wF !== 0)
            await _fPause(wF);
          }
         }
        }
        if (pause === false)
         return;
        if (pause !== true)
        {
         await _sleep(pause);
         return;
        }
        do
        {
         if (_iTitanic > tInit)
          return;
         await _sleep(100);
         for (let i = imgs.length - 1; i >= 0; i--)
         {
          if (imgs[i] === null || imgs[i].hasAttribute('deleted'))
           imgs.splice(i, 1);
         }
        } while (imgs.length > 0);
       }

       function _run(tInit, url, v, d, sW, eW, eH, maxW)
       {
        if (_iTitanic > tInit)
         return;
        const h = -2 * maxW;
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Stampede.time);
        const tSpeed = Math.floor(tMS * timing.kappa.Stampede.speed);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eW + 'px;';
        if (d)
         s += ' transform: translate(' + sW + 'px, ' + v + 'px);';
        else
         s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        s += _styleEmoteString([], [], [], [], [], []);
        let img;
        if (d)
         img = _addEmoteToDoc(tInit, url, 1, {style: s, classes: ['ktStampede']}, true, {space: false, time: tSpeed}, {x: h, y: v});
        else
         img = _addEmoteToDoc(tInit, url, 1, {style: s, classes: ['ktStampede']}, true, {space: false, time: tSpeed}, {x: sW, y: v});
        window.setTimeout(_tMark, tSpeed, tInit, img);
        return img;
       }

       function _tMark(tInit, img)
       {
        if (_iTitanic > tInit)
         return;
        if (img === null)
         return;
        if (img.parentNode !== null)
         document.body.removeChild(img);
        img.setAttribute('deleted', true);
       }

       return task;
      }();

      const $Conga = function()
      {
       async function task(kList, sW, sH, eH, nM)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let v = 0;
        let unique = false;
        const bS = Math.ceil(eH * timing.kappa.Conga.size);
        const seg = Math.floor(eH * timing.kappa.Conga.height);
        const sht = Math.floor(sH / seg);
        let lns = sht;
        if (nM)
         lns = timing.kappa.Conga.avoidMiddle;
        while (_conga.length >= lns)
        {
         if (_iTitanic > tInit)
          return;
         await _sleep(250);
        }
        while (!unique)
        {
         v = shared.rnd(sht) * seg;
         if (nM)
         {
          v = shared.rnd(timing.kappa.Conga.avoidMiddle);
          const hMid = Math.floor(timing.kappa.Conga.avoidMiddle / 2);
          if (v >= hMid)
           v = sht - 1 - (v - hMid);
          v *= seg;
         }
         let found = false;
         for (let i = 0, l = _conga.length; i < l; i++)
         {
          if (_conga[i].row === v)
          {
           found = true;
           break;
          }
         }
         if (!found)
          unique = true;
        }
        _conga.push({row: v, done: false});
        let urls = [];
        let zurls = [];
        const ct = Math.floor(sW / bS);
        for (let i = 0; i < ct; i++)
        {
         const oK = kList[shared.rnd(kList.length)];
         urls.push(oK.url);
         let oZ = [];
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           oZ.push(oK.zwe[j].url);
          }
         }
         zurls.push(oZ);
        }
        const d = v / seg % 2 === 0;
        const xtra = Math.floor((sW - ct * bS) / 2);
        let imgs = [];
        let zimgs = [];
        for (let i = 0; i < ct; i++)
        {
         imgs.push(_dance(tInit, urls[i], i, sW, v, eH, bS, ct, d, xtra));
         let oZ = [];
         for (let j = 0, l = zurls[i].length; j < l; j++)
         {
          oZ.push(_dance(tInit, zurls[i][j], i, sW, v, eH, bS, ct, d, xtra));
         }
         zimgs.push(oZ);
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Conga.time.show);
        await _sleep(tMS);
        let full = false;
        if (_conga.length === sht)
         full = true;
        await _sleep(Math.floor(cfg.display.kappa.conga.time * 1000));
        if (cfg.display.kappa.conga.contagious)
        {
         let ex = false;
         let lC = _conga.length;
         if (lC > 1)
          ex = true;
         for (let i = 0; i < lC; i++)
         {
          if (_conga[i].row !== v)
           continue;
          _conga[i].done = true;
          break;
         }
         let done = false;
         while (!done)
         {
          if (_iTitanic > tInit)
           return;
          lC = _conga.length;
          if (!ex && lC > 1)
           ex = true;
          let notDone = false;
          for (let i = 0; i < lC; i++)
          {
           if (_conga[i].done === false)
           {
            notDone = true;
            break;
           }
          }
          if (notDone === false)
           done = true;
          await _sleep(100);
         }
        }
        for (let i = 0, l = imgs.length; i < l; i++)
        {
         _endDance(tInit, imgs[i], i, sW, v, eH, bS, ct, d, xtra);
         for (let j = 0, m = zimgs[i].length; j < m; j++)
         {
          _endDance(tInit, zimgs[i][j], i, sW, v, eH, bS, ct, d, xtra);
         }
        }
        await _sleep(tMS);
        for (let i = 0, l = _conga.length; i < l; i++)
        {
         if (_conga[i].row !== v)
          continue;
         _conga.splice(i, 1);
         break;
        }
       }

       function _dance(tInit, url, col, sW, v, eH, bS, ct, d, xtra)
       {
        if (_iTitanic > tInit)
         return;
        let box = document.createElement('div');
        box.setAttribute('class', 'scene ktCongaIn');
        let img = document.createElement('img');
        img.setAttribute('class', 'dancer fit');
        _setImgSrc(img, url);
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        img.setAttribute('style', s);
        let sE = bS * col + xtra;
        let sB = sE - sW;
        if (d)
        {
         sE = bS * (ct - 1 - col) + xtra;
         sB = sE + sW;
        }
        s = 'top: ' + v + 'px;';
        s += ' left: 0px;';
        s += ' height: ' + bS + 'px;';
        s += ' width: ' + bS + 'px;';
        s += ' z-index: ' + v + ';';
        s += ' transform: translateX(' + sB + 'px);';
        box.setAttribute('style', s);
        _eActive++;
        box.appendChild(img);
        document.body.appendChild(box);
        shared.doNextFrame(_tMove, tInit, box, sE);
        return box;
       }

       function _endDance(tInit, box, col, sW, v, eH, bS, ct, d, xtra)
       {
        if (_iTitanic > tInit)
         return;
        let sB = bS * col + xtra;
        let sE = sB + sW;
        if (d)
        {
         sB = bS * (ct - 1 - col) + xtra;
         sE = sB - sW;
        }
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Conga.time.hide);
        box.classList.replace('ktCongaIn', 'ktCongaOut');
        _gc.hook(box, true, true, Math.ceil(tMS * 1.25));
        shared.doNextFrame(_tMove, tInit, box, sE);
       }

       function _tMove(tInit, box, sE)
       {
        if (_iTitanic > tInit)
         return;
        box.style.transform = 'translateX(' + sE + 'px)';
       }

       return task;
      }();

      const $TheCube = function()
      {
       function task(eInf, sW, sH, eH, bC, iR)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const eHh = Math.ceil(eH / 2);
        const nHh = eHh * -1;
        const sWm = Math.ceil(sW / 2);
        const sHm = Math.ceil(sH / 2);
        let scene = document.createElement('div');
        scene.setAttribute('class', 'scene fit cube kappa');
        const tMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.TheCube.time);
        let cube = document.createElement('div');
        cube.setAttribute('class', 'cube');
        cube.setAttribute('style', 'transform: translateZ(' + nHh + 'px);');
        if (!eInf.hasOwnProperty('zwe') || eInf.zwe.length === 0)
        {
         let cubeF = document.createElement('img');
         _setImgSrc(cubeF, eInf.url);
         cubeF.dataset.face = 'front';
         cube.appendChild(cubeF);
         let cubeB = document.createElement('img');
         _setImgSrc(cubeB, eInf.url);
         cubeB.dataset.face = 'back';
         cube.appendChild(cubeB);
         let cubeR = document.createElement('img');
         _setImgSrc(cubeR, eInf.url);
         cubeR.dataset.face = 'right';
         cube.appendChild(cubeR);
         let cubeL = document.createElement('img');
         _setImgSrc(cubeL, eInf.url);
         cubeL.dataset.face = 'left';
         cube.appendChild(cubeL);
         let cubeT = document.createElement('img');
         _setImgSrc(cubeT, eInf.url);
         cubeT.dataset.face = 'top';
         cube.appendChild(cubeT);
         let cubeU = document.createElement('img');
         _setImgSrc(cubeU, eInf.url);
         cubeU.dataset.face = 'bottom';
         cube.appendChild(cubeU);
        }
        else
        {
         const lZ = eInf.zwe.length;
         let cubeF = document.createElement('div');
         cubeF.dataset.face = 'front';
         let pctF = document.createElement('img');
         _setImgSrc(pctF, eInf.url);
         cubeF.appendChild(pctF);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeF.appendChild(pctZ);
         }
         cube.appendChild(cubeF);
         let cubeB = document.createElement('div');
         cubeB.dataset.face = 'back';
         let pctB = document.createElement('img');
         _setImgSrc(pctB, eInf.url);
         cubeB.appendChild(pctB);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeB.appendChild(pctZ);
         }
         cube.appendChild(cubeB);
         let cubeR = document.createElement('div');
         cubeR.dataset.face = 'right';
         let pctR = document.createElement('img');
         _setImgSrc(pctR, eInf.url);
         cubeR.appendChild(pctR);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeR.appendChild(pctZ);
         }
         cube.appendChild(cubeR);
         let cubeL = document.createElement('div');
         cubeL.dataset.face = 'left';
         let pctL = document.createElement('img');
         _setImgSrc(pctL, eInf.url);
         cubeL.appendChild(pctL);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeL.appendChild(pctZ);
         }
         cube.appendChild(cubeL);
         let cubeT = document.createElement('div');
         cubeT.dataset.face = 'top';
         let pctT = document.createElement('img');
         _setImgSrc(pctT, eInf.url);
         cubeT.appendChild(pctT);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeT.appendChild(pctZ);
         }
         cube.appendChild(cubeT);
         let cubeU = document.createElement('div');
         cubeU.dataset.face = 'bottom';
         let pctU = document.createElement('img');
         _setImgSrc(pctU, eInf.url);
         cubeU.appendChild(pctU);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, eInf.zwe[i].url);
          cubeU.appendChild(pctZ);
         }
         cube.appendChild(cubeU);
        }
        scene.appendChild(cube);
        let h = shared.rnd(sW - eH);
        let v = shared.rnd(sH - eH);
        if (bC)
        {
         h = Math.floor(sWm - eHh);
         v = Math.floor(sHm - eHh);
        }
        let s = '--emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        s += ' --cube-depth: ' + eHh + 'px;';
        s += ' perspective: ' + eH * 3 + 'px;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false, tMS);
        scene.setAttribute('style', s);
        _eActive++;
        document.body.appendChild(scene);
        _gc.hook(scene, false, true, tMS);
        shared.doNextFrame(_tMove, tInit, cube, iR, eH);
       }

       function _tMove(tInit, cube, iR, eH)
       {
        if (_iTitanic > tInit)
         return;
        const nHh = Math.ceil(eH / 2) * -1;
        let rX = 0;
        let rY = 0;
        while (Math.abs(rX) + Math.abs(rY) < 45)
        {
         rX = (360 - shared.rnd() * 720) * iR;
         rY = (360 - shared.rnd() * 720) * iR;
        }
        cube.style.transform = 'translateZ(' + nHh + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
       }

       return task;
      }();

      const $Text = function()
      {
       let _mL = 0;

       function task(kList, sW, sH, sMsg, iTime)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const msgDist = _buildMsgArr(sMsg);
        let ct = 0;
        let ctT = 0;
        let drawn = [];
        const lM = msgDist.length;
        for (let x = 0; x < lM; x++)
        {
         const lX = msgDist[x].length;
         for (let y = 0; y < lX; y++)
         {
          if (msgDist[x][y] !== 0)
           ctT += 1;
         }
         ct += lX;
         drawn.push(0);
        }
        const eH = Math.min(Math.floor(sW / (lM + 2)), Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small));
        const tMS = Math.floor(iTime * 1000 * timing.kappa.Text.time);
        const sT = tMS * timing.kappa.Text.show.total;
        const tPerB = Math.max(Math.floor(sT / ct), timing.kappa.Text.show.min);
        const eT = tPerB * ctT;
        const lF = msgDist[0].length;
        const lFS = eH * lF;
        const vH = shared.rnd(sH - lFS) + lFS;
        const oX = shared.rnd(sW - eH * lM);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lM);
         while (drawn[x] >= msgDist[x].length);
         if (msgDist[x][drawn[x]] !== 0)
         {
          const oK = kList[shared.rnd(kList.length)];
          _block(tInit, oK.url, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, eH);
          if (oK.hasOwnProperty('zwe'))
          {
           for (let j = 0, l = oK.zwe.length; j < l; j++)
           {
            _eActive++;
            _block(tInit, oK.zwe[j].url, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, eH);
           }
          }
          t += tPerB;
         }
         drawn[x]++;
        }
       }

       function _buildMsgArr(s)
       {
        let o = [];
        let spc = [];
        if (_mL === 0)
        {
         for (let i = 0, k = Object.keys(alnumDist), l = k.length; i < l; i++)
         {
          _mL = Math.max(_mL, alnumDist[k[i]][0].length);
         }
        }
        for (let y = 0; y < _mL; y++)
        {
         spc.push(0);
        }
        for (let i = 0, l = s.length; i < l; i++)
        {
         if (i > 0)
          o.push(spc);
         if (s[i] === ' ')
         {
          o.push(spc);
          o.push(spc);
          continue;
         }
         const v = s[i];
         if (!alnumDist.hasOwnProperty(v))
          continue;
         const c = alnumDist[v];
         for (let x = 0, m = c.length; x < m; x++)
         {
          o.push(c[x]);
         }
        }
        return o;
       }

       function _block(tInit, url, vH, oX, dX, tPerB, eT, iTime, x, t, sH, eH)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote fit');
        _setImgSrc(img, url);
        const h = oX + eH * x;
        const v = -1 * eH;
        const vD = vH - eH * dX;
        let s = 'top: 0px;';
        s += ' left: ' + h + 'px;';
        s += ' --emote-height: ' + eH + 'px;';
        s += ' --emote-width: ' + eH + 'px;';
        s += ' transition: transform ' + tPerB + 'ms ease-in;';
        s += ' transform: translateY(' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        const tMS = Math.floor(iTime * 1000 * timing.kappa.Text.time);
        window.setTimeout(_tDrop, Math.floor(eT + tMS + t / 10), tInit, img, sH, tMS);
        window.setTimeout(_tMove, t, tInit, img, vD);
       }

       function _tMove(tInit, img, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translateY(' + vD + 'px)';
       }

       function _tDrop(tInit, img, sH, tMS)
       {
        if (_iTitanic > tInit)
         return;
        const pT = Math.floor(tMS * timing.kappa.Text.hide);
        img.style.transform = 'translateY(' + sH + 'px)';
        img.style.transitionDuration = pT + 'ms';
        _gc.hook(img, false, true, pT);
       }

       return task;
      }();

      return {
       Fireworks: $Fireworks,
       Spiral: $Spiral,
       Pyramid: $Pyramid,
       SmallPyramid: $SmallPyramid,
       Stampede: $Stampede,
       Conga: $Conga,
       TheCube: $TheCube,
       Text: $Text
      };
     }();

     function _canShowKappa(k)
     {
      if (cfg.emote.max < 1)
       return true;
      if (_eActive < 1)
       return true;
      let tC = cfg.display.kappa.count;
      if (k !== false)
       tC = _getKappaCountEstimate(k);
      let cM = Math.max(cfg.emote.max, tC);
      return _eActive + tC < cM;
     }

     function _showKappas()
     {
      if (_tKappa !== false)
      {
       window.clearTimeout(_tKappa);
       _tKappa = false;
      }
      if (_toKappa.length < 1)
       return;
      let nK = _getNextKappa(_toKappa[0]);
      if (nK === false)
       return;
      if (!_canShowKappa(nK))
      {
       _tKappa = window.setTimeout(_showKappas, _dKappa);
       return;
      }
      let e = null;
      while ((e = _toKappa.shift()) !== undefined)
      {
       nK = false;
       let a = {};
       a[e.style] = e.prefs;
       display.kappa.show(e.list, a, e.params);
       if (_toKappa.length < 1)
        return;
       nK = _getNextKappa(_toKappa[0]);
       if (nK === false)
        return;
       if (!_canShowKappa(nK))
       {
        if (cfg.emote.queue > 0 && _toKappa.length > cfg.emote.queue)
         _toKappa.splice(0, _toKappa.length - cfg.emote.queue);
        _tKappa = window.setTimeout(_showKappas, _dKappa);
        return;
       }
      }
     }

     function _getNextKappa(k)
     {
      let a = [];
      a[k.style] = k.prefs;
      return _getNextKappaEx(a, k.params);
     }

     function _getKappaCountParam(p)
     {
      const a = p.split(' ');
      for (let i = 0, l = a.length; i < l; i++)
      {
       if (!isNaN(a[i]))
        return parseInt(a[i], 10);
      }
      return false;
     }

     function _getNextKappaEx(kS = false, kP = false)
     {
      if (typeof kS !== 'object')
      {
       if (cfg.display.kappa.styles.length < 1)
        return false;
       kS = cfg.display.kappa.styles;
      }
      let s, p;
      const keys = Object.keys(kS);
      if (cfg.display.kappa.conga.contagious && _conga.length > 0)
      {
       s = 'Conga';
       p = {};
       if (keys.includes(s))
        p = kS[s];
      }
      else
      {
       s = keys[shared.rnd(keys.length)];
       p = kS[s];
      }
      if (s === undefined)
       return false;
      let iKC = cfg.display.kappa.count;
      if (cfg.display.kappa.styles.hasOwnProperty(s) && cfg.display.kappa.styles[s].hasOwnProperty('count') && cfg.display.kappa.styles[s].count > 0)
       iKC = cfg.display.kappa.styles[s].count;
      if (p === undefined)
       p = {};
      let pMax = cfg.emote.max;
      if (p.hasOwnProperty('count'))
      {
       let tKC = 0;
       if (Number.isInteger(p.count))
        tKC = p.count;
       else
       {
        if (p.count.hasOwnProperty('maximum'))
         pMax = p.count.maximum;
        if (p.count.hasOwnProperty('default'))
         tKC = p.count.default;
        if (p.count.hasOwnProperty('dynamic') && p.count.dynamic !== false)
        {
         if (p.hasOwnProperty('params') && p.params !== null)
         {
          const pC = _getKappaCountParam(p.params);
          if (pC !== false)
           tKC = pC;
         }
        }
       }
       if (tKC === -1 && kP !== false && kP.hasOwnProperty('%AMOUNT%') && Math.ceil(kP['%AMOUNT%']) > 0)
        tKC = Math.ceil(kP['%AMOUNT%']);
       if (tKC > 0)
        iKC = tKC;
      }
      if (pMax > 0 && iKC > pMax)
       iKC = pMax;
      return {style: s, prefs: p, count: iKC};
     }

     function _getKappaCountEstimate(k)
     {
      switch (k.style)
      {
       case 'Pyramid':
       case 'SmallPyramid':
        let c = 0;
        for (let i = 0, l = pyramidDist.length; i < l; i++)
         c += pyramidDist[i];
        return c;
       case 'Fireworks':
        const inner = Math.floor(k.count / 8);
        const outer = inner;
        const core = k.count - (inner + outer);
        return 1 + inner + core + outer;
       case 'Conga':
        const sW = window.innerWidth;
        const sH = window.innerHeight;
        const eH = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
        const bS = Math.ceil(eH * (5/3));
        return Math.floor(sW / bS);
      }
      return k.count;
     }

     async function _StringArrayToEmoteArray(s)
     {
      let r = [];
      let idx = 0;
      for (let i = 0, l = s.length; i < l; i++)
      {
       let v = {};
       v.str = s[i];
       v.pos = idx;
       idx+= s[i].length + 1;
       if (s[i].includes('//'))
       {
        v.svc = 'u';
        v.scope = 'g';
        v.url = s[i];
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('twitch') && thirdparty.emotes.twitch.hasOwnProperty(s[i]) && thirdparty.emotes.twitch[s[i]].scope === 'c')
       {
        v.svc = 't';
        v.url = thirdparty.emotes.twitch[s[i]].url;
        v.scope = thirdparty.emotes.twitch[s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('ffz') && thirdparty.emotes.ffz.hasOwnProperty(s[i]) && thirdparty.emotes.ffz[s[i]].scope === 'c')
       {
        v.svc = 'f';
        v.url = thirdparty.emotes.ffz[s[i]].url;
        v.scope = thirdparty.emotes.ffz[s[i]].scope;
        v.width = thirdparty.emotes.ffz[s[i]].width;
        v.height = thirdparty.emotes.ffz[s[i]].height;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('bttv') && thirdparty.emotes.bttv.hasOwnProperty(s[i]) && thirdparty.emotes.bttv[s[i]].scope === 'c')
       {
        v.svc = 'b';
        v.url = thirdparty.emotes.bttv[s[i]].url;
        v.scope = thirdparty.emotes.bttv[s[i]].scope;
        v.width = thirdparty.emotes.bttv[s[i]].width;
        v.height = thirdparty.emotes.bttv[s[i]].height;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('7tv') && thirdparty.emotes['7tv'].hasOwnProperty(s[i]) && thirdparty.emotes['7tv'][s[i]].scope === 'c')
       {
        v.svc = '7';
        v.url = thirdparty.emotes['7tv'][s[i]].url;
        v.scope = thirdparty.emotes['7tv'][s[i]].scope;
        v.width = thirdparty.emotes['7tv'][s[i]].width;
        v.height = thirdparty.emotes['7tv'][s[i]].height;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('twitch') && thirdparty.emotes.twitch.hasOwnProperty(s[i]) && thirdparty.emotes.twitch[s[i]].scope === 'g')
       {
        v.svc = 't';
        v.url = thirdparty.emotes.twitch[s[i]].url;
        v.scope = thirdparty.emotes.twitch[s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('ffz') && thirdparty.emotes.ffz.hasOwnProperty(s[i]) && thirdparty.emotes.ffz[s[i]].scope === 'g')
       {
        v.svc = 'f';
        v.url = thirdparty.emotes.ffz[s[i]].url;
        v.scope = thirdparty.emotes.ffz[s[i]].scope;
        v.width = thirdparty.emotes.ffz[s[i]].width;
        v.height = thirdparty.emotes.ffz[s[i]].height;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('bttv') && thirdparty.emotes.bttv.hasOwnProperty(s[i]) && thirdparty.emotes.bttv[s[i]].scope === 'g')
       {
        v.svc = 'b';
        v.url = thirdparty.emotes.bttv[s[i]].url;
        v.scope = thirdparty.emotes.bttv[s[i]].scope;
        v.width = thirdparty.emotes.bttv[s[i]].width;
        v.height = thirdparty.emotes.bttv[s[i]].height;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('7tv') && thirdparty.emotes['7tv'].hasOwnProperty(s[i]) && thirdparty.emotes['7tv'][s[i]].scope === 'g')
       {
        v.svc = '7';
        v.url = thirdparty.emotes['7tv'][s[i]].url;
        v.scope = thirdparty.emotes['7tv'][s[i]].scope;
        v.width = thirdparty.emotes['7tv'][s[i]].width;
        v.height = thirdparty.emotes['7tv'][s[i]].height;
        r.push(v);
        continue;
       }
       if (cfg.display.useEmoji !== false)
       {
        const cmd = {params: [null, s[i]]};
        const eMoji = await twitch.parse.content.emoji(cmd, cfg.display.useEmoji, true);
        if (eMoji.length > 0)
        {
         v.svc = 'e';
         v.scope = 'g';
         const vStart = v.pos;
         for (let j = 0, m = eMoji.length; j < m; j++)
         {
          v.url = eMoji[j].url;
          v.str = eMoji[j].str;
          v.pos = vStart + eMoji[j].pos;
          r.push(v);
         }
         continue;
        }
       }
      }
      return r;
     }

     async function $show(kList, kStyles = false, kParams = false)
     {
      const kStyle = _getNextKappaEx(kStyles, kParams);
      if (kStyle === false)
       return;
      if (kStyle.style === undefined)
       return;
      if (kStyle.prefs.hasOwnProperty('emotes'))
      {
       let kForce = [];
       let bForce = false;
       if (Array.isArray(kStyle.prefs.emotes))
        kForce = kStyle.prefs.emotes;
       else
       {
        if (kStyle.prefs.emotes.hasOwnProperty('list'))
         kForce = kStyle.prefs.emotes.list;
        if (kStyle.prefs.emotes.hasOwnProperty('dynamic') && kStyle.prefs.emotes.dynamic === false)
         bForce = true;
       }
       if (!Array.isArray(kList) || kList.length < 1)
        bForce = true;
       if (bForce)
       {
        const fList = await _StringArrayToEmoteArray(kForce);
        if (fList.length > 0)
         kList = fList;
       }
      }
      if (!Array.isArray(kList) || kList.length < 1)
       kList = cSafe;
      if (!Array.isArray(kList) || kList.length < 1)
       kList = bareList;
      const sW = window.innerWidth;
      const sH = window.innerHeight;
      const eH = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
      const eHh = Math.max(cfg.emote.size.min, Math.min(Math.floor(cfg.emote.size.max / 2), Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small)));
      const sB = sH - eH;
      document.documentElement.style.setProperty('--height', sH + 'px');
      document.documentElement.style.setProperty('--width', sW + 'px');
      const waitFor = _getKappaCountEstimate(kStyle);
      if (!_canShowKappa(kStyle))
      {
       _toKappa.push({list: kList, style: kStyle.style, prefs: kStyle.prefs, params: kParams});
       if (_tKappa !== false)
       {
        window.clearTimeout(_tKappa);
        _tKappa = false;
       }
       _tKappa = window.setTimeout(_showKappas, _dKappa);
       return;
      }
      _eActive += waitFor;
      const lK = kList.length;
      const tInit = new Date().getTime();
      let estMS = Math.floor(cfg.emote.time * 1000);
      if (timing.kappa.hasOwnProperty(kStyle.style) && timing.kappa[kStyle.style].hasOwnProperty('time'))
       estMS = Math.floor(cfg.emote.time * 1000 * timing.kappa[kStyle.style].time);
      else if (timing.display.hasOwnProperty(kStyle.style) && timing.display[kStyle.style].hasOwnProperty('time'))
       estMS = Math.floor(cfg.emote.time * 1000 * timing.display[kStyle.style].time);
      switch (kStyle.style)
      {
       case 'Stampede':
        await _list.Stampede(kList, sW, sH, eH, kStyle.count);
        _eActive -= kStyle.count;
        break;
       case 'Fireworks':
        _list.Fireworks(kList, sW, sH, eHh, kStyle.count);
        break;
       case 'Spiral':
        _list.Spiral(kList, sW, sH, eHh, kStyle.count);
        break;
       case 'Pyramid':
        _list.Pyramid(kList, sW, sH);
        break;
       case 'SmallPyramid':
        _list.SmallPyramid(kList, sW, sH);
        break;
       case 'Conga':
        _eActive -= waitFor;
        let avoidMiddle = false;
        if (cfg.display.kappa.conga.hasOwnProperty('avoidMiddle') && cfg.display.kappa.conga.avoidMiddle === true)
         avoidMiddle = true;
        if (kStyle.prefs.hasOwnProperty('avoidMiddle') && kStyle.prefs.avoidMiddle === true)
         avoidMiddle = true;
        _list.Conga(kList, sW, sH, eH, avoidMiddle);
        break;
       case 'Text':
        _eActive -= waitFor;
        let sTM = 'HYPE!';
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('message'))
         sTM = cfg.display.kappa.styles[kStyle.style].message[shared.rnd(cfg.display.kappa.styles[kStyle.style].message.length)];
        if (kStyle.prefs.hasOwnProperty('message') && Array.isArray(kStyle.prefs.message) && kStyle.prefs.message.length > 0)
         sTM = kStyle.prefs.message[shared.rnd(kStyle.prefs.message.length)];
        let sTT = cfg.emote.time;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('time'))
         sTT = cfg.display.kappa.styles[kStyle.style].time;
        if (kStyle.prefs.hasOwnProperty('time') && kStyle.prefs.time > 0)
         sTT = kStyle.prefs.time;
        if (kParams !== false)
        {
         const pK = Object.keys(kParams);
         for (let i = 0, l = pK.length; i < l; i++)
         {
          sTM = sTM.replaceAll(pK[i], kParams[pK[i]]);
         }
        }
        _list.Text(kList, sW, sH, sTM, sTT);
        break;
       case 'TheCube':
        _eActive -= waitFor;
        const cS = Math.min(sW, sH);
        const rC = shared.rnd(lK);
        let sCS = 8 / 10;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('size'))
         sCS = cfg.display.kappa.styles[kStyle.style].size;
        if (kStyle.prefs.hasOwnProperty('size'))
         sCS = kStyle.prefs.size;
        let sCC = true;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('center'))
         sCC = cfg.display.kappa.styles[kStyle.style].center;
        if (kStyle.prefs.hasOwnProperty('center'))
         sCC = kStyle.prefs.center;
        let sCR = 5;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('rotations'))
         sCR = cfg.display.kappa.styles[kStyle.style].rotations;
        if (kStyle.prefs.hasOwnProperty('rotations'))
         sCR = kStyle.prefs.rotations;
        _list.TheCube(kList[rC], sW, sH, Math.floor(cS * sCS), sCC, sCR);
        break;
       case 'Burst':
        const oH = _rndFromRange(timing.kappa[kStyle.style].left);
        const oV = _rndFromRange(timing.kappa[kStyle.style].top) * sB;
        const bA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rB = shared.rnd(lK);
         _eActive--;
         let eWb = eH;
         if (kList[rB].hasOwnProperty('width') && kList[rB].hasOwnProperty('height'))
          eWb = kList[rB].width / kList[rB].height * eH;
         const sRb = sW - Math.ceil(eWb / 2);
         display.emote.list.StraightLine(kList[rB], sW, sH, eH, oH * sRb, oV, false, tInit);
         if (i % bA.ct === bA.ct - 1)
          await _fPause(bA.f);
        }
        break;
       case 'Fountain':
        const fX = _rndFromRange(timing.kappa[kStyle.style].left) * sW;
        const fY = _rndFromRange(timing.kappa[kStyle.style].top);
        const fA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rF = shared.rnd(lK);
         _eActive--;
         display.emote.list.Fountain(kList[rF], sW, sH, eH, fX, fY, false, tInit);
         if (i % fA.ct === fA.ct - 1)
          await _fPause(fA.f);
        }
        break;
       case 'Confetti':
        const cA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rN = shared.rnd(lK);
         _eActive--;
         display.emote.list.Confetti(kList[rN], sW, sH, eHh, false, tInit);
         if (i % cA.ct === cA.ct - 1)
          await _fPause(cA.f);
        }
        break;
       default:
        if (typeof display.emote.list[kStyle.style] === 'undefined')
         return;
        const kA = _kAcTime(kStyle.count, estMS);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const r = shared.rnd(lK);
         _eActive--;
         if (kStyle.style === 'StraightLine')
          display.emote.list.StraightLine(kList[r], sW, sH, eH, false, false, false, tInit);
         else
          display.emote.list[kStyle.style](kList[r], sW, sH, eH, false, tInit);
         if (i % kA.ct === kA.ct - 1)
          await _fPause(kA.f);
        }
      }
     }

     function $hide()
     {
      if (_tKappa !== false)
      {
       window.clearTimeout(_tKappa);
       _tKappa = false;
      }
      _toKappa.length = 0;
      _conga.length = 0;
     }

     function _sleep(ms)
     {
      if (ms < shared.mspf.value)
       return _fPause();
      return new Promise(
       function(resolve)
       {
        let n = 0;
        function _next(ts)
        {
         if (n === 0)
         {
          n = ts;
          window.requestAnimationFrame(_next);
          return;
         }
         else if (ts - n < ms)
         {
          window.requestAnimationFrame(_next);
          return;
         }
         resolve(true);
        }
        window.requestAnimationFrame(_next);
       }
      );
     }

     function _fPause(frames = 1)
     {
      return new Promise(
       function(resolve)
       {
        if (frames < 1)
        {
         resolve(false);
         return;
        }
        let n = 0;
        function _next()
        {
         n++;
         if (n < frames)
         {
          window.requestAnimationFrame(_next);
          return;
         }
         resolve(true);
        }
        window.requestAnimationFrame(_next);
       }
      );
     }

     function _kAcTime(ct, t = false)
     {
      if (t === false)
       t = Math.floor(cfg.emote.time * 1000);
      const f = Math.floor(t / shared.mspf.value);
      const r = f / ct;
      if (r > 1)
       return {f: Math.ceil(r), ct: 1};
      return {f: 1, ct: Math.ceil(1 / r)};
     }

     return {
      show: $show,
      hide: $hide
     };
    }();

    const _gc = function()
    {
     let _toGC = {};

     let _tGC = false;

     function _doGC()
     {
      if (_tGC === false)
       return;
      window.clearTimeout(_tGC);
      _tGC = false;
      let done = true;
      const tNow = new Date().getTime();
      for (const idx in _toGC)
      {
       if (!_toGC.hasOwnProperty(idx))
        continue;
       done = false;
       const i = _toGC[idx].img;
       const t = _toGC[idx].end;
       const d = _toGC[idx].dec;
       if (_toGC[idx].space)
       {
        const r = i.getBoundingClientRect();
        if (t > tNow && r.bottom > 0 && r.right > 0 && r.top < window.innerHeight && r.left < window.innerWidth)
         continue;
       }
       else
       {
        if (t > tNow)
         continue;
       }
       delete _toGC[idx];
       if (i.parentNode !== null)
        document.body.removeChild(i);
       if (d)
        _eActive--;
      }
      if (!done)
       _tGC = window.setTimeout(_doGC, 500);
     }

     function $hook(img, space = true, decActive = true, t = false)
     {
      if (t === false)
       t = Math.floor(cfg.emote.time * 1000);
      let x = 0;
      do
      {
       x++;
      } while (_toGC.hasOwnProperty(x));
      _toGC[x] = {img: img, space: space, dec: decActive, end: new Date().getTime() + t};
      if (_tGC === false)
       _tGC = window.setTimeout(_doGC, 500);
     }

     return {
      hook: $hook
     };
    }();

    function _rndFromRange(range)
    {
     return shared.rnd(range.max - range.min) + range.min;
    }

    function _safePoints(h, v, th, r, fL, fT, fR, fB)
    {
     const hD = Math.floor(h + r * Math.cos(th));
     const vD = Math.floor(v + r * Math.sin(th));
     const slope = Math.tan(th);
     let hL = Number.MAX_SAFE_INTEGER;
     let hU = 0;
     let vL = Number.MAX_SAFE_INTEGER;
     let vU = 0;
     if (hD < fL)
      hL = h - (hU = fL);
     else if (hD > fR)
      hL = (hU = fR) - h;
     if (vD < fT)
      vL = v - (vU = fT);
     else if (vD > fB)
      vL = (vU = fB) - v;
     if (vU === 0 && hU === 0)
      return true;
     let vT = vU;
     let hT = hU;
     if (hL > vL)
      hT = Math.floor((vT - v) / slope + h);
     else
      vT = Math.floor((hT - h) * slope + v);
     const l = Math.sqrt(Math.abs(h - hT) ** 2 + Math.abs(v - vT) ** 2);
     return (l > Math.ceil(r / 2));
    }

    function _addEmoteToDoc(tInit, uri, variationSize, attrs = {}, r = false, oGC = {}, oT = false)
    {
     if (_iTitanic > tInit)
      return;
     let img = document.createElement('img');
     let c = [];
     c.push('emote');
     if (attrs.hasOwnProperty('classes'))
      c.push(...attrs.classes);
     if (variationSize === 0)
      c.push('eHalf');
     else if (variationSize === 2)
      c.push('eDouble');
     else
      c.push('eNorm');
     img.classList.add(...c);
     _setImgSrc(img, uri);
     if (attrs.hasOwnProperty('style'))
      img.setAttribute('style', attrs.style);
     if (attrs.hasOwnProperty('dataset'))
     {
      for (let i = 0, k = Object.keys(attrs.dataset); i < k.length; i++)
      {
       img.setAttribute('data-' + k[i], attrs.dataset[k[i]]);
      }
     }
     _eActive++;
     document.body.appendChild(img);
     let space = true;
     let decActive = true;
     let t = false;
     if (oGC !== false)
     {
      if (oGC.hasOwnProperty('space'))
       space = oGC.space;
      if (oGC.hasOwnProperty('decrement'))
       decActive = oGC.decrement;
      if (oGC.hasOwnProperty('time'))
       t = oGC.time;
      _gc.hook(img, space, decActive, t);
     }
     if (oT !== false)
     {
      let sTF = null;
      if (oT.hasOwnProperty('x') && oT.hasOwnProperty('y'))
       sTF = 'translate(' + oT.x + 'px, ' + oT.y + 'px)';
      else if (oT.hasOwnProperty('x'))
       sTF = 'translateX(' + oT.x + 'px)';
      else if (oT.hasOwnProperty('y'))
       sTF = 'translateY(' + oT.y + 'px)';
      if (sTF !== null)
       shared.doNextFrame(_tMoveOnDock, tInit, img, sTF);
     }
     if (r)
      return img;
    }

    function _tMoveOnDock(tInit, img, sTF)
    {
     if (_iTitanic > tInit)
      return;
     img.style.transform = sTF;
    }

    function _setImgSrc(img, url)
    {
     img.alt = '';
     img.onload = function()
     {
      img.onerror = null;
      img.onload = null;
      if (img.naturalWidth !== img.naturalHeight)
       shared.ec.save(url, img.naturalWidth, img.naturalHeight);
     };
     img.onerror = function()
     {
      img.onerror = null;
      img.onload = null;
      img.src = bareList[shared.rnd(bareList.length)].url;
     };
     img.src = url;
    }

    function _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters)
    {
     let s = '';
     if (aNames.length > 0)
     {
      s += ' animation-name: ' + aNames.join() + ';';
      s += ' animation-delay: ' + aDelays.join() + ';';
      s += ' animation-duration: ' + aDurs.join() + ';';
      s += ' animation-timing-function: ' + aTimings.join() + ';';
      s += ' animation-fill-mode: ' + aFills.join() + ';';
      s += ' animation-iteration-count: ' + aIters.join() + ';';
     }
     if (aNames.includes('fadeIn'))
      s += ' opacity: 0;';
     return s;
    }

    function _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, fadeIn = true, zoomIn = true, fadeOut = true, zoomOut = true, tMS = false)
    {
     if (tMS === false)
      tMS = Math.floor(cfg.emote.time * 1000);
     const tFI = _tAnim.fade.in / 100;
     const tFO = _tAnim.fade.out / 100;
     const tZI = _tAnim.zoom.in / 100;
     const tZO = _tAnim.zoom.out / 100;
     if (fadeIn)
     {
      aNames.push('fadeIn');
      aDelays.push('0s');
      aDurs.push(Math.floor(tMS * tFI) + 'ms');
      aTimings.push('ease-in');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (zoomIn)
     {
      aNames.push('zoomIn');
      aDelays.push('0s');
      aDurs.push(Math.floor(tMS * tZI) + 'ms');
      aTimings.push('linear');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (fadeOut)
     {
      aNames.push('fadeOut');
      aDelays.push(Math.floor(tMS - tMS * tFO) + 'ms');
      aDurs.push(Math.floor(tMS * tFO) + 'ms');
      aTimings.push('ease-out');
      aFills.push('forwards');
      aIters.push('1');
     }
     else
     {
      aNames.push('noFadeOut');
      aDelays.push(tMS - 50 + 'ms');
      aDurs.push('50ms');
      aTimings.push('ease-out');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (zoomOut)
     {
      aNames.push('zoomOut');
      aDelays.push(Math.floor(tMS - tMS * tZO) + 'ms');
      aDurs.push(Math.floor(tMS * tZO) + 'ms');
      aTimings.push('linear');
      aFills.push('forwards');
      aIters.push('1');
     }
     return _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
    }

    function $eraseAll()
    {
     _iTitanic = new Date().getTime();
     display.kappa.hide();
     let cubes = document.getElementsByClassName('scene');
     while (cubes.length)
      cubes[0].parentElement.removeChild(cubes[0]);
     let imgs = document.getElementsByTagName('img');
     while (imgs.length)
      imgs[0].parentElement.removeChild(imgs[0]);
     twitch.parse.clearCooldowns();
    }

    return {
     emote: $emote,
     kappa: $kappa,
     eraseAll: $eraseAll
    };
   }();

   const twitch = function()
   {
    let _rList = {};
    let _aTagged = {};

    const $net = function()
    {
     async function _loadCheer_channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('cheer'))
       thirdparty.emotes.cheer = {};
      const url = cURLs.api.twitch.bits.cheermotes.replaceAll('%CHANNEL_ID%', chID);
      const h = {
       'Authorization': 'Bearer ' + cfg.login.oauth,
       'Client-Id': cfg.login.client
      };
      const r = await shared.httpRequest('GET', url, h);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('data'))
       return false;
      for (let c = 0, l = j.data.length; c < l; c++)
      {
       const set = j.data[c];
       if (!set.hasOwnProperty('prefix'))
        continue;
       if (!set.hasOwnProperty('tiers'))
        continue;
       const prefix = set.prefix;
       let tierList = [];
       for (let i = set.tiers.length - 1; i >= 0; i--)
       {
        if (!set.tiers[i].hasOwnProperty('min_bits'))
         continue;
        if (!set.tiers[i].hasOwnProperty('images'))
         continue;
        const amt = set.tiers[i].min_bits;
        let img = null;
        if (set.tiers[i].images.hasOwnProperty('dark'))
        {
         if (set.tiers[i].images.dark.hasOwnProperty('animated'))
         {
          if (set.tiers[i].images.dark.animated.hasOwnProperty('4'))
           img = set.tiers[i].images.dark.animated['4'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('3'))
           img = set.tiers[i].images.dark.animated['3'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('2'))
           img = set.tiers[i].images.dark.animated['2'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('1.5'))
           img = set.tiers[i].images.dark.animated['1.5'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('1'))
           img = set.tiers[i].images.dark.animated['1'];
         }
         else if (set.tiers[i].images.dark.hasOwnProperty('static'))
         {
          if (set.tiers[i].images.dark.static.hasOwnProperty('4'))
           img = set.tiers[i].images.dark.static['4'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('3'))
           img = set.tiers[i].images.dark.static['3'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('2'))
           img = set.tiers[i].images.dark.static['2'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('1.5'))
           img = set.tiers[i].images.dark.static['1.5'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('1'))
           img = set.tiers[i].images.dark.static['1'];
         }
        }
        else if (set.tiers[i].images.hasOwnProperty('light'))
        {
         if (set.tiers[i].images.light.hasOwnProperty('animated'))
         {
          if (set.tiers[i].images.light.animated.hasOwnProperty('4'))
           img = set.tiers[i].images.light.animated['4'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('3'))
           img = set.tiers[i].images.light.animated['3'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('2'))
           img = set.tiers[i].images.light.animated['2'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('1.5'))
           img = set.tiers[i].images.light.animated['1.5'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('1'))
           img = set.tiers[i].images.light.animated['1'];
         }
         else if (set.tiers[i].images.light.hasOwnProperty('static'))
         {
          if (set.tiers[i].images.light.static.hasOwnProperty('4'))
           img = set.tiers[i].images.light.static['4'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('3'))
           img = set.tiers[i].images.light.static['3'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('2'))
           img = set.tiers[i].images.light.static['2'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('1.5'))
           img = set.tiers[i].images.light.static['1.5'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('1'))
           img = set.tiers[i].images.light.static['1'];
         }
        }
        if (img === null)
         continue;
        tierList.push({min: amt, img: img});
       }
       thirdparty.emotes.cheer[prefix] = tierList;
      }
      return true;
     }

     const _eventSub = function()
     {
      let _wsURL = cURLs.ws.twitch.eventSub;
      let _wsRetry = null;
      let _ws = null;
      let _oldWS = null;
      let _lTimeout = 5000;
      let _tTimeout = false;
      const _lOldTimeout = 10000;
      let _tOldTimeout = false;

      function task(chID = null)
      {
       if (chID !== null)
        twitch.net.eventSubCtl.channelID = chID;
       _ws = new WebSocket(_wsURL);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      }

      function _wsClose()
      {
       notice.error(0x1A);
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws !== null)
       {
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
       }
       if (twitch.net.dead)
        return;
       if (_wsURL.length > cURLs.ws.twitch.eventSub.length && _wsURL.slice(0, cURLs.ws.twitch.eventSub.length) === cURLs.ws.twitch.eventSub)
        _wsURL = cURLs.ws.twitch.eventSub;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(_eventSub, wsWait);
      }

      async function _wsMessage(ev)
      {
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (twitch.net.dead)
       {
        if (_ws === null)
         return;
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        return;
       }
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
       const r = JSON.parse(ev.data);
       if (!r.hasOwnProperty('metadata'))
        return;
       if (!r.hasOwnProperty('payload'))
        return;
       notice.info(0x1A);
       switch (r.metadata.message_type)
       {
        case 'session_welcome':
         if (_oldWS !== null)
         {
          _oldWS.close();
          _oldWS = null;
          if (_tOldTimeout !== false)
          {
           window.clearTimeout(_tOldTimeout);
           _tOldTimeout = false;
          }
         }
         if (!r.payload.hasOwnProperty('session'))
          return;
         if (r.payload.session.hasOwnProperty('id'))
          twitch.net.eventSubCtl.sessionID = r.payload.session.id;
         if (r.payload.session.hasOwnProperty('keepalive_timeout_seconds'))
         {
          _lTimeout = parseInt(r.payload.session.keepalive_timeout_seconds, 10) * 2 * 1000;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
         }
         const haveSubs = await twitch.net.eventSubCtl.init();
         if (!haveSubs)
         {
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          if (_ws !== null)
          {
           _ws.onopen = null;
           _ws.onmessage = null;
           _ws.onclose = null;
           _ws.close();
           _ws = null;
          }
          return;
         }
         if (r.payload.session.hasOwnProperty('id'))
          await shared.httpRequest('POST', cURLs.api.rr.feedback.eventsub, {'Content-Type': 'application/x-www-form-urlencoded'}, 'type=new&id=' + encodeURIComponent(twitch.net.eventSubCtl.sessionID), false, false);
         break;
        case 'session_keepalive':
         _wsRetry = 0;
         await shared.httpRequest('POST', cURLs.api.rr.feedback.eventsub, {'Content-Type': 'application/x-www-form-urlencoded'}, 'type=recv&id=' + encodeURIComponent(twitch.net.eventSubCtl.sessionID), false, false);
         break;
        case 'notification':
         await shared.httpRequest('POST', cURLs.api.rr.feedback.eventsub, {'Content-Type': 'application/x-www-form-urlencoded'}, 'type=recv&id=' + encodeURIComponent(twitch.net.eventSubCtl.sessionID), false, false);
         if (!r.metadata.hasOwnProperty('subscription_type'))
          return;
         switch (r.metadata.subscription_type)
         {
          case 'channel.follow':
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('user_id'))
            return;
           if (cfg.ignore.users !== false && r.payload.event.hasOwnProperty('user_login') && cfg.ignore.users.includes(r.payload.event.user_login))
            return;
           if (!r.payload.event.hasOwnProperty('user_name'))
            return;
           twitch.net.fList[r.payload.event.user_id] = {value: true, t: new Date().getTime()};
           if (cfg.event.follow === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           display.kappa.show(false, cfg.event.follow, {'%USER%': r.payload.event.user_name});
           break;
          case 'channel.channel_points_custom_reward_redemption.add':
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('reward'))
            return;
           if (!r.payload.event.reward.hasOwnProperty('title'))
            return;
           if (cfg.ignore.users !== false && r.payload.event.hasOwnProperty('user_login') && cfg.ignore.users.includes(r.payload.event.user_login))
            return;
           const n = r.payload.event.reward.title;
           if (!r.payload.event.hasOwnProperty('user_input') || r.payload.event.user_input === '')
           {
            await twitch.parse.event.redeem(n, false);
            return;
           }
           if (!r.payload.event.reward.hasOwnProperty('id'))
            return;
           const lnID = r.payload.event.reward.id;
           if (!_rList.hasOwnProperty(lnID))
           {
            _rList[lnID] = {name: n, cmds: []};
            return;
           }
           if (_rList[lnID].name === false)
            _rList[lnID].name = n;
           while (_rList[lnID].cmds.length > 0)
           {
            await twitch.parse.event.redeem(n, _rList[lnID].cmds.shift());
           }
           break;
          case 'channel.shoutout.create':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('to_broadcaster_user_id'))
            return;
           if (!r.payload.event.hasOwnProperty('to_broadcaster_user_name'))
            return;
           await twitch.parse.event.shoutoutCreate(r.payload.event.to_broadcaster_user_id, r.payload.event.to_broadcaster_user_name);
           break;
          case 'channel.shoutout.receive':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('from_broadcaster_user_id'))
            return;
           if (cfg.ignore.users !== false && r.payload.event.hasOwnProperty('from_broadcaster_user_login') && cfg.ignore.users.includes(r.payload.event.from_broadcaster_user_login))
            return;
           if (!r.payload.event.hasOwnProperty('from_broadcaster_user_name'))
            return;
           await twitch.parse.event.shoutoutReceive(r.payload.event.from_broadcaster_user_id, r.payload.event.from_broadcaster_user_name);
           break;
          case 'channel.hype_train.begin':
           if (cfg.event.hypetrain === false)
            return;
           if (!cfg.event.hypetrain.hasOwnProperty('begin'))
            return;
           if (cfg.event.hypetrain.begin === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           display.kappa.show(false, cfg.event.hypetrain.begin);
           break;
          case 'channel.hype_train.end':
           if (cfg.event.hypetrain === false)
            return;
           if (!cfg.event.hypetrain.hasOwnProperty('success'))
            return;
           if (cfg.event.hypetrain.success === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('level'))
            return;
           const rs = shared.findInMaybeRange(cfg.event.hypetrain.success, r.payload.event.level);
           if (rs === false)
            return;
           display.kappa.show(false, rs);
           break;
          case 'channel.poll.begin':
           if (cfg.event.poll === false)
            return;
           if (!cfg.event.poll.hasOwnProperty('begin'))
            return;
           if (cfg.event.poll.begin === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           display.kappa.show(false, cfg.event.poll.begin, {'%TITLE%': r.payload.event.title});
           break;
          case 'channel.poll.end':
           if (cfg.event.poll === false)
            return;
           if (!cfg.event.poll.hasOwnProperty('end'))
            return;
           if (cfg.event.poll.end === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           if (!r.payload.event.hasOwnProperty('status') || r.payload.event.status !== 'completed')
            return;
           if (!r.payload.event.hasOwnProperty('choices'))
            return;
           twitch.parse.event.pollEnd(r.payload.event);
           break;
          case 'channel.prediction.begin':
           if (cfg.event.prediction === false)
            return;
           if (!cfg.event.prediction.hasOwnProperty('begin'))
            return;
           if (cfg.event.prediction.begin === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           display.kappa.show(false, cfg.event.prediction.begin, {'%TITLE%': r.payload.event.title});
           break;
          case 'channel.prediction.end':
           if (cfg.event.prediction === false)
            return;
           if (!cfg.event.prediction.hasOwnProperty('resolved'))
            return;
           if (cfg.event.prediction.resolved === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           if (!r.payload.event.hasOwnProperty('status') || r.payload.event.status !== 'resolved')
            return;
           if (!r.payload.event.hasOwnProperty('winning_outcome_id'))
            return;
           if (!r.payload.event.hasOwnProperty('outcomes'))
            return;
           twitch.parse.event.predictionEnd(r.payload.event);
           break;
          case 'channel.charity_campaign.donate':
           if (cfg.event.charity === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('user_name'))
            return;
           const dName = r.payload.event.user_name;
           if (!r.payload.event.hasOwnProperty('amount'))
            return;
           if (!r.payload.event.amount.hasOwnProperty('value'))
            return;
           if (!r.payload.event.amount.hasOwnProperty('decimal_places'))
            return;
           if (!r.payload.event.amount.hasOwnProperty('currency'))
            return;
           const dAmt = r.payload.event.amount.value / Math.pow(10, r.payload.event.decimal_places) + ' ' + r.payload.event.amount.currency;
           const rd = shared.findInMaybeRange(cfg.event.charity, r.payload.event.amount.value);
           if (rd === false)
            return;
           display.kappa.show(false, rd, {'%USER%': dName, '%AMOUNT%': dAmt});
           break;
          case 'channel.goal.begin':
           if (cfg.event.goal === false)
            return;
           if (!cfg.event.goal.hasOwnProperty('begin'))
            return;
           if (cfg.event.goal.begin === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('type'))
            return;
           if (!r.payload.event.hasOwnProperty('description'))
            return;
           if (!r.payload.event.hasOwnProperty('target_amount'))
            return;
           display.kappa.show(false, cfg.event.goal.begin, {'%TITLE%': r.payload.event.description, '%TYPE%': r.payload.event.type, '%AMOUNT%': r.payload.event.target_amount});
           break;
          case 'channel.goal.end':
           if (cfg.event.goal === false)
            return;
           if (!cfg.event.goal.hasOwnProperty('achieved'))
            return;
           if (cfg.event.goal.achieved === false)
            return;
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('type'))
            return;
           if (!r.payload.event.hasOwnProperty('description'))
            return;
           if (!r.payload.event.hasOwnProperty('current_amount'))
            return;
           if (!r.payload.event.hasOwnProperty('is_achieved') || r.payload.event.is_achieved !== true)
            return;
           display.kappa.show(false, cfg.event.goal.achieved, {'%TITLE%': r.payload.event.description, '%TYPE%': r.payload.event.type, '%AMOUNT%': r.payload.event.current_amount});
           break;
          case 'channel.update':
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           await _addToChannelTitleTags(r.payload.event.title);
           break;
         }
         break;
        case 'session_reconnect':
         if (!r.payload.hasOwnProperty('session'))
          return;
         if (_tTimeout !== false)
         {
          window.clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         if (r.payload.session.hasOwnProperty('id'))
          twitch.net.eventSubCtl.sessionID = r.payload.session.id;
         if (r.payload.session.hasOwnProperty('keepalive_timeout_seconds') && r.payload.session.keepalive_timeout_seconds !== null)
          _lTimeout = parseInt(r.payload.session.keepalive_timeout_seconds, 10) * 2 * 1000;
         if (_ws !== null)
         {
          if (r.payload.session.hasOwnProperty('reconnect_url'))
           _wsURL = r.payload.session.reconnect_url;
          _oldWS = _ws;
          _oldWS.onclose = null;
          _oldWS.onmessage = null;
          _tOldTimeout = window.setTimeout(_oldWSTimeout, _lOldTimeout);
          _ws = null;
         }
         const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
         if (_wsRetry < 2)
          _wsRetry += 0.2;
         window.setTimeout(_eventSub, wsWait);
         break;
        case 'revocation':
         if (!r.metadata.hasOwnProperty('subscription_type'))
          return;
         const subType = r.metadata.subscription_type;
         let subVer = '1';
         if (r.metadata.hasOwnProperty('subscription_version'))
          subVer = r.metadata.subscription_version;
         await twitch.net.eventSubCtl.subscribe(subType, subVer);
         break;
       }
      }

      function _wsTimeout()
      {
       notice.error(0x1A);
       _lTimeout = 5000;
       if (_wsURL.length > cURLs.ws.twitch.eventSub.length && _wsURL.slice(0, cURLs.ws.twitch.eventSub.length) === cURLs.ws.twitch.eventSub)
        _wsURL = cURLs.ws.twitch.eventSub;
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (twitch.net.dead === true)
        return;
       _eventSub();
      }

      function _oldWSTimeout()
      {
       if (_tOldTimeout !== false)
       {
        window.clearTimeout(_tOldTimeout);
        _tOldTimeout = false;
       }
       if (_oldWS === null)
        return;
       _oldWS.onopen = null;
       _oldWS.onmessage = null;
       _oldWS.onclose = null;
       _oldWS.close();
       _oldWS = null;
      }

      return task;
     }();

     const $eventSubCtl = function()
     {
      async function $init()
      {
       const aSubs = [
        {id: 'channel.follow', v: '2', scope: ['moderator:read:followers'], cfg: ['event.follow']},
        {id: 'channel.channel_points_custom_reward_redemption.add', scope: ['channel:read:redemptions'], cfg: false},
        {id: 'channel.shoutout.create', scope: ['moderator:read:shoutouts'], cfg: ['event.shoutout.create.styles']},
        {id: 'channel.shoutout.receive', scope: ['moderator:read:shoutouts'], cfg: ['event.shoutout.receive.styles']},
        {id: 'channel.hype_train.begin', scope: ['channel:read:hype_train'], cfg: ['event.hypetrain.begin']},
        {id: 'channel.hype_train.end', scope: ['channel:read:hype_train'], cfg: ['event.hypetrain.success']},
        {id: 'channel.poll.begin', scope: ['channel:read:polls'], cfg: ['event.poll.begin']},
        {id: 'channel.poll.end', scope: ['channel:read:polls'], cfg: ['event.poll.end']},
        {id: 'channel.prediction.begin', scope: ['channel:read:predictions'], cfg: ['event.prediction.begin']},
        {id: 'channel.prediction.end', scope: ['channel:read:predictions'], cfg: ['event.prediction.resolved']},
        {id: 'channel.goal.begin', scope: ['channel:read:goals'], cfg: ['event.goal.begin']},
        {id: 'channel.goal.end', scope: ['channel:read:goals'], cfg: ['event.goal.achieved']},
        {id: 'channel.charity_campaign.donate', scope: ['channel:read:charity'], cfg: ['event.charity']},
        {id: 'channel.update', scope: false, cfg: ['event.tag.styles']}
       ];
       const aActive = await _cleanAndRecover();
       let didSomething = aActive.length > 0;
       for (let i = 0, l = aSubs.length; i < l; i++)
       {
        if (await _handleSub(aSubs[i], aActive) !== false)
         didSomething = true;
       }
       return didSomething;
      }

      async function _handleSub(sub, aActive)
      {
       if (sub.hasOwnProperty('cfg') && sub.cfg !== false)
       {
        let found = true;
        for (let i = 0, l = sub.cfg.length; i < l; i++)
        {
         let aPref = sub.cfg[i].split('.');
         let cPref = cfg;
         found = true;
         for (let j = 0, m = aPref.length; j < m; j++)
         {
          if (!cPref.hasOwnProperty(aPref[j]))
          {
           found = false;
           break;
          }
          if (cPref[aPref[j]] === false)
          {
           found = false;
           break;
          }
          cPref = cPref[aPref[j]];
         }
         if (found !== false)
          break;
        }
        if (found === false)
         return false;
       }
       else if (sub.id === 'channel.channel_points_custom_reward_redemption.add')
       {
        let found = false;
        for (const k of cfg.commands)
        {
         if (!k.hasOwnProperty('redeem') || !Array.isArray(k.redeem) || k.redeem.length < 1)
          continue;
         found = true;
         break;
        }
        if (found === false)
         return false;
       }
       if (sub.hasOwnProperty('scope') && sub.scope !== false)
       {
        for (let i = 0, l = sub.scope.length; i < l; i++)
        {
         if (!cfg.login.scope.includes(sub.scope[i]))
          return false;
        }
       }
       if (aActive.includes(sub.id))
        return false;
       if (!sub.hasOwnProperty('v'))
        return twitch.net.eventSubCtl.subscribe(sub.id);
       return twitch.net.eventSubCtl.subscribe(sub.id, sub.v);
      }

      async function _getList()
      {
       const h = {
        'Authorization': 'Bearer ' + cfg.login.oauth,
        'Client-Id': cfg.login.client
       };
       const r = await shared.httpRequest('GET', cURLs.api.twitch.eventSub.get, h);
       if (!r.success)
        return [];
       const j = r.json;
       if (j === null)
        return [];
       if (!j.hasOwnProperty('data'))
        return [];
       if (!j.hasOwnProperty('total'))
        return [];
       if (j.total < 1)
        return [];
       return j.data;
      }

      async function $erase()
      {
       const d = await _getList();
       if (d.length < 1)
        return;
       for (let i = 0, l = d.length; i < l; i++)
       {
        if (!d[i].hasOwnProperty('id'))
         continue;
        if (!d[i].hasOwnProperty('transport'))
         continue;
        if (!d[i].transport.hasOwnProperty('session_id'))
         continue;
        await _unsubscribe(d[i].id, d[i].transport.session_id);
       }
       window.location.reload();
      }

      async function _cleanAndRecover()
      {
       const d = await _getList();
       if (d.length < 1)
        return [];
       let rList = [];
       for (let i = 0, l = d.length; i < l; i++)
       {
        if (!d[i].hasOwnProperty('id'))
         continue;
        if (!d[i].hasOwnProperty('status'))
         continue;
        switch (d[i].status)
        {
         case 'enabled':
          if (!d[i].hasOwnProperty('type'))
           continue;
          if (!d[i].hasOwnProperty('transport'))
           continue;
          if (!d[i].transport.hasOwnProperty('method'))
           continue;
          if (d[i].transport.method !== 'websocket')
           continue;
          if (!d[i].transport.hasOwnProperty('session_id'))
           continue;
          if (d[i].transport.session_id !== twitch.net.eventSubCtl.sessionID)
           continue;
          rList.push(d[i].type);
          break;
         case 'authorization_revoked':
         case 'moderator_removed':
         case 'user_removed':
         case 'version_removed':
         case 'websocket_disconnected':
         case 'websocket_failed_ping_pong':
         case 'websocket_received_inbound_traffic':
         case 'websocket_connection_unused':
         case 'websocket_internal_error':
         case 'websocket_network_timeout':
         case 'websocket_network_error':
          if (!d[i].hasOwnProperty('transport'))
           continue;
          if (!d[i].transport.hasOwnProperty('session_id'))
           continue;
          await _unsubscribe(d[i].id, d[i].transport.session_id);
          break;
        }
       }
       return rList;
      }

      async function $subscribe(type, version = '1')
      {
       let d = {
        'type': type,
        'version': version,
        'condition': {'broadcaster_user_id': twitch.net.eventSubCtl.channelID},
        'transport': {'method': 'websocket', 'session_id': twitch.net.eventSubCtl.sessionID}
       };
       switch (type)
       {
        case 'channel.follow':
        case 'channel.shoutout.create':
        case 'channel.shoutout.receive':
         d.condition.moderator_user_id = twitch.net.eventSubCtl.channelID;
         break;
       }
       const h = {
        'Authorization': 'Bearer ' + cfg.login.oauth,
        'Client-Id': cfg.login.client,
        'Content-Type': 'application/json'
       };
       const r = await shared.httpRequest('POST', cURLs.api.twitch.eventSub.get, h, JSON.stringify(d), false);
       if (r.success)
        return true;
       if (r.code === 429)
       {
        const eNote = document.getElementById('notice' + 0x1A);
        if (!eNote || !eNote.classList.contains('noticeWarning'))
        {
         if (!await _handleDanglingEventSubs())
          notice.warning(0x1A);
        }
       }
       return false;
      }

      async function _handleDanglingEventSubs()
      {
       const d = await _getList();
       if (d.length < 1)
        return false;
       let ids = {};
       for (let i = 0, l = d.length; i < l; i++)
       {
        if (!d[i].hasOwnProperty('id'))
         continue;
        if (!d[i].hasOwnProperty('status'))
         continue;
        if (d[i].status !== 'enabled')
         continue;
        if (!d[i].hasOwnProperty('transport'))
         continue;
        if (!d[i].transport.hasOwnProperty('method'))
         continue;
        if (d[i].transport.method !== 'websocket')
         continue;
        if (!d[i].transport.hasOwnProperty('session_id'))
         continue;
        if (!Object.keys(ids).includes(d[i].transport.session_id))
         ids[d[i].transport.session_id] = [];
        ids[d[i].transport.session_id].push(d[i].id);
       }
       if (Object.keys(ids).length < 1)
        return false;
       let b = 'type=check&ids=' + encodeURIComponent(Object.keys(ids).join(' '));
       for (let id in ids)
       {
        if (!id.hasOwnProperty(id))
         continue;
        b += '&sub' + encodeURIComponent(id) + '=' + encodeURIComponent(ids[id].join(' '));
       }
       const r = await shared.httpRequest('POST', cURLs.api.rr.feedback.eventsub, {'Content-Type': 'application/x-www-form-urlencoded'}, b, false);
       if (!r.success)
        return false;
       const j = r.json;
       if (j === null)
        return false;
       if (j.length < 1)
        return false;
       console.log(j);
       for (let i = 0, l = d.length; i < l; i++)
       {
        if (!d[i].hasOwnProperty('transport'))
         continue;
        if (!d[i].transport.hasOwnProperty('session_id'))
         continue;
        if (!j.includes(d[i].transport.session_id))
         continue;
        console.log('server gives permission to delete', d[i].id);
        await _unsubscribe(d[i].id, d[i].transport.session_id);
       }
       return true;
      }

      async function _unsubscribe(id = false, sessID = false)
      {
       if (id !== false)
       {
        const h = {
         'Authorization': 'Bearer ' + cfg.login.oauth,
         'Client-Id': cfg.login.client
        };
        const r = await shared.httpRequest('DELETE', cURLs.api.twitch.eventSub.delete.replaceAll('%ID%', id), h, null, false);
        if (!r.success)
         return false;
       }
       if (sessID !== false)
        await shared.httpRequest('POST', cURLs.api.rr.feedback.eventsub, {'Content-Type': 'application/x-www-form-urlencoded'}, 'type=close&id=' + sessID, false, false);
       return true;
      }

      return {
       init: $init,
       subscribe: $subscribe,
       erase: $erase,
       channelID: 0,
       sessionID: null
      };
     }();

     const $irc = function()
     {
      let _wsRetry = 0;
      let _firstRS = true;
      let _ws = null;
      const _lPing = 30000;
      const _lTimeout = 35000;
      const _lExpire = 5000;
      let _tTimeout = false;
      let _tExpire = false;
      let _tPing = 0;

      function task()
      {
       _tPing = 0;
       _firstRS = true;
       _ws = new WebSocket(cURLs.ws.twitch.irc);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
       _tExpire = window.setTimeout(_wsExpire, _lExpire);
       _ws.send('CAP REQ :twitch.tv/commands twitch.tv/tags');
       _ws.send('PASS oauth:' + cfg.login.oauth);
       _ws.send('NICK ' + cfg.channel);
       _ws.send('JOIN #' + cfg.channel);
      }

      function _wsClose()
      {
       notice.error(0x12);
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(twitch.net.irc, wsWait);
      }

      async function _wsMessage(ev)
      {
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       _tPing = window.setInterval(_wsPing, _lPing);
       if (_ws === null)
        return;
       if (twitch.net.dead)
       {
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        return;
       }
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
       _wsRetry = 0;
       const data = ev.data.split('\r\n');
       for (let i = 0, l = data.length; i < l; i++)
       {
        if (data[i].length === 0)
         continue;
        let cmd = twitch.parse.message(data[i]);
        if (cmd === false)
        {
         console.log('Unparsed IRC Command: ', data[i]);
         continue;
        }
        notice.info(0x12);
        switch (cmd.command)
        {
         case 'PING':
          if (_ws.readyState === 1)
           _ws.send('PONG ' + cmd.params[0]);
          if ((login.cfgVals() & 0x02) === 0x02)
          {
           await twitch.net.oAuth.update();
           if ((login.cfgVals() & 0x04) !== 0x04)
            notice.error(0x11);
          }
          break;
         case 'PRIVMSG':
          if (document.visibilityState === 'hidden')
           continue;
          if (cmd.params.length > 1)
           cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d');
          if (!await twitch.parse.event.cheer(cmd))
           twitch.parse.line(cmd);
          break;
         case 'NOTICE':
          if (cmd.params.length > 1 && cmd.params[1] === 'Login authentication failed')
          {
           if (_tTimeout !== false)
           {
            window.clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           if (_tPing !== 0)
           {
            window.clearInterval(_tPing);
            _tPing = 0;
           }
           _ws.onmessage = null;
           _ws.onclose = null;
           _ws.close();
           _ws = null;
           if (await twitch.net.oAuth.reinit())
           {
            window.setTimeout(twitch.net.irc, 1000);
            return;
           }
           twitch.net.dead = true;
           notice.error(0x11);
           if (!login.inUse)
            twitch.net.oAuth.clear(true);
          }
          break;
         case 'ROOMSTATE':
          if (!cmd.hasOwnProperty('tags'))
           continue;
          if (!cmd.tags.hasOwnProperty('room-id'))
           continue;
          twitch.net.channelID = cmd.tags['room-id'];
          if (_firstRS)
          {
           if (_tExpire !== false)
           {
            window.clearTimeout(_tExpire);
            _tExpire = false;
           }
           _firstRS = false;
           await _loadEmote_channel(twitch.net.channelID);
           await _loadCheer_channel(twitch.net.channelID);
           if (cfg.event.tag.hasOwnProperty('styles') && cfg.event.tag.styles !== false)
            await _getChannelTitleTags(twitch.net.channelID);
           if (cfg.display.extended.useFFZ)
            thirdparty.ffz.channel(twitch.net.channelID);
           if (cfg.display.extended.useBTTV)
           {
            thirdparty.bttv.channel(twitch.net.channelID);
            thirdparty.bttv.socket(twitch.net.channelID);
           }
           if (cfg.display.extended.use7TV)
           {
            thirdparty['7tv'].channel(twitch.net.channelID);
            thirdparty['7tv'].socket(twitch.net.channelID);
           }
           if (cfg.display.extended.useFFZ | cfg.display.extended.use7TV)
            thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval, twitch.net.channelID);
           if (cfg.display.extended.useBTTV)
            thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, thirdparty.interval, twitch.net.channelID);
           _eventSub(twitch.net.channelID);
          }
          break;
         case 'USERNOTICE':
          if (document.visibilityState === 'hidden')
           continue;
          if (!cmd.hasOwnProperty('tags'))
           continue;
          if (!cmd.tags.hasOwnProperty('msg-id'))
           continue;
          if (cmd.params.length > 1)
           cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d');
          switch (cmd.tags['msg-id'])
          {
           case 'raid':
            twitch.parse.event.raid(cmd);
            break;
           case 'sub':
           case 'resub':
           case 'subgift':
           case 'submysterygift':
           case 'giftpaidupgrade':
           case 'primepaidupgrade':
            twitch.parse.event.sub(cmd);
            break;
           case 'bitsbadgetier':
            twitch.parse.event.badge(cmd);
            break;
           default:
            if (cmd.params.length > 1)
             twitch.parse.line(cmd);
            break;
          }
          break;
         case 'CLEARCHAT':
          switch (cmd.params.length)
          {
           case 1:
            if (cfg.event.clear)
             display.eraseAll();
            break;
           case 2:
            if (document.visibilityState === 'hidden')
             continue;
            if (cmd.tags.hasOwnProperty('ban-duration'))
            {
             if (cfg.event.timeout !== false)
             await twitch.parse.event.timeout(cmd);
            }
            else
            {
             if (cfg.event.ban !== false)
              await twitch.parse.event.ban(cmd);
            }
            break;
          }
          break;
         case 'RECONNECT':
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          if (_tPing !== 0)
          {
           window.clearInterval(_tPing);
           _tPing = 0;
          }
          _ws.onmessage = null;
          _ws.onclose = null;
          _ws.close();
          _ws = null;
          if (twitch.net.dead === true)
           return;
          window.setTimeout(twitch.net.irc, 1000);
          break;
        }
       }
      }

      function _wsExpire()
      {
       notice.error(0x12);
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_ws === null)
        return;
       if (twitch.net.dead === true)
        return;
       twitch.net.dead = true;
       if (_tExpire !== false)
       {
        window.clearTimeout(_tExpire);
        _tExpire = false;
       }
       _ws.close();
       _ws = null;
      }

      function _wsPing()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send('PING');
      }

      function _wsTimeout()
      {
       notice.error(0x12);
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_tPing !== 0)
       {
        window.clearInterval(_tPing);
        _tPing = 0;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (twitch.net.dead === true)
        return;
       twitch.net.irc();
      }

      return task;
     }();

     async function _loadEmote_channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('twitch'))
       thirdparty.emotes.twitch = {};
      const r = await _findEmote_channel(chID, thirdparty.emotes.twitch);
      if (r === false)
       return false;
      if (cList.length === 0)
       cList = r;
      else
      {
       for (let n in thirdparty.emotes.twitch)
       {
        if (!thirdparty.emotes.twitch[n].hasOwnProperty('scope'))
         continue;
        if (thirdparty.emotes.twitch[n].scope !== 'c')
         continue;
        for (let c = cList.length - 1; c >= 0; c--)
        {
         if (cList[c].url !== thirdparty.emotes.twitch[n].url)
          continue;
         cList.splice(c, 1);
         break;
        }
       }
       for (let i = 0, l = r.length; i < l; i++)
       {
        if (!cList.includes(r[i]))
         cList.push(r[i]);
       }
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     async function $userInfo(u, isID = false)
     {
      let url = cURLs.api.twitch.users.name.replaceAll('%USER%', u);
      if (isID)
       url = cURLs.api.twitch.users.id.replaceAll('%USER_ID%', u);
      const h = {
       'Authorization': 'Bearer ' + cfg.login.oauth,
       'Client-Id': cfg.login.client
      };
      const r = await shared.httpRequest('GET', url, h);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('data'))
       return false;
      if (j.data.length !== 1)
       return false;
      return j.data[0];
     }

     async function _getChannelTitleTags(chID)
     {
      const url = cURLs.api.twitch.channels.root.replaceAll('%CHANNEL_ID%', chID);
      const h = {
       'Authorization': 'Bearer ' + cfg.login.oauth,
       'Client-Id': cfg.login.client
      };
      const r = await shared.httpRequest('GET', url, h);
      if (!r.success)
       return;
      const j = r.json;
      if (j === null)
       return;
      if (!j.hasOwnProperty('data'))
       return;
      if (j.data.length !== 1)
       return;
      if (!j.data[0].hasOwnProperty('title'))
       return;
      await _addToChannelTitleTags(j.data[0].title);
     }

     async function _addToChannelTitleTags(title)
     {
      const tReg = /(?:^| )(?:@([A-Za-z0-9_]+))/g;
      let tList = [];
      let match = '';
      while ((match = tReg.exec(title)) !== null)
      {
       tList.push(match);
      }
      if (tList.length < 1)
       return;
      _aTagged = {};
      for (let i = 0, l = tList.length; i < l; i++)
      {
       if (tList[i][1].length < 1)
        continue;
       let u = await twitch.net.userInfo(tList[i][1]);
       if (u === false)
        continue;
       if (!u.hasOwnProperty('id'))
        continue;
       if (!u.hasOwnProperty('login'))
        continue;
       _aTagged[u.login] = u.id;
      }
     }

     const $oAuth = function()
     {
      async function _getToken(t)
      {
       const url = cURLs.api.rr.refresh.t;
       const h = {'Content-Type': 'application/x-www-form-urlencoded'};
       let b = 'refresh=' + encodeURIComponent(t);
       if (cfg.login.share)
        b += '&share=1';
       const r = await shared.httpRequest('POST', url, h, b, false);
       if (!r.success)
       {
        if (r.code === 401)
        {
         notice.error(0x11);
         twitch.net.oAuth.clear(true);
        }
        return false;
       }
       const j = r.json;
       if (j === null)
        return false;
       if (!j.hasOwnProperty('access_token'))
        return false;
       if (!j.hasOwnProperty('refresh_token'))
        return false;
       return j;
      }

      async function $update()
      {
       const lsOAuth = window.localStorage.getItem(login.path() + '.oauth');
       const lsRefresh = window.localStorage.getItem(login.path() + '.refresh');
       const lsRefreshed = window.localStorage.getItem(login.path() + '.refreshed');
       if (lsOAuth !== null)
        cfg.login.oauth = lsOAuth;
       if (lsRefresh !== null)
        cfg.login.oauth_refresh = lsRefresh;
       if (lsRefreshed !== null)
        cfg.login.oauth_refreshed = lsRefreshed;
       if (cfg.login.hasOwnProperty('oauth_refreshed') && cfg.login.oauth_refreshed > 0)
       {
        const tokAge = Math.floor(new Date().getTime() / 1000) - cfg.login.oauth_refreshed;
        if (tokAge < 60 * 60)
         return;
       }
       const ret = await _getToken(cfg.login.oauth_refresh);
       if (ret === false)
        return;
       cfg.login.oauth = ret.access_token;
       cfg.login.oauth_refresh = ret.refresh_token;
       cfg.login.oauth_refreshed = Math.floor(new Date().getTime() / 1000);
       window.localStorage.setItem(login.path() + '.oauth', cfg.login.oauth);
       window.localStorage.setItem(login.path() + '.refresh', cfg.login.oauth_refresh);
       window.localStorage.setItem(login.path() + '.refreshed', cfg.login.oauth_refreshed);
      }

      async function $reinit()
      {
       if ((login.cfgVals() & 0x02) === 0x02)
       {
        twitch.net.oAuth.clear();
        await twitch.net.oAuth.update();
        if ((login.cfgVals() & 0x04) === 0x04)
         return true;
        twitch.net.oAuth.clear(true);
       }
       return false;
      }

      function $clear(clearRefresh = false)
      {
       cfg.login.oauth = 'OAUTH_ID';
       delete cfg.login.oauth_refreshed;
       window.localStorage.removeItem(login.path() + '.oauth');
       window.localStorage.removeItem(login.path() + '.refreshed');
       if (!clearRefresh)
        return;
       cfg.channel = 'CHANNEL_NAME';
       cfg.login.oauth_refresh = 'OAUTH_REFRESH';
       cfg.login.client = oauthClient;
       cfg.login.scope = [];
       window.localStorage.removeItem(login.path() + '.channel');
       window.localStorage.removeItem(login.path() + '.refresh');
       window.localStorage.removeItem(login.path() + '.client');
       window.localStorage.removeItem(login.path() + '.scope');
      }

      return {
       update: $update,
       reinit: $reinit,
       clear: $clear
      };
     }();

     return {
      channelID: 0,
      fList: {},
      dead: false,
      eventSubCtl: $eventSubCtl,
      irc: $irc,
      userInfo: $userInfo,
      oAuth: $oAuth
     };
    }();

    const $parse = function()
    {
     let _aLast = {};

     function _parseUser(cmd, latinOnly = false)
     {
      let data = cmd.prefix;
      let ret = {};
      if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('display-name'))
       ret['display-name'] = cmd.tags['display-name'];
      const gReg = new RegExp(twitch.parse.uReg, 'g');
      if (data.includes('!'))
      {
       ret.nick = data.slice(0, data.indexOf('!'));
       data = data.slice(data.indexOf('!') + 1);
       if (!ret.hasOwnProperty('display-name') || (latinOnly && ret['display-name'] !== ret['display-name'].replaceAll(gReg, '')))
        ret['display-name'] = ret.nick;
      }
      if (data.includes('@'))
      {
       ret.host = data.slice(0, data.indexOf('@'));
       data = data.slice(data.indexOf('@') + 1);
       if (!ret.hasOwnProperty('display-name') || (latinOnly && ret['display-name'] !== ret['display-name'].replaceAll(gReg, '')))
        ret['display-name'] = ret.host;
      }
      ret.user = data;
      return ret;
     }

     function $message(line)
     {
      let cmd = {};
      if (line.slice(0, 1) === '@')
      {
       line = line.slice(1);
       if (!line.includes(' '))
        return false;
       cmd.tags = {};
       const t = line.slice(0, line.indexOf(' '));
       line = line.slice(line.indexOf(' ') + 1);
       const a = t.split(';');
       for (let i = 0, l = a.length; i < l; i++)
       {
        const k = a[i].slice(0, a[i].indexOf('='));
        let v = a[i].slice(a[i].indexOf('=') + 1);
        v = v.replace(/\\s/g, ' ');
        cmd.tags[k] = v;
       }
      }
      if (line.slice(0, 1) === ':')
      {
       line = line.slice(1);
       if (!line.includes(' '))
        return false;
       cmd.prefix = line.slice(0, line.indexOf(' '));
       line = line.slice(line.indexOf(' ') + 1);
      }
      if (!line.includes(' '))
      {
       cmd.command = line;
       return cmd;
      }
      cmd.command = line.slice(0, line.indexOf(' '));
      line = line.slice(line.indexOf(' ') + 1);
      cmd.params = [];
      if (!line.includes(' '))
      {
       cmd.params.push(line);
       return cmd;
      }
      while (line.includes(' '))
      {
       if (line.slice(0, 1) === ':')
       {
        cmd.params.push(line.slice(1));
        return cmd;
       }
       cmd.params.push(line.slice(0, line.indexOf(' ')));
       line = line.slice(line.indexOf(' ') + 1);
      }
      if (line.slice(0, 1) === ':')
       line = line.slice(1);
      cmd.params.push(line);
      return cmd;
     }

     const $content = function()
     {
      const $emoji = function()
      {
       let _uList = {};

       async function task(cmd, set, dup = null)
       {
        if (cmd.params.length < 2)
         return [];
        const msg = cmd.params[1];
        const emSeg = /((?:[\p{EPres}\p{ExtPict}]\ufe0f?\u200d?)+)+/gu;
        let emList = [];
        let match = '';
        while ((match = emSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        const kcSeg = /((?:[0-9#\*]\ufe0f\u20e3)+)+/gu;
        match = '';
        while ((match = kcSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        const acSeg = /(\u0d9e)/gu;
        match = '';
        while ((match = acSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        if (emList.length === 0)
         return [];
        if (dup === null)
         dup = cfg.display.duplicates;
        if (set === true)
         set = 'twemoji';
        let ret = [];
        const uri = cURLs.cdn.ffz.emoji.replaceAll('%SET_ID%', set);
        let addList = {};
        function __showEmoji(c, p)
        {
         if (c.slice(-5) === '-fe0f' && !c.match(/-200d-264[0|2]-/) && !c.match(/-200d-269[5|6]-/) && !c.match(/-200d-26a7/) && !c.match(/-200d-2620/) && !c.match(/-200d-2708/))
          c = c.slice(0, -5);
         if (!addList.hasOwnProperty(c))
          addList[c] = 0;
         else
         {
          if (dup === false)
           return false;
          if (dup !== true && addList[c] >= dup)
           return false;
         }
         addList[c]++;
         ret.push({svc: 'e', url: uri + c + '.png', str: c, pos: p});
         return true;
        }
        function __showCrew(p)
        {
         if (!addList.hasOwnProperty('0d9e'))
          addList['0d9e'] = 0;
         else
         {
          if (dup === false)
           return false;
          if (dup !== true && addList['0d9e'] >= dup)
           return false;
         }
         addList['0d9e']++;
         const crew = cURLs.cdn.crew.replaceAll('%DIRECTION%', shared.rnd(2)).replaceAll('%COLOR%', shared.rnd(18));
         ret.push({svc: 'e', url: crew, str: '0d9e', pos: p});
         return true;
        }
        for (let i = 0, l = emList.length; i < l; i++)
        {
         let cpList = [];
         for (const c of emList[i][0])
         {
          const p = c.codePointAt(0).toString(16).padStart(4, '0');
          if (cpList.length === 0)
          {
           cpList.push(p);
           continue;
          }
          const lL = cpList.length - 1;
          if (p === 'fe0f')
           cpList[lL] += '-' + p;
          else if (p === '200d')
           cpList[lL] += '-' + p;
          else if (p === '20e3')
           cpList[lL] += '-' + p;
          else if (p.match(/1f3f[b-f]/))
           cpList[lL] += '-' + p;
          else if (p.match(/1f9b[0-3]/))
          {
           if (cpList[lL].slice(-5) === '-200d')
            cpList[lL] += '-' + p;
           else
            cpList[lL] += '-200d-' + p;
          }
          else if (p.match(/264[0|2]/) || p.match(/26a7/))
          {
           if (cpList[lL].slice(-5) === '-200d')
            cpList[lL] += '-' + p;
           else
            cpList[lL] += '-200d-' + p;
          }
          else if (p.match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].length < 11)
           cpList[lL] += '-' + p;
          else if (p === '1f308' && cpList[lL] === '1f3f3-fe0f')
           cpList[lL] += '-200d-' + p;
          else if (p === '2620' && cpList[lL] === '1f3f4')
           cpList[lL] += '-200d-' + p;
          else if (cpList[lL].slice(-5) === '-200d')
           cpList[lL] += '-' + p;
          else
           cpList.push(p);
         }
         let found = false;
         const lP = cpList.length;
         if (lP === 1)
         {
          let s = cpList[0];
          if (s === '0d9e')
          {
           __showCrew(emList[i].index);
           continue;
          }
          let tU;
          if (s.slice(-5) === '-fe0f')
          {
           if (s.match(/-200d-264[0|2]-/) || s.match(/-200d-264[0|2]-/) || s.match(/-200d-26a7/) || s.match(/-200d-2620/) || s.match(/-200d-2708/))
            tU = uri + s + '.png';
           else
            tU = uri + s.slice(0, -5) + '.png';
          }
          else
           tU = uri + s + '.png';
          found = await _checkURL(tU);
          if (found)
          {
           __showEmoji(s, emList[i].index);
           continue;
          }
          while (s.includes('-'))
          {
           s = s.slice(0, s.lastIndexOf('-'));
           if (s.slice(-5) === '-fe0f')
            tU = uri + s.slice(0, -5) + '.png';
           else
            tU = uri + s + '.png';
           found = await _checkURL(tU);
           if (found)
           {
            __showEmoji(s, emList[i].index);
            break;
           }
          }
          continue;
         }
         let p = emList[i].index;
         for (let j = 0; j < lP; j++)
         {
          p += cpList[j].replaceAll(/[^\-]/g, '').length + 1;
          found = await _checkURL(uri + cpList[j] + '.png');
          if (found)
           __showEmoji(cpList[j], p);
         }
        }
        return ret;
       }

       function _checkURL(url)
       {
        const p = new Promise(
         function(resolve)
         {
          if (_uList.hasOwnProperty(url))
          {
           resolve(_uList[url]);
           return;
          }
          const x = new XMLHttpRequest();
          x.open('HEAD', url);
          x.onreadystatechange = function()
          {
           if (x.readyState < 2)
            return;
           x.onreadystatechange = null;
           const r = x.status === 200;
           _uList[url] = r;
           resolve(r);
          };
          x.send();
         }
        );
        return p;
       }

       return task;
      }();

      function $twitch(cmd, dup = null)
      {
       if (!cmd.hasOwnProperty('tags'))
        return [];
       if (!cmd.tags.hasOwnProperty('emotes'))
        return [];
       if (cmd.tags.emotes === '')
        return [];
       if (cmd.params.length < 2)
        return [];
       const m = cmd.params[1];
       const e = cmd.tags.emotes.split('/');
       if (dup === null)
        dup = cfg.display.duplicates;
       let ret = [];
       for (let i = 0, n = e.length; i < n; i++)
       {
        const eID = e[i].slice(0, e[i].indexOf(':'));
        const u = cURLs.cdn.twitch.emote.replaceAll('%EMOTE_ID%', eID);
        const eVals = e[i].slice(e[i].indexOf(':') + 1).split(',');
        const eStart = parseInt(eVals[0].split('-')[0], 10);
        const eEnd = parseInt(eVals[0].split('-')[1], 10);
        const sName = m.slice(eStart, eEnd + 1);
        let sc = 'c';
        if (thirdparty.emotes.twitch.hasOwnProperty(sName) && thirdparty.emotes.twitch[sName].hasOwnProperty('scope'))
         sc = thirdparty.emotes.twitch[sName].scope;
        let l = eVals.length;
        if (dup === false)
         l = 1;
        else if (dup !== true)
         l = Math.min(l, dup);
        for (let c = 0; c < l; c++)
        {
         const p = parseInt(eVals[c].split('-')[0], 10);
         ret.push({svc: 't', url: u, str: sName, pos: p, scope: sc});
        }
       }
       return ret;
      }

      const $3rdparty = function()
      {
       const $ffz = function()
       {
        function $general(cmd, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('ffz'))
          return [];
         if (cmd.params.length < 2)
          return [];
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes.ffz.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          ret.push({svc: 'f', url: thirdparty.emotes.ffz[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.ffz[m[i]].scope, width: thirdparty.emotes.ffz[m[i]].width, height: thirdparty.emotes.ffz[m[i]].height});
         }
         return ret;
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!thirdparty.emotes.hasOwnProperty('zwe'))
          return;
         if (!thirdparty.emotes.zwe.hasOwnProperty('ffz'))
          return;
         if (cmd.params.length < 2)
          return;
         const u = _parseUser(cmd);
         l.sort(_posSort);
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!thirdparty.emotes.zwe.ffz.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: 'f', url: thirdparty.emotes.zwe.ffz[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffz[m[i]].scope, width: thirdparty.emotes.zwe.ffz[m[i]].width, height: thirdparty.emotes.zwe.ffz[m[i]].height});
          }
          else
          {
           let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(thirdparty.emotes.zwe.ffz);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('ffzU') && thirdparty.emotes.zwe.ffzU.hasOwnProperty(u.host))
           {
            z = Object.keys(thirdparty.emotes.zwe.ffzU[u.host]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttv'))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttv);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttvU') && thirdparty.emotes.zwe.bttvU.hasOwnProperty(u.host))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttvU[u.host]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('7tv'))
           {
            z = Object.keys(thirdparty.emotes.zwe['7tv']);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: 'f', url: thirdparty.emotes.zwe.ffz[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffz[m[i]].scope, width: thirdparty.emotes.zwe.ffz[m[i]].width, height: thirdparty.emotes.zwe.ffz[m[i]].height});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: 'f', url: thirdparty.emotes.zwe.ffz[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffz[m[i]].scope, width: thirdparty.emotes.zwe.ffz[m[i]].width, height: thirdparty.emotes.zwe.ffz[m[i]].height});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== 'f')
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          if (!thirdparty.emotes.hasOwnProperty('ffzU'))
           return [];
          if (cmd.params.length < 2)
           return [];
          const m = cmd.params[1].split(' ');
          const u = _parseUser(cmd);
          if (!thirdparty.emotes.ffzU.hasOwnProperty(u.host))
           return [];
          if (dup === null)
           dup = cfg.display.duplicates;
          let ret = [];
          let addList = {};
          for (let i = 0, l = m.length; i < l; i++)
          {
           if (!thirdparty.emotes.ffzU[u.host].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p+= m[j].length + 1;
           }
           ret.push({svc: 'f', url: thirdparty.emotes.ffzU[u.host][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.ffzU[u.host][m[i]].scope, width: thirdparty.emotes.ffzU[u.host][m[i]].width, height: thirdparty.emotes.ffzU[u.host][m[i]].height});
          }
          return ret;
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          if (!cfg.display.extended.useZWE)
           return;
          if (!thirdparty.emotes.hasOwnProperty('zwe'))
           return;
          if (!thirdparty.emotes.zwe.hasOwnProperty('ffzU'))
           return;
          if (cmd.params.length < 2)
           return;
          const u = _parseUser(cmd);
          if (!thirdparty.emotes.zwe.ffzU.hasOwnProperty(u.host))
           return [];
          l.sort(_posSort);
          const m = cmd.params[1].split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          let addList = {};
          for (let i = 0, n = m.length; i < n; i++)
          {
           if (!thirdparty.emotes.zwe.ffzU[u.host].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p+= m[j].length + 1;
           }
           let f = -1;
           let h = -1;
           for (let j = 0, o = l.length; j < o; j++)
           {
            if (l[j].pos > h)
             h = l[j].pos;
            else
             continue;
            if (l[j].pos < p)
             f = j;
           }
           if (f === -1)
           {
            if (pass === 1)
             l.push({svc: 'f', url: thirdparty.emotes.zwe.ffzU[u.host][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffzU[u.host][m[i]].scope, width: thirdparty.emotes.zwe.ffzU[u.host][m[i]].width, height: thirdparty.emotes.zwe.ffzU[u.host][m[i]].height});
           }
           else
           {
            let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
            let z = Object.keys(thirdparty.emotes.zwe.ffzU[u.host]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('ffz'))
            {
             z = Object.keys(thirdparty.emotes.zwe.ffz);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('bttv'))
            {
             z = Object.keys(thirdparty.emotes.zwe.bttv);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('bttvU') && thirdparty.emotes.zwe.bttvU.hasOwnProperty(u.host))
            {
             z = Object.keys(thirdparty.emotes.zwe.bttvU[u.host]);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('7tv'))
            {
             z = Object.keys(thirdparty.emotes.zwe['7tv']);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            t = t.trim();
            if (t.length > 0)
            {
             if (pass === 1)
              l.push({svc: 'f', url: thirdparty.emotes.zwe.ffzU[u.host][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffzU[u.host][m[i]].scope, width: thirdparty.emotes.zwe.ffzU[u.host][m[i]].width, height: thirdparty.emotes.zwe.ffzU[u.host][m[i]].height});
            }
            else if (pass === 2)
            {
             if (!l[f].hasOwnProperty('zwe'))
              l[f].zwe = [];
             l[f].zwe.push({svc: 'f', url: thirdparty.emotes.zwe.ffzU[u.host][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.ffzU[u.host][m[i]].scope, width: thirdparty.emotes.zwe.ffzU[u.host][m[i]].width, height: thirdparty.emotes.zwe.ffzU[u.host][m[i]].height});
             l[f].zwe.sort(_posSort);
             for (let j = 0, o = l.length; j < o; j++)
             {
              if (l[j].svc !== 'f')
               continue;
              if (l[j].pos !== p)
               continue;
              l.splice(j, 1);
              break;
             }
            }
           }
          }
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $bttv = function()
       {
        function $general(cmd, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('bttv'))
          return [];
         if (cmd.params.length < 2)
          return [];
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes.bttv.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          ret.push({svc: 'b', url: thirdparty.emotes.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.bttv[m[i]].scope, width: thirdparty.emotes.bttv[m[i]].width, height: thirdparty.emotes.bttv[m[i]].height});
         }
         return ret;
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!thirdparty.emotes.hasOwnProperty('zwe'))
          return;
         if (!thirdparty.emotes.zwe.hasOwnProperty('bttv'))
          return;
         if (cmd.params.length < 2)
          return;
         const u = _parseUser(cmd);
         l.sort(_posSort);
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!thirdparty.emotes.zwe.bttv.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope, width: thirdparty.emotes.zwe.bttv[m[i]].width, height: thirdparty.emotes.zwe.bttv[m[i]].height});
          }
          else
          {
           let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(thirdparty.emotes.zwe.bttv);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('ffz'))
           {
            z = Object.keys(thirdparty.emotes.zwe.ffz);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('ffzU') && thirdparty.emotes.zwe.ffzU.hasOwnProperty(u.host))
           {
            z = Object.keys(thirdparty.emotes.zwe.ffzU[u.host]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttvU') && thirdparty.emotes.zwe.bttvU.hasOwnProperty(u.host))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttvU[u.host]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('7tv'))
           {
            z = Object.keys(thirdparty.emotes.zwe['7tv']);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope, width: thirdparty.emotes.zwe.bttv[m[i]].width, height: thirdparty.emotes.zwe.bttv[m[i]].height});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope, width: thirdparty.emotes.zwe.bttv[m[i]].width, height: thirdparty.emotes.zwe.bttv[m[i]].height});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== 'b')
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        const $user = function()
        {
         function $userGeneral(cmd, dup = null)
         {
          if (!thirdparty.emotes.hasOwnProperty('bttvU'))
           return [];
          if (cmd.params.length < 2)
           return [];
          const u = _parseUser(cmd);
          if (!thirdparty.emotes.bttvU.hasOwnProperty(u.host))
           return [];
          const m = cmd.params[1].split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          let ret = [];
          let addList = {};
          for (let i = 0, l = m.length; i < l; i++)
          {
           if (!thirdparty.emotes.bttvU[u.host].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p+= m[j].length + 1;
           }
           ret.push({svc: 'b', url: thirdparty.emotes.bttvU[u.host][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.bttvU[u.host][m[i]].scope, width: thirdparty.emotes.bttvU[u.host][m[i]].width, height: thirdparty.emotes.bttvU[u.host][m[i]].height});
          }
          return ret;
         }

         function $userZWE(l, cmd, pass, dup = null)
         {
          if (!cfg.display.extended.useZWE)
           return;
          if (!thirdparty.emotes.hasOwnProperty('zwe'))
           return;
          if (!thirdparty.emotes.zwe.hasOwnProperty('bttvU'))
           return;
          if (cmd.params.length < 2)
           return;
          const u = _parseUser(cmd);
          if (!thirdparty.emotes.zwe.bttvU.hasOwnProperty(u.host))
           return [];
          l.sort(_posSort);
          const m = cmd.params[1].split(' ');
          if (dup === null)
           dup = cfg.display.duplicates;
          let addList = {};
          for (let i = 0, n = m.length; i < n; i++)
          {
           if (!thirdparty.emotes.zwe.bttvU[u.host].hasOwnProperty(m[i]))
            continue;
           if (!addList.hasOwnProperty(m[i]))
            addList[m[i]] = 0;
           else
           {
            if (dup === false)
             continue;
            if (dup !== true && addList[m[i]] >= dup)
             continue;
           }
           addList[m[i]]++;
           let p = 0;
           for (let j = 0; j < i; j++)
           {
            p+= m[j].length + 1;
           }
           let f = -1;
           let h = -1;
           for (let j = 0, o = l.length; j < o; j++)
           {
            if (l[j].pos > h)
             h = l[j].pos;
            else
             continue;
            if (l[j].pos < p)
             f = j;
           }
           if (f === -1)
           {
            if (pass === 1)
             l.push({svc: 'b', url: thirdparty.emotes.zwe.bttvU[u.host][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttvU[u.host][m[i]].scope, width: thirdparty.emotes.zwe.bttvU[u.host][m[i]].width, height: thirdparty.emotes.zwe.bttvU[u.host][m[i]].height});
           }
           else
           {
            let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
            let z = Object.keys(thirdparty.emotes.zwe.bttvU[u.host]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('ffz'))
            {
             z = Object.keys(thirdparty.emotes.zwe.ffz);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('ffzU') && thirdparty.emotes.zwe.ffzU.hasOwnProperty(u.host))
            {
             z = Object.keys(thirdparty.emotes.zwe.ffzU[u.host]);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('bttv'))
            {
             z = Object.keys(thirdparty.emotes.zwe.bttv);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            if (thirdparty.emotes.zwe.hasOwnProperty('7tv'))
            {
             z = Object.keys(thirdparty.emotes.zwe['7tv']);
             for (let j = 0, o = z.length; j < o; j++)
             {
              t = t.replaceAll(z[j], '');
             }
            }
            t = t.trim();
            if (t.length > 0)
            {
             if (pass === 1)
              l.push({svc: 'b', url: thirdparty.emotes.zwe.bttvU[u.host][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttvU[u.host][m[i]].scope, width: thirdparty.emotes.zwe.bttvU[u.host][m[i]].width, height: thirdparty.emotes.zwe.bttvU[u.host][m[i]].height});
            }
            else if (pass === 2)
            {
             if (!l[f].hasOwnProperty('zwe'))
              l[f].zwe = [];
             l[f].zwe.push({svc: 'b', url: thirdparty.emotes.zwe.bttvU[u.host][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttvU[u.host][m[i]].scope, width: thirdparty.emotes.zwe.bttvU[u.host][m[i]].width, height: thirdparty.emotes.zwe.bttvU[u.host][m[i]].height});
             l[f].zwe.sort(_posSort);
             for (let j = 0, o = l.length; j < o; j++)
             {
              if (l[j].svc !== 'b')
               continue;
              if (l[j].pos !== p)
               continue;
              l.splice(j, 1);
              break;
             }
            }
           }
          }
         }

         return {
          general: $userGeneral,
          zwe: $userZWE
         };
        }();

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: $general,
         zwe: $zwe,
         user: $user
        };
       }();

       const $7tv = function()
       {
        function $general(cmd, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('7tv'))
          return [];
         if (cmd.params.length < 2)
          return [];
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes['7tv'].hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          ret.push({svc: '7', url: thirdparty.emotes['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes['7tv'][m[i]].scope, width: thirdparty.emotes['7tv'][m[i]].width, height: thirdparty.emotes['7tv'][m[i]].height});
         }
         return ret;
        }

        function $zwe(l, cmd, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!thirdparty.emotes.hasOwnProperty('zwe'))
          return;
         if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
          return;
         if (cmd.params.length < 2)
          return;
         const u = _parseUser(cmd);
         l.sort(_posSort);
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!thirdparty.emotes.zwe['7tv'].hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope, width: thirdparty.emotes.zwe['7tv'][m[i]].width, height: thirdparty.emotes.zwe['7tv'][m[i]].height});
          }
          else
          {
           let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(thirdparty.emotes.zwe['7tv']);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('ffz'))
           {
            z = Object.keys(thirdparty.emotes.zwe.ffz);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('ffzU') && thirdparty.emotes.zwe.ffzU.hasOwnProperty(u.host))
           {
            z = Object.keys(thirdparty.emotes.zwe.ffzU[u.host]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttv'))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttv);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttvU') && thirdparty.emotes.zwe.bttvU.hasOwnProperty(u.host))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttvU[u.host]);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope, width: thirdparty.emotes.zwe['7tv'][m[i]].width, height: thirdparty.emotes.zwe['7tv'][m[i]].height});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope, width: thirdparty.emotes.zwe['7tv'][m[i]].width, height: thirdparty.emotes.zwe['7tv'][m[i]].height});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== '7')
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: $general,
         zwe: $zwe
        };
       }();

       return {
        ffz: $ffz,
        bttv: $bttv,
        '7tv': $7tv
       };
      }();

      return {
       emoji: $emoji,
       twitch: $twitch,
       '3rdparty': $3rdparty
      };
     }();

     const $line = function()
     {
      async function task(cmd)
      {
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       if (await _parseCustomReward(cmd))
        return;
       if (cmd.params.length < 2)
        return;
       const lv = await _level(cmd);
       if (await _parseTaggedChannel(cmd, lv))
        return;
       if (await _parseCommand(cmd, lv))
        return;
       if ((lv & cfg.display.access) === 0)
        return;
       const p = _handleDuplicates(await _eListFromCmd(cmd));
       if (p.length === 0)
        return;
       display.emote.addToShowList(p);
       display.emote.showEmotes();
      }

      async function _parseCustomReward(cmd)
      {
       if (!cmd.hasOwnProperty('tags'))
        return false;
       if (!cmd.tags.hasOwnProperty('custom-reward-id'))
        return false;
       const lnID = cmd.tags['custom-reward-id'];
       if (!_rList.hasOwnProperty(lnID))
       {
        _rList[lnID] = {name: false, cmds: [cmd]};
        return true;
       }
       _rList[lnID].cmds.push(cmd);
       if (_rList[lnID].name === false)
        return true;
       while (_rList[lnID].cmds.length > 0)
       {
        await twitch.parse.event.redeem(_rList[lnID].name, _rList[lnID].cmds.shift());
       }
       return true;
      }

      async function _parseTaggedChannel(cmd, lv)
      {
       if (Object.keys(_aTagged).length < 1)
        return false;
       if (!cfg.event.tag.hasOwnProperty('styles'))
        return false;
       if (cfg.event.tag.styles === false)
        return false;
       const m = cmd.params[1];
       if (m.slice(0, 1) !== '@')
        return false;
       let uTagged = m.slice(1);
       if (uTagged.indexOf(' ') > -1)
        uTagged = uTagged.slice(0, uTagged.indexOf(' '));
       uTagged = uTagged.toLowerCase();
       if (!_aTagged.hasOwnProperty(uTagged))
        return false;
       const uID = _aTagged[uTagged];
       let rq = cfg.display.kappa.access;
       if (cfg.event.tag.hasOwnProperty('access') && cfg.event.tag.access >= 0)
        rq = cfg.event.tag.access;
       if ((lv & rq) === 0)
        return false;
       if (!cfg.event.tag.targetEmotes)
       {
        display.kappa.show(false, cfg.event.tag.styles, {'%USER%': uTagged});
        return true;
       }
       const e = await _findEmote_channel(uID);
       if (cfg.event.tag.targetExtendedEmotes)
       {
        if (cfg.display.extended.useFFZ)
        {
         const rFFZ = await thirdparty.ffz.channelEx(uID);
         if (rFFZ !== false)
         {
          for (let i = 0, l = rFFZ.length; i < l; i++)
          {
           if (rFFZ[i].modifier !== false)
            continue;
           e.push({url: rFFZ[i].url, width: rFFZ[i].width, height: rFFZ[i].height});
          }
         }
        }
        if (cfg.display.extended.useBTTV)
        {
         const rBTTV = await thirdparty.bttv.channelEx(uID);
         if (rBTTV !== false)
         {
          for (let i = 0, l = rBTTV.length; i < l; i++)
          {
           e.push({url: rBTTV[i].url, width: rBTTV[i].width, height: rBTTV[i].height});
          }
         }
        }
        if (cfg.display.extended.use7TV)
        {
         const r7TV = await thirdparty['7tv'].channelEx(uID);
         if (r7TV !== false)
         {
          for (let i = 0, l = r7TV.length; i < l; i++)
          {
           if ((r7TV[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
            continue;
           e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
          }
         }
        }
       }
       display.kappa.show(e, cfg.event.tag.styles, {'%USER%': uTagged});
       return true;
      }

      async function _parseCommand(cmd, lv)
      {
       const kNow = new Date().getTime();
       const m = cmd.params[1].toLowerCase();
       let foundAdvCmd = false;
       if (m === '!cesc' && (lv & 0xC00) !== 0)
       {
        shared.ec.clear();
        return;
       }
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('styles') && !k.hasOwnProperty('erase') && !k.hasOwnProperty('rave') && !k.hasOwnProperty('raveon') && !k.hasOwnProperty('raveoff'))
         continue;
        if (!k.hasOwnProperty('aliases'))
         continue;
        let foundKCmd = false;
        if (k.aliases.includes(m))
         foundKCmd = m;
        if (foundKCmd === false)
        {
         for (let i = 0, l = k.aliases.length; i < l; i++)
         {
          if (m.slice(0, k.aliases[i].length + 1) === k.aliases[i] + ' ')
          {
           foundKCmd = k.aliases[i];
           break;
          }
         }
        }
        if (foundKCmd === false)
         continue;
        let kAccess = cfg.display.kappa.access;
        if (k.hasOwnProperty('access'))
         kAccess = k.access;
        if ((lv & kAccess) === 0)
         continue;
        foundAdvCmd = true;
        if (k.hasOwnProperty('cooldown'))
        {
         let hK = _hashCode(k);
         if (!_aLast.hasOwnProperty(hK))
          _aLast[hK] = 0;
         if (k.cooldown !== 0 && kNow - _aLast[hK] < k.cooldown * 1000)
          continue;
        }
        if (k.hasOwnProperty('erase'))
        {
         display.eraseAll();
         return true;
        }
        if (k.hasOwnProperty('rave'))
        {
         if (document.body.classList.contains('rave'))
          document.body.classList.remove('rave');
         else
          document.body.classList.add('rave');
         return true;
        }
        if (k.hasOwnProperty('raveon'))
        {
         document.body.classList.add('rave');
         return true;
        }
        if (k.hasOwnProperty('raveoff'))
        {
         if (document.body.classList.contains('rave'))
          document.body.classList.remove('rave');
         return true;
        }
        let kC = {};
        let cStyles = k.styles;
        if (typeof cStyles !== 'object')
        {
         if (cStyles === false)
          return foundAdvCmd;
         if (cfg.display.kappa.styles.length < 1)
          return foundAdvCmd;
         cStyles = cfg.display.kappa.styles;
        }
        for (let kS in cStyles)
        {
         if (!cStyles.hasOwnProperty(kS))
          continue;
         kC[kS] = JSON.parse(JSON.stringify(cStyles[kS]));
         kC[kS].command = foundKCmd;
         if (foundKCmd.length === m.length)
          kC[kS].params = null;
         else
          kC[kS].params = m.slice(foundKCmd.length + 1);
        }
        let eA = false;
        if (foundKCmd.length < m.length)
         eA = _handleDuplicates(await _eListFromCmd(cmd, true));
        _aLast[_hashCode(k)] = kNow;
        display.kappa.show(eA, kC);
        return true;
       }
       let foundCmd = false;
       if (cfg.display.kappa.aliases.includes(m))
        foundCmd = m;
       if (foundCmd === false)
       {
        for (let i = 0, l = cfg.display.kappa.aliases.length; i < l; i++)
        {
         if (m.slice(0, cfg.display.kappa.aliases[i].length + 1) === cfg.display.kappa.aliases[i] + ' ')
         {
          foundCmd = cfg.display.kappa.aliases[i];
          break;
         }
        }
       }
       if (foundCmd === false)
        return foundAdvCmd;
       if ((lv & cfg.display.kappa.access) === 0)
        return foundAdvCmd;
       let h = _hashCode(null);
       if (!_aLast.hasOwnProperty(h))
        _aLast[h] = 0;
       if (cfg.display.kappa.cooldown > 0 && kNow - _aLast[h] < cfg.display.kappa.cooldown * 1000)
        return true;
       let a = false;
       if (foundCmd.length < m.length)
        a = _handleDuplicates(await _eListFromCmd(cmd, true));
       _aLast[h] = kNow;
       display.kappa.show(a);
       return true;
      }

      function _hashCode(o)
      {
       const s = JSON.stringify(o);
       let h = 0;
       for (let i = 0, l = s.length; i < l; i++)
        h = Math.imul(31, h) + s.charCodeAt(i) | 0;
       return h;
      }

      return task;
     }();

     const $event = function()
     {
      async function $cheer(cmd)
      {
       if (!thirdparty.emotes.hasOwnProperty('cheer'))
        return false;
       if (cfg.event.cheer === false)
        return false;
       if (!cfg.event.cheer.hasOwnProperty('bits'))
        return false;
       if (cfg.event.cheer.bits === false)
        return false;
       if (!cmd.hasOwnProperty('tags'))
        return false;
       if (!cmd.tags.hasOwnProperty('bits'))
        return false;
       if (cmd.tags.bits < 1)
        return false;
       let p = [];
       const msg = cmd.params[1].split(' ');
       for (let m = 0, l = msg.length; m < l; m++)
       {
        for (const prefix in thirdparty.emotes.cheer)
        {
         if (!thirdparty.emotes.cheer.hasOwnProperty(prefix))
          continue;
         const firstChars = prefix.length;
         if (msg[m].slice(0, firstChars).toLowerCase() !== prefix.toLowerCase())
          continue;
         const amt = msg[m].slice(firstChars);
         if (isNaN(amt))
          continue;
         for (let i = 0, n = thirdparty.emotes.cheer[prefix].length; i < n; i++)
         {
          if (parseInt(amt, 10) < thirdparty.emotes.cheer[prefix][i].min)
           continue;
          const sName = prefix + thirdparty.emotes.cheer[prefix][i].min;
          p.push({svc: 'c', url: thirdparty.emotes.cheer[prefix][i].img, str: sName});
          break;
         }
        }
       }
       if (cfg.event.cheer.useMsg)
       {
        const a = await _eListFromCmd(cmd);
        p = p.concat(a);
       }
       else
        await twitch.parse.line(cmd);
       p = _handleDuplicates(p);
       if (p.length === 0)
        return false;
       const r = shared.findInMaybeRange(cfg.event.cheer.bits, cmd.tags.bits);
       if (r === false)
       {
        display.emote.addToShowList(p);
        display.emote.showEmotes();
        return true;
       }
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       display.kappa.show(p, r, {'%USER%': dn, '%AMOUNT%': cmd.tags.bits});
       return true;
      }

      async function $raid(cmd)
      {
       if (cfg.event.raid === false)
        return;
       if (!cfg.event.raid.hasOwnProperty('raiders'))
        return;
       if (cfg.event.raid.raiders === false)
        return;
       if (!cmd.hasOwnProperty('tags'))
        return;
       if (!cmd.tags.hasOwnProperty('msg-param-viewerCount'))
        return;
       const c = cmd.tags['msg-param-viewerCount'];
       const r = shared.findInMaybeRange(cfg.event.raid.raiders, c);
       if (r === false)
        return;
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       if (!cfg.event.raid.originEmotes)
       {
        display.kappa.show(false, r, {'%USER%': dn, '%AMOUNT%': c});
        return;
       }
       const d = cmd.tags['user-id'];
       const e = await _findEmote_channel(d);
       if (cfg.event.raid.originExtendedEmotes)
       {
        if (cfg.display.extended.useFFZ)
        {
         const rFFZ = await thirdparty.ffz.channelEx(d);
         if (rFFZ !== false)
         {
          for (let i = 0, l = rFFZ.length; i < l; i++)
          {
           if (rFFZ[i].modifier !== false)
            continue;
           e.push({url: rFFZ[i].url, width: rFFZ[i].width, height: rFFZ[i].height});
          }
         }
        }
        if (cfg.display.extended.useBTTV)
        {
         const rBTTV = await thirdparty.bttv.channelEx(d);
         if (rBTTV !== false)
         {
          for (let i = 0, l = rBTTV.length; i < l; i++)
          {
           e.push({url: rBTTV[i].url, width: rBTTV[i].width, height: rBTTV[i].height});
          }
         }
        }
        if (cfg.display.extended.use7TV)
        {
         const r7TV = await thirdparty['7tv'].channelEx(d);
         if (r7TV !== false)
         {
          for (let i = 0, l = r7TV.length; i < l; i++)
          {
           if ((r7TV[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
            continue;
           e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
          }
         }
        }
       }
       display.kappa.show(e, r, {'%USER%': dn, '%AMOUNT%': c});
      }

      const $sub = function()
      {
       let _bList = {
        bombs: [],
        bulk: [],
        check: []
       };
       let _tGC = null;

       async function task(cmd)
       {
        if (!cmd.tags.hasOwnProperty('msg-id'))
         return;
        const subPlan = _parsePlan(cmd);
        if (subPlan === false)
         return;
        const mID = cmd.tags['msg-id'];
        let mpoi = false;
        if (cmd.tags.hasOwnProperty('msg-param-origin-id'))
         mpoi = cmd.tags['msg-param-origin-id'];
        const usesBomb = cfg.event.sub[subPlan].hasOwnProperty('gift') && cfg.event.sub[subPlan].gift.hasOwnProperty('bomb') && cfg.event.sub[subPlan].gift.bomb !== false;
        if (mpoi !== false && usesBomb)
        {
         if (_bList.bombs.includes(mpoi))
          return;
         if (mID === 'subgift')
         {
          if (_bList.bulk.includes(mpoi))
           return;
          if (_bList.check.includes(mpoi))
          {
           _bList.bulk.push(mpoi);
           _bList.check.splice(_bList.check.indexOf(mpoi), 1);
           _resetGC();
           return;
          }
         }
        }
        let a = [];
        if (cmd.params.length > 1)
        {
         if (cfg.event.sub.useMsg)
          a = await _eListFromCmd(cmd, true);
         else
          await twitch.parse.line(cmd);
        }
        let mpm = 1;
        if (cmd.tags.hasOwnProperty('msg-param-months'))
         mpm = parseInt(cmd.tags['msg-param-months'], 10);
        let mpcm = 1;
        if (cmd.tags.hasOwnProperty('msg-param-cumulative-months'))
         mpcm = parseInt(cmd.tags['msg-param-cumulative-months'], 10);
        let mpmgc = 1;
        if (cmd.tags.hasOwnProperty('msg-param-mass-gift-count'))
         mpmgc = parseInt(cmd.tags['msg-param-mass-gift-count'], 10);
        let dn = 'Anonymous';
        let ln = 'anonymous';
        if (cmd.tags.hasOwnProperty('login'))
         ln = cmd.tags.login;
        if (cmd.tags.hasOwnProperty('display-name'))
         dn = cmd.tags['display-name'];
        if (ln === 'anonymous' || dn === 'Anonymous')
        {
         const u = _parseUser(cmd, true);
         if (ln === 'anonymous' && u.hasOwnProperty('host'))
          ln = u.host;
         if (dn === 'Anonymous' && u.hasOwnProperty('display-name'))
          dn = u['display-name'];
        }
        if (cfg.ignore.users !== false && cfg.ignore.users.includes(ln))
         return;
        let mprdn = 'Anonymous';
        if (cmd.tags.hasOwnProperty('msg-param-recipient-display-name'))
         mprdn = cmd.tags['msg-param-recipient-display-name'];
        if (mpoi !== false && usesBomb)
        {
         if (_bList.bombs.includes(mpoi))
          return;
         if (mID === 'subgift')
         {
          if (_bList.bulk.includes(mpoi))
           return;
          if (_bList.check.includes(mpoi))
          {
           _bList.bulk.push(mpoi);
           _bList.check.splice(_bList.check.indexOf(mpoi), 1);
           _resetGC();
           return;
          }
          if (!cmd.tags.hasOwnProperty('msg-param-sender-count') || cmd.tags['msg-param-sender-count'] === '0')
          {
           _bList.check.push(mpoi);
           window.setTimeout(_show, 2000, mID, subPlan, mpoi, mpm, mpcm, mpmgc, dn, mprdn, a);
           _resetGC();
           return;
          }
         }
        }
        _show(mID, subPlan, mpoi, mpm, mpcm, mpmgc, dn, mprdn, a);
       }

       function _show(id, subPlan, mpoi, mpm, mpcm, mpmgc, dn, mprdn, a)
       {
        const usesBomb = cfg.event.sub.hasOwnProperty(subPlan) && cfg.event.sub[subPlan].hasOwnProperty('gift') && cfg.event.sub[subPlan].gift.hasOwnProperty('bomb') && cfg.event.sub[subPlan].gift.bomb !== false;
        if (mpoi !== false && usesBomb)
        {
         if (_bList.bombs.includes(mpoi))
          return;
         if (id === 'subgift' && _bList.bulk.includes(mpoi))
         {
          _resetGC();
          return;
         }
        }
        switch (id)
        {
         case 'sub':
          if (!cfg.event.sub.hasOwnProperty(subPlan))
           return;
          if (!cfg.event.sub[subPlan].hasOwnProperty('first'))
           return;
          if (cfg.event.sub[subPlan].first === false)
           return;
          display.kappa.show(a, cfg.event.sub[subPlan].first, {'%USER%': dn});
          break;
         case 'resub':
          if (!cfg.event.sub.hasOwnProperty(subPlan))
           return;
          if (!cfg.event.sub[subPlan].hasOwnProperty('resub'))
           return;
          const rs = shared.findInMaybeRange(cfg.event.sub[subPlan].resub, mpcm);
          if (rs === false)
           return;
          display.kappa.show(a, rs, {'%USER%': dn, '%AMOUNT%': mpcm});
          break;
         case 'primepaidupgrade':
          if (!cfg.event.sub.hasOwnProperty(subPlan))
           return;
          if (!cfg.event.sub[subPlan].hasOwnProperty('upgrade'))
           return;
          if (!cfg.event.sub[subPlan].upgrade.hasOwnProperty('prime'))
           return;
          display.kappa.show(a, cfg.event.sub[subPlan].upgrade.prime, {'%USER%': dn});
          break;
         case 'giftpaidupgrade':
          if (!cfg.event.sub.hasOwnProperty(subPlan))
           return;
          if (!cfg.event.sub[subPlan].hasOwnProperty('upgrade'))
           return;
          if (!cfg.event.sub[subPlan].upgrade.hasOwnProperty('gift'))
           return;
          display.kappa.show(a, cfg.event.sub[subPlan].upgrade.gift, {'%USER%': dn});
          break;
         case 'subgift':
          if (!cfg.event.sub.hasOwnProperty(subPlan))
           return;
          if (!cfg.event.sub[subPlan].hasOwnProperty('gift'))
           return;
          if (mpm === 1)
          {
           if (!cfg.event.sub[subPlan].gift.hasOwnProperty('first'))
            return;
           if (cfg.event.sub[subPlan].gift.first === false)
            return;
           display.kappa.show(a, cfg.event.sub[subPlan].gift.first, {'%SENDER%': dn, '%USER%': mprdn});
           return;
          }
          if (!cfg.event.sub[subPlan].gift.hasOwnProperty('resub'))
           return;
          const gpr = shared.findInMaybeRange(cfg.event.sub[subPlan].gift.resub, mpm);
          if (gpr === false)
           return;
          display.kappa.show(a, gpr, {'%SENDER%': dn, '%USER%': mprdn, '%AMOUNT%': mpm});
          break;
         case 'submysterygift':
          if (!usesBomb)
           return;
          if (mpoi !== false)
          {
           _bList.bombs.push(mpoi);
           if (_bList.bulk.includes(mpoi))
            _bList.bulk.splice(_bList.bulk.indexOf(mpoi), 1);
           if (_bList.check.includes(mpoi))
            _bList.check.splice(_bList.check.indexOf(mpoi), 1);
           _resetGC();
          }
          const gpb = shared.findInMaybeRange(cfg.event.sub[subPlan].gift.bomb, mpmgc);
          if (gpb === false)
           return;
          display.kappa.show(a, gpb, {'%SENDER%': dn, '%AMOUNT%': mpmgc});
          break;
        }
       }

       function _parsePlan(c)
       {
        if (!c.tags.hasOwnProperty('msg-param-sub-plan'))
         return false;
        const p = c.tags['msg-param-sub-plan'];
        switch (p)
        {
         case '1000': return 't1';
         case '2000': return 't2';
         case '3000': return 't3';
         case 'Prime': return 'prime';
        }
        return false;
       }

       function _resetGC()
       {
        if (_tGC !== null)
        {
         window.clearTimeout(_tGC);
         _tGC = null;
        }
        _tGC = window.setTimeout(_tmrGC, 10000);
       }

       function _tmrGC()
       {
        if (_tGC === null)
         return;
        window.clearTimeout(_tGC);
        _tGC = null;
        _bList.check = [];
        _bList.bulk = [];
       }

       return task;
      }();

      function $badge(cmd)
      {
       if (!cmd.tags.hasOwnProperty('msg-param-threshold'))
        return;
       const c = cmd.tags['msg-param-threshold'];
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       if (cfg.event.badge.hasOwnProperty(c) && cfg.event.badge[c] !== false)
       {
        display.kappa.show(false, cfg.event.badge[c], {'%USER%': dn, '%AMOUNT%': c});
        return;
       }
       let closest = null;
       for (const b in cfg.event.badge)
       {
        if (!cfg.event.badge.hasOwnProperty(b))
         continue;
        if (closest === null)
        {
         closest = b;
         continue;
        }
        if (Math.abs(parseInt(closest, 10) - parseInt(c, 10)) > Math.abs(parseInt(b, 10) - parseInt(c, 10)))
         closest = b;
       }
       if (closest === null)
        return;
       if (cfg.event.badge[closest] === false)
        return;
       display.kappa.show(false, cfg.event.badge[closest], {'%USER%': dn, '%AMOUNT%': c});
      }

      async function $redeem(title, cmd)
      {
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('redeem'))
         continue;
        if (!k.redeem.includes(title))
         continue;
        let kC = k.styles;
        if (cmd === false)
        {
         display.kappa.show(false, kC);
         return;
        }
        const a = _handleDuplicates(await _eListFromCmd(cmd, true));
        display.kappa.show(a, kC);
        return;
       }
      }

      async function $ban(cmd)
      {
       let dn = cmd.params[1];
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(dn))
        return;
       if (cmd.tags.hasOwnProperty('target-user-id'))
       {
        const r = await twitch.net.userInfo(cmd.tags['target-user-id'], true);
        if (r.hasOwnProperty('display_name'))
         dn = r.display_name;
       }
       display.kappa.show(false, cfg.event.ban, {'%USER%': dn});
      }

      async function $timeout(cmd)
      {
       let dn = cmd.params[1];
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(dn))
        return;
       if (cmd.tags.hasOwnProperty('target-user-id'))
       {
        const r = await twitch.net.userInfo(cmd.tags['target-user-id'], true);
        if (r.hasOwnProperty('display_name'))
         dn = r.display_name;
       }
       const dDur = cmd.tags['ban-duration'];
       const r = shared.findInMaybeRange(cfg.event.timeout, dDur);
       if (r === false)
        return;
       display.kappa.show(false, r, {'%USER%': dn, '%AMOUNT%': dDur});
      }

      async function $shoutoutCreate(uID, uName)
      {
       if (cfg.event.shoutout === false)
        return false;
       if (!cfg.event.shoutout.hasOwnProperty('create'))
        return false;
       if (cfg.event.shoutout.create === false)
        return false;
       if (!cfg.event.shoutout.create.hasOwnProperty('styles'))
        return false;
       if (cfg.event.shoutout.create.styles === false)
        return false;
       if (!cfg.event.shoutout.create.targetEmotes)
       {
        display.kappa.show(false, cfg.event.shoutout.create.styles, {'%USER%': uName});
        return;
       }
       const e = await _findEmote_channel(uID);
       if (cfg.event.shoutout.create.targetExtendedEmotes)
       {
        if (cfg.display.extended.useFFZ)
        {
         const rFFZ = await thirdparty.ffz.channelEx(uID);
         if (rFFZ !== false)
         {
          for (let i = 0, l = rFFZ.length; i < l; i++)
          {
           if (rFFZ[i].modifier !== false)
            continue;
           e.push({url: rFFZ[i].url, width: rFFZ[i].width, height: rFFZ[i].height});
          }
         }
        }
        if (cfg.display.extended.useBTTV)
        {
         const rBTTV = await thirdparty.bttv.channelEx(uID);
         if (rBTTV !== false)
         {
          for (let i = 0, l = rBTTV.length; i < l; i++)
          {
           e.push({url: rBTTV[i].url, width: rBTTV[i].width, height: rBTTV[i].height});
          }
         }
        }
        if (cfg.display.extended.use7TV)
        {
         const r7TV = await thirdparty['7tv'].channelEx(uID);
         if (r7TV !== false)
         {
          for (let i = 0, l = r7TV.length; i < l; i++)
          {
           if ((r7TV[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
            continue;
           e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
          }
         }
        }
       }
       display.kappa.show(e, cfg.event.shoutout.create.styles, {'%USER%': uName});
      }

      async function $shoutoutReceive(uID, uName)
      {
       if (cfg.event.shoutout === false)
        return false;
       if (!cfg.event.shoutout.hasOwnProperty('receive'))
        return false;
       if (cfg.event.shoutout.receive === false)
        return false;
       if (!cfg.event.shoutout.receive.hasOwnProperty('styles'))
        return false;
       if (cfg.event.shoutout.receive.styles === false)
        return false;
       if (!cfg.event.shoutout.receive.originEmotes)
       {
        display.kappa.show(false, cfg.event.shoutout.receive.styles, {'%USER%': uName});
        return;
       }
       const e = await _findEmote_channel(uID);
       if (cfg.event.shoutout.receive.originExtendedEmotes)
       {
        if (cfg.display.extended.useFFZ)
        {
         const rFFZ = await thirdparty.ffz.channelEx(uID);
         if (rFFZ !== false)
         {
          for (let i = 0, l = rFFZ.length; i < l; i++)
          {
           if (rFFZ[i].modifier !== false)
            continue;
           e.push({url: rFFZ[i].url, width: rFFZ[i].width, height: rFFZ[i].height});
          }
         }
        }
        if (cfg.display.extended.useBTTV)
        {
         const rBTTV = await thirdparty.bttv.channelEx(uID);
         if (rBTTV !== false)
         {
          for (let i = 0, l = rBTTV.length; i < l; i++)
          {
           e.push({url: rBTTV[i].url, width: rBTTV[i].width, height: rBTTV[i].height});
          }
         }
        }
        if (cfg.display.extended.use7TV)
        {
         const r7TV = await thirdparty['7tv'].channelEx(uID);
         if (r7TV !== false)
         {
          for (let i = 0, l = r7TV.length; i < l; i++)
          {
           if ((r7TV[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
            continue;
           e.push({url: r7TV[i].url, width: r7TV[i].width, height: r7TV[i].height});
          }
         }
        }
       }
       display.kappa.show(e, cfg.event.shoutout.receive.styles, {'%USER%': uName});
      }

      function $pollEnd(e)
      {
       let vPoll = 0;
       for (let i = 0, l = e.choices.length; i < l; i++)
       {
        if (!e.choices[i].hasOwnProperty('title'))
         continue;
        if (!e.choices[i].hasOwnProperty('votes'))
         continue;
        vPoll = Math.max(vPoll, e.choices[i].votes);
       }
       let rPoll = [];
       for (let i = 0, l = e.choices.length; i < l; i++)
       {
        if (!e.choices[i].hasOwnProperty('title'))
         continue;
        if (!e.choices[i].hasOwnProperty('votes'))
         continue;
        if (e.choices[i].votes === vPoll)
         rPoll.push(e.choices[i].title);
       }
       let sPoll = 'None';
       if (rPoll.length > 0)
        sPoll = rPoll.join(' + ');
       display.kappa.show(false, cfg.event.poll.end, {'%TITLE%': e.title, '%RESULT%': sPoll});
      }

      function $predictionEnd(e)
      {
       let sPrediction = 'None';
       for (let i = 0, l = e.outcomes.length; i < l; i++)
       {
        if (!e.outcomes[i].hasOwnProperty('id'))
         continue;
        if (e.outcomes[i].id !== e.winning_outcome_id)
         continue;
        if (!e.outcomes[i].hasOwnProperty('title'))
         continue;
        sPrediction = e.outcomes[i].title;
        break;
       }
       display.kappa.show(false, cfg.event.prediction.resolved, {'%TITLE%': e.title, '%RESULT%': sPrediction});
      }

      return {
       cheer: $cheer,
       raid: $raid,
       sub: $sub,
       badge: $badge,
       redeem: $redeem,
       ban: $ban,
       timeout: $timeout,
       shoutoutCreate: $shoutoutCreate,
       shoutoutReceive: $shoutoutReceive,
       pollEnd: $pollEnd,
       predictionEnd: $predictionEnd
      };
     }();

     const _level = function()
     {
      const _rFH = 3600000;

      async function task(cmd)
      {
       let r = 0x001;
       if (cmd.tags.hasOwnProperty('mod') && cmd.tags.mod === '1')
        r |= 0x400;
       if (cmd.tags.hasOwnProperty('vip') && cmd.tags.vip === '1')
        r |= 0x100;
       if (cmd.tags.hasOwnProperty('badges'))
       {
        const badges = cmd.tags.badges.split(',');
        for (let i = 0, l = badges.length; i < l; i++)
        {
         const bData = _jSplit(badges[i], '/', 2);
         switch (bData[0])
         {
          case 'broadcaster':
           r |= 0x800;
           break;
          case 'moderator':
           r |= 0x400;
           break;
          case 'vip':
           r |= 0x100;
           break;
          case 'artist-badge':
           r |= 0x080;
           break;
          case 'founder':
           r |= 0x200;
           break;
          case 'bits':
           r |= 0x004;
           break;
          case 'subscriber':
           const badge = parseInt(bData[1], 10);
           if (badge < 2000)
            r |= 0x010;
           else if (badge < 3000)
            r |= 0x020;
           else
            r |= 0x040;
           break;
         }
        }
       }
       /* api-heavy, only check if follower access is allowed and there's a chance it matters */
       let needF = false;
       if ((cfg.display.access & 0x002) === 0x002 && (cfg.display.access & 0x001) !== 0x001)
        needF = true;
       else if ((cfg.display.kappa.access & 0x002) === 0x002 && (cfg.display.kappa.access & 0x001) !== 0x001)
        needF = true;
       else
       {
        for (const k of cfg.commands)
        {
         if (!k.hasOwnProperty('styles'))
          continue;
         if (!k.hasOwnProperty('access'))
          continue;
         if ((k.access & 0x002) === 0x002 && (k.access & 0x001) !== 0x001)
         {
          needF = true;
          break;
         }
        }
       }
       if (needF)
       {
        const f = await _checkFollower(cmd);
        if (f)
         r |= 0x002;
       }
       if ((r & 0x800) === 0x800 && (r & 0x070) !== 0)
        return r & ~0x070;
       return r;
      }

      async function _checkFollower(cmd)
      {
       const uID = cmd.tags['user-id'];
       if (twitch.net.fList.hasOwnProperty(uID))
       {
        const tDif = new Date().getTime() - twitch.net.fList[uID].t;
        if (tDif < _rFH)
         return twitch.net.fList[uID].value;
       }
       const url = cURLs.api.twitch.channels.followers.replaceAll('%USER_ID%', uID).replaceAll('%CHANNEL_ID%', cmd.tags['room-id']);
       const h = {
        'Authorization': 'Bearer ' + cfg.login.oauth,
        'Client-Id': cfg.login.client
       };
       const r = await shared.httpRequest('GET', url, h);
       if (!r.success)
       {
        if (r.code === 401)
        {
         if (await twitch.net.oAuth.reinit())
          return _checkFollower(cmd);
         notice.error(0x11);
         if (!login.inUse)
          twitch.net.oAuth.clear(true);
        }
        return false;
       }
       const j = r.json;
       if (j === null)
        return false;
       if (j.hasOwnProperty('data') && j.data.length > 0)
       {
        twitch.net.fList[uID] = {value: true, t: new Date().getTime()};
        return true;
       }
       twitch.net.fList[uID] = {value: false, t: new Date().getTime()};
       return false;
      }

      function _jSplit(s, sep, limit)
      {
       let arr = [];
       let v = '';
       for (let i = 0, l = s.length; i < l; i++)
       {
        if (arr.length < limit - 1)
        {
         if (s[i] === sep)
         {
          arr.push(v);
          v = '';
          continue;
         }
        }
        v += s[i];
       }
       if (v.length > 0)
        arr.push(v);
       return arr;
      }

      return task;
     }();

     function _handleDuplicates(a)
     {
      const lA = a.length;
      if (lA < 1)
       return a;
      let r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 'c')
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'u')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 't' && a[i].scope === 'c')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'c' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 't' && a[i].scope === 'g')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'g' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 'e')
       {
        if (_notDupe(a[i], r))
         r.push(a[i]);
       }
      }
      return r;
     }

     function _notDupe(add, pend)
     {
      for (let i = 0, l = pend.length; i < l; i++)
      {
       if (pend[i].str === add.str)
        return (pend[i].svc === add.svc);
      }
      return true;
     }

     async function _eListFromCmd(cmd, dup = null)
     {
      let r = [];
      const u = _parseUser(cmd, true);
      if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
       return r;
      r = r.concat(twitch.parse.content.twitch(cmd, dup));
      if (cfg.display.useEmoji)
       r = r.concat(await twitch.parse.content.emoji(cmd, cfg.display.useEmoji, dup));
      if (cfg.display.extended.useFFZ)
      {
       r = r.concat(twitch.parse.content['3rdparty'].ffz.general(cmd, dup));
       r = r.concat(twitch.parse.content['3rdparty'].ffz.user.general(cmd, dup));
      }
      if (cfg.display.extended.useBTTV)
      {
       r = r.concat(twitch.parse.content['3rdparty'].bttv.general(cmd, dup));
       r = r.concat(twitch.parse.content['3rdparty'].bttv.user.general(cmd, dup));
      }
      if (cfg.display.extended.use7TV)
       r = r.concat(twitch.parse.content['3rdparty']['7tv'].general(cmd, dup));
      if (cfg.display.extended.useFFZ)
      {
       twitch.parse.content['3rdparty'].ffz.zwe(r, cmd, 1, dup);
       twitch.parse.content['3rdparty'].ffz.user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       twitch.parse.content['3rdparty'].bttv.zwe(r, cmd, 1, dup);
       twitch.parse.content['3rdparty'].bttv.user.zwe(r, cmd, 1, dup);
      }
      if (cfg.display.extended.use7TV)
       twitch.parse.content['3rdparty']['7tv'].zwe(r, cmd, 1, dup);
      if (cfg.display.extended.useFFZ)
      {
       twitch.parse.content['3rdparty'].ffz.zwe(r, cmd, 2, dup);
       twitch.parse.content['3rdparty'].ffz.user.zwe(r, cmd, 2, dup);
      }
      if (cfg.display.extended.useBTTV)
      {
       twitch.parse.content['3rdparty'].bttv.zwe(r, cmd, 2, dup);
       twitch.parse.content['3rdparty'].bttv.user.zwe(r, cmd, 2, dup);
      }
      if (cfg.display.extended.use7TV)
       twitch.parse.content['3rdparty']['7tv'].zwe(r, cmd, 2, dup);
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.length > 0)
      {
       for (let i = r.length - 1; i >= 0; i--)
       {
        let m = r[i].str;
        if (r[i].svc === 'e')
         m = String.fromCharCode(parseInt(m, 16));
        if (cfg.ignore.emotes.includes(m))
         r.splice(i, 1);
       }
      }
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (r[i].hasOwnProperty('width') || r[i].hasOwnProperty('height'))
        continue;
       if (!r[i].hasOwnProperty('url'))
        continue;
       const sz = await shared.ec.get(r[i].url);
       if (sz === null)
        continue;
       r[i].width = sz.width;
       r[i].height = sz.height;
      }
      return r;
     }

     function $clearCooldowns()
     {
      _aLast = {};
     }

     return {
      message: $message,
      content: $content,
      line: $line,
      event: $event,
      clearCooldowns: $clearCooldowns,
      uReg: /[^A-Za-z0-9_]/
     };
    }();

    const _findEmote_channel = function()
    {
     const _rCH = 300000;
     let _chList = {};

     async function task(chID, n = false)
     {
      if (n === false && _chList.hasOwnProperty(chID))
      {
       const tDif = new Date().getTime() - _chList[chID].t;
       if (tDif < _rCH)
        return _chList[chID].value;
      }
      const url = cURLs.api.twitch.chat.emotes.root.replaceAll('%CHANNEL_ID%', chID);
      const h = {
       'Authorization': 'Bearer ' + cfg.login.oauth,
       'Client-Id': cfg.login.client
      };
      const r = await shared.httpRequest('GET', url, h);
      if (!r.success)
      {
       if (r.code === 401)
       {
        if (await twitch.net.oAuth.reinit())
         return _findEmote_channel(chID, n);
        notice.error(0x11);
        if (!login.inUse)
         twitch.net.oAuth.clear(true);
       }
       return false;
      }
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('data'))
       return false;
      if (!Array.isArray(j.data))
       return false;
      let ret = [];
      for (let i = 0, l = j.data.length; i < l; i++)
      {
       if (!j.data[i].hasOwnProperty('id'))
        continue;
       if (cfg.ignore.emotes !== false && j.data[i].hasOwnProperty('name') && cfg.ignore.emotes.includes(j.data[i].name))
        continue;
       const eURL = cURLs.cdn.twitch.emote.replaceAll('%EMOTE_ID%', j.data[i].id);
       if (n !== false && j.data[i].hasOwnProperty('name'))
       {
        n[j.data[i].name] = {
         scope: 'c',
         url: eURL,
         id: j.data[i].id
        };
       }
       ret.push({url: eURL});
      }
      _chList[chID] = {t: new Date().getTime(), value: ret};
      return ret;
     }

     return task;
    }();

    async function $global()
    {
     if (!thirdparty.emotes.hasOwnProperty('twitch'))
      thirdparty.emotes.twitch = {};
     const url = cURLs.api.twitch.chat.emotes.global;
     const h = {
      'Authorization': 'Bearer ' + cfg.login.oauth,
      'Client-Id': cfg.login.client
     };
     const r = await shared.httpRequest('GET', url, h);
     if (!r.success)
     {
      if (r.code === 401)
      {
       if (await twitch.net.oAuth.reinit())
        return twitch.global();
       notice.error(0x11);
       if (!login.inUse)
        twitch.net.oAuth.clear(true);
      }
      return false;
     }
     const j = r.json;
     if (j === null)
      return false;
     if (!j.hasOwnProperty('data'))
      return false;
     if (!Array.isArray(j.data))
      return false;
     for (let i = 0, l = j.data.length; i < l; i++)
     {
      if (!j.data[i].hasOwnProperty('id'))
       continue;
      if (!j.data[i].hasOwnProperty('name'))
       continue;
      thirdparty.emotes.twitch[j.data[i].name] = {
       scope: 'g',
       url: cURLs.cdn.twitch.emote.replaceAll('%EMOTE_ID%', j.data[i].id),
       id: j.data[i].id
      };
     }
     return true;
    }

    return {
     net: $net,
     parse: $parse,
     global: $global
    };
   }();

   const streamlabs = function()
   {
    async function _showStreamlabsDonations(dRet)
    {
     for (let i = 0, l = dRet.length; i < l; i++)
     {
      const n = dRet[i].name;
      const a = dRet[i].amt;
      const v = Math.floor(a * cfg.streamlabs.curMul);
      const r = shared.findInMaybeRange(cfg.event.tip.streamlabs.donation, v);
      if (r === false)
       continue;
      let p = false;
      if (cfg.event.tip.useProfileImage && n !== false)
      {
       let u = false;
       if (!twitch.parse.uReg.test(n))
        u = await twitch.net.userInfo(n);
       if (u !== false)
       {
        if (u.hasOwnProperty('profile_image_url'))
         p = [
          {url: u.profile_image_url}
         ];
       }
      }
      let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
      if (cfg.streamlabs.dispDec > 0)
       s = s.toFixed(cfg.streamlabs.dispDec);
      else
       s = Math.floor(s);
      if (cfg.streamlabs.dispPre !== false)
       s = cfg.streamlabs.dispPre + s;
      if (cfg.streamlabs.dispSuf !== false)
       s += cfg.streamlabs.dispSuf;
      display.kappa.show(p, r, {'%USER%': n, '%AMOUNT%': s});
     }
    }

    async function _showStreamlabsPledges(pRet)
    {
     for (let i = 0, l = pRet.length; i < l; i++)
     {
      const n = pRet[i].name;
      const a = pRet[i].amt;
      const v = Math.floor(a * cfg.streamlabs.curMul);
      const r = shared.findInMaybeRange(cfg.event.tip.streamlabs.pledge, v);
      if (r === false)
       continue;
      let p = false;
      if (cfg.event.tip.useProfileImage && n !== false)
      {
       let u = false;
       if (!twitch.parse.uReg.test(n))
        u = await twitch.net.userInfo(n);
       if (u !== false)
       {
        if (u.hasOwnProperty('profile_image_url'))
         p = [
          {url: u.profile_image_url}
         ];
       }
      }
      let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
      if (cfg.streamlabs.dispDec > 0)
       s = s.toFixed(cfg.streamlabs.dispDec);
      else
       s = Math.floor(s);
      if (cfg.streamlabs.dispPre !== false)
       s = cfg.streamlabs.dispPre + s;
      if (cfg.streamlabs.dispSuf !== false)
       s += cfg.streamlabs.dispSuf;
      display.kappa.show(p, r, {'%USER%': n, '%AMOUNT%': s});
     }
    }

    const $socket = function()
    {
     let _wsRetry = 0;
     let _tPing = false;
     let _ws = null;
     let _lTimeout = 5000;
     let _tTimeout = false;

     function task()
     {
      _tPing = 0;
      _ws = new WebSocket(cURLs.ws.streamlabs.replaceAll('%TOKEN%', cfg.streamlabs.token));
      _ws.onopen = _wsOpen;
      _ws.onclose = _wsClose;
      _ws.onmessage = _wsMessage;
     }

     function _wsOpen()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.onopen = null;
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
     }

     function _wsClose()
     {
      notice.error(0x82);
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws = null;
      if (twitch.net.dead)
       return;
      const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
      if (_wsRetry < 2)
       _wsRetry += 0.2;
      window.setTimeout(streamlabs.socket, wsWait);
     }

     async function _wsMessage(ev)
     {
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_ws === null)
       return;
      if (twitch.net.dead)
      {
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       return;
      }
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      _wsRetry = 0;
      const d = ev.data;
      if (d.length < 1)
       return;
      notice.info(0x82);
      switch (d.slice(0, 1))
      {
       case '0':
        let t = 25000;
        let u = 5000;
        if (d.length > 1)
        {
         const c = JSON.parse(d.slice(1));
         if (c.hasOwnProperty('pingInterval'))
          t = c.pingInterval;
         if (c.hasOwnProperty('pingTimeout'))
          u = c.pingTimeout;
        }
        _lTimeout = t + u;
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, t);
        break;
       case '4':
        if (document.visibilityState === 'hidden')
         return;
        if (d.slice(1, 2) !== '2')
        {
         if (d.slice(1, 2) === '4')
         {
          notice.error(0x81);
          notice.error(0x82);
          _lTimeout = 5000;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          if (_tPing !== 0)
          {
           window.clearInterval(_tPing);
           _tPing = 0;
          }
          if (_ws === null)
           return;
          _ws.onopen = null;
          _ws.onmessage = null;
          _ws.onclose = null;
          _ws.close();
          _ws = null;
         }
         return;
        }
        if (d.length < 2)
         return;
        const o = JSON.parse(d.slice(2));
        if (o.length < 2)
         return;
        if (o[0] !== 'event')
         return;
        if (!o[1].hasOwnProperty('message'))
         return;
        let rD = [];
        let rP = [];
        for (let i = 0, l = o[1].message.length; i < l; i++)
        {
         if (!o[1].message[i].hasOwnProperty('amount'))
          continue;
         if (!o[1].message[i].hasOwnProperty('type'))
          continue;
         if (o[1].message[i].type === 'donation')
         {
          let n = false;
          if (o[1].message[i].hasOwnProperty('name'))
           n = o[1].message[i].name;
          rD.push({amt: o[1].message[i].amount, name: n});
         }
         if (o[1].message[i].type === 'pledge')
         {
          let n = false;
          if (o[1].message[i].hasOwnProperty('name'))
           n = o[1].message[i].name;
          rP.push({amt: o[1].message[i].amount, name: n});
         }
        }
        if (rD.length > 0)
         await _showStreamlabsDonations(rD);
        if (rP.length > 0)
         await _showStreamlabsPledges(rP);
        break;
      }
     }

     function _wsPing()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.send('2');
     }

     function _wsTimeout()
     {
      notice.error(0x82);
      _lTimeout = 5000;
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws.close();
      _ws = null;
      if (twitch.net.dead === true)
       return;
      streamlabs.socket();
     }

     return task;
    }();

    function $cfgVals()
    {
     if (!cfg.hasOwnProperty('streamlabs'))
      return 0;
     let r = 0;
     if (cfg.streamlabs.hasOwnProperty('token') && cfg.streamlabs.token !== false && cfg.streamlabs.token !== null && cfg.streamlabs.token !== 'SOCKET_TOKEN')
      r |= 0x01;
     return r;
    }

    return {
     socket: $socket,
     cfgVals: $cfgVals
    };
   }();

   const streamelements = function()
   {
    async function _showStreamElementsTip(dAmt, dName)
    {
     const v = Math.floor(dAmt * cfg.streamelements.curMul);
     if (v < 1)
      return;
     const r = shared.findInMaybeRange(cfg.event.tip.streamelements, v);
     if (r === false)
      return;
     let p = false;
     if (cfg.event.tip.useProfileImage && dName !== false)
     {
      let u = false;
      if (!twitch.parse.uReg.test(dName))
       u = await twitch.net.userInfo(dName);
      if (u !== false)
      {
       if (u.hasOwnProperty('profile_image_url'))
        p = [
         {url: u.profile_image_url}
        ];
      }
     }
     let s = Number.parseFloat(dAmt * cfg.streamelements.dispMul);
     if (cfg.streamelements.dispDec > 0)
      s = s.toFixed(cfg.streamelements.dispDec);
     else
      s = Math.floor(s);
     if (cfg.streamelements.dispPre !== false)
      s = cfg.streamelements.dispPre + s;
     if (cfg.streamelements.dispSuf !== false)
      s += cfg.streamelements.dispSuf;
     display.kappa.show(p, r, {'%USER%': dName, '%AMOUNT%': s});
    }

    const $socket = function()
    {
     let _wsRetry = 0;
     let _tPing = 0;
     let _ws = null;
     let _lTimeout = 5000;
     let _tTimeout = false;

     function task()
     {
      _tPing = 0;
      _ws = new WebSocket(cURLs.ws.streamelements);
      _ws.onopen = _wsOpen;
      _ws.onclose = _wsClose;
      _ws.onmessage = _wsMessage;
     }

     function _wsOpen()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.onopen = null;
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
     }

     function _wsClose()
     {
      notice.error(0x72);
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws = null;
      if (twitch.net.dead)
       return;
      const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
      if (_wsRetry < 2)
       _wsRetry += 0.2;
      window.setTimeout(streamelements.socket, wsWait);
     }

     async function _wsMessage(ev)
     {
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_ws === null)
       return;
      if (twitch.net.dead)
      {
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       return;
      }
      _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      _wsRetry = 0;
      const d = ev.data;
      if (d.length < 1)
       return;
      notice.info(0x72);
      switch (d.slice(0, 1))
      {
       case '0':
        let t = 25000;
        let u = 20000;
        if (d.length > 1)
        {
         const c = JSON.parse(d.slice(1));
         if (c.hasOwnProperty('pingInterval'))
          t = c.pingInterval;
         if (c.hasOwnProperty('pingTimeout'))
          u = c.pingTimeout;
        }
        _lTimeout = t + u;
        if (_tTimeout !== false)
        {
         window.clearTimeout(_tTimeout);
         _tTimeout = false;
        }
        _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, t);
        break;
       case '4':
        if (d.slice(1, 2) === '0')
        {
         let a = '';
         const seCfg = streamelements.cfgVals();
         if ((seCfg & 0x04) === 0x04)
          a = JSON.stringify(['authenticate', {'method': 'oauth2', 'token': cfg.streamelements.oauth}]);
         else if ((seCfg & 0x01) === 0x01)
          a = JSON.stringify(['authenticate', {'method': 'jwt', 'token': cfg.streamelements.token}]);
         if (_ws.readyState === 1)
          _ws.send('42' + a);
         return;
        }
        if (d.slice(1, 2) !== '2')
         return;
        if (d.length < 2)
         return;
        const o = JSON.parse(d.slice(2));
        if (o.length < 2)
         return;
        if (o[0] === 'unauthorized')
        {
         notice.error(0x71);
         notice.error(0x72);
         _lTimeout = 5000;
         if (_tTimeout !== false)
         {
          window.clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         if (_tPing !== 0)
         {
          window.clearInterval(_tPing);
          _tPing = 0;
         }
         if (_ws === null)
          return;
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         return;
        }
        if (document.visibilityState === 'hidden')
         return;
        if (o[0] !== 'event:update')
         return;
        if (!o[1].hasOwnProperty('name'))
         return;
        if (o[1].name !== 'tip-latest')
         return;
        if (!o[1].hasOwnProperty('data'))
         return;
        if (!o[1].data.hasOwnProperty('amount'))
         return;
        let n = false;
        if (o[1].data.hasOwnProperty('name'))
         n = o[1].data.name;
        await _showStreamElementsTip(o[1].data.amount, n);
        break;
      }
     }

     function _wsPing()
     {
      if (_ws === null)
       return;
      if (_ws.readyState !== 1)
       return;
      _ws.send('2');
     }

     function _wsTimeout()
     {
      notice.error(0x72);
      _lTimeout = 5000;
      if (_tTimeout !== false)
      {
       window.clearTimeout(_tTimeout);
       _tTimeout = false;
      }
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onopen = null;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws.close();
      _ws = null;
      if (twitch.net.dead === true)
       return;
      streamelements.socket();
     }

     return task;
    }();

    async function _getOAuthToken(t)
    {
     const url = cURLs.api.rr.refresh.se;
     const h = {'Content-Type': 'application/x-www-form-urlencoded'};
     const b = 'refresh=' + encodeURIComponent(t);
     const r = await shared.httpRequest('POST', url, h, b, false);
     if (!r.success)
      return false;
     const j = r.json;
     if (j === null)
      return false;
     if (!j.hasOwnProperty('access_token'))
      return false;
     if (!j.hasOwnProperty('refresh_token'))
      return false;
     if (!j.hasOwnProperty('expires_in'))
      return false;
     return j;
    }

    async function $updateOAuth()
    {
     const lsOAuth = window.localStorage.getItem('streamelements.tips:read.oauth');
     const lsRefresh = window.localStorage.getItem('streamelements.tips:read.refresh');
     const lsExpires = window.localStorage.getItem('streamelements.tips:read.expires');
     const lsRefreshed = window.localStorage.getItem('streamelements.tips:read.refreshed');
     if (lsOAuth !== null)
      cfg.streamelements.oauth = lsOAuth;
     if (lsRefresh !== null)
      cfg.streamelements.oauth_refresh = lsRefresh;
     if (lsExpires !== null)
      cfg.streamelements.oauth_expires = lsExpires;
     if (lsRefreshed !== null)
      cfg.streamelements.oauth_refreshed = lsRefreshed;
     let mustR = true;
     if (cfg.streamelements.hasOwnProperty('oauth_refreshed') && cfg.streamelements.oauth_refreshed > 0)
     {
      const tokAge = Math.floor(new Date().getTime() / 1000) - cfg.streamelements.oauth_refreshed;
      if (tokAge < 24 * 60 * 60)
       mustR = false;
     }
     if (cfg.streamelements.hasOwnProperty('oauth_expires') && cfg.streamelements.oauth_expires > 0)
     {
      const expTime = cfg.streamelements.oauth_expires - Math.floor(new Date().getTime() / 1000);
      if (expTime < 0)
       mustR = true;
     }
     if (!mustR)
      return;
     const ret = await _getOAuthToken(cfg.streamelements.oauth_refresh);
     if (ret === false)
     {
      window.localStorage.removeItem('streamelements.tips:read.oauth');
      window.localStorage.removeItem('streamelements.tips:read.refresh');
      window.localStorage.removeItem('streamelements.tips:read.expires');
      window.localStorage.removeItem('streamelements.tips:read.refreshed');
      notice.error(0x71);
      return;
     }
     cfg.streamelements.oauth = ret.access_token;
     cfg.streamelements.oauth_refresh = ret.refresh_token;
     cfg.streamelements.oauth_expires = Math.floor(new Date().getTime() / 1000) + ret.expires_in;
     cfg.streamelements.oauth_refreshed = Math.floor(new Date().getTime() / 1000);
     window.localStorage.setItem('streamelements.tips:read.oauth', cfg.streamelements.oauth);
     window.localStorage.setItem('streamelements.tips:read.refresh', cfg.streamelements.oauth_refresh);
     window.localStorage.setItem('streamelements.tips:read.expires', cfg.streamelements.oauth_expires);
     window.localStorage.setItem('streamelements.tips:read.refreshed', cfg.streamelements.oauth_refreshed);
    }

    function $cfgVals()
    {
     if (!cfg.hasOwnProperty('streamelements'))
      return 0;
     let r = 0;
     if (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== null && cfg.streamelements.token !== 'JWT_TOKEN')
      r |= 0x01;
     if (cfg.streamelements.hasOwnProperty('oauth_refresh') && cfg.streamelements.oauth_refresh !== false && cfg.streamelements.oauth_refresh !== null && cfg.streamelements.oauth_refresh !== 'OAUTH_REFRESH')
      r |= 0x02;
     if (cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== null && cfg.streamelements.oauth !== 'OAUTH_ID')
      r |= 0x04;
     return r;
    }

    return {
     socket: $socket,
     updateOAuth: $updateOAuth,
     cfgVals: $cfgVals
    };
   }();

   const thirdparty = function()
   {
    const _defSize = 28;

    function _addEmote(list, scope, code, id, url, w = false, h = false, zwe = false)
    {
     if (typeof list === 'undefined')
      return;
     if (cfg.ignore.emotes !== false && cfg.ignore.emotes.includes(code))
      return;
     if (w === false)
      w = _defSize;
     if (h === false)
      h = _defSize;
     list[code] = {scope: scope, url: url, id: id, width: w, height: h};
     if (scope === 'c' && !zwe)
      cList.push({url: url, width: w, height: h});
    }

    function _removeEmote(list, scope, code)
    {
     if (typeof list === 'undefined')
      return;
     if (!list.hasOwnProperty(code))
      return;
     if (list[code].scope !== scope)
      return;
     if (scope === 'c')
     {
      for (let c = cList.length - 1; c >= 0; c--)
      {
       if (cList[c].url !== list[code].url)
        continue;
       cList.splice(c, 1);
       break;
      }
     }
     delete list[code];
    }

    function _removeEmoteByID(list, scope, id)
    {
     if (typeof list === 'undefined')
      return;
     for (let i = Object.keys(list).length - 1; i >= 0; i--)
     {
      const k = Object.keys(list)[i];
      if (list[k].scope !== scope)
       continue;
      if (list[k].id !== id)
       continue;
      _removeEmote(list, scope, k);
      break;
     }
    }

    function _removeEmoteByScope(list, scope)
    {
     if (typeof list === 'undefined')
      return;
     for (let i = Object.keys(list).length - 1; i >= 0; i--)
     {
      const k = Object.keys(list)[i];
      if (list[k].scope !== scope)
       continue;
      _removeEmote(list, scope, k);
     }
    }

    const $ffz = function()
    {
     function _readFFZ_URL(entry)
     {
      let g = entry.animated ?? entry.urls ?? false;
      if (g === false)
       return false;
      let find = ['4', '2', '1'];
      for (let i = 0, l = find.length; i < l; i++)
      {
       if (!g.hasOwnProperty(find[i]))
        continue;
       return g[find[i]];
      }
      return false;
     }

     async function $global()
     {
      if (!thirdparty.emotes.hasOwnProperty('ffz'))
       thirdparty.emotes.ffz = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('ffz'))
       thirdparty.emotes.zwe.ffz = {};
      const url = cURLs.api.ffz.set.global;
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('sets'))
       return false;
      let usedSets = [];
      if (j.hasOwnProperty('default_sets'))
      {
       for (let i = 0, l = j.default_sets.length; i < l; i++)
        usedSets.push(j.default_sets[i]);
      }
      for (const set in j.sets)
      {
       if (!j.sets.hasOwnProperty(set))
        continue;
       if (!usedSets.includes(j.sets[set].id))
        continue;
       if (!j.sets[set].hasOwnProperty('emoticons'))
        continue;
       for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
       {
        if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
         continue;
        const u = _readFFZ_URL(j.sets[set].emoticons[i]);
        if (u === false)
         continue;
        let w = false;
        let h = false;
        if (j.sets[set].emoticons[i].hasOwnProperty('width'))
         w = j.sets[set].emoticons[i].width;
        if (j.sets[set].emoticons[i].hasOwnProperty('height'))
         h = j.sets[set].emoticons[i].height;
        if (j.sets[set].emoticons[i].hasOwnProperty('modifier') && j.sets[set].emoticons[i].modifier === true)
        {
         if (j.sets[set].emoticons[i].hasOwnProperty('modifier_flags') && (j.sets[set].emoticons[i].modifier_flags & 0x01) === 0x01)
          continue;
         if (cfg.display.extended.useZWE)
          _addEmote(thirdparty.emotes.zwe.ffz, 'g', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, w, h, true);
         continue;
        }
        _addEmote(thirdparty.emotes.ffz, 'g', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, w, h);
       }
      }
      if (!j.hasOwnProperty('users'))
      {
       cSafe = JSON.parse(JSON.stringify(cList));
       return true;
      }
      for (const setID in j.users)
      {
       if (!j.users.hasOwnProperty(setID))
        continue;
       const aList = j.users[setID];
       if (!Array.isArray(aList))
        continue;
       for (const set in j.sets)
       {
        if (!j.sets.hasOwnProperty(set))
         continue;
        if (setID !== set)
         continue;
        if (!j.sets[set].hasOwnProperty('emoticons'))
         continue;
        for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
        {
         if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
          continue;
         const u = _readFFZ_URL(j.sets[set].emoticons[i]);
         if (u === false)
          continue;
         let w = false;
         let h = false;
         if (j.sets[set].emoticons[i].hasOwnProperty('width'))
          w = j.sets[set].emoticons[i].width;
         if (j.sets[set].emoticons[i].hasOwnProperty('height'))
          h = j.sets[set].emoticons[i].height;
         if (j.sets[set].emoticons[i].hasOwnProperty('modifier') && j.sets[set].emoticons[i].modifier === true)
         {
          if (j.sets[set].emoticons[i].hasOwnProperty('modifier_flags') && (j.sets[set].emoticons[i].modifier_flags & 0x01) === 0x01)
           continue;
          if (cfg.display.extended.useZWE)
          {
           if (!thirdparty.emotes.zwe.hasOwnProperty('ffzU'))
            thirdparty.emotes.zwe.ffzU = {};
           for (let k = 0, m = aList.length; k < m; k++)
           {
            if (!thirdparty.emotes.zwe.ffzU.hasOwnProperty(aList[k]))
             thirdparty.emotes.zwe.ffzU[aList[k]] = {};
            _addEmote(thirdparty.emotes.zwe.ffzU[aList[k]], 'u', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, w, h, true);
           }
          }
          continue;
         }
         if (!thirdparty.emotes.hasOwnProperty('ffzU'))
          thirdparty.emotes.ffzU = {};
         for (let k = 0, m = aList.length; k < m; k++)
         {
          if (!thirdparty.emotes.ffzU.hasOwnProperty(aList[k]))
           thirdparty.emotes.ffzU[aList[k]] = {};
          _addEmote(thirdparty.emotes.ffzU[aList[k]], 'u', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, w, h);
         }
        }
       }
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     async function $channelEx(chID)
     {
      const url = cURLs.api.ffz.room.replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('sets'))
       return false;
      let ret = [];
      for (const set in j.sets)
      {
       if (!j.sets[set].hasOwnProperty('emoticons'))
        continue;
       for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
       {
        if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
         continue;
        let m = false;
        if (j.sets[set].emoticons[i].hasOwnProperty('modifier') && j.sets[set].emoticons[i].modifier === true)
        {
         if (j.sets[set].emoticons[i].hasOwnProperty('modifier_flags'))
          m = j.sets[set].emoticons[i].modifier_flags;
         else
          m = 0;
        }
        const u = _readFFZ_URL(j.sets[set].emoticons[i]);
        if (u === false)
         continue;
        let w = false;
        let h = false;
        if (j.sets[set].emoticons[i].hasOwnProperty('width'))
         w = j.sets[set].emoticons[i].width;
        if (j.sets[set].emoticons[i].hasOwnProperty('height'))
         h = j.sets[set].emoticons[i].height;
        ret.push({name: j.sets[set].emoticons[i].name, id: j.sets[set].emoticons[i].id, url: u, modifier: m, width: w, height: h});
       }
      }
      return ret;
     }

     async function $channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('ffz'))
       thirdparty.emotes.ffz = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('ffz'))
       thirdparty.emotes.zwe.ffz = {};
      const r = await thirdparty.ffz.channelEx(chID);
      if (r === false)
       return false;
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (r[i].modifier !== false)
       {
        if ((r[i].modifier & 0x01) === 0x01)
         continue;
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe.ffz, 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height, true);
        continue;
       }
       _addEmote(thirdparty.emotes.ffz, 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height);
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     return {
      global: $global,
      channel: $channel,
      channelEx: $channelEx
     };
    }();

    const $bttv = function()
    {
     const _rBE = 600000;

     function $reload(chID)
     {
      if (thirdparty.bttv.timer === false)
       return;
      window.clearTimeout(thirdparty.bttv.timer);
      thirdparty.bttv.timer = false;
      if (cfg.display.extended.useBTTV)
       thirdparty.bttv.channel(twitch.net.channelID);
      thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, thirdparty.interval, chID);
     }

     async function $global()
     {
      if (!thirdparty.emotes.hasOwnProperty('bttv'))
       thirdparty.emotes.bttv = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('bttv'))
       thirdparty.emotes.zwe.bttv = {};
      const url = cURLs.api.bttv.emotes.global;
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!Array.isArray(j))
       return false;
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('code'))
        continue;
       if (!j[i].hasOwnProperty('id'))
        continue;
       const eURL = cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', j[i].id);
       let w = _defSize;
       let h = _defSize;
       if (j[i].hasOwnProperty('width'))
        w = j[i].width;
       if (j[i].hasOwnProperty('height'))
        h = j[i].height;
       if (bttvZWE.includes(j[i].id))
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe.bttv, 'g', j[i].code, j[i].id, eURL, w, h, true);
        continue;
       }
       _addEmote(thirdparty.emotes.bttv, 'g', j[i].code, j[i].id, eURL, w, h);
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     async function $channelEx(chID)
     {
      const url = cURLs.api.bttv.users.twitch.replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      let ret = [];
      if (j.hasOwnProperty('channelEmotes'))
      {
       for (let i = 0, l = j.channelEmotes.length; i < l; i++)
       {
        if (!j.channelEmotes[i].hasOwnProperty('code'))
         continue;
        if (!j.channelEmotes[i].hasOwnProperty('id'))
         continue;
        let w = _defSize;
        let h = _defSize;
        if (j.channelEmotes[i].hasOwnProperty('width'))
         w = j.channelEmotes[i].width;
        if (j.channelEmotes[i].hasOwnProperty('height'))
         h = j.channelEmotes[i].height;
        ret.push({name: j.channelEmotes[i].code, id: j.channelEmotes[i].id, url: cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', j.channelEmotes[i].id), width: w, height: h});
       }
      }
      if (j.hasOwnProperty('sharedEmotes'))
      {
       for (let i = 0, l = j.sharedEmotes.length; i < l; i++)
       {
        if (!j.sharedEmotes[i].hasOwnProperty('code'))
         continue;
        if (!j.sharedEmotes[i].hasOwnProperty('id'))
         continue;
        let w = _defSize;
        let h = _defSize;
        if (j.sharedEmotes[i].hasOwnProperty('width'))
         w = j.sharedEmotes[i].width;
        if (j.sharedEmotes[i].hasOwnProperty('height'))
         h = j.sharedEmotes[i].height;
        ret.push({name: j.sharedEmotes[i].code, id: j.sharedEmotes[i].id, url: cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', j.sharedEmotes[i].id), width: w, height: h});
       }
      }
      return ret;
     }

     async function $channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('bttv'))
       thirdparty.emotes.bttv = {};
      const r = await thirdparty.bttv.channelEx(chID);
      if (r === false)
       return false;
      _removeEmoteByScope(thirdparty.emotes.bttv, 'c');
      _removeEmoteByScope(thirdparty.emotes.zwe.bttv, 'c');
      for (let i = 0, l = r.length; i < l; i++)
      {
       if (bttvZWE.includes(r[i].id))
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe.bttv, 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height, true);
        continue;
       }
       _addEmote(thirdparty.emotes.bttv, 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height);
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     const $socket = function()
     {
      let _wsRetry = 0;
      let _ch = 0;
      let _ws = null;

      function task(chID = false)
      {
       if (chID !== false)
        _ch = chID;
       _ws = new WebSocket(cURLs.ws.bttv);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       notice.info(0xB2);
       _ws.onopen = null;
       _ws.send(JSON.stringify({'name': 'join_channel', 'data': {'name': 'twitch:' + _ch}}));
      }

      function _wsClose()
      {
       notice.error(0xB2);
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(thirdparty.bttv.socket, wsWait);
      }

      function _wsMessage(ev)
      {
       if (_ws === null)
        return;
       if (twitch.net.dead)
       {
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        return;
       }
       _wsRetry = 0;
       const d = JSON.parse(ev.data);
       if (!d.hasOwnProperty('name'))
        return;
       if (!d.hasOwnProperty('data'))
        return;
       switch (d.name)
       {
        case 'lookup_user':
         if (!d.data.hasOwnProperty('name'))
          return;
         if (!d.data.hasOwnProperty('emotes') || !Array.isArray(d.data.emotes) || d.data.emotes.length < 1)
          return;
         if (!thirdparty.emotes.hasOwnProperty('bttvU'))
          thirdparty.emotes.bttvU = {};
         thirdparty.emotes.bttvU[d.data.name] = {};
         if (!thirdparty.emotes.zwe.hasOwnProperty('bttvU'))
          thirdparty.emotes.zwe.bttvU = {};
         thirdparty.emotes.zwe.bttvU[d.data.name] = {};
         for (let i = 0, l = d.data.emotes.length; i < l; i++)
         {
          if (!d.data.emotes[i].hasOwnProperty('code'))
           continue;
          if (!d.data.emotes[i].hasOwnProperty('id'))
           continue;
          let w = _defSize;
          let h = _defSize;
          if (d.data.emotes[i].hasOwnProperty('width'))
           w = d.data.emotes[i].width;
          if (d.data.emotes[i].hasOwnProperty('height'))
           h = d.data.emotes[i].height;
          if (bttvZWE.includes(d.data.emotes[i].id))
          {
           if (cfg.display.extended.useZWE)
            _addEmote(thirdparty.emotes.zwe.bttvU[d.data.name], 'u', d.data.emotes[i].code, d.data.emotes[i].id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emotes[i].id), w, h, true);
           continue;
          }
          _addEmote(thirdparty.emotes.bttvU[d.data.name], 'u', d.data.emotes[i].code, d.data.emotes[i].id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emotes[i].id), w, h);
         }
         cSafe = JSON.parse(JSON.stringify(cList));
         break;
        case 'emote_create':
         if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + _ch)
          return;
         if (!d.data.hasOwnProperty('emote'))
          return;
         if (!d.data.emote.hasOwnProperty('id'))
          return;
         if (!d.data.emote.hasOwnProperty('code'))
          return;
         let wC = _defSize;
         let hC = _defSize;
         if (d.data.emote.hasOwnProperty('width'))
          wC = d.data.emote.width;
         if (d.data.emote.hasOwnProperty('height'))
          hC = d.data.emote.height;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _addEmote(thirdparty.emotes.bttv, 'c', d.data.emote.code, d.data.emote.id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emote.id), wC, hC);
         cSafe = JSON.parse(JSON.stringify(cList));
         thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, _rBE, _ch);
         break;
        case 'emote_delete':
         if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + _ch)
          return;
         if (!d.data.hasOwnProperty('emoteId'))
          return;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _removeEmoteByID(thirdparty.emotes.bttv, 'c', d.data.emoteId);
         cSafe = JSON.parse(JSON.stringify(cList));
         thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, _rBE, _ch);
         break;
        case 'emote_update':
         if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + _ch)
          return;
         if (!d.data.hasOwnProperty('emote'))
          return;
         if (!d.data.emote.hasOwnProperty('id'))
          return;
         if (!d.data.emote.hasOwnProperty('code'))
          return;
         let wU = _defSize;
         let hU = _defSize;
         if (d.data.emote.hasOwnProperty('width'))
          wU = d.data.emote.width;
         if (d.data.emote.hasOwnProperty('height'))
          hU = d.data.emote.height;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _removeEmoteByID(thirdparty.emotes.bttv, 'c', d.data.emote.id);
         _addEmote(thirdparty.emotes.bttv, 'c', d.data.emote.code, d.data.emote.id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emote.id), wU, hU);
         cSafe = JSON.parse(JSON.stringify(cList));
         thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, _rBE, _ch);
         break;
       }
      }

      return task;
     }();

     return {
      timer: false,
      global: $global,
      channel: $channel,
      channelEx: $channelEx,
      socket: $socket,
      reload: $reload
     };
    }();

    const $7tv = function()
    {
     function _read7tv_URL(entry)
     {
      if (!entry.hasOwnProperty('host') || entry.host === null)
       return false;
      if (!entry.host.hasOwnProperty('url') || entry.host.url === null)
       return false;
      if (!entry.host.hasOwnProperty('files') || entry.host.files === null)
       return false;
      if (!Array.isArray(entry.host.files))
       return false;
      let g = [];
      let findFormat = 'WEBP';
      if (typeof cfg.display.extended.use7TV === 'string')
       findFormat = cfg.display.extended.use7TV.toUpperCase();
      for (let i = 0, l = entry.host.files.length; i < l; i++)
      {
       if (!entry.host.files[i].hasOwnProperty('format') || entry.host.files[i].format === null)
        continue;
       if (!entry.host.files[i].hasOwnProperty('name') || entry.host.files[i].name === null)
        continue;
       if (entry.host.files[i].format !== findFormat)
        continue;
       const dpp = entry.host.files[i].name.slice(0, 1);
       const addr = 'https:' + entry.host.url + '/' + entry.host.files[i].name;
       let w = false;
       let h = false;
       if (entry.host.files[i].hasOwnProperty('width') && entry.host.files[i].width !== null)
        w = entry.host.files[i].width;
       if (entry.host.files[i].hasOwnProperty('height') && entry.host.files[i].height !== null)
        h = entry.host.files[i].height;
       g.push({dpp: dpp, url: addr, width: w, height: h});
      }
      if (g.length < 1)
       return false;
      let find = ['4', '3', '2', '1'];
      for (let i = 0, l = find.length; i < l; i++)
      {
       for (let j = 0, m = g.length; j < m; j++)
       {
        if (g[j].dpp === find[i])
         return g[j];
       }
      }
      return false;
     }

     async function $global()
     {
      if (!thirdparty.emotes.hasOwnProperty('7tv'))
       thirdparty.emotes['7tv'] = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
       thirdparty.emotes.zwe['7tv'] = {};
      const url = cURLs.api['7tv'].emotes.global;
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('emotes') || j.emotes === null)
       return false;
      if (!Array.isArray(j.emotes))
       return false;
      for (let i = 0, l = j.emotes.length; i < l; i++)
      {
       if (!j.emotes[i].hasOwnProperty('data') || j.emotes[i].data === null)
        continue;
       if (!j.emotes[i].data.hasOwnProperty('id') || j.emotes[i].data.id === null)
        continue;
       if (!j.emotes[i].data.hasOwnProperty('name') || j.emotes[i].data.name === null)
        continue;
       const jInf = _read7tv_URL(j.emotes[i].data);
       if (jInf === false)
        continue;
       if (j.emotes[i].data.hasOwnProperty('flags') && j.emotes[i].data.flags !== null && (j.emotes[i].data.flags & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe['7tv'], 'g', j.emotes[i].data.name, j.emotes[i].data.id, jInf.url, jInf.width, jInf.height, true);
        continue;
       }
       _addEmote(thirdparty.emotes['7tv'], 'g', j.emotes[i].data.name, j.emotes[i].data.id, jInf.url, jInf.width, jInf.height);
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     async function $channelEx(chID)
     {
      const url = cURLs.api['7tv'].users.root.replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('emote_set') || j.emote_set === null)
       return false;
      if (!j.emote_set.hasOwnProperty('emotes') || j.emote_set.emotes === null)
       return false;
      if (!Array.isArray(j.emote_set.emotes))
       return false;
      let ret = [];
      for (let i = 0, l = j.emote_set.emotes.length; i < l; i++)
      {
       if (!j.emote_set.emotes[i].hasOwnProperty('data') || j.emote_set.emotes[i].data === null)
        continue;
       if (!j.emote_set.emotes[i].data.hasOwnProperty('id') || j.emote_set.emotes[i].data.id === null)
        continue;
       if (!j.emote_set.emotes[i].data.hasOwnProperty('name') || j.emote_set.emotes[i].data.name === null)
        continue;
       const jInf = _read7tv_URL(j.emote_set.emotes[i].data);
       if (jInf === false)
        continue;
       let vis = 0;
       if (j.emote_set.emotes[i].data.hasOwnProperty('flags') && j.emote_set.emotes[i].data.flags !== null)
        vis = j.emote_set.emotes[i].data.flags;
       ret.push({name: j.emote_set.emotes[i].data.name, id: j.emote_set.emotes[i].data.id, url: jInf.url, vis: vis, width: jInf.width, height: jInf.height});
      }
      return ret;
     }

     async function $channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('7tv'))
       thirdparty.emotes['7tv'] = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
       thirdparty.emotes.zwe['7tv'] = {};
      const r = await thirdparty['7tv'].channelEx(chID);
      if (r === false)
       return false;
      for (let i = 0, l = r.length; i < l; i++)
      {
       if ((r[i].vis & thirdparty['7tv'].zweFlag) === thirdparty['7tv'].zweFlag)
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe['7tv'], 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height, true);
        continue;
       }
       _addEmote(thirdparty.emotes['7tv'], 'c', r[i].name, r[i].id, r[i].url, r[i].width, r[i].height);
      }
      cSafe = JSON.parse(JSON.stringify(cList));
      return true;
     }

     async function _load7TV_channelID(chID)
     {
      const url = cURLs.api['7tv'].users.root.replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest('GET', url);
      if (!r.success)
       return false;
      const j = r.json;
      if (j === null)
       return false;
      if (!j.hasOwnProperty('user') || j.user === null)
       return false;
      if (!j.user.hasOwnProperty('id') || j.user.id === null)
       return false;
      return j.user.id;
     }

     const $socket = function()
     {
      const _lDelay = 500;
      let _wsRetry = 0;
      let _wsR_RL = 0;
      let _wsR_M = 0;
      let _ch = 0;
      let _accID = false;
      let _ws = null;
      let _sess = null;
      let _lTimeout = 5000;
      let _tTimeout = false;
      let _okCt = 0;

      async function task(chID = false)
      {
       if (chID !== false)
        _ch = chID;
       _accID = await _load7TV_channelID(_ch);
       if (_accID === false)
        return;
       _ws = new WebSocket(cURLs.ws['7tv']);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.onopen = null;
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
      }

      function _wsClose()
      {
       notice.error(0xC2);
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(thirdparty['7tv'].socket, wsWait);
      }

      function _wsMessage(ev)
      {
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       if (twitch.net.dead)
       {
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
        _ws = null;
        return;
       }
       _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
       const d = JSON.parse(ev.data);
       if (!d.hasOwnProperty('op') || d.op === null)
        return;
       if (!d.hasOwnProperty('d'))
        return;
       notice.info(0xC2);
       switch (d.op)
       {
        case 0:
         if (thirdparty.timer !== false)
          window.clearTimeout(thirdparty.timer);
         thirdparty.timer = window.setTimeout(thirdparty.reload, _lDelay, _ch);
         break;
        case 1:
         if (d.d === null)
          return;
         _okCt = 0;
         if (_sess !== null)
         {
          if (_ws.readyState === 1)
           _ws.send(JSON.stringify({'op': 34, 'd': {'session_id': _sess}}));
         }
         else
          _wsSub();
         if (d.d.hasOwnProperty('session_id') && d.d.session_id !== null)
          _sess = d.d.session_id;
         if (d.d.hasOwnProperty('heartbeat_interval') && d.d.heartbeat_interval !== null)
         {
          _lTimeout = parseInt(d.d.heartbeat_interval, 10) * 3;
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _tTimeout = window.setTimeout(_wsTimeout, _lTimeout);
         }
         break;
        case 2:
         if (_okCt !== 3)
         {
          if (_tTimeout !== false)
          {
           window.clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _ws.onopen = null;
          _ws.onmessage = null;
          _ws.onclose = null;
          _ws.close();
          _ws = null;
          const wsRedo = Math.floor(wWS ** (1 + _wsRetry) * 1000);
          if (_wsRetry < 2)
           _wsRetry += 0.2;
          window.setTimeout(thirdparty['7tv'].socket, wsRedo);
          return;
         }
         _wsRetry = 0;
         _wsR_RL = 0;
         _wsR_M = 0;
         break;
        case 5:
         if (d.d === null)
          return;
         if (!d.d.hasOwnProperty('command') || d.d.command === null)
          return;
         switch (d.d.command)
         {
          case 'RESUME':
           if (!d.d.hasOwnProperty('data') || d.d.data === null)
            return;
           if (!d.d.data.hasOwnProperty('success'))
            return;
           if (d.d.data.success === false || d.d.data.success === null)
            _wsSub();
           else
           {
            if (!d.d.data.hasOwnProperty('subscriptions_restored') || d.d.data.subscriptions_restored === null)
             return;
            if (d.d.data.subscriptions_restored !== 3)
            {
             if (d.d.data.subscriptions_restored > 0)
              _wsUnsub();
             _wsSub();
            }
            else
             _okCt = d.d.data.subscriptions_restored;
           }
           break;
          case 'SUBSCRIBE':
           _okCt++;
           break;
         }
         break;
        case 7:
         if (d.d === null)
          return;
         if (_tTimeout !== false)
         {
          window.clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         let wsWait = _lDelay;
         if (d.d.hasOwnProperty('code') && d.d.code !== null)
         {
          switch (d.d.code)
          {
           case 4001:
           case 4002:
           case 4003:
           case 4004:
           case 4009:
           case 4010:
           case 4011:
            _sess = null;
            return;
           case 4005:
            wsWait = Math.floor((5 ** (1 + _wsR_RL) / 5) * 60 * 1000);
            if (_wsR_RL < 2.6)
             _wsR_RL += 0.2;
            break;
           case 4006:
            wsWait = Math.max(wsWait, 5 * 60 * 1000);
            break;
           case 4007:
            wsWait = 5 * 60 * 1000 + Math.floor(wWS ** (1 + _wsR_M) * 1000) - 5000;
            if (_wsR_M < 2)
             _wsR_M += 0.2;
            break;
           case 4000:
           case 4008:
            wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
            if (_wsRetry < 2)
             _wsRetry += 0.2;
            break;
          }
         }
         window.setTimeout(thirdparty['7tv'].socket, wsWait);
         break;
       }
      }

      function _wsUnsub()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send(JSON.stringify({'op': 36, 'd': {'type':'user.*', 'condition': {'object_id': _accID}}}));
       _ws.send(JSON.stringify({'op': 36, 'd': {'type':'emote.*', 'condition': {'object_id': _accID}}}));
       _ws.send(JSON.stringify({'op': 36, 'd': {'type':'emote_set.*', 'condition': {'object_id': _accID}}}));
      }

      function _wsSub()
      {
       if (_ws === null)
        return;
       if (_ws.readyState !== 1)
        return;
       _ws.send(JSON.stringify({'op': 35, 'd': {'type':'user.*', 'condition': {'object_id': _accID}}}));
       _ws.send(JSON.stringify({'op': 35, 'd': {'type':'emote.*', 'condition': {'object_id': _accID}}}));
       _ws.send(JSON.stringify({'op': 35, 'd': {'type':'emote_set.*', 'condition': {'object_id': _accID}}}));
      }

      function _wsTimeout()
      {
       notice.error(0xC2);
       _lTimeout = 5000;
       if (_tTimeout !== false)
       {
        window.clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws.close();
       _ws = null;
       if (twitch.net.dead === true)
        return;
       thirdparty['7tv'].socket();
      }

      return task;
     }();

     return {
      global: $global,
      channel: $channel,
      channelEx: $channelEx,
      socket: $socket,
      zweFlag: 0x100
     };
    }();

    function $reload(chID)
    {
     if (thirdparty.timer === false)
      return;
     window.clearTimeout(thirdparty.timer);
     thirdparty.timer = false;
     if (cfg.display.extended.useFFZ)
      thirdparty.ffz.channel(twitch.net.channelID);
     if (cfg.display.extended.use7TV)
      thirdparty['7tv'].channel(twitch.net.channelID);
     thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval, chID);
    }

    return {
     emotes: {},
     timer: false,
     interval: 60000,
     ffz: $ffz,
     bttv: $bttv,
     '7tv': $7tv,
     reload: $reload
    };
   }();

   const shared = function()
   {
    function $rnd(m)
    {
     let r = new Uint32Array(1);
     window.crypto.getRandomValues(r);
     const f = r[0] / 4294967295;
     if (m === undefined)
      return f;
     if (m < 1)
      return f * m;
     return Math.floor(f * m);
    }

    function $httpRequest(type, url, hdrs = {}, body = null, nocache = true, ret = true)
    {
     const p = new Promise(
      function(resolve)
      {
       const x = new XMLHttpRequest();
       if (nocache)
       {
        if (url.includes('?'))
         url+= '&';
        else
         url+= '?';
        url+= 'nocache=' + shared.rnd(0xFFFFFFFF);
       }
       x.open(type, url);
       for (const hK in hdrs)
       {
        if (!hdrs.hasOwnProperty(hK))
         continue;
        x.setRequestHeader(hK, hdrs[hK]);
       }
       x.onreadystatechange = function()
       {
        if (ret === false)
        {
         if (x.readyState < 2)
          return;
         x.onreadystatechange = null;
         resolve(Math.floor(x.status / 100) === 2);
         return;
        }
        if (x.readyState !== 4)
         return;
        x.onreadystatechange = null;
        resolve({code: x.status, data: x.responseText, get success(){return Math.floor(this.code / 100) === 2;}, get json(){try{return JSON.parse(this.data);}catch(ex){return null;}}});
       };
       if (body === null)
        x.send();
       else
        x.send(body);
      }
     );
     return p;
    }

    function $findInMaybeRange(r, v)
    {
     const t = typeof r;
     switch (t)
     {
      case 'undefined':
       return false;
      case 'boolean':
       return r === true;
      case 'number':
       if (r > 0 && v >= r)
        return true;
       return false;
      case 'object':
       if (r === null)
        return false;
       for (const k in r)
       {
        if (!r.hasOwnProperty(k))
         continue;
        let lower = 0;
        let upper = 0;
        if (k.slice(-1) === '+')
        {
         lower = parseInt(k.slice(0, -1), 10);
         upper = Number.MAX_SAFE_INTEGER;
        }
        else if (k.indexOf('-') !== -1)
        {
         lower = parseInt(k.slice(0, k.indexOf('-')), 10);
         upper = parseInt(k.slice(k.indexOf('-') + 1), 10);
        }
        else
        {
         lower = parseInt(k, 10);
         upper = parseInt(k, 10);
        }
        if (v >= lower && v <= upper)
         return r[k];
       }
     }
     return false;
    }

    function $clearAddr()
    {
     const o = window.location.toString();
     let u = o;
     if (u.indexOf('#') > -1)
      u = u.slice(0, u.indexOf('#'));
     if (u.indexOf('?') > -1)
      u = u.slice(0, u.indexOf('?'));
     if (u !== o)
      window.history.replaceState(null, '', u);
    }

    function $doNextFrame(cb)
    {
     let a = [];
     for (let i = 1, l = arguments.length; i < l; i++)
     {
      a.push(arguments[i]);
     }
     let n = false;
     function _next()
     {
      if (n === false)
      {
       n = true;
       window.requestAnimationFrame(_next);
       return;
      }
      cb(...a);
     }
     window.requestAnimationFrame(_next);
    }

    const $mspf = function()
    {
     let _init = 0;
     let _avg = [];

     function $init()
     {
      if (shared.mspf.value !== 0)
       return;
      window.requestAnimationFrame(_test);
     }

     function _test(ms)
     {
      if (_init !== 0)
       _avg.push(ms - _init);
      if (_avg.length > 2)
       shared.mspf.value = _avg.reduce((a,b) => (a+b)) / _avg.length;
      if (_avg.length > 300)
      {
       shared.mspf.value = Math.round(shared.mspf.value * 1000) / 1000;
       return;
      }
      _init = ms;
      window.requestAnimationFrame(_test);
     }

     return {
      init: $init,
      value: 0
     };
    }();

    const $ec = function()
    {
     const _dbName = 'ewec';
     const _tblName = 'emotes';

     function $save(url, w, h)
     {
      const o = window.indexedDB.open(_dbName, 1);
      o.onupgradeneeded = function(ev)
      {
       const d = ev.target.result;
       d.createObjectStore(_tblName, {keyPath: 'url'});
      };
      o.onerror = function()
      {
       window.indexedDB.deleteDatabase(_dbName);
      };
      o.onsuccess = function(ev)
      {
       const d = ev.target.result;
       if (d.objectStoreNames[0] !== _tblName)
       {
        d.close();
        window.indexedDB.deleteDatabase(_dbName);
        return;
       }
       let tx;
       try
       {
        tx = d.transaction(_tblName, 'readwrite');
       }
       catch(ex)
       {
        d.close();
        window.indexedDB.deleteDatabase(_dbName);
        return;
       }
       const s = tx.objectStore(_tblName);
       const p = s.put({url: url, w: w, h: h});
       p.onerror = function()
       {
        d.close();
       };
       p.onsuccess = function()
       {
        d.close();
       };
      };
     }

     function $get(url)
     {
      return new Promise(
       function(resolve)
       {
        const o = window.indexedDB.open(_dbName, 1);
        o.onupgradeneeded = function()
        {
         resolve(null);
        };
        o.onblocked = function()
        {
         resolve(null);
        };
        o.onerror = function()
        {
         resolve(null);
        };
        o.onsuccess = function(ev)
        {
         const dbr = ev.target.result;
         if (dbr.objectStoreNames[0] !== _tblName)
         {
          dbr.close();
          resolve(null);
          return;
         }
         let tx;
         try
         {
          tx = dbr.transaction(_tblName, 'readonly');
         }
         catch(ex)
         {
          dbr.close();
          resolve(null);
          return;
         }
         const s = tx.objectStore(_tblName);
         let g = s.get(url);
         g.onerror = function()
         {
          dbr.close();
          resolve(null);
         };
         g.onsuccess = function(ev2)
         {
          dbr.close();
          if (typeof ev2.currentTarget.result !== 'undefined')
           resolve({width: ev2.currentTarget.result.w, height: ev2.currentTarget.result.h});
          else
           resolve(null);
         };
        };
       }
      );
     }

     function $clear()
     {
      window.indexedDB.deleteDatabase(_dbName);
     }

     return {
      save: $save,
      get: $get,
      clear: $clear
     };
    }();

    return {
     rnd: $rnd,
     httpRequest: $httpRequest,
     findInMaybeRange: $findInMaybeRange,
     clearAddr: $clearAddr,
     doNextFrame: $doNextFrame,
     mspf: $mspf,
     ec: $ec
    };
   }();

   const login = function()
   {
    let _tL = false;
    const _visTime = 5000;

    function _activeScope()
    {
     let r = [];
     r.push('chat:read');
     for (const k of cfg.commands)
     {
      if (!k.hasOwnProperty('redeem') || !Array.isArray(k.redeem) || k.redeem.length < 1)
       continue;
      r.push('channel:read:redemptions');
      break;
     }
     let needF = false;
     if (cfg.event.follow !== false)
      needF = true;
     else
     {
      if ((cfg.display.access & 0x002) === 0x002 && (cfg.display.access & 0x001) !== 0x001)
       needF = true;
      else if ((cfg.display.kappa.access & 0x002) === 0x002 && (cfg.display.kappa.access & 0x001) !== 0x001)
       needF = true;
      else
      {
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('styles'))
         continue;
        if (!k.hasOwnProperty('access'))
         continue;
        if ((k.access & 0x002) === 0x002 && (k.access & 0x001) !== 0x001)
        {
         needF = true;
         break;
        }
       }
      }
     }
     if (needF)
      r.push('moderator:read:followers');
     if (cfg.event.hypetrain !== false && ((cfg.event.hypetrain.hasOwnProperty('begin') && cfg.event.hypetrain.begin !== false) || (cfg.event.hypetrain.hasOwnProperty('success') && cfg.event.hypetrain.success !== false)))
      r.push('channel:read:hype_train');
     if (cfg.event.goal !== false && ((cfg.event.goal.hasOwnProperty('begin') && cfg.event.goal.begin !== false) || (cfg.event.goal.hasOwnProperty('achieved') && cfg.event.goal.achieved !== false)))
      r.push('channel:read:goals');
     if (cfg.event.poll !== false && ((cfg.event.poll.hasOwnProperty('begin') && cfg.event.poll.begin !== false) || (cfg.event.poll.hasOwnProperty('end') && cfg.event.poll.end !== false)))
      r.push('channel:read:polls');
     if (cfg.event.prediction !== false && ((cfg.event.prediction.hasOwnProperty('begin') && cfg.event.prediction.begin !== false) || (cfg.event.prediction.hasOwnProperty('resolved') && cfg.event.prediction.resolved !== false)))
      r.push('channel:read:predictions');
     if (cfg.event.charity !== false)
      r.push('channel:read:charity');
     if (cfg.event.shoutout !== false && ((cfg.event.shoutout.hasOwnProperty('create') && cfg.event.shoutout.create !== false && cfg.event.shoutout.create.hasOwnProperty('styles') && cfg.event.shoutout.create.styles !== false) || (cfg.event.shoutout.hasOwnProperty('receive') && cfg.event.shoutout.receive !== false && cfg.event.shoutout.receive.hasOwnProperty('styles') && cfg.event.shoutout.receive.styles !== false)))
      r.push('moderator:read:shoutouts');
     return r;
    }

    function _uScope()
    {
     return encodeURIComponent(_activeScope().join(' '));
    }

    function $path()
    {
     return 'twitch.' + _activeScope().join('+');
    }

    function $cfgVals()
    {
     if (!cfg.hasOwnProperty('login'))
      return 0;
     let r = 0;
     if (cfg.hasOwnProperty('channel') && cfg.channel !== false && cfg.channel !== null && cfg.channel !== 'CHANNEL_NAME')
      r |= 0x01;
     if (cfg.login.hasOwnProperty('oauth_refresh') && cfg.login.oauth_refresh !== false && cfg.login.oauth_refresh !== null && cfg.login.oauth_refresh !== 'OAUTH_REFRESH')
      r |= 0x02;
     if (cfg.login.hasOwnProperty('oauth') && cfg.login.oauth !== false && cfg.login.oauth !== null && cfg.login.oauth !== 'OAUTH_ID')
      r |= 0x04;
     return r;
    }

    function $use()
    {
     login.inUse = false;
     if (login.cfgVals() > 0x01)
      return false;
     login.inUse = true;
     let lsChannel = window.localStorage.getItem(login.path() + '.channel');
     let lsClient = window.localStorage.getItem(login.path() + '.client');
     let lsOAuth = window.localStorage.getItem(login.path() + '.oauth');
     let lsRefresh = window.localStorage.getItem(login.path() + '.refresh');
     let lsScope = window.localStorage.getItem(login.path() + '.scope');
     if (lsChannel === null || lsRefresh === null)
     {
      const h = _getHashParams();
      if (!h.hasOwnProperty('channel') || !h.hasOwnProperty('client') || !h.hasOwnProperty('oauth') || !h.hasOwnProperty('oauth_refresh') || !h.hasOwnProperty('scope'))
      {
       login.showIn();
       return true;
      }
      lsChannel = h.channel;
      lsClient = h.client;
      lsOAuth = h.oauth;
      lsRefresh = h.oauth_refresh;
      lsScope = decodeURIComponent(h.scope);
      window.localStorage.setItem(login.path() + '.channel', lsChannel);
      window.localStorage.setItem(login.path() + '.oauth', lsOAuth);
      window.localStorage.setItem(login.path() + '.refresh', lsRefresh);
      window.localStorage.setItem(login.path() + '.client', lsClient);
      window.localStorage.setItem(login.path() + '.scope', lsScope);
     }
     cfg.channel = lsChannel;
     cfg.login.oauth = lsOAuth;
     cfg.login.oauth_refresh = lsRefresh;
     cfg.login.client = lsClient;
     cfg.login.scope = decodeURIComponent(lsScope).split(' ');
     login.showOut();
     return false;
    }

    function _getHashParams()
    {
     const d = function(s) {
      const a = /\+/g;
      return decodeURIComponent(s.replace(a, ' '));
     };
     let hashParams = {};
     const r = /([^&;=]+)=?([^&;]*)/g;
     const q = window.location.hash.substring(1);
     let e;
     while ((e = r.exec(q)) !== null)
     {
      hashParams[d(e[1])] = d(e[2]);
     }
     return hashParams;
    }

    function $begin()
    {
     twitch.net.oAuth.clear(true);
     let loc = window.location.toString();
     if (window.location.hash.length > 1)
      loc = loc.slice(0, -1 * window.location.hash.length);
     const o = encodeURIComponent(window.btoa(loc));
     const c = encodeURIComponent(oauthClient);
     const r = encodeURIComponent(cURLs.html.rr.auth);
     const u = cURLs.html.twitch.replaceAll('%CLIENT_ID%', c).replaceAll('%URL%', r).replaceAll('%SCOPE%', _uScope()).replaceAll('%ORIGIN%', o);
     if (u.length < 1500)
     {
      window.location = u;
      return;
     }
     const f = document.createElement('form');
     f.setAttribute('method', 'POST');
     f.setAttribute('action', cURLs.html.rr.redir);
     const ft = document.createElement('input');
     ft.setAttribute('type', 'hidden');
     ft.setAttribute('name', 't');
     ft.setAttribute('value', 'code');
     f.appendChild(ft);
     const fv = document.createElement('input');
     fv.setAttribute('type', 'hidden');
     fv.setAttribute('name', 'v');
     fv.setAttribute('value', 'twitch');
     f.appendChild(fv);
     const fc = document.createElement('input');
     fc.setAttribute('type', 'hidden');
     fc.setAttribute('name', 'c');
     fc.setAttribute('value', oauthClient);
     f.appendChild(fc);
     const fr = document.createElement('input');
     fr.setAttribute('type', 'hidden');
     fr.setAttribute('name', 'r');
     fr.setAttribute('value', cURLs.html.rr.auth);
     f.appendChild(fr);
     const fs = document.createElement('input');
     fs.setAttribute('type', 'hidden');
     fs.setAttribute('name', 's');
     fs.setAttribute('value', _activeScope().join(' '));
     f.appendChild(fs);
     const fu = document.createElement('input');
     fu.setAttribute('type', 'hidden');
     fu.setAttribute('name', 'u');
     fu.setAttribute('value', loc);
     f.appendChild(fu);
     document.body.appendChild(f);
     f.submit();
    }

    function $showIn()
    {
     if (document.getElementById('cmdLogout'))
      document.body.removeChild(document.getElementById('cmdLogout'));
     twitch.net.oAuth.clear(true);
     let cmdLogin = document.createElement('button');
     cmdLogin.setAttribute('id', 'cmdLogin');
     cmdLogin.setAttribute('type', 'button');
     cmdLogin.classList.add('login');
     cmdLogin.setAttribute('onclick', 'login.begin();');
     cmdLogin.innerHTML = 'Authenticate Emote Wall';
     document.body.appendChild(cmdLogin);
    }

    function $showOut(v = false)
    {
     if (document.getElementById('cmdLogout'))
      document.body.removeChild(document.getElementById('cmdLogout'));
     let cmdLogout = document.createElement('button');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     cmdLogout.setAttribute('id', 'cmdLogout');
     cmdLogout.setAttribute('type', 'button');
     cmdLogout.classList.add('logout');
     document.addEventListener('mousemove', _fadeInLogout);
     if (v)
     {
      cmdLogout.setAttribute('onclick', 'login.begin();');
      cmdLogout.innerHTML = 'Re-Auth';
      _tL = window.setTimeout(_fadeOutLogout, _visTime);
     }
     else
     {
      cmdLogout.setAttribute('onclick', 'login.showIn();');
      cmdLogout.innerHTML = 'Log Out';
      cmdLogout.classList.add('hidden');
     }
     document.body.appendChild(cmdLogout);
    }

    function _fadeInLogout()
    {
     if (document.getElementById('cmdLogout'))
      document.getElementById('cmdLogout').classList.remove('hidden');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogout, _visTime);
    }

    function _fadeOutLogout()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById('cmdLogout'))
      document.getElementById('cmdLogout').classList.add('hidden');
    }

    return {
     inUse: false,
     use: $use,
     begin: $begin,
     showIn: $showIn,
     showOut: $showOut,
     path: $path,
     cfgVals: $cfgVals
    };
   }();

   const startup = function()
   {
    async function task()
    {
     shared.mspf.init();
     if (cfg.display.hasOwnProperty('hue') && cfg.display.hue === 'rave' && !_hasRaveToggle())
      document.body.classList.add('rave');
     _css();
     if (!window.hasOwnProperty('obsstudio') && !window.localStorage.getItem('emotewall.obs_notfound'))
     {
      window.localStorage.setItem('emotewall.obs_notfound', '1');
      notice.error(0x09);
     }
     if (login.use() === true)
      return;
     shared.clearAddr();
     _streamlabs();
     await _streamelements();
     await _bttv();
     await _7tv();
     if (login.cfgVals() > 0x01)
     {
      if (await _twitch() === false)
       twitch.net.dead = true;
     }
     else
      twitch.net.dead = true;
    }

    async function _twitch()
    {
     let tCfg = login.cfgVals();
     if ((tCfg & (0x02 | 0x01)) === (0x02 | 0x01))
     {
      await twitch.net.oAuth.update();
      tCfg = login.cfgVals();
      if ((tCfg & 0x04) !== 0x04)
      {
       notice.error(0x11);
       return false;
      }
     }
     if ((tCfg & (0x04 | 0x01)) !== (0x04 | 0x01))
      return false;
     if (await twitch.global() === false)
      return false;
     await _ffz();
     twitch.net.irc();
     return true;
    }

    function _streamlabs()
    {
     const slCfg = streamlabs.cfgVals();
     if ((slCfg & 0x01) !== 0x01)
      return;
     streamlabs.socket();
    }

    async function _streamelements()
    {
     let seCfg = streamelements.cfgVals();
     if (seCfg === 0)
      return;
     if ((seCfg & 0x02) === 0x02)
      await streamelements.updateOAuth();
     seCfg = streamelements.cfgVals();
     if ((seCfg & 0x01) !== 0x01 && (seCfg & 0x04) !== 0x04)
      return;
     streamelements.socket();
    }

    async function _ffz()
    {
     if (!cfg.display.extended.useFFZ)
      return;
     await thirdparty.ffz.global();
    }

    async function _bttv()
    {
     if (!cfg.display.extended.useBTTV)
      return;
     await thirdparty.bttv.global();
    }

    async function _7tv()
    {
     if (!cfg.display.extended.use7TV)
      return;
     await thirdparty['7tv'].global();
    }

    function _css()
    {
     const css = document.getElementsByTagName('STYLE')[0];
     let h = css.innerHTML;
     if (cfg.display.hasOwnProperty('hue') && cfg.display.hue !== false)
     {
      if (cfg.display.hue === 'rave')
      {
       let r = '   body.rave\n';
       r += '   {\n';
       r += '    animation: rave 3s linear infinite;\n';
       r += '   }\n';
       r += '   @keyframes rave\n';
       r += '   {\n';
       for (let i = 0; i <= 100; i += 10)
       {
        r += '    ' + i + '%\n';
        r += '    {\n';
        r += '     filter: hue-rotate(' + i * 3.6 + 'deg);\n';
        r += '    }\n';
       }
       r += '   }\n';
       h = h.replace('   img\n', r + '   img\n');
      }
      else if (!isNaN(cfg.display.hue))
      {
       const iHue = parseInt(cfg.display.hue, 10);
       if (iHue > 0 && iHue < 360)
        h = h.replace('   body\n   {\n', '   body\n   {\n    filter: hue-rotate(' + iHue + 'deg);\n');
      }
     }
     let a = '   [data-squash="vertical"]\n';
     a += '   {\n';
     a += '    transform: scale(' + timing.display.Crazy.squash.width + ', ' + timing.display.Crazy.squash.height + ');\n';
     a += '   }\n';
     a += '   [data-squash="horizontal"]\n';
     a += '   {\n';
     a += '    transform: scale(' + timing.display.Crazy.squash.height + ', ' + timing.display.Crazy.squash.width + ');\n';
     a += '   }\n';
     h = h.replace('   [data-squash="no"]\n', a + '   [data-squash="no"]\n');
     if (cfg.display.extended.useZWE && cfg.display.extended.hasOwnProperty('fillZWE') && cfg.display.extended.fillZWE)
     {
      h = h.replace('padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) 0;', 'padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) calc((var(--zoom-width) - (var(--zoom-width) * 0.1)) / 2);');
      h = h.replace('padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.8)) / 2) 0;', 'padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.8)) / 2) calc((var(--zoom-width) - (var(--zoom-width) * 0.8)) / 2);');
      h = h.replace('padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.95)) / 2) 0;', 'padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.95)) / 2) calc((var(--zoom-width) - (var(--zoom-width) * 0.95)) / 2);');
      h = h.replace('padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) 0;', 'padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) calc((var(--zoom-width) - (var(--zoom-width) * 0.1)) / 2);');
      let z = '   img.fit,\n';
      z += '   .fit img\n';
      z += '   {\n';
      z += '    object-fit: contain;\n';
      z += '    object-position: 50% 50%;\n';
      z += '   }\n';
      h = h.replace('   img\n   {\n', z + '   img\n   {\n');
     }
     else
     {
      let z = '   img\n';
      z += '   {\n';
      z += '    object-fit: contain;\n';
      z += '    object-position: 50% 50%;\n';
      h = h.replace('   img\n   {\n', z);
     }
     let t = '   .etStraightLine\n';
     t += '   {\n';
     t += '    transition: transform linear ' + Math.floor(cfg.emote.time * 1000 * timing.display.StraightLine.time) + 'ms;\n';
     t += '   }\n';
     t += '   .etThrowTwist\n';
     t += '   {\n';
     t += '    transition: transform cubic-bezier(0.32, 0, 0.67, 0) ' + Math.floor(cfg.emote.time * 1000 * timing.display.Throw.time * timing.display.Throw.twist) + 'ms;\n';
     t += '   }\n';
     t += '   .etThrowDrop\n';
     t += '   {\n';
     t += '    transition: transform cubic-bezier(0.5, 0, 0.75, 0) ' + Math.floor(cfg.emote.time * 1000 * timing.display.Throw.time * timing.display.Throw.drop) + 'ms;\n';
     t += '   }\n';
     t += '   .etFountain\n';
     t += '   {\n';
     t += '    transition: transform cubic-bezier(0, 0, 0.58, 1) ' + Math.floor(cfg.emote.time * 1000 * timing.display.Fountain.time) + 'ms;\n';
     t += '   }\n';
     t += '   div.scene.cube:not(.kappa),\n';
     t += '   div.scene.cube:not(.kappa) div.cube\n';
     t += '   {\n';
     t += '    transition: transform linear ' + Math.floor(cfg.emote.time * 1000 * timing.display.TheCube.time) + 'ms;\n';
     t += '   }\n';
     t += '   .ktFireworkRocket\n';
     t += '   {\n';
     t += '    transition: transform linear ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time * timing.kappa.Fireworks.speed.rocket) + 'ms;\n';
     t += '   }\n';
     t += '   .ktFireworkSparkler\n';
     t += '   {\n';
     t += '    transition: transform ease-out ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.Fireworks.time) + 'ms;\n';
     t += '   }\n';
     t += '   .ktSpiral\n';
     t += '   {\n';
     t += '    transition: transform ease-out ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.Spiral.time) + 'ms;\n';
     t += '   }\n';
     t += '   .ktPyramid\n';
     t += '   {\n';
     let ctP = 0;
     const lP = pyramidDist.length;
     for (let i = 0; i < lP; i++)
      ctP += pyramidDist[i];
     const tP = Math.floor(cfg.emote.time * 1000 * timing.kappa.Pyramid.time * timing.kappa.Pyramid.show.total);
     const tPerB = Math.max(Math.floor(tP / ctP), timing.kappa.Pyramid.show.min);
     t += '    transition: transform ease-in ' + tPerB + 'ms;\n';
     t += '   }\n';
     t += '   .ktPyramidDrop\n';
     t += '   {\n';
     t += '    transition: transform ease-in ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.Pyramid.time * timing.kappa.Pyramid.hide) + 'ms;\n';
     t += '   }\n';
     t += '   .ktSmallPyramid\n';
     t += '   {\n';
     const tSP = Math.floor(cfg.emote.time * 1000 * timing.kappa.SmallPyramid.time * timing.kappa.SmallPyramid.show.total);
     const tPerSB = Math.max(Math.floor(tSP / ctP), timing.kappa.SmallPyramid.show.min);
     t += '    transition: transform ease-in ' + tPerSB + 'ms;\n';
     t += '   }\n';
     t += '   .ktSmallPyramidDrop\n';
     t += '   {\n';
     t += '    transition: transform ease-in ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.SmallPyramid.time * timing.kappa.SmallPyramid.hide) + 'ms;\n';
     t += '   }\n';
     t += '   .ktStampede\n';
     t += '   {\n';
     t += '    transition: transform linear ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.Stampede.time * timing.kappa.Stampede.speed) + 'ms;\n';
     t += '   }\n';
     const congaShowMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Conga.time.show);
     const congaHideMS = Math.floor(cfg.emote.time * 1000 * timing.kappa.Conga.time.hide);
     t += '   .ktCongaIn\n';
     t += '   {\n';
     t += '    transition: transform linear ' + congaShowMS + 'ms;\n';
     t += '   }\n';
     t += '   .ktCongaOut\n';
     t += '   {\n';
     t += '    transition: transform ease-in ' + congaHideMS + 'ms;\n';
     t += '   }\n';
     t += '   div.scene.cube.kappa,\n';
     t += '   div.scene.cube.kappa div.cube\n';
     t += '   {\n';
     t += '    transition: transform linear ' + Math.floor(cfg.emote.time * 1000 * timing.kappa.TheCube.time) + 'ms;\n';
     t += '   }\n';
     h = h.replace('   [data-squash="vertical"]\n', t + '\n   [data-squash="vertical"]\n');
     css.innerHTML = h;
    }

    function _hasRaveToggle()
    {
     for (const k of cfg.commands)
     {
      if (k.hasOwnProperty('rave'))
       return true;
      if (k.hasOwnProperty('raveon'))
       return true;
     }
     return false;
    }

    return task;
   }();

   window.addEventListener('load', startup);
  </script>
  <style>
   :root
   {
    --height: 0px;
    --width: 0px;
    --emote-height: 0px;
    --emote-width: 0px;
    --zoom-height: var(--emote-height);
    --zoom-width: var(--emote-width);
   }
   body
   {
    margin: 0;
    overflow: hidden;
   }
   img
   {
    box-sizing: border-box;
    height: var(--emote-height);
    width: var(--emote-width);
   }
   img.emote
   {
    position: fixed;
    border: 0;
    margin: 0;
    padding: 0;
    offset-rotate: 0deg;
   }

   div.scene
   {
    position: fixed;
    border: 0;
    margin: 0;
    padding: 0;
   }
   div.scene.cube
   {
    height: var(--emote-height);
    width: var(--emote-width);
   }
   div.scene div.cube
   {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
   }
   div.scene div.cube div[data-face]
   {
    height: var(--emote-height);
    width: var(--emote-width);
   }
   div.scene div.cube div[data-face] img
   {
    position: absolute;
    transform: translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face]
   {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.2);
   }
   div.scene div.cube [data-face="front"]
   {
    transform: translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="back"]
   {
    transform: rotateY(90deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="right"]
   {
    transform: rotateY(180deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="left"]
   {
    transform: rotateY(-90deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="top"]
   {
    transform: rotateX(90deg) translateZ(var(--cube-depth));
   }
   div.scene div.cube [data-face="bottom"]
   {
    transform: rotateX(-90deg) translateZ(var(--cube-depth));
   }

   div.scene img.dancer
   {
    text-align: center;
    position: relative;
    animation: dance 4s linear infinite;
   }

   @keyframes dance
   {
    0%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    6%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    13%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    19%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    25%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    31%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    38%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    44%
    {
     transform: translate(20%, 10%) rotate(-30deg);
    }
    50%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    56%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    63%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    69%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    75%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    81%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    88%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    94%
    {
     transform: translate(80%, 10%) rotate(30deg);
    }
    100%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
   }

   @keyframes wiggleL
   {
    33%
    {
     transform: translateX(-50%);
    }
    66%
    {
     transform: translateX(50%);
    }
   }
   @keyframes wiggleR
   {
    33%
    {
     transform: translateX(50%);
    }
    66%
    {
     transform: translateX(-50%);
    }
   }

   @keyframes speedL
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(-1 * var(--width) * 4), 0);
    }
   }
   @keyframes speedR
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(var(--width) * 4), 0);
    }
   }

   @keyframes dropL
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(350deg);
    }
   }
   @keyframes dropR
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(-35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(-350deg);
    }
   }

   @keyframes confettiA
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0.5, 0, -4500deg);
    }
   }

   @keyframes confettiB
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0, 0, -4500deg);
    }
   }

   @keyframes confettiC
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, -0.5, 0, -4500deg);
    }
   }

   @keyframes offsetPath
   {
    0%
    {
     offset-distance: 0%;
    }
    100%
    {
     offset-distance: 100%;
    }
   }

   .eNorm
   {
    --zoom-height: var(--emote-height);
    --zoom-width: var(--emote-width);
   }
   .eHalf
   {
    --zoom-height: calc(var(--emote-height) / 2);
    --zoom-width: calc(var(--emote-width) / 2);
   }
   .eDouble
   {
    --zoom-height: calc(var(--emote-height) * 2);
    --zoom-width: calc(var(--emote-width) * 2);
   }

   [data-squash="no"]
   {
    transform: scale(1, 1);
   }

   [data-origin="center"]
   {
    transform-origin: center center;
   }
   [data-origin="topleft"]
   {
    transform-origin: left top;
   }
   [data-origin="topright"]
   {
    transform-origin: right top;
   }
   [data-origin="top"]
   {
    transform-origin: center top;
   }
   [data-origin="bottom"]
   {
    transform-origin: center bottom;
   }
   [data-origin="left"]
   {
    transform-origin: left center;
   }
   [data-origin="right"]
   {
    transform-origin: right center;
   }

   @keyframes fadeIn
   {
    0%
    {
     opacity: 0;
    }
    100% /* 8% */
    {
     opacity: 1;
    }
   }

   @keyframes fadeOut
   {
    0% /* 95% */
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes noFadeOut
   {
    99%
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes zoomIn
   {
    0%
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) 0;
    }
    24% /* 4% */
    {
     padding: 0;
    }
    47% /* 8% */
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.8)) / 2) 0;
    }
    71% /* 12% */
    {
     padding: 0;
    }
    88% /* 15% */
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.95)) / 2) 0;
    }
    100% /* 17% */
    {
     padding: 0;
    }
   }

   @keyframes zoomOut
   {
    0% /* 95% */
    {
     padding: 0;
    }
    100%
    {
     padding: calc((var(--zoom-height) - (var(--zoom-height) * 0.1)) / 2) 0;
    }
   }

   #notices
   {
    position: absolute;
    top: 8px;
    left: 8px;
    width: 35em;
   }
   #notices #badge
   {
    position: fixed;
    font-family: sans-serif;
    font-size: 14px;
    left: 8px;
    width: 16px;
    height: 16px;
    display: inline-block;
    border: 1.5px solid #000000;
    border-radius: 8px;
    text-align: center;
    background-color: #E0E0E0;
    color: #000000;
    opacity: 0.75;
    transition: opacity 1s ease-in;
    cursor: default;
   }
   #notices #badge[data-alerts="0"]
   {
    opacity: 0;
   }
   #notices #badge.fader
   {
    transition: all 300ms ease-out;
   }
   #notices #badge.fade
   {
    opacity: 0;
   }
   #notices .noticeLine
   {
    position: relative;
    font-family: sans-serif;
    font-size: 14px;
    border: 1.5px solid #000000;
    border-radius: 8px;
    padding-left: 24px;
    padding-right: 8px;
    margin-left: 24px;
    margin-bottom: 4px;
    white-space: nowrap;
    max-width: fit-content;
    width: 100%;
    transition: all 300ms ease-out;
    opacity: 0.75;
    cursor: default;
   }
   #notices .noticeLine:hover
   {
    opacity: 1;
   }
   #notices .noticeLine.hide
   {
    width: 0%;
    overflow: hidden;
   }
   #notices .noticeLine.fader
   {
    transition: opacity 0.5s;
    opacity: 0.75;
   }
   #notices .noticeLine.fader:hover
   {
    opacity: 1;
   }
   #notices .noticeLine.fader.fade
   {
    opacity: 0;
   }
   #notices .noticeLine.fader.faded
   {
    height: 0;
    margin: 0;
    padding: 0;
    border: 0;
   }
   #notices .noticeInfo
   {
    background-image: linear-gradient(to right, transparent 0, transparent 20px, #E0E0E0 24px);
   }
   #notices .noticeWarning
   {
    background-image: linear-gradient(to right, transparent 0, transparent 20px, #FFFF00 24px);
   }
   #notices .noticeError
   {
    color: #FFFFFF;
    background-image: linear-gradient(to right, transparent 0, transparent 20px, #FF0000 24px);
   }
   #notices .noticeError a
   {
    color: #FFFF00;
    text-decoration: none;
   }
   #notices .noticeError a:hover
   {
    color: #FFFFC0;
   }
   #notices .global
   {
    background-color: #FFFFFF;
   }
   #notices .sTwitch
   {
    background-color: #7D5BBE;
   }
   #notices .sTwitch:after
   {
    position: absolute;
    top: 0;
    left: 7px;
    content: 'T';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .tStreamElements
   {
    background-color: #0000FF;
   }
   #notices .tStreamElements:after
   {
    position: absolute;
    top: 0;
    left: 2px;
    content: 'SE';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .tStreamlabs
   {
    background-color: #80F5D2;
   }
   #notices .tStreamlabs:after
   {
    position: absolute;
    top: 0;
    left: 3px;
    content: 'SL';
    color: #000000;
    font-size: 14px;
   }
   #notices .eBTTV
   {
    background-color: #FF0000;
   }
   #notices .eBTTV:after
   {
    position: absolute;
    top: 0;
    left: 7px;
    content: 'B';
    color: #FFFFFF;
    font-size: 14px;
   }
   #notices .e7TV
   {
    background-color: #00FFFF;
   }
   #notices .e7TV:after
   {
    position: absolute;
    top: 0;
    left: 8px;
    content: '7';
    color: #000000;
    font-size: 14px;
   }

   button
   {
    background-color: #7D5BBE;
    transition: background 0.12s ease-in, color 0.12s ease-in;
    white-space: nowrap;
    cursor: pointer;
    color: #FFFFFF;
    border-radius: 4px;
    border: none;
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    z-index: 1000;
    opacity: 1;
    position: absolute;
   }
   button.hidden
   {
    opacity: 0;
   }
   button:focus, button:hover
   {
    background-color: #772CE8;
   }
   button:focus
   {
    outline: none;
   }
   button:active
   {
    background-color: #5C16C5;
   }

   button.login
   {
    top: calc(50% - 1em - 1.25em);
    left: calc(50% - 6.5em);
    width: 13em;
    font-size: 6vmin;
    padding: 0.5em;
   }
   .notice + button.login
   {
    top: calc(100% - 10vw);
   }
   .notice.hiding + button.login
   {
    transition: top 500ms ease-out;
    top: calc(50% - 1em - 1.25em);
   }

   button.logout
   {
    transition: opacity 0.5s;
    top: 1em;
    right: 1em;
    width: 5em;
    font-size: 2vmin;
    padding: 0.5em;
   }
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
 </head>
</html>