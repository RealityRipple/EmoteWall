<!doctype html>
<html lang="en">
 <head>
  <meta charset="utf-8" />
  <script>
   /* RealityRipple's Homemade Emote Wall (Version 0.5.1.1 BETA)
    * ===================================
    *
    * Notes and Caveats
    *
    * This emote wall uses normal <img> objects rather than a HTML Canvas. While this lowers efficiency, it also adds
    * better GIF file support and allows easier user manipulation.
    *
    * Note: At present, the "zoom in" and "zoom out" feature uses a resource-heavy design which can be replaced with
    * the "scale: " CSS directive as soon as Chrome adds support. Additionally, the Bounce animation uses specific
    * position-based drawing rather than actually being animated. Finally, The Cube animation uses eight objects
    * on screen for every image, making it a particularly resource-heavy drawing. If your computer has trouble with
    * this emote wall, please try disabling these options.
    *
    * Update Procedure: To update this emote wall, simply use the Wizard to import and download it.
    * 1) Visit the official page <https://realityripple.com/Tools/Twitch/EmoteWall/>.
    * 2) Under "Config Wizard", click "Authorize on Twitch".
    * 3) Import this HTML file by clicking Import.
    * 4) Make any changes you need to make on each page.
    * 5) At the end of your configuration, hit "Download".
    * You will receive a new version of this HTML file with your previous settings.
    *
    * Configuration Information
    * =========================
    *
    * channel     The name of the channel to join. Also used to choose an IRC nickname.
    *             If FALSE, the interactive login process will be enabled.
    *
    * login       Settings related to the login process.
    *
    *             NOTE: OAuth tokens expire automatically (usually after 60 days). Please make sure to update
    *                   these values on a regular basis, if not using the interactive login process.
    *
    *  client     The Client ID value is used to track which third-party project is accessing your account.
    *             This emote wall does not require a constant ID, and will work with whatever tool you use to
    *             get an OAuth ID (see below).
    *
    *  oauth      The OAuth ID value is used in lieu of a password to access the Twitch API.
    *             Please generate an OAuth ID and matching Client ID:
    *             - Visit https://realityripple.com/Tools/Twitch/EmoteWall/
    *             - Click the "Authenticate on Twitch" button under "Do-it-Yourself" and log in
    *             - Fill out the captcha prompt, if necessary
    *             - Copy the Client ID value and paste it into "client:"
    *             - Copy the OAuth ID value and paste it into "oauth:"
    *             If you ever stop using this emote wall, please log into Twitch and visit
    *             https://www.twitch.tv/settings/connections . Under "Other Connections", click the "Disconnect" button
    *             next to "RealityRipple's Homemade Emote Wall". If you want to use a different Twitch OAuth generator
    *             (or do it yourself), feel free.
    *             If FALSE, the interactive login process will be enabled.
    *
    * streamlabs  Settings related to Streamlabs tips.
    *
    *  token      The Socket Token is used in lieu of a password to access the Streamlabs API.
    *             Please generate a Socket Token:
    *             - Visit https://realityripple.com/Tools/Twitch/EmoteWall/
    *             - Click the "Streamlabs Tip Support" button and log in
    *             - Copy the Token value and paste it into "token:"
    *             If you ever stop using this emote wall, please log into Streamlabs and visit
    *             https://streamlabs.com/dashboard#/settings/api-settings . Under "Connected Apps", click the
    *             "Revoke Access" button next to "RealityRipple's Homemade Emote Wall". If you want to use a different
    *             Streamlabs OAuth generator (or do it yourself), feel free.
    *
    *  curMul     This value is the currency multiplier. The ranges of Streamlabs tip entries (see below) will
    *             match against this multiplier. For example, if you use USD and want to set ranges by penny amount,
    *             then set this value to 100. If you want to use dollar amounts, set the value to 1. Please note that
    *             any decimal amount will be rounded down after multiplying, so $3.95 will be handled as "395" pennies
    *             when multiplied by 100, or "3" dollars when multiplied by 1.
    *
    * streamelements  Settings related to StreamElements tips.
    *
    *  oauth      The OAuth ID value is used in lieu of a password to access the StreamElements API.
    *             Please generate an OAuth ID:
    *             - Visit https://realityripple.com/Tools/Twitch/EmoteWall/
    *             - Click the "StreamElements Tip Support" button and log in
    *             - Copy the OAuth ID value and paste it into "oauth:"
    *             If you ever stop using this emote wall, please log into StreamElements and visit
    *             https://streamelements.com/dashboard/account/security. Click the "Reset my Personal Access Token"
    *             button. If you want to use a different StreamElements OAuth generator (or do it yourself), feel free.
    *             Please only use oauth or token, not both. Token does not expire, but is also less secure. OAuth is
    *             recommended, if possible.
    *
    *  token      The JWT Token is used in lieu of a password to access the StreamElements API.
    *             Please grab your JWT Token from the StreamElements Dashboard:
    *             - Visit https://streamelements.com/dashboard/account/channels
    *             - Click the "Show secrets" button
    *             - Copy the JWT Token value and paste it into "token:"
    *             Please only use oauth or token, not both. Token does not expire, but is also less secure. OAuth is
    *             recommended, if possible.
    *
    *  curMul     This value is the currency multiplier. The ranges of StreamElements tip entries (see below) will
    *             match against this multiplier. For example, if you use USD and want to set ranges by penny amount,
    *             then set this value to 100. If you want to use dollar amounts, set the value to 1. Please note that
    *             any decimal amount will be rounded down after multiplying, so $3.95 will be handled as "395" pennies
    *             when multiplied by 100, or "3" dollars when multiplied by 1.
    *
    * reddit      The unique ID of a Reddit RPAN session (usually 6 characters at the end of the URL).  If you don't
    *             use Reddit to stream, please keep this set to FALSE. You must change this for every Reddit stream
    *             at present, unfortunately.
    *
    * display     Settings related to the animation of the emote wall.
    *
    *  styles     An array of animation styles which individual emotes randomly perform.  You may turn on and off
    *             elements in this array by "commenting out" a style by putting two slashes before the name:
    *              // 'Still',        <-- disabled
    *                 'StraightLine', <-- allowed
    *
    *  access     A bitwise flag representing which users' messages show up on the emote wall. Account types are
    *             represented by the following values:
    *
    *              0x800 = broadcaster
    *              0x400 = moderator badge
    *              0x200 = founder badge
    *              0x100 = vip badge
    *              0x080 = artist badge
    *              0x040 = tier 3 subscriber badge
    *              0x020 = tier 2 subscriber badge
    *              0x010 = tier 1 subscriber badge
    *              0x004 = cheer badge
    *              0x002 = follower
    *              0x001 = stranger
    *
    *             Just put a vertical pipe " | " in between each of the values representing levels of access:
    *
    *              ACCESS                                 MEANING 
    *             0x800 | 0x400                           broadcaster and moderator only
    *             0x800 | 0x400 | 0x100 | 0x040 | 0x020   broadcasters, mods, VIPs, and tier 2 and 3 subscribers
    *             0x800 | 0x010 | 0x002                   boradcaster, tier 1 subscribers, and followers
    *
    *             If you know how bitwise flags work, you can also use them
    *             in more complicated ways:
    *               ACCESS           MEANING
    *             0xFF7             all users from the broadcaster to strangers
    *             0xFF7 ^ 0x003     all users except followers and strangers
    *             0x070             all subscribers
    *
    *  duplicates  A boolean or integer to toggle duplicate emotes per message.
    *             If TRUE, every emote posted in chat will be shown.
    *             If FALSE, only one of each emote per message will be shown.
    *             If greater than 1, sets the maximum number of identical emotes shown from any message.
    *
    *  useEmoji   Toggles display of emojis on the emote wall, and lets you choose an emoji font style.
    *             If TRUE, emojis will be shown using the "twemoji" font.
    *             If FALSE, emojis will not be shown on the emote wall.
    *             If 'twemoji', emojis will be shown using the "twemoji" font.
    *             If 'openmoji', emojis will be shown using the "openmoji" font.
    *             If 'noto', emojis will be shown using the "noto" font.
    *             If 'blob', emojis will be shown using the "blobmoji" font.
    *
    *  extended   Settings related to third-party emotes.
    *
    *   useFFZ    Toggles display of FrankerFaceZ emotes.
    *
    *   useBTTV   Toggles display of BetterTTV emotes.
    *
    *   use7TV    Toggles display of 7TV emotes.
    *
    *  kappa      Settings related to emote-splosions and the !kappagen command.
    *
    *   count     The number of emotes to display per kappagen. This value must be less than the "emote max" value
    *             seen below (best would be 1/4th or less).
    *
    *   styles    Similar to the array of styles for normal emotes, but this one lists emote-splosion types.
    *             Please do not try to add normal styles to the kappa list or vice versa. This is an associative array
    *             which can have custom settings for certain styles (namely The Cube and Text - see below).
    *
    *    [ALL]    Settings related to multiple kappagens. These settings will be the default for all instances of their
    *             respective kappagens. Each setting below may or may not apply to a specific kappagen style.
    *
    *     count   The number of emotes to display for this specific kappagen. This value must be less than the
    *             "emote max" value seen below (best would be 1/4th or less). If unset, this will default to the global
    *             kappa count preference listed above.
    *             Additional Note: if this preference is in an event below (not in this general kappa context), then
    *             an additional value is possible: -1, which will refer to the AMOUNT value present in the event.
    *             This can be the number of raiders, bits cheered, dollars tipped, subs gifted, or months subscribed.
    *
    *    TheCube  Settings related to The Cube kappagen. These settings will be the default for all instances of
    *             TheCube kappagen.
    *
    *     size    A decimal value representing the height of The Cube kappagen, relative to the smallest
    *             screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "8 / 10" (80%).
    *
    *     center  If TRUE, The Cube will show up in the exact center of the screen.
    *             If FALSE, The Cube will show up in a random location.
    *
    *     rotations  The maximum number of rotations a kappa cube might spin while on screen. This effectively controls
    *               the maximum possible speed at which cubes will rotate.
    *
    *    Text     Settings related to Text kappagen. These settings will be the default for all instances of Text
    *             kappagen.
    *
    *     message  An array of alphanumeric strings (letters, numbers, and spaces), one of which will randomly be used.
    *
    *     time    The number of seconds the Text kappagen should show the final result for.
    *             This value should be adjusted depending on the average message length, for readability.
    *
    *   access    Similar to the access flag for normal emotes, but controls which users can use the !kappagen command.
    *
    *   conga     Settings related to Conga kappagen.
    *
    *    contagious  If TRUE, while one Conga kappagen is visible, all additional kappagens will also be Conga.
    *               If FALSE, Conga kappagns will behave like any other kappagen.
    *
    *    time     The number of seconds the Conga kappagen should show up on the screen for.
    *             This value lets you increase or decrease the chances of keeping a "contagious" Conga line going.
    *
    * emote       Settings related to individual emote display.
    *
    *  time       The number of seconds an emote should show up on the screen for.
    *
    *  max        The maximum nuber of emotes to show on the screen at one time. Set this value to 0 for
    *             infinite emotes. This value should be greater than the "kappa count" value seen above
    *             (best would be 4x or more).
    *
    *  queue      The maximum number of emotes to save in queue. Set this value to 0 for an infinite queue.
    *             This value will be ignored if the previous value (cfg.emote.max) is infinite (0).
    *
    *  size       Settings related to the size of emotes.
    *
    *   ratio     Emotes show up in multiple sizes due to the kappagen feature. There are a total of four sizes
    *             that an emote can be:
    *              - The Cube kappagen's faces are squares equal to 80% of the smaller screen dimension
    *                (usually height on PC).
    *              - Pyramid kappagen emotes have a height equal to 1/19th of the screen's width.
    *              - Fireworks, Spiral, and Confetti kappagen emotes have a height equal to the small ratio (see below).
    *              - All standard emotes and kappagens not listed above will use the normal ratio (see below).
    *                Most normal emotes will limit by height, except The Cube, which fits in the center of every side.
    *
    *    normal   A decimal value representing the height of each emote, relative to the smallest screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "1 / n" where n is greater than 10.
    *
    *    small    A decimal value representing the height of small emotes, relative to the smallest screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "1 / n" where n is greater than 20.
    *
    *   min       The minimum height of an emote, in pixels.
    *
    *   max       The maximum height of an emote, in pixels.
    *
    *   variation  An integer variable that determines how often occasional random large or small emotes show up.
    *             If FALSE, no variations will occur.
    *
    *  cube      Settings related to The Cube emote.
    *
    *   rotations  The maximum number of rotations a cube might spin while on screen. This effectively controls the
    *             maximum possible speed at which cubes will rotate.
    *
    *  in         Settings related to the showing of an emote.
    *             Note: some kappagen styles do not use these. See the notes next to each kappagen style name.
    *
    *   fade      A boolean to toggle the "fade in" style.
    *
    *   zoom      A boolean to toggle the "zoom in" style.
    *
    *  out        Settings related to the hiding of an emote.
    *             Note: some kappagen styles do not use these. See the notes next to each kappagen style name.
    *
    *   fade      A boolean to toggle the "fade out" style.
    *
    *   zoom      A boolean to toggle the "zoom out" style.
    *
    * event       Settings related to channel events which trigger emote-splosions (kappagen).
    *
    *  raid       Settings related to kappagens when being raided.
    *
    *   raiders   A streamer raids the channel with viewers. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all raids.
    *              If FALSE, no kappagen will occur on raids.
    *              If Integer, the value is the minimum raiders required for a raid to trigger a kappagen.
    *               If 0, no kappagen will occur on raid.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *                Keep in mind that kappagen arrays are also associative, and may have independent settings for
    *                kappas such as TheCube and Text. This applies to all such arrays listed below as well.
    *
    *   originEmotes  A boolean to toggle the use of the raiding streamer's channel emotes for raid kappagens.
    *                If TRUE, raid kappagens will use channel emotes from the raider's channel (not including third-party).
    *               If FALSE, raid kappagens will use your channel's emotes (including third-party).
    *
    *  follow     A user follows the channel.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  sub        Settings related to kappagens on a subscribe event.
    *             Note: Sub event booleans can also be arrays of kappa styles.  This will override the default list
    *                   of kappa styles for the particular event in question.
    *
    *   useMsg    If TRUE, any emotes in resub messages will be used for the kappagen.
    *             If FALSE, any emotes in resub messages will show up like normal emotes.
    *
    *   t1        Settings related to kappagens on a tier 1 subscribe event.
    *
    *    first    A user subscribes at Tier 1 for the first time.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    resub    A user resubscribes at Tier 1. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Tier 1 resubs.
    *              If FALSE, no kappagen will occur on T1 resubs.
    *              If Integer, the value is the minimum months required for a Tier 1 resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    upgrade  Settings related to "converted" subscriptions.
    *
    *     gift     A user upgrades a gift sub to Tier 1.
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     prime    A user upgrades a Prime sub to Tier 1.
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    gift     Settings related to tier 1 gifts.
    *
    *     first   A user gifts another user their first Tier 1 subscription.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     resub   A user gifts another user a Tier 1 resubscription. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Tier 1 gift resubs.
    *              If FALSE, no kappagen will occur on T1 gift resubs.
    *              If Integer, the value is the minimum months required for a Tier 1 gift resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     bomb    A user gifts multiple Tier 1 subscriptions. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on any random gift.
    *              If FALSE, no kappagen will occur on giftbombs.
    *              If Integer, the value is the minimum gifts required for a gift bomb to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur on any random gift.
    *               If greater than 1, the number of gifted users in a Tier 1 giftbomb must be greater than or equal to
    *               this number to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   t2        Identical to t1, but for Tier 2 subscriptions.
    *
    *   t3        Identical to t1, but for Tier 3 subscriptions.
    *
    *   prime     Settings related to kappagens on an Amazon Prime subscribe event.
    *
    *    first    A user subscribes with Prime for the first time.
    *             If TRUE, a kappagen will occur.
    *             If FALSE, no kappagen will occur.
    *             If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    resub    A user resubscribes with Prime. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Prime resubs.
    *              If FALSE, no kappagen will occur on Prime resubs.
    *              If Integer, the value is the minimum months required for a Prime resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  cheer      Settings related to kappagens on a cheer event.
    *
    *   useMsg    If TRUE, any emotes in cheer messages will also be included in the kappagen.
    *             If FALSE, any emotes in cheer messages will show up like normal emotes.
    *
    *   bits       Minimum number of bits for a kappagen. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all cheers.
    *              If FALSE, no kappagen will occur on cheers.
    *              If Integer, the value is the minimum bits required for a cheer to trigger a kappagen.
    *               If 0, no kappagen will occur on cheer.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-499' or '2500-4999', or an open-maximum range such as '7500+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  badge      Settings related to users earning bits badges.
    *             This section is more "fluid" than other sections.
    *             Each entry is a number representing a bits badge and a kappa boolean value.
    *             For example:
    *   '1'        If TRUE, a kappagen will occur when a user gets their 1 bit badge.
    *              If FALSE, no kappagen will occur for 1 bit badges.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *             If a user earns a bits badge for a number not listed in the array, the system will find the number
    *             which is closest to the badge, favoring the lower number in case of a tie.
    *             For example:
    *   '100': false
    *   '5000': true
    *              If a user earns their 1000 bits badge, no kappagen will occur because 1000 is closer to 100
    *              than 5000.
    *              If a user earns their 10000 bits badge, a kappagen will occur because 5000 is the closest
    *              listed number.
    *             Note that the numbers must be strings (in 'single quotes') to function properly.
    *
    *  tip        Settings related to third-party tip systems.
    *
    *   useProfileImage  If TRUE, tips will use the tipper's profile image instead of emotes.
    *                   If FALSE, tips will use your standard kappagen emotes.
    *
    *   streamlabs  Minimum tip amount through Streamlabs for a kappagen. This value can be a boolean, integer,
    *              or array:
    *              If TRUE, a kappagen will occur on all Streamlabs tips.
    *              If FALSE, no kappagen will occur on tips.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on tips through Streamlabs.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamlabs.curMul setting (see above)
    *              based on your default currency in Streamlabs.
    *
    *   streamelements  Minimum tip amount through StreamElements for a kappagen. This value can be a boolean,
    *                  integer, or array:
    *              If TRUE, a kappagen will occur on all StreamElements tips.
    *              If FALSE, no kappagen will occur on tips.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on tips through StreamElements.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamelements.curMul setting (see above)
    *              based on your default currency in StreamElements.
    *
    *
    * Additional Notes
    * ================
    * Emojis: Twitch filters out the ZWJ (Zero-Width Joiner) character which is used for merging many emojis.
    *         This system makes use of basic character detection to correctly parse many standard ZWJ-style
    *         emojis even without the ZWJ character, however more complicated sets such as the "family units"
    *         are not possible to correctly handle. The alternative character 0xE0002 used by some third-party
    *         Twitch chat projects will be correctly parsed as a ZWJ according to the rules laid out in the RFC:
    *          <https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f>
    *
    * Follow: Detecting followers on the current Twitch API is limited and relies on server-to-server events.
    *         The current system uses a kludge and may have issues in rare situations. The current system regularly
    *         grabs the most recent 100 followers and tries to find the previous request's latest follower, counting
    *         how many followers exist in the list before the last known follower. If the latest follower is removed
    *         from the list, or if more than 100 followers join between one check and another, the system will ignore
    *         the event and assign a new latest follower. Real support for follow events requires an API change:
    *          <https://twitch.uservoice.com/forums/310213/suggestions/41794465>
    *
    * Cheers: The cheer style will be used for kappagens. If a user cheers 1000 bits in a single 1000 bit emote,
    *         then the kappagen will be made of the 1000-bit cheers. However, if the user cheers 1000 bits using
    *         multiple smaller cheer emotes, those emotes will be used for the kappagen instead.
    *
    * Kappa:  Each emote-splosion uses the number of emotes defined in the kappa count preference mentioned above,
    *         except Pyramid, which uses a constant number based on the pyramidDist array (below). If the trigger
    *         includes specific emotes (via kappagen, cheer, or resub message), the ratio of one emote to another
    *         will be maintained. If a user with kappa access posts "!kappagen PunchTrees PunchTrees SSSsss" then
    *         two thirds of the emotes in the emote-splosion will be "PunchTrees", and one third will be "SSSsss".
    *
    * ZWEs:   Zero-Width emotes are not supported. I really wanted to add support for this, but it would take a lot
    *         more processing power than it's worth. Emotes marked as zero-width will not show up on the emote wall.
    *         If you remove an emote from the bttvZWE list (below), however, it will show up on the wall.
    *
    * OBS:    This emote wall may do better if the browser source has a frame rate limit of 30 or 60.
    *         If you use your GPU while streaming, you may wish to disable Browser Source Hardware Acceleration.
    *         It may also work better using a smaller screen resolution (such as 720p on a 1080p screen) and then
    *         stretching the browser source to fit to the screen using the OBS Transform feature.
    *
    * Sizes:  Emotes that are not square may display differently in different contexts. Usually the height of the
    *         emote will take precedent, but in cases where the width is strictly limited (such as TheCube), the 
    *         width will limit the height of the emote to keep things "square".
    *
    * Help:   Please contact @realityripple for assistance, bug reports, or questions.
    */

   var cfg = {
    channel: 'CHANNEL_NAME',
    login: {
     client: '4umzcpmjkg6ar78b81s7302jlj33t8',
     oauth: 'OAUTH_ID' //Requires chat:read
    },
    streamlabs: {
     token: 'SOCKET_TOKEN', //Requires socket.token
     curMul: 100
    },
    streamelements: {
     oauth: 'OAUTH_ID', //Requires tips:read
     token: 'JWT_TOKEN',
     curMul: 100
    },
    reddit: false,
    display: {
     styles: [
    //'Still',        // No movement
      'StraightLine', // Gentle movement in a random straight line
      'Rise',         // Slowly rise to top while wobbling back and forth
      'Bounce',       // Fall from the top at an angle and bounce along the bottom (Windows Solitaire style)
      'Speed',        // Zoom across the screen
      'Drop',         // Get stuck at the top and tumble down (no fade/zoom in, only out)
      'Crazy',        // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
      'Confetti',     // Fall like confetti                   (no zoom, no fade in, only fade out)
      'TheCube',      // Rotate a 3D cube of an emote         (no zoom, only fade)
     ],
     access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x004 | 0x002 | 0x001,
     duplicates: true,
     useEmoji: true,
     extended: {
      useFFZ: true,
      useBTTV: true,
      use7TV: true
     },
     kappa: {
      count: 150,
      styles: {
       'Rise': {},        // Slowly rise to top while wobbling back and forth
       'Speed': {},       // Zoom across the screen
       'Crazy': {},       // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
       'Burst': {},       // Expand from a center point
       'Fireworks': {},   // Burst out from a single emote (no fade/zoom; small emotes)
       'Spiral': {},      // Burst out from a single emote in a spiral (no fade/zoom; small emotes)
       'Pyramid': {},     // Build a pyramid        (no fade/zoom; specific-size emotes)
       'SmallPyramid': {},// Build a small pyramid  (no fade/zoom; small emotes)
       'Fountain': {},    // Spout from a fountain  (no fade/zoom)
       'Stampede': {},    // Stampede of emotes     (no fade/zoom)
       'Confetti': {},    // Fall like confetti     (no zoom, no fade in, only fade out; small emotes)
       'Conga': {},       // Start a conga line     (no fade/zoom)
       'TheCube': {       // Rotate a 3D cube of an emote (no zoom, only fade)
        size: 8/10,
        center: true,
        rotations: 5
       },
       'Text': {          // Show a message         (no fade/zoom; specific-size emotes)
        message: ['HYPE!'],
        time: 3
       },
      },
      access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x004 | 0x002,
      aliases: [      // !kappagen command aliases (must be lower-case)
       '!kappagen',
       '-kappagen'
      ],
      conga: {
       contagious: false,
       time: 5
      }
     }
    },
    emote: {
     time: 5,
     max: 0,
     queue: 0,
     size: {
      ratio: {
       normal: 1/12,
       small: 1/24
      },
      min: 16,
      max: 112,
      variation: false
     },
     cube: {
      rotations: 5
     },
     in: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     },
     out: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     }
    },
    event: {
     raid: {
      raiders: 2,
      originEmotes: false
     },
     follow: true,
     sub: {
      useMsg: true,
      t1: {
       first: false,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: false,
        resub: false,
        bomb: 5
       }
      },
      t2: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      t3: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      prime: {
       first: true,
       resub: true
      }
     },
     cheer: {
      useMsg: true,
      bits: 50
     },
     badge: {
      '1': false,
      '100': true
     },
     tip: {
      useProfileImage: false,
      streamlabs: false,
      streamelements: false
     }
    }
   };

   /* potentially alterable arrays */

   // distribution of emojis for Pyramid and SmallPyramid kappagen
   var pyramidDist = [1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1];

   // distribution of emojis for letters in message kappagens
   var alnumDist = {
    'A': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'a': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'B': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    'b': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'C': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0]
    ],
    'c': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'D': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'd': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'E': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'e': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'F': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'f': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    'G': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 1, 0, 0]
    ],
    'g': [
     [1, 0, 0, 1, 1, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'H': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'h': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0]
    ],
    'I': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'i': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'J': [
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'j': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0]
    ],
    'K': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'k': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
    ],
    'L': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'l': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'M': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'm': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'N': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'n': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'O': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'o': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'P': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    'p': [
     [1, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 1, 0, 0, 0, 0]
    ],
    'Q': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [1, 1, 0, 1, 1, 1, 1, 0, 0]
    ],
    'q': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'R': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 1, 0, 0]
    ],
    'r': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'S': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    's': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    'T': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    't': [
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0]
    ],
    'U': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'u': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'V': [
     [0, 0, 0, 0, 1, 1, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 1, 1, 0]
    ],
    'v': [
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0]
    ],
    'W': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'w': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 0, 0, 0]
    ],
    'X': [
     [0, 1, 1, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 0, 1, 1, 0]
    ],
    'x': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'Y': [
     [0, 0, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    'y': [
     [1, 0, 0, 1, 1, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'Z': [
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0]
    ],
    'z': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '1': [
     [0, 1, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '2': [
     [0, 1, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '3': [
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '4': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0]
    ],
    '5': [
     [0, 0, 1, 0, 0, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 0, 1, 0]
    ],
    '6': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0]
    ],
    '7': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    '8': [
     [0, 0, 1, 1, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '9': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 1, 1, 0, 0]
    ],
    '0': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    ':': [
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    '.': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    ',': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '\'': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 1]
    ],
    '-': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '_': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '+': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '=': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0]
    ],
    '!': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    '@': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 1, 1, 0, 0]
    ],
    '#': [
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    '$': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [1, 1, 1, 1, 1, 1, 1, 1, 1],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    '%': [
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0]
    ],
    '?': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ]
   };

   // don't show these zero-width emote modifiers at all
   var bttvZWE = [
    'SoSnowy',  'IceCold',   'SantaHat', 'TopHat',
    'ReinDeer', 'CandyCane', 'cvMask',   'cvHazmat',
   ];

   // list of default images to use if your channel has no emotes
   var bareList = [
    {url: 'https://cdn.betterttv.net/frankerfacez_emote/675080/4'}
   ];
   //////////////////////////////////////////////////////////////////////////////
   // don't mess with things below this line without knowing what you're doing //
   //////////////////////////////////////////////////////////////////////////////
  </script>
  <title>Emote Wall</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
   :root
   {
    --height: 0px;
    --width: 0px;
    --emote-height: 0px;
    --emote-height-s: 0px;
    --emote-height-l: 0px;
   }
   body
   {
    margin: 0;
    overflow: hidden;
   }
   img
   {
    object-fit: contain;
    object-position: 50% 50%;
   }
   img.emote
   {
    position: fixed;
    height: 100%;
    border: 0;
    margin: 0;
    padding: 0;
    offset-rotate: 0deg;
   }

   div.scene
   {
    position: fixed;
    border: 0;
    margin: 0;
    padding: 0;
   }
   div.scene div.cube
   {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
   }
   div.scene div.cube img.cubeFace
   {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.2);
   }

   div.scene img.dancer
   {
    text-align: center;
    position: relative;
    animation: dance 4s linear infinite;
   }

   @keyframes dance
   {
    0%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    6%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    13%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    19%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    25%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    31%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    38%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    44%
    {
     transform: translate(20%, 10%) rotate(-30deg);
    }
    50%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    56%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    63%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    69%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    75%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    81%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    88%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    94%
    {
     transform: translate(80%, 10%) rotate(30deg);
    }
    100%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
   }

   @keyframes wiggleL
   {
    33%
    {
     transform: translateX(-50%);
    }
    66%
    {
     transform: translateX(50%);
    }
   }
   @keyframes wiggleR
   {
    33%
    {
     transform: translateX(50%);
    }
    66%
    {
     transform: translateX(-50%);
    }
   }

   @keyframes speedL
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(-1 * var(--width) * 4), 0);
    }
   }
   @keyframes speedR
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(var(--width) * 4), 0);
    }
   }

   @keyframes dropL
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(350deg);
    }
   }
   @keyframes dropR
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(-35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(-350deg);
    }
   }

   @keyframes confettiA
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0.5, 0, -4500deg);
    }
   }

   @keyframes confettiB
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0, 0, -4500deg);
    }
   }

   @keyframes confettiC
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, -0.5, 0, -4500deg);
    }
   }

   @keyframes offsetPath
   {
    0%
    {
     offset-distance: 0%;
    }
    100%
    {
     offset-distance: 100%;
    }
   }

   @keyframes fadeIn
   {
    0%
    {
     opacity: 0;
    }
    100% /* 8% */
    {
     opacity: 1;
    }
   }

   @keyframes fadeOut
   {
    0% /* 95% */
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes noFadeOut
   {
    99%
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes zoomIn
   {
    0%
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.1)) / 2);
     max-height: calc(var(--emote-height) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 1.2)) / 2);
     max-height: calc(var(--emote-height) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.8)) / 2);
     max-height: calc(var(--emote-height) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.95)) / 2);
     max-height: calc(var(--emote-height) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
   }

   @keyframes zoomOut
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    100%
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.1)) / 2);
     max-height: calc(var(--emote-height) * 0.1);
    }
   }

   @keyframes zoomInS
   {
    0%
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.1)) / 2);
     max-height: calc(var(--emote-height-s) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 1.2)) / 2);
     max-height: calc(var(--emote-height-s) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.8)) / 2);
     max-height: calc(var(--emote-height-s) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.95)) / 2);
     max-height: calc(var(--emote-height-s) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
   }

   @keyframes zoomOutS
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    100%
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.1)) / 2);
     max-height: calc(var(--emote-height-s) * 0.1);
    }
   }

   @keyframes zoomInL
   {
    0%
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.1)) / 2);
     max-height: calc(var(--emote-height-l) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 1.2)) / 2);
     max-height: calc(var(--emote-height-l) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.8)) / 2);
     max-height: calc(var(--emote-height-l) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.95)) / 2);
     max-height: calc(var(--emote-height-l) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
   }

   @keyframes zoomOutL
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    100%
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.1)) / 2);
     max-height: calc(var(--emote-height-l) * 0.1);
    }
   }
   button
   {
    background-color: #7D5BBE;
    transition: background 0.12s ease-in, color 0.12s ease-in;
    white-space: nowrap;
    cursor: pointer;
    color: #FFFFFF;
    border-radius: 4px;
    border: none;
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
   }
   button:focus, button:hover
   {
    background-color: #772CE8;
   }
   button:focus
   {
    outline: none;
   }
   button:active
   {
    background-color: #5C16C5;
   }
  </style>
  <script>
   if (typeof cfg === 'undefined')
    throw new Error('Corrupted Configuration detected.');
   document.title = cfg.channel + ' Emote Wall';
   /* global variables */
   var channelID = 0;
   var dead = false;   // hard disconnect (usually caused by an error)
   var useL = false;   // interactive login in use
   var toShow = [];    // emote queue
   var toKappa = [];   // kappagen queue
   var toGC = {};      // list of image elements to garbage collect
   var eList = {};     // pre-listed emotes, sub-grouped into: cheer, ffz, 7tv, bttv, and bttvU (user-specific BTTV)
   var cList = [];     // list of channel-specific emotes, used for kappagens
   var fList = [];     // cache of users in chat and their follow status
   var bList = [];     // list of giftbomb event origin ids (to prevent kappas for each gift in a bomb)
   var conga = [];     // CONGA TIME!
   var eActive = 0;    // active emote count (effective, not actual)
   var tStart = 48;    // time to wait for transition trigger (ms)
   var uLF = false;    // user id of the most recent follower
   var rFC = 2500;     // follower count interval (ms)
   var tAnim = {       // animation timing constants
    fade: {
     in: 8,            // percentage of animation spent on fading in (8% of 5 seconds)
     out: 8            // percentage of animation spent on fading out
    },
    zoom: {
     in: 17,           // percentage of animation spent on zooming in (17% of 5 seconds)
     out: 8            // percentage of animation spent on zooming out
    }
   };
   /* Timers */
   var tIRC = false    // irc connection timeout
   var tEmote = false; // emote queue timer
   var tKappa = false; // kappagen queue timer
   var tGC = false;    // garbage collection
   var tFC = false;    // follower kludge
   var tL = false;     // logout button display

   function sleep(ms)
   {
    return new Promise(resolve => setTimeout(resolve, ms));
   }

   function checkURL(url)
   {
    let p = new Promise(
     async function(resolve, reject)
     {
      let x = new XMLHttpRequest();
      x.open('HEAD', url);
      x.onreadystatechange = function()
      {
       if (x.status === 200)
        resolve(true);
       else
        resolve(false);
      };
      x.send();
     }
    );
    return p;
   }

   function jSplit(s, sep, limit)
   {
    let arr = [];
    let v = '';
    for (let i = 0; i < s.length; i++)
    {
     if (arr.length < limit - 1)
     {
      if (s[i] === sep)
      {
       arr.push(v);
       v = '';
       continue;
      }
     }
     v += s[i];
    }
    if (v.length > 0)
     arr.push(v);
    return arr;
   }

   function findInMaybeRange(r, v)
   {
    let t = typeof r;
    switch (t)
    {
     case 'undefined':
      return false;
     case 'boolean':
      return (r === true);
     case 'number':
      if (r > 0 && v >= r)
       return true;
      return false;
     case 'object':
      if (r === null)
       return false;
      for (const k in r)
      {
       if (!r.hasOwnProperty(k))
        continue;
       let lower = 0;
       let upper = 0;
       if (k.slice(-1) === '+')
       {
        lower = parseInt(k.slice(0, -1), 10);
        upper = Number.MAX_SAFE_INTEGER;
       }
       else if (k.indexOf('-') !== -1)
       {
        lower = parseInt(k.slice(0, k.indexOf('-')), 10);
        upper = parseInt(k.slice(k.indexOf('-') + 1), 10);
       }
       else
       {
        lower = parseInt(k, 10);
        upper = parseInt(k, 10);
       }
       if (v >= lower && v <= upper)
        return r[k];
      }
    }
    return false;
   }

   function parseMsg(line)
   {
    let cmd = {};
    if (line.slice(0, 1) === '@')
    {
     line = line.slice(1);
     if (!line.includes(' '))
      return false;
     cmd.tags = {};
     let t = line.slice(0, line.indexOf(' '));
     line = line.slice(line.indexOf(' ') + 1);
     let a = t.split(';');
     for (let i = 0; i < a.length; i++)
     {
      let k = a[i].slice(0, a[i].indexOf('='));
      let v = a[i].slice(a[i].indexOf('=') + 1);
      v = v.replace(/\\s/g, ' ');
      cmd.tags[k] = v;
     }
    }
    if (line.slice(0, 1) === ':')
    {
     line = line.slice(1);
     if (!line.includes(' '))
      return false;
     cmd.prefix = line.slice(0, line.indexOf(' '));
     line = line.slice(line.indexOf(' ') + 1);
    }
    if (!line.includes(' '))
    {
     cmd.command = line;
     return cmd;
    }
    cmd.command = line.slice(0, line.indexOf(' '));
    line = line.slice(line.indexOf(' ') + 1);
    cmd.params = [];
    if (!line.includes(' '))
    {
     cmd.params.push(line);
     return cmd;
    }
    while (line.includes(' '))
    {
     if (line.slice(0, 1) === ':')
     {
      cmd.params.push(line.slice(1));
      return cmd;
     }
     cmd.params.push(line.slice(0, line.indexOf(' ')));
     line = line.slice(line.indexOf(' ') + 1);
    }
    if (line.slice(0, 1) === ':')
     line = line.slice(1);
    cmd.params.push(line);
    return cmd;
   }

   function parseUser(cmd, latinOnly = false)
   {
    let data = cmd.prefix;
    let ret = {};
    if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('display-name'))
     ret['display-name'] = cmd.tags['display-name'];
    if (data.includes('!'))
    {
     ret.nick = data.slice(0, data.indexOf('!'));
     data = data.slice(data.indexOf('!') + 1);
     if (!ret.hasOwnProperty('display-name') || (ret['display-name'] !== ret['display-name'].replaceAll(/[^A-Za-z0-9_]/g, '')))
     {
      console.log(ret['display-name'], ' should be known as ', ret.nick, ' because it isn\'t ', ret['display-name'].replaceAll(/[^A-Za-z0-9_]/g, ''));
      ret['display-name'] = ret.nick;
     }
    }
    if (data.includes('@'))
    {
     ret.host = data.slice(0, data.indexOf('@'));
     data = data.slice(data.indexOf('@') + 1);
     if (!ret.hasOwnProperty('display-name') || (ret['display-name'] !== ret['display-name'].replaceAll(/[^A-Za-z0-9_]/g, '')))
     {
      console.log(ret['display-name'], ' should be known as ', ret.host, ' because it isn\'t ', ret['display-name'].replaceAll(/[^A-Za-z0-9_]/g, ''));
      ret['display-name'] = ret.host;
     }
    }
    ret.user = data;
    return ret;
   }

   function getUserInfo(u)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.twitch.tv/helix/users?login=' + u);
      x.setRequestHeader('Authorization', 'Bearer ' + cfg.login.oauth);
      x.setRequestHeader('Client-Id', cfg.login.client);
      x.onreadystatechange = function()
      {
       if (x.status !== 200)
       {
        if (x.status === 401)
         blargIAmDead(3);
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('data'))
       {
        resolve(false);
        return;
       }
       if (j.data.length !== 1)
       {
        console.log('returned ', j.data.length, ' entries: ', j.data);
        resolve(false);
        return;
       }
       resolve(j.data[0]);
      };
      x.send();
     }
    );
    return p;
   }

   function findEmote_channel(chID)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.twitch.tv/helix/chat/emotes?broadcaster_id=' + chID);
      x.setRequestHeader('Authorization', 'Bearer ' + cfg.login.oauth);
      x.setRequestHeader('Client-Id', cfg.login.client);
      x.onreadystatechange = function()
      {
       if (x.status !== 200)
       {
        if (x.status === 401)
         blargIAmDead(3);
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('data'))
       {
        resolve(false);
        return;
       }
       let ret = [];
       let f = 'default';
       let t = 'dark';
       let r = '3.0';
       for (let i = 0; i < j.data.length; i++)
        ret.push({url: 'https://static-cdn.jtvnw.net/emoticons/v2/' + j.data[i].id + '/' + f + '/' + t + '/' + r});
       resolve(ret);
      };
      x.send();
     }
    );
    return p;
   }

   async function loadEmote_channel(chID)
   {
    cList = [];
    let r = await findEmote_channel(chID);
    if (r === false)
     return false;
    cList = r;
    return true;
   }

   function loadCheer_channel(chID)
   {
    eList.cheer = {};
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.twitch.tv/helix/bits/cheermotes?broadcaster_id=' + chID);
      x.setRequestHeader('Authorization', 'Bearer ' + cfg.login.oauth);
      x.setRequestHeader('Client-Id', cfg.login.client);
      x.onreadystatechange = function()
      {
       if (x.status !== 200)
       {
        if (x.status === 401)
         blargIAmDead(3);
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('data'))
       {
        resolve(false);
        return;
       }
       for (let c = 0; c < j.data.length; c++)
       {
        let set = j.data[c];
        if (!set.hasOwnProperty('prefix'))
         continue;
        if (!set.hasOwnProperty('tiers'))
         continue;
        let prefix = set.prefix;
        let tierList = [];
        for (let i = set.tiers.length - 1; i >= 0; i--)
        {
         if (!set.tiers[i].hasOwnProperty('min_bits'))
          continue;
         if (!set.tiers[i].hasOwnProperty('images'))
          continue;
         let amt = set.tiers[i].min_bits;
         let img = null;
         if (set.tiers[i].images.hasOwnProperty('dark'))
         {
          if (set.tiers[i].images.dark.hasOwnProperty('animated'))
          {
           if (set.tiers[i].images.dark.animated.hasOwnProperty('4'))
            img = set.tiers[i].images.dark.animated['4'];
           else if (set.tiers[i].images.dark.animated.hasOwnProperty('3'))
            img = set.tiers[i].images.dark.animated['3'];
           else if (set.tiers[i].images.dark.animated.hasOwnProperty('2'))
            img = set.tiers[i].images.dark.animated['2'];
           else if (set.tiers[i].images.dark.animated.hasOwnProperty('1.5'))
            img = set.tiers[i].images.dark.animated['1.5'];
           else if (set.tiers[i].images.dark.animated.hasOwnProperty('1'))
            img = set.tiers[i].images.dark.animated['1'];
          }
          else if (set.tiers[i].images.dark.hasOwnProperty('static'))
          {
           if (set.tiers[i].images.dark.static.hasOwnProperty('4'))
            img = set.tiers[i].images.dark.static['4'];
           else if (set.tiers[i].images.dark.static.hasOwnProperty('3'))
            img = set.tiers[i].images.dark.static['3'];
           else if (set.tiers[i].images.dark.static.hasOwnProperty('2'))
            img = set.tiers[i].images.dark.static['2'];
           else if (set.tiers[i].images.dark.static.hasOwnProperty('1.5'))
            img = set.tiers[i].images.dark.static['1.5'];
           else if (set.tiers[i].images.dark.static.hasOwnProperty('1'))
            img = set.tiers[i].images.dark.static['1'];
          }
         }
         else if (set.tiers[i].images.hasOwnProperty('light'))
         {
          if (set.tiers[i].images.light.hasOwnProperty('animated'))
          {
           if (set.tiers[i].images.light.animated.hasOwnProperty('4'))
            img = set.tiers[i].images.light.animated['4'];
           else if (set.tiers[i].images.light.animated.hasOwnProperty('3'))
            img = set.tiers[i].images.light.animated['3'];
           else if (set.tiers[i].images.light.animated.hasOwnProperty('2'))
            img = set.tiers[i].images.light.animated['2'];
           else if (set.tiers[i].images.light.animated.hasOwnProperty('1.5'))
            img = set.tiers[i].images.light.animated['1.5'];
           else if (set.tiers[i].images.light.animated.hasOwnProperty('1'))
            img = set.tiers[i].images.light.animated['1'];
          }
          else if (set.tiers[i].images.light.hasOwnProperty('static'))
          {
           if (set.tiers[i].images.light.static.hasOwnProperty('4'))
            img = set.tiers[i].images.light.static['4'];
           else if (set.tiers[i].images.light.static.hasOwnProperty('3'))
            img = set.tiers[i].images.light.static['3'];
           else if (set.tiers[i].images.light.static.hasOwnProperty('2'))
            img = set.tiers[i].images.light.static['2'];
           else if (set.tiers[i].images.light.static.hasOwnProperty('1.5'))
            img = set.tiers[i].images.light.static['1.5'];
           else if (set.tiers[i].images.light.static.hasOwnProperty('1'))
            img = set.tiers[i].images.light.static['1'];
          }
         }
         if (img === null)
          continue;
         tierList.push({min: amt, img: img});
        }
        eList.cheer[prefix] = tierList;
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function readFFZ_URL(entry)
   {
    if (!entry.hasOwnProperty('urls'))
     return false;
    if (entry.urls.hasOwnProperty('4'))
    {
     let u4 = entry.urls[4];
     if (u4.slice(0, 2) === '//')
      u4 = 'https:' + u4;
     return u4;
    }
    if (entry.urls.hasOwnProperty('2'))
    {
     let u2 = entry.urls[2];
     if (u2.slice(0, 2) === '//')
      u2 = 'https:' + u2;
     let u24 = u2;
     if (u24.slice(-2) === '/2')
      u24 = u24.slice(0, -1) + '4';
     return u24;
    }
    if (entry.urls.hasOwnProperty('1'))
    {
     let u1 = entry.urls[1];
     if (u1.slice(0, 2) === '//')
      u1 = 'https:' + u1;
     let u14 = u1;
     if (u14.slice(-2) === '/1')
      u14 = u14.slice(0, -1) + '4';
     return u14;
    }
    return false;
   }

   function loadFFZ_global()
   {
    eList.ffz = {};
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.frankerfacez.com/v1/set/global');
      x.onreadystatechange = function()
      {
       if (x.status !== 200)
       {
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('sets'))
       {
        resolve(false);
        return;
       }
       let usedSets = [];
       if (j.hasOwnProperty('default_sets'))
       {
        for (let i = 0; i < j.default_sets.length; i++)
         usedSets.push(j.default_sets[i]);
       }
       for (const set in j.sets)
       {
        if (!j.sets.hasOwnProperty(set))
         continue;
        if (!usedSets.includes(j.sets[set].id))
         continue;
        if (!j.sets[set].hasOwnProperty('emoticons'))
         continue;
        for (let i = 0; i < j.sets[set].emoticons.length; i++)
        {
         if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
          continue;
         let u = readFFZ_URL(j.sets[set].emoticons[i]);
         if (u === false)
          continue;
         eList.ffz[j.sets[set].emoticons[i].name] = {url: u, users: null, scope: 'g'};
        }
       }
       //user-specific, from here on everything resolve()s true
       if (!j.hasOwnProperty('users'))
       {
        resolve(true);
        return;
       }
       for (const setID in j.users)
       {
        if (!j.users.hasOwnProperty(setID))
         continue;
        let aList = j.users[setID];
        if (!Array.isArray(aList))
         continue;
        for (const set in j.sets)
        {
         if (!j.sets.hasOwnProperty(set))
          continue;
         if (setID !== set)
          continue;
         if (!j.sets[set].hasOwnProperty('emoticons'))
          continue;
         for (let i = 0; i < j.sets[set].emoticons.length; i++)
         {
          if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
           continue;
          let u = readFFZ_URL(j.sets[set].emoticons[i]);
          if (u === false)
           continue;
          eList.ffz[j.sets[set].emoticons[i].name] = {url: u, users: aList, scope: 'g'};
         }
        }
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function loadFFZ_channel(chID)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.frankerfacez.com/v1/room/id/' + chID);
      x.onreadystatechange = function()
      {
       if (x.status !== 200)
       {
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       if (!j.hasOwnProperty('sets'))
       {
        resolve(false);
        return;
       }
       for (const set in j.sets)
       {
        if (!j.sets[set].hasOwnProperty('emoticons'))
         continue;
        for (let i = 0; i < j.sets[set].emoticons.length; i++)
        {
         if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
          continue;
         let u = readFFZ_URL(j.sets[set].emoticons[i]);
         if (u === false)
          continue;
         cList.push({url: u});
         eList.ffz[j.sets[set].emoticons[i].name] = {url: u, users: null, scope: 'c'};
        }
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function loadBTTV_global()
   {
    eList.bttv = {};
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.betterttv.net/3/cached/emotes/global');
      x.onreadystatechange = function()
      {
       if (x.status !== 200)
       {
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       for (let i = 0; i < j.length; i++)
       {
        if (!j[i].hasOwnProperty('code'))
         continue;
        if (!j[i].hasOwnProperty('id'))
         continue;
        if (bttvZWE.includes(j[i].code))
         continue;
        eList.bttv[j[i].code] = {url: 'https://cdn.betterttv.net/emote/' + j[i].id + '/3x', scope: 'g'};
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function loadBTTV_channel(chID)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.betterttv.net/3/cached/users/twitch/' + chID);
      x.onreadystatechange = function()
      {
       if (x.status !== 200)
       {
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       if (j.hasOwnProperty('channelEmotes'))
       {
        for (let i = 0; i < j.channelEmotes.length; i++)
        {
         if (!j.channelEmotes[i].hasOwnProperty('code'))
          continue;
         if (!j.channelEmotes[i].hasOwnProperty('id'))
          continue;
         cList.push({url: 'https://cdn.betterttv.net/emote/' + j.channelEmotes[i].id + '/3x'});
         eList.bttv[j.channelEmotes[i].code] = {url: 'https://cdn.betterttv.net/emote/' + j.channelEmotes[i].id + '/3x', scope: 'c'};
        }
       }
       if (j.hasOwnProperty('sharedEmotes'))
       {
        for (let i = 0; i < j.sharedEmotes.length; i++)
        {
         if (!j.sharedEmotes[i].hasOwnProperty('code'))
          continue;
         if (!j.sharedEmotes[i].hasOwnProperty('id'))
          continue;
         cList.push({url: 'https://cdn.betterttv.net/emote/' + j.sharedEmotes[i].id + '/3x'});
         eList.bttv[j.sharedEmotes[i].code] = {url: 'https://cdn.betterttv.net/emote/' + j.sharedEmotes[i].id + '/3x', scope: 'c'};
        }
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function loadBTTV_ws_channel(chID)
   {
    eList.bttvU = {};
    const ws = new WebSocket('wss://sockets.betterttv.net/ws');
    ws.onopen = function(event)
    {
     ws.send('{"name":"join_channel","data":{"name":"twitch:' + chID + '"}}');
     ws.send('{"name":"broadcast_me","data":{"name":"' + cfg.channel + '","channel":"twitch:' + chID + '"}}');
    };
    ws.onclose = function()
    {
     window.setTimeout(function(){loadBTTV_ws_channel(chID);}, 5000);
    };
    ws.onmessage = function(event)
    {
     if (!event.isTrusted)
      return;
     let d = JSON.parse(event.data);
     if (!d.hasOwnProperty('name'))
      return;
     if (!d.hasOwnProperty('data'))
      return;
     if (d.name !== 'lookup_user')
      return;
     if (!d.data.hasOwnProperty('name'))
      return;
     if (!d.data.hasOwnProperty('emotes') || !Array.isArray(d.data.emotes) || d.data.emotes.length < 1)
      return;
     eList.bttvU[d.data.name] = {};
     for (let i = 0; i < d.data.emotes.length; i++)
     {
      if (!d.data.emotes[i].hasOwnProperty('code'))
       continue;
      if (!d.data.emotes[i].hasOwnProperty('id'))
       continue;
      eList.bttvU[d.data.name][d.data.emotes[i].code] = {url: 'https://cdn.betterttv.net/emote/' + d.data.emotes[i].id + '/3x', scope: 'u'};
     }
    };
   }

   function load7TV_global()
   {
    eList['7tv'] = {};
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.7tv.app/v2/emotes/global');
      x.onreadystatechange = function()
      {
       if (x.status !== 200)
       {
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       for (let i = 0; i < j.length; i++)
       {
        if (!j[i].hasOwnProperty('name'))
         continue;
        if (!j[i].hasOwnProperty('urls'))
         continue;
        let t4 = null;
        for (let u = 0; u < j[i].urls.length; u++)
        {
         if (j[i].urls[u][0] === '1')
         {
          let t1 = j[i].urls[u][1];
          if (t1.slice(-3) === '/1x')
          {
           if (t4 === null)
            t4 = t1.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '2')
         {
          let t2 = j[i].urls[u][1];
          if (t2.slice(-3) === '/2x')
          {
           if (t4 === null)
            t4 = t2.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '3')
         {
          let t3 = j[i].urls[u][1];
          if (t3.slice(-3) === '/3x')
          {
           if (t4 === null)
            t4 = t3.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '4')
          t4 = j[i].urls[u][1];
        }
        if (j[i].hasOwnProperty('visibility') && (j[i].visibility & 0x80) === 0x80) //Zero-Width
         continue;
        eList['7tv'][j[i].name] = {url: t4, scope: 'g'};
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function load7TV_channel(chN)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.7tv.app/v2/users/' + chN + '/emotes');
      x.onreadystatechange = function()
      {
       if (x.status !== 200)
       {
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       for (let i = 0; i < j.length; i++)
       {
        if (!j[i].hasOwnProperty('name'))
         continue;
        if (!j[i].hasOwnProperty('urls'))
         continue;
        let t4 = null;
        for (let u = 0; u < j[i].urls.length; u++)
        {
         if (j[i].urls[u][0] === '1')
         {
          let t1 = j[i].urls[u][1];
          if (t1.slice(-3) === '/1x')
          {
           if (t4 === null)
            t4 = t1.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '2')
         {
          let t2 = j[i].urls[u][1];
          if (t2.slice(-3) === '/2x')
          {
           if (t4 === null)
            t4 = t2.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '3')
         {
          let t3 = j[i].urls[u][1];
          if (t3.slice(-3) === '/3x')
          {
           if (t4 === null)
            t4 = t3.slice(0, -2) + '4x';
          }
         }
         if (j[i].urls[u][0] === '4')
          t4 = j[i].urls[u][1];
        }
        if (j[i].hasOwnProperty('visibility') && (j[i].visibility & 0x80) === 0x80) //Zero-Width
         continue;
        cList.push({url: t4});
        eList['7tv'][j[i].name] = {url: t4, scope: 'c'};
       }
       resolve(true);
      };
      x.send();
     }
    );
    return p;
   }

   function doGC()
   {
    if (tGC === false)
     return;
    window.clearTimeout(tGC);
    tGC = false;
    let done = true;
    for (let idx in toGC)
    {
     if (!toGC.hasOwnProperty(idx))
      continue;
     done = false;
     let i = toGC[idx].img;
     let t = toGC[idx].end;
     let d = toGC[idx].dec;
     if (toGC[idx].space)
     {
      let r = i.getBoundingClientRect();
      if ((r.bottom > 0 && r.right > 0 && r.top < window.innerHeight && r.left < window.innerWidth) && t > new Date().getTime())
       continue;
     }
     else
     {
      if (t > new Date().getTime())
       continue;
     }
     delete toGC[idx];
     if (d !== false)
      window.clearTimeout(t);
     document.body.removeChild(i);
     if (d)
      eActive--;
    }
    if (!done)
     tGC = window.setTimeout(doGC, 500);
   }

   function gcEmote(img, space = true, decActive = true, t = false)
   {
    if (t === false)
     t = cfg.emote.time * 1000;
    let x = 0;
    do
    {
     x++;
    } while(toGC.hasOwnProperty(x));
    toGC[x] = {img: img, space: space, dec: decActive, end: new Date().getTime() + t};
    if (tGC === false)
     tGC = window.setTimeout(doGC, 500);
   }

   function showEmote_Rise(url, sW, sH, sS, canV = true)
   {
    let img = document.createElement('img');
    img.setAttribute('class', 'emote');
    img.setAttribute('src', url);
    img.setAttribute('alt', '');
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = Math.floor(Math.random() * (cfg.emote.size.variation + 2));
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = Math.floor(Math.random() * sW) - (sS / 2);
    let v = Math.floor((Math.random() * 0.3) * sH) + Math.floor(0.8 * sH);
    let s = 'left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    if (cfg.emote.out.fade || cfg.emote.out.zoom)
     s += ' offset-path: path("M 0 ' + v + ' L 0 ' + Math.floor(v * 0.05) + '") ;';
    else
     s += ' offset-path: path("M 0 ' + v + ' L 0 -' + sS + '") ;';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (Math.floor(Math.random() * 2) === 1)
     aNames.push('wiggleL');
    else
     aNames.push('wiggleR');
    let d = Math.floor(Math.random() * 600);
    aDelays.push(d + 'ms');
    let w = Math.floor(Math.random() * 3) + 2;
    aDurs.push(w + 's');
    aTimings.push('ease-in-out');
    aFills.push('both');
    aIters.push('infinite');
    aNames.push('offsetPath');
    aDelays.push('0s');
    aDurs.push(cfg.emote.time + 's');
    aTimings.push('linear');
    aFills.push('forwards');
    aIters.push('1');
    if (cfg.emote.in.fade)
    {
     aNames.push('fadeIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('ease-in');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.in.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomInS');
     else if (variationSize === 2)
      aNames.push('zoomInL');
     else
      aNames.push('zoomIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.in / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomOutS');
     else if (variationSize === 2)
      aNames.push('zoomOutL');
     else
      aNames.push('zoomOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.zoom.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.out / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    s += ' animation-name: ' + aNames.join() + ';';
    s += ' animation-delay: ' + aDelays.join() + ';';
    s += ' animation-duration: ' + aDurs.join() + ';';
    s += ' animation-timing-function: ' + aTimings.join() + ';';
    s += ' animation-fill-mode: ' + aFills.join() + ';';
    s += ' animation-iteration-count: ' + aIters.join() + ';';
    img.setAttribute('style', s);
    eActive++;
    document.body.appendChild(img);
    gcEmote(img, false);
   }

   function showEmote_Bounce(url, sW, sH, sS, canV = true)
   {
    let ms = 20;
    let img = document.createElement('img');
    img.setAttribute('class', 'emote');
    img.setAttribute('src', url);
    img.setAttribute('alt', '');
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = Math.floor(Math.random() * (cfg.emote.size.variation + 2));
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = Math.floor(Math.random() * sW) - (sS / 2);
    let v = Math.floor((Math.random() * 0.2) * sH);
    let s = ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (cfg.emote.in.fade)
    {
     aNames.push('fadeIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('ease-in');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.in.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomInS');
     else if (variationSize === 2)
      aNames.push('zoomInL');
     else
      aNames.push('zoomIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.in / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomOutS');
     else if (variationSize === 2)
      aNames.push('zoomOutL');
     else
      aNames.push('zoomOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.zoom.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.out / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (aNames.length > 0)
    {
     s += ' animation-name: ' + aNames.join() + ';';
     s += ' animation-delay: ' + aDelays.join() + ';';
     s += ' animation-duration: ' + aDurs.join() + ';';
     s += ' animation-timing-function: ' + aTimings.join() + ';';
     s += ' animation-fill-mode: ' + aFills.join() + ';';
     s += ' animation-iteration-count: ' + aIters.join() + ';';
    }
    s += ' transform: translate(' + h + 'px, ' + v + 'px);';
    let bX = h;
    let bY = v;
    let velX = Math.floor((Math.random() * 6) + 3);
    let velY = Math.floor((Math.random() * 3) + 4);
    if (bX + (sS / 2) > (sW / 2))
     velX = -1 * velX;
    let c = null;
    let tmr = window.setTimeout(
     function tLoop()
     {
      window.clearTimeout(tmr);
      tmr = null;
      bX += velX;
      bY += velY;
      velY += 1;
      if (bY + sS >= sH)
      {
       bY = sH - sS;
       velY *= -0.7;
       velY = Math.floor(velY);
      }
      img.style.transform = 'translate(' + bX + 'px, ' + bY + 'px)';
      if ((bX < 0 - sS) || (bX > sW))
      {
       if (c !== null)
       {
        window.clearTimeout(c);
        c = null;
        document.body.removeChild(img);
        eActive--;
       }
       return;
      }
      tmr = window.setTimeout(tLoop, ms);
     },
     ms
    );
    img.setAttribute('style', s);
    eActive++;
    document.body.appendChild(img);
    c = window.setTimeout(
     function()
     {
      c = null;
      window.clearTimeout(tmr);
      tmr = null;
      document.body.removeChild(img);
      eActive--;
     },
     cfg.emote.time * 1000
    );
   }

   function showEmote_Speed(url, sW, sH, sS, canV = true)
   {
    let img = document.createElement('img');
    img.setAttribute('class', 'emote');
    img.setAttribute('src', url);
    img.setAttribute('alt', '');
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = Math.floor(Math.random() * (cfg.emote.size.variation + 2));
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = Math.floor(Math.random() * sW) - (sS / 2);
    let v = Math.floor((Math.random() * 0.4) * sH) + Math.floor(0.3 * sH);
    let s = 'top: ' + v + 'px;';
    s += ' left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    let goLeft = (h + (sS / 2) > (sW / 2));
    if (goLeft)
     s += ' transform-origin: center right;';
    else
     s += ' transform-origin: center left;';
    if (goLeft)
     aNames.push('speedL');
    else
     aNames.push('speedR');
    aDelays.push('0.5s');
    aDurs.push(cfg.emote.time + 's');
    aTimings.push('ease-in');
    aFills.push('forwards');
    aIters.push('1');
    if (cfg.emote.in.fade)
    {
     aNames.push('fadeIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('ease-in');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.in.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomInS');
     else if (variationSize === 2)
      aNames.push('zoomInL');
     else
      aNames.push('zoomIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.in / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomOutS');
     else if (variationSize === 2)
      aNames.push('zoomOutL');
     else
      aNames.push('zoomOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.zoom.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.out / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    s += ' animation-name: ' + aNames.join() + ';';
    s += ' animation-delay: ' + aDelays.join() + ';';
    s += ' animation-duration: ' + aDurs.join() + ';';
    s += ' animation-timing-function: ' + aTimings.join() + ';';
    s += ' animation-fill-mode: ' + aFills.join() + ';';
    s += ' animation-iteration-count: ' + aIters.join() + ';';
    img.setAttribute('style', s);
    eActive++;
    document.body.appendChild(img);
    gcEmote(img);
   }

   function showEmote_Drop(url, sW, sH, sS, canV = true)
   {
    let img = document.createElement('img');
    img.setAttribute('class', 'emote');
    img.setAttribute('src', url);
    img.setAttribute('alt', '');
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = Math.floor(Math.random() * (cfg.emote.size.variation + 2));
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = Math.floor(Math.random() * sW) - (sS / 2);
    let s = 'left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    let goLeft = (Math.floor(Math.random() * 2) === 1);
    if (goLeft)
     s += ' transform-origin: top left;';
    else
     s += ' transform-origin: top right;';
    if (goLeft)
     aNames.push('dropL');
    else
     aNames.push('dropR');
    aDelays.push('0s');
    aDurs.push(cfg.emote.time + 's');
    aTimings.push('ease-in');
    aFills.push('forwards');
    aIters.push('1');
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomOutS');
     else if (variationSize === 2)
      aNames.push('zoomOutL');
     else
      aNames.push('zoomOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.zoom.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.out / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    s += ' animation-name: ' + aNames.join() + ';';
    s += ' animation-delay: ' + aDelays.join() + ';';
    s += ' animation-duration: ' + aDurs.join() + ';';
    s += ' animation-timing-function: ' + aTimings.join() + ';';
    s += ' animation-fill-mode: ' + aFills.join() + ';';
    s += ' animation-iteration-count: ' + aIters.join() + ';';
    img.setAttribute('style', s);
    eActive++;
    document.body.appendChild(img);
    gcEmote(img, false);
   }

   function showEmote_Confetti(url, sW, sH, sS, canV = true)
   {
    let img = document.createElement('img');
    img.setAttribute('class', 'emote');
    img.setAttribute('src', url);
    img.setAttribute('alt', '');
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = Math.floor(Math.random() * (cfg.emote.size.variation + 2));
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = Math.floor(Math.random() * sW) - (sS / 2);
    let s = 'left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += ' transform-origin: center center;';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    let style = Math.floor(Math.random() * 3);
    switch (style)
    {
     case 0:
      aNames.push('confettiA');
      break;
     case 1:
      aNames.push('confettiB');
      break;
     case 2:
      aNames.push('confettiC');
      break;
    }
    aDelays.push('0s');
    aDurs.push(cfg.emote.time + 's');
    aTimings.push('linear');
    aFills.push('forwards');
    aIters.push('1');
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    s += ' animation-name: ' + aNames.join() + ';';
    s += ' animation-delay: ' + aDelays.join() + ';';
    s += ' animation-duration: ' + aDurs.join() + ';';
    s += ' animation-timing-function: ' + aTimings.join() + ';';
    s += ' animation-fill-mode: ' + aFills.join() + ';';
    s += ' animation-iteration-count: ' + aIters.join() + ';';
    img.setAttribute('style', s);
    eActive++;
    document.body.appendChild(img);
    gcEmote(img, false);
   }

   function showEmote_Crazy(url, sW, sH, sS, canV = true)
   {
    /* LAYOUT SHIFTS
     * =============
     * squashes via scale
     * offset-path requires support for offset-anchor/offset-position
     * due to transform-origin changes during squash
     */
    let squashT = 100;
    let img = document.createElement('img');
    img.setAttribute('class', 'emote');
    img.setAttribute('src', url);
    img.setAttribute('alt', '');
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = Math.floor(Math.random() * (cfg.emote.size.variation + 2));
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = Math.floor(Math.random() * (sW - sS - 5)) + 10;
    let v = Math.floor(Math.random() * (sH - sS - 5)) + 10;
    let s = 'top: ' + v + 'px;';
    s += ' left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    //s += ' transition: all 0.9s linear;';
    let dests = [];
    let traj = {x: 0, y: 0};
    traj.x = Math.random() * 11 - 5;
    traj.y = Math.random() * 11 - 5;
    let pos = {x: h, y: v, t: 0};
    let lastT = 0;
    let bCt = 0;
    while(pos.t + (bCt * (squashT * 2)) < (cfg.emote.time * 1000))
    {
     pos.x += traj.x;
     pos.y += traj.y;
     pos.t += 5;
     let wall = false;
     if (pos.x < 0)
     {
      pos.x = 0;
      traj.x *= -1;
      wall = 1;
     }
     else if (pos.x > (sW - sS))
     {
      pos.x = sW - sS;
      traj.x *= -1;
      wall = 3;
     }
     if (pos.y < 0)
     {
      pos.y = 0;
      traj.y *= -1;
      wall = 2;
     }
     else if (pos.y > (sH - sS))
     {
      pos.y = sH - sS;
      traj.y *= -1;
      wall = 4;
     }
     if (wall !== false)
     {
      bCt++;
      dests.push({x: Math.floor(pos.x), y: Math.floor(pos.y), t: (pos.t - lastT), w: wall});
      lastT = pos.t;
     }
    }
    dests.push({x: pos.x, y: pos.y, t: (pos.t - lastT), w: 0});
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (cfg.emote.in.fade)
    {
     aNames.push('fadeIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('ease-in');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.in.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomInS');
     else if (variationSize === 2)
      aNames.push('zoomInL');
     else
      aNames.push('zoomIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.in / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomOutS');
     else if (variationSize === 2)
      aNames.push('zoomOutL');
     else
      aNames.push('zoomOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.zoom.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.out / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    s += ' animation-name: ' + aNames.join() + ';';
    s += ' animation-delay: ' + aDelays.join() + ';';
    s += ' animation-duration: ' + aDurs.join() + ';';
    s += ' animation-timing-function: ' + aTimings.join() + ';';
    s += ' animation-fill-mode: ' + aFills.join() + ';';
    s += ' animation-iteration-count: ' + aIters.join() + ';';
    img.setAttribute('style', s);
    eActive++;
    document.body.appendChild(img);
    gcEmote(img, false);
    let d = 0;
    let tmr = window.setTimeout(
     function tLoop()
     {
      if (d >= dests.length)
       return;
      window.clearTimeout(tmr);
      img.style.transformOrigin = 'center center';
      img.style.transform = 'scale(1, 1)';
      img.style.top = dests[d].y + 'px';
      img.style.left = dests[d].x + 'px';
      img.style.transition = 'all ' + dests[d].t + 'ms linear';
      d++;
      tmr = window.setTimeout(
       function tSquash()
       {
        window.clearTimeout(tmr);
        img.style.transition = 'transform ' + squashT + 'ms linear';
        switch(dests[d-1].w)
        {
         case 1:
          //left
          img.style.transformOrigin = 'left center';
          img.style.transform = 'scale(0.7, 2)';
          break;
         case 2:
          //top
          img.style.transformOrigin = 'center top';
          img.style.transform = 'scale(2, 0.7)';
          break;
         case 3:
          //right
          img.style.transformOrigin = 'right center';
          img.style.transform = 'scale(0.7, 2)';
          break;
         case 4:
          //bottom
          img.style.transformOrigin = 'center bottom';
          img.style.transform = 'scale(2, 0.7)';
          break;
        }
        tmr = window.setTimeout(
         function tUnsquash()
         {
          window.clearTimeout(tmr);
          img.style.transition = 'transform ' + squashT + 'ms linear';
          img.style.transform = 'scale(1, 1)';
          tmr = window.setTimeout(tLoop, squashT);
         },
         squashT
        );
       }, dests[d - 1].t
      );
     },
     tStart
    );
   }

   function showEmote_StraightLine(url, sW, sH, sS, x = false, y = false, canV = true)
   {
    let img = document.createElement('img');
    img.setAttribute('class', 'emote');
    img.setAttribute('src', url);
    img.setAttribute('alt', '');
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = Math.floor(Math.random() * (cfg.emote.size.variation + 2));
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = x;
    if (h === false)
     h = Math.floor((Math.random() * sW) - (sS / 2));
    let v = y;
    if (v === false)
     v = Math.floor((Math.random() * sH) - (sS / 2));
    let r = sW;
    if (sH < r)
     r = sH;
    r = r * (Math.random() + 1);
    let th = (Math.random() * (Math.PI * 2));
    let hD = Math.floor(h + r * Math.cos(th));
    let vD = Math.floor(v + r * Math.sin(th));
    if (!x && !y)
    {
     while ((h < 0 && hD < 0) || (v < 0 && vD < 0) || (h > (sW - sS) && hD > (sW - sS)) || (v > (sH - sS) && vD > (sH - sS)))
     {
      th = (Math.random() * (Math.PI * 2));
      hD = Math.floor(h + r * Math.cos(th));
      vD = Math.floor(v + r * Math.sin(th));
     }
    }
    let s = 'height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += ' transition: transform ' + cfg.emote.time + 's linear;';
    s += ' transform: translate(' + h + 'px, ' + v + 'px);';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (cfg.emote.in.fade)
    {
     aNames.push('fadeIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('ease-in');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.in.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomInS');
     else if (variationSize === 2)
      aNames.push('zoomInL');
     else
      aNames.push('zoomIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.in / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomOutS');
     else if (variationSize === 2)
      aNames.push('zoomOutL');
     else
      aNames.push('zoomOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.zoom.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.out / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    s += ' animation-name: ' + aNames.join() + ';';
    s += ' animation-delay: ' + aDelays.join() + ';';
    s += ' animation-duration: ' + aDurs.join() + ';';
    s += ' animation-timing-function: ' + aTimings.join() + ';';
    s += ' animation-fill-mode: ' + aFills.join() + ';';
    s += ' animation-iteration-count: ' + aIters.join() + ';';
    img.setAttribute('style', s);
    eActive++;
    document.body.appendChild(img);
    gcEmote(img);
    window.setTimeout(
     function()
     {
      img.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
     },
     tStart
    );
   }

   function showEmote_Fountain(url, sW, sH, sS, fX, fY, canV = true)
   {
    let aT = Math.floor((cfg.emote.time * 1000) / 2);
    let img = document.createElement('img');
    img.setAttribute('class', 'emote');
    img.setAttribute('src', url);
    img.setAttribute('alt', '');
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = Math.floor(Math.random() * (cfg.emote.size.variation + 2));
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = fX;
    if (h === false)
     h = Math.floor((Math.random() * ((sW - sS) * 0.33)) + (sW - sS) * 0.33);
    let hD;
    if (Math.floor(Math.random() * 2) === 0)
     hD = h - Math.floor(Math.random() * ((sW - sS) * 0.2));
    else
     hD = h + Math.floor(Math.random() * ((sW - sS) * 0.2));
    let s = 'height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += ' transition: transform ' + aT + 'ms cubic-bezier(0, 0, 0.58, 1);';
    s += ' transform: translateX(' + h + 'px);';
    s += ' offset-path: path("M 0 ' + sH + ' L 0 ' + Math.floor(fY / 100 * sH + Math.floor(Math.random() * ((sH - sS) * 0.5))) + ' L 0 ' + (sH + sS) + '");';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    aNames.push('offsetPath');
    aDelays.push('0s');
    aDurs.push(aT + 'ms');
    aTimings.push('cubic-bezier(0, 0.9, 1, 0.15)');
    aFills.push('forwards');
    aIters.push('1');
    s += ' animation-name: ' + aNames.join() + ';';
    s += ' animation-delay: ' + aDelays.join() + ';';
    s += ' animation-duration: ' + aDurs.join() + ';';
    s += ' animation-timing-function: ' + aTimings.join() + ';';
    s += ' animation-fill-mode: ' + aFills.join() + ';';
    s += ' animation-iteration-count: ' + aIters.join() + ';';
    img.setAttribute('style', s);
    eActive++;
    document.body.appendChild(img);
    gcEmote(img, true, true, aT);
    window.setTimeout(
     function()
     {
      img.style.transform = 'translateX(' + hD + 'px)';
     },
     tStart
    );
   }

   function showEmote_Still(url, sW, sH, sS, canV = true)
   {
    let img = document.createElement('img');
    img.setAttribute('class', 'emote');
    let variationSize = 1;
    if (canV, cfg.emote.size.variation !== false)
    {
     variationSize = Math.floor(Math.random() * (cfg.emote.size.variation + 2));
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    let h = Math.floor(Math.random() * sW) - (sS / 2);
    let v = Math.floor(Math.random() * sH) - (sS / 2);
    img.setAttribute('src', url);
    img.setAttribute('alt', '');
    let s = 'top: ' + v + 'px;';
    s += ' left: ' + h + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (cfg.emote.in.fade)
    {
     aNames.push('fadeIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('ease-in');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.in.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomInS');
     else if (variationSize === 2)
      aNames.push('zoomInL');
     else
      aNames.push('zoomIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.in / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.zoom)
    {
     if (variationSize === 0)
      aNames.push('zoomOutS');
     else if (variationSize === 2)
      aNames.push('zoomOutL');
     else
      aNames.push('zoomOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.zoom.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.zoom.out / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (aNames.length > 0)
    {
     s += ' animation-name: ' + aNames.join() + ';';
     s += ' animation-delay: ' + aDelays.join() + ';';
     s += ' animation-duration: ' + aDurs.join() + ';';
     s += ' animation-timing-function: ' + aTimings.join() + ';';
     s += ' animation-fill-mode: ' + aFills.join() + ';';
     s += ' animation-iteration-count: ' + aIters.join() + ';';
    }
    img.setAttribute('style', s);
    eActive++;
    document.body.appendChild(img);
    gcEmote(img, false);
   }

   function showEmote_TheCube(url, sW, sH, sS, canV = true)
   {
    let scene = document.createElement('div');
    scene.setAttribute('class', 'scene');
    let variationSize = 1;
    if (canV && cfg.emote.size.variation !== false)
    {
     variationSize = Math.floor(Math.random() * (cfg.emote.size.variation + 2));
     if (variationSize !== 0 && variationSize !== 2)
      variationSize = 1;
    }
    if (variationSize === 0)
     sS = Math.ceil(sS * 0.5);
    else if (variationSize === 2)
     sS = sS * 2;
    scene.setAttribute('width', sS);
    scene.setAttribute('height', sS);
    let cube = document.createElement('div');
    cube.setAttribute('class', 'cube');
    cube.setAttribute('style', 'transform: translateZ(' + (sS * -0.5) + 'px);  transition: transform linear ' + cfg.emote.time + 's;');
    let f = 'height: ' + sS + 'px;';
    f += ' width: ' + sS + 'px;';
    let cubeF = document.createElement('img');
    cubeF.setAttribute('src', url);
    cubeF.setAttribute('alt', '');
    cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
    cubeF.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeF);
    let cubeB = document.createElement('img');
    cubeB.setAttribute('src', url);
    cubeB.setAttribute('alt', '');
    cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
    cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeB);
    let cubeR = document.createElement('img');
    cubeR.setAttribute('src', url);
    cubeR.setAttribute('alt', '');
    cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
    cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeR);
    let cubeL = document.createElement('img');
    cubeL.setAttribute('src', url);
    cubeL.setAttribute('alt', '');
    cubeL.setAttribute('class', 'cubeFace cubeFaceLeft');
    cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeL);
    let cubeT = document.createElement('img');
    cubeT.setAttribute('src', url);
    cubeT.setAttribute('alt', '');
    cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
    cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeT);
    let cubeU = document.createElement('img');
    cubeU.setAttribute('src', url);
    cubeU.setAttribute('alt', '');
    cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
    cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeU);
    scene.appendChild(cube);
    let h = Math.floor((Math.random() * sW) - (sS / 2));
    let v = Math.floor((Math.random() * sH) - (sS / 2));
    let r = sW;
    if (sH < r)
     r = sH;
    r = r * (Math.random() + 1);
    let th = (Math.random() * (Math.PI * 2));
    let hD = Math.floor(h + r * Math.cos(th));
    let vD = Math.floor(v + r * Math.sin(th));
    while ((h < 0 && hD < 0) || (v < 0 && vD < 0) || (h > (sW - sS) && hD > (sW - sS)) || (v > (sH - sS) && vD > (sH - sS)))
    {
     th = (Math.random() * (Math.PI * 2));
     hD = Math.floor(h + r * Math.cos(th));
     vD = Math.floor(v + r * Math.sin(th));
    }
    let s = 'width: ' + sS + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' perspective: ' + (sS * 3)  + 'px;';
    s += ' transition: all ' + cfg.emote.time + 's linear;';
    s += ' transform: translate(' + h + 'px, ' + v + 'px);';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (cfg.emote.in.fade)
    {
     aNames.push('fadeIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('ease-in');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (aNames.length > 0)
    {
     s += ' animation-name: ' + aNames.join() + ';';
     s += ' animation-delay: ' + aDelays.join() + ';';
     s += ' animation-duration: ' + aDurs.join() + ';';
     s += ' animation-timing-function: ' + aTimings.join() + ';';
     s += ' animation-fill-mode: ' + aFills.join() + ';';
     s += ' animation-iteration-count: ' + aIters.join() + ';';
    }
    scene.setAttribute('style', s);
    eActive++;
    document.body.appendChild(scene);
    gcEmote(scene);
    window.setTimeout(
     function()
     {
      let rX = Math.floor(180 - (Math.random() * 360)) * (cfg.emote.cube.rotations * 2);
      let rY = Math.floor(180 - (Math.random() * 360)) * (cfg.emote.cube.rotations * 2);
      cube.style.transform = 'translateZ(' + (sS * -0.5) + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
      scene.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
     },
     tStart
    );
   }

   function showKappa_TheCube(url, sW, sH, sS, bC, iR)
   {
    let scene = document.createElement('div');
    scene.setAttribute('class', 'scene');
    scene.setAttribute('width', sS);
    scene.setAttribute('height', sS);
    let cube = document.createElement('div');
    cube.setAttribute('class', 'cube');
    cube.setAttribute('style', 'transform: translateZ(' + (sS * -0.5) + 'px);  transition: transform linear ' + cfg.emote.time + 's;');
    let f = 'height: ' + sS + 'px;';
    f += ' width: ' + sS + 'px;';
    let cubeF = document.createElement('img');
    cubeF.setAttribute('src', url);
    cubeF.setAttribute('alt', '');
    cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
    cubeF.setAttribute('style', f + ' transform: translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeF);
    let cubeB = document.createElement('img');
    cubeB.setAttribute('src', url);
    cubeB.setAttribute('alt', '');
    cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
    cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeB);
    let cubeR = document.createElement('img');
    cubeR.setAttribute('src', url);
    cubeR.setAttribute('alt', '');
    cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
    cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeR);
    let cubeL = document.createElement('img');
    cubeL.setAttribute('src', url);
    cubeL.setAttribute('alt', '');
    cubeL.setAttribute('class', 'cubeFace cubeFaceLeft');
    cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeL);
    let cubeT = document.createElement('img');
    cubeT.setAttribute('src', url);
    cubeT.setAttribute('alt', '');
    cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
    cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeT);
    let cubeU = document.createElement('img');
    cubeU.setAttribute('src', url);
    cubeU.setAttribute('alt', '');
    cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
    cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + (sS * 0.5) + 'px);');
    cube.appendChild(cubeU);
    scene.appendChild(cube);
    let h = Math.floor(Math.random() * (sW - sS));
    let v = Math.floor(Math.random() * (sH - sS));
    if (bC)
    {
     h = Math.floor((sW / 2) - (sS / 2));
     v = Math.floor((sH / 2) - (sS / 2));
    }
    let s = 'width: ' + sS + 'px;';
    s += ' height: ' + sS + 'px;';
    s += ' perspective: ' + (sS * 3)  + 'px;';
    s += ' transition: all ' + cfg.emote.time + 's linear;';
    s += ' transform: translate(' + h + 'px, ' + v + 'px);';
    let aNames = [];
    let aDelays = [];
    let aDurs = [];
    let aTimings = [];
    let aFills = [];
    let aIters = [];
    if (cfg.emote.in.fade)
    {
     aNames.push('fadeIn');
     aDelays.push('0s');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('ease-in');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (cfg.emote.out.fade)
    {
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    else
    {
     aNames.push('noFadeOut');
     aDelays.push(((cfg.emote.time * 1000) - 50) + 'ms');
     aDurs.push('50ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
    }
    if (aNames.length > 0)
    {
     s += ' animation-name: ' + aNames.join() + ';';
     s += ' animation-delay: ' + aDelays.join() + ';';
     s += ' animation-duration: ' + aDurs.join() + ';';
     s += ' animation-timing-function: ' + aTimings.join() + ';';
     s += ' animation-fill-mode: ' + aFills.join() + ';';
     s += ' animation-iteration-count: ' + aIters.join() + ';';
    }
    scene.setAttribute('style', s);
    eActive++;
    document.body.appendChild(scene);
    gcEmote(scene, false);
    window.setTimeout(
     function()
     {
      let rX = Math.floor(180 - (Math.random() * 360)) * (iR * 2);
      let rY = Math.floor(180 - (Math.random() * 360)) * (iR * 2);
      cube.style.transform = 'translateZ(' + (sS * -0.5) + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
     },
     tStart
    );
   }

   function showKappa_Fireworks(kList, sW, sH, sS, iKC)
   {
    let sendUp = 2;
    let oX = (sW * 0.5) - (sS * 0.5);
    let oY = sH;
    let cX = oX;
    switch(Math.floor(Math.random() * 3))
    {
     case 0:
      cX = Math.floor(cX * 0.5);
      break;
     case 2:
      cX = Math.floor(cX * 1.5);
      break;
    }
    let cY = oY * 0.33;
    function sparkler(url, r, d)
    {
     let simg = document.createElement('img');
     simg.setAttribute('class', 'emote');
     simg.setAttribute('src', url);
     simg.setAttribute('alt', '');
     let th = (Math.random() * (Math.PI * 2));
     let hD = Math.floor(cX + r * Math.cos(th));
     let vD = Math.floor(cY + r * Math.sin(th));
     let s = 'height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: transform ' + cfg.emote.time + 's ease-out;';
     s += ' transform: translate(' + cX + 'px, ' + cY + 'px);';
     let aNames = [];
     let aDelays = [];
     let aDurs = [];
     let aTimings = [];
     let aFills = [];
     let aIters = [];
     aNames.push('fadeIn');
     aDelays.push((d * 1000) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
     aNames.push('fadeOut');
     aDelays.push((d * 1000) + Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
     s += ' animation-name: ' + aNames.join() + ';';
     s += ' animation-delay: ' + aDelays.join() + ';';
     s += ' animation-duration: ' + aDurs.join() + ';';
     s += ' animation-timing-function: ' + aTimings.join() + ';';
     s += ' animation-fill-mode: ' + aFills.join() + ';';
     s += ' animation-iteration-count: ' + aIters.join() + ';';
     simg.setAttribute('style', s);
     document.body.appendChild(simg);
     gcEmote(simg, true, true, (d + cfg.emote.time) * 1000);
     window.setTimeout(
      function()
      {
       simg.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
      },
      (d * 1000) + tStart
     );
    }
    let oURL = kList[Math.floor(Math.random() * kList.length)].url;
    let img = document.createElement('img');
    img.setAttribute('class', 'emote');
    img.setAttribute('src', oURL);
    img.setAttribute('alt', '');
    let s = 'height: ' + sS + 'px;';
    s += ' width: ' + sS + 'px;';
    s += ' transition: transform ' + sendUp + 's linear;';
    s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
    img.setAttribute('style', s);
    document.body.appendChild(img);
    window.setTimeout(
     async function()
     {
      document.body.removeChild(img);
      eActive--;
      let r = sW;
      if (sH < r)
       r = sH;
      r *= 0.66;
      let inner = Math.floor(iKC / 8);
      let outer = inner;
      let core = iKC - (inner + outer);
      let t = 0;
      for (let i = 0; i < inner; i++)
      {
       sparkler(kList[Math.floor(Math.random() * kList.length)].url, r * 0.5, t);
       if (i % Math.floor(outer / 3) === 0)
        await sleep(1);
      }
      t += 0.5;
      for (let i = 0; i < core; i++)
      {
       sparkler(kList[Math.floor(Math.random() * kList.length)].url, r, t);
       t += 0.005;
       if (i % Math.floor(outer / 9) === 0)
        await sleep(1);
      }
      t += 0.25;
      for (let i = 0; i < outer; i++)
      {
       sparkler(kList[Math.floor(Math.random() * kList.length)].url, r * 1.5, t);
       if (i % Math.floor(outer / 3) === 0)
        await sleep(1);
      }
     },
     sendUp * 1000
    );
    window.setTimeout(
     function()
     {
      img.style.transform = 'translate(' + cX + 'px, ' + cY + 'px)';
     },
     tStart
    );
   }

   function showKappa_Spiral(kList, sW, sH, sS, iKC)
   {
    let oX = Math.floor(Math.random() * (sW - sS));
    let oY = Math.floor(Math.random() * (sH - sS));
    function sparkler(url, r, th)
    {
     let simg = document.createElement('img');
     simg.setAttribute('class', 'emote');
     simg.setAttribute('src', url);
     simg.setAttribute('alt', '');
     let hD = Math.floor(oX + r * Math.cos(th));
     let vD = Math.floor(oY + r * Math.sin(th));
     let s = 'height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: transform ' + cfg.emote.time + 's ease-out;';
     s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
     let aNames = [];
     let aDelays = [];
     let aDurs = [];
     let aTimings = [];
     let aFills = [];
     let aIters = [];
     aNames.push('fadeIn');
     aDelays.push('0ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.in / 100)) + 'ms');
     aTimings.push('linear');
     aFills.push('forwards');
     aIters.push('1');
     aNames.push('fadeOut');
     aDelays.push(Math.floor((cfg.emote.time * 1000) - ((cfg.emote.time * 1000) * (tAnim.fade.out / 100))) + 'ms');
     aDurs.push(Math.floor((cfg.emote.time * 1000) * (tAnim.fade.out / 100)) + 'ms');
     aTimings.push('ease-out');
     aFills.push('forwards');
     aIters.push('1');
     s += ' animation-name: ' + aNames.join() + ';';
     s += ' animation-delay: ' + aDelays.join() + ';';
     s += ' animation-duration: ' + aDurs.join() + ';';
     s += ' animation-timing-function: ' + aTimings.join() + ';';
     s += ' animation-fill-mode: ' + aFills.join() + ';';
     s += ' animation-iteration-count: ' + aIters.join() + ';';
     simg.setAttribute('style', s);
     document.body.appendChild(simg);
     gcEmote(simg, true, true);
     window.setTimeout(
      function()
      {
       simg.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
      },
      tStart
     );
    }
    window.setTimeout(
     async function()
     {
      let r = sW;
      if (sH < r)
       r = sH;
      let l = iKC / 25 + 2;
      l = l + (Math.random() * 4 - 2);
      if (l < 0.1)
       l = 0.1;
      let c = (Math.PI * l) / iKC;
      let th = (Math.random() * (Math.PI * 2));
      let o = (Math.floor(Math.random() * 2) === 0);
      for (let i = 0; i < iKC; i++)
      {
       if (o)
       {
        th-= c;
        if (th <= 0)
         th+= Math.PI * 2;
       }
       else
       {
        th+= c;
        if (th >= Math.PI * 2)
         th+= Math.PI * 2;
       }
       sparkler(kList[Math.floor(Math.random() * kList.length)].url, r, th);
       await sleep(10);
      }
     },
     tStart
    );
   }

   function showKappa_Pyramid(kList, sW, sH)
   {
    let sS = sW / 19;
    let drawn = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    let ct = 0;
    for (let i = 0; i < pyramidDist.length; i++)
     ct += pyramidDist[i];
    let eT = cfg.emote.time * 1000;
    let tPerB = Math.floor(eT / ct);
    if (tPerB < 24)
     tPerB = 24;
    eT = tPerB * ct;
    function block(url, x, t)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', url);
     img.setAttribute('alt', '');
     let h = sS * x;
     let v = -1 * sS;
     let vD = sH - (sS * (drawn[x] + 1));
     let s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: all ' + tPerB + 'ms ease-in;';
     s += ' transform: translate(' + h + 'px, ' + v + 'px);';
     img.setAttribute('style', s);
     document.body.appendChild(img);
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
       img.style.transitionTime = '500ms';
       gcEmote(img, false, true, 500);
      },
      Math.floor(eT + (cfg.emote.time * 1000) + (t / 10))
     );
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
      },
      t
     );
    }
    let t = 0;
    for (let i = 0; i < ct; i++)
    {
     let x;
     do
      x = Math.floor(Math.random() * pyramidDist.length);
     while(drawn[x] >= pyramidDist[x]);
     block(kList[Math.floor(Math.random() * kList.length)].url, x, t);
     drawn[x]++;
     t += tPerB;
    }
   }

   function showKappa_SmallPyramid(kList, sW, sH)
   {
    let sS = sW / 19;
    if (sS > Math.floor(sW * cfg.emote.size.ratio.small))
     sS = Math.floor(sW * cfg.emote.size.ratio.small);
    if (sS > Math.floor(sH * cfg.emote.size.ratio.small))
     sS = Math.floor(sH * cfg.emote.size.ratio.small);
    let drawn = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    let ct = 0;
    for (let i = 0; i < pyramidDist.length; i++)
     ct += pyramidDist[i];
    let eT = cfg.emote.time * 1000;
    let tPerB = Math.floor(eT / ct);
    if (tPerB < 24)
     tPerB = 24;
    eT = tPerB * ct;
    function block(url, oX, x, t)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', url);
     img.setAttribute('alt', '');
     let h = oX + sS * x;
     let v = -1 * sS;
     let vD = sH - (sS * (drawn[x] + 1));
     let s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: all ' + tPerB + 'ms ease-in;';
     s += ' transform: translate(' + h + 'px, ' + v + 'px);';
     img.setAttribute('style', s);
     document.body.appendChild(img);
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
       img.style.transitionTime = '500ms';
       gcEmote(img, false, true, 500);
      },
      Math.floor(eT + (cfg.emote.time * 1000) + (t / 10))
     );
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
      },
      t
     );
    }
    let oX = Math.floor(Math.random() * (sW - (sS * pyramidDist.length)));
    let t = 0;
    for (let i = 0; i < ct; i++)
    {
     let x;
     do
      x = Math.floor(Math.random() * pyramidDist.length);
     while(drawn[x] >= pyramidDist[x]);
     block(kList[Math.floor(Math.random() * kList.length)].url, oX, x, t);
     drawn[x]++;
     t += tPerB;
    }
   }

   async function showKappa_Stampede(kList, sW, sH, sS, iKC)
   {
    let speed = 2000;
    let bandHeight = sS * 3;
    let d = (Math.floor(Math.random() * 2) === 1);
    let bandTop = Math.floor(Math.random() * (sH - (sS * 2.5)));
    function run(url)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', url);
     img.setAttribute('alt', '');
     let h = -2 * sS;
     let v = Math.floor((Math.random() * bandHeight) + bandTop);
     let s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: all ' + (speed / 1000) + 's linear;';
     if (d)
      s += ' transform: translate(' + sW + 'px, ' + v + 'px);';
     else
      s += ' transform: translate(' + h + 'px, ' + v + 'px);';
     img.setAttribute('style', s);
     document.body.appendChild(img);
     window.setTimeout(
      function()
      {
       document.body.removeChild(img);
       img.setAttribute('deleted', true);
      },
      speed
     );
     window.setTimeout(
      function()
      {
       if (d)
        img.style.transform = 'translate(' + h + 'px, ' + v + 'px)';
       else
        img.style.transform = 'translate(' + (sW + sS) + 'px, ' + v + 'px)';
      },
      tStart
     );
     return img;
    }
    async function stampede(ct, pause)
    {
     let imgs = [];
     for (let i = 0; i < ct; i++)
     {
      imgs.push(run(kList[Math.floor(Math.random() * kList.length)].url));
      await sleep(Math.floor(Math.random() * 90) + 10);
     }
     if (pause === false)
      return;
     if (pause !== true)
     {
      await sleep(pause);
      return;
     }
     do
     {
      await sleep(100);
      for (let i = 0; i < imgs.length; i++)
      {
       if (imgs[i] === null || imgs[i].hasAttribute('deleted'))
        imgs.splice(i, 1);
      }
     } while (imgs.length > 0);
    }
    let b1 = Math.floor(Math.random() * 4) + 1;
    let b2 = Math.floor(Math.random() * (8 - b1)) + b1;
    let b4 = Math.floor(Math.random() * 4);
    await stampede(b1, speed * 0.8);
    await stampede(b2, speed * 0.4);
    await stampede(iKC, (b4 > 0));
    if (b4 > 0)
     await stampede(b4, false);
   }

   async function showKappa_Conga(kList, sW, sH, sS)
   {
    let v = 0;
    let unique = false;
    let bS = Math.ceil(sS * (5/3));
    let seg = Math.floor(bS / 2);
    let sht = Math.floor(sH / seg);
    let longWait = cfg.emote.time * 2;
    while (conga.length >= sht)
    {
     await sleep(250);
    }
    while (!unique)
    {
     v = Math.floor(Math.random() * sht) * seg;
     let found = false;
     for (let i = 0; i < conga.length; i++)
     {
      if (conga[i].row === v)
      {
       found = true;
       break;
      }
     }
     if (!found)
      unique = true;
    }
    conga.push({row: v, done: false});
    let urls = [];
    let ct = Math.floor(sW / bS);
    for (let i = 0; i < ct; i++)
    {
     urls.push(kList[Math.floor(Math.random() * kList.length)].url);
    }
    let d = ((v / seg) % 2 === 1);
    let xtra = Math.floor((sW - (ct * bS)) / 2);
    function dance(url, col)
    {
     let box = document.createElement('div');
     box.setAttribute('class', 'scene');
     let img = document.createElement('img');
     img.setAttribute('class', 'dancer');
     img.setAttribute('src', url);
     img.setAttribute('alt', '');
     let s = 'width: ' + sS + 'px;';
     s += ' height: ' + sS + 'px;';
     img.setAttribute('style', s);
     let sE = bS * col + xtra;
     let sB = sE - sW;
     if (d)
     {
      sE = bS * ((ct - 1) - col) + xtra;
      sB = sE + sW;
      img.setAttribute('title', 'd is true');
     }
     s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' width: ' + bS + 'px;';
     s += ' height: ' + bS + 'px;';
     s += ' z-index: ' + v + ';';
     s += ' transition: all ' + longWait + 's linear;';
     s += ' transform: translate(' + sB + 'px, ' + v + 'px);';
     box.setAttribute('style', s);
     eActive++;
     box.appendChild(img);
     document.body.appendChild(box);
     window.setTimeout(
      function()
      {
       box.style.transform = 'translate(' + sE + 'px, ' + v + 'px)';
      },
      tStart
     );
     return box;
    }
    function endDance(box, col)
    {
     let sB = bS * col + xtra;
     let sE = sB + sW;
     if (d)
     {
      sB = bS * ((ct - 1) - col) + xtra;
      sE = sB - sW;
     }
     let s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' width: ' + bS + 'px;';
     s += ' height: ' + bS + 'px;';
     s += ' z-index: ' + v + ';';
     s += ' transition: all ' + longWait + 's ease-in;';
     s += ' transform: translate(' + sB + 'px, ' + v + 'px);';
     box.setAttribute('style', s);
     gcEmote(box, true, true, longWait * 1000 * 1.25);
     window.setTimeout(
      function()
      {
       box.style.transform = 'translate(' + sE + 'px, ' + v + 'px)';
      },
      tStart
     );
    }
    let imgs = [];
    for (let i = 0; i < ct; i++)
    {
     imgs.push(dance(urls[i], i));
    }
    await sleep(longWait * 1000);
    let full = false;
    if (conga.length == sht)
     full = true;
    await sleep(cfg.display.kappa.conga.time * 1000);
    if (cfg.display.kappa.conga.contagious)
    {
     let ex = false;
     if (conga.length > 1)
      ex = true;
     for (let i = 0; i < conga.length; i++)
     {
      if (conga[i].row !== v)
       continue;
      conga[i].done = true;
      break;
     }
     let done = false;
     while (!done)
     {
      if (!ex && conga.length > 1)
       ex = true;
      let notDone = false;
      for (let i = 0; i < conga.length; i++)
      {
       if (conga[i].done === false)
       {
        notDone = true;
        break;
       }
      }
      if (notDone === false)
       done = true;
      await sleep(100);
     }
    }
    for (let i = 0; i < imgs.length; i++)
    {
     endDance(imgs[i], i);
    }
    await sleep(longWait * 1000);
    for (let i = 0; i < conga.length; i++)
    {
     if (conga[i].row !== v)
      continue;
     conga.splice(i, 1);
     break;
    }
   }

   function showKappa_Text(kList, sW, sH, sMsg, iTime)
   {
    function buildMsgArr(s)
    {
     let o = [];
     let spc = [];
     for (let y = 0; y < alnumDist['A'][0].length; y++)
     {
      spc.push(0);
     }
     for (let i = 0; i < s.length; i++)
     {
      if (i > 0)
       o.push(spc);
      if (s[i] === ' ')
      {
       o.push(spc);
       o.push(spc);
       continue;
      }
      let v = s[i];
      if (!alnumDist.hasOwnProperty(v))
       continue;
      let c = alnumDist[v];
      for (let x = 0; x < c.length; x++)
      {
       o.push(c[x]);
      }
     }
     return o;
    }
    let msgDist = buildMsgArr(sMsg);
    let ct = 0;
    let ctT = 0;
    let drawn = [];
    for (let x = 0; x < msgDist.length; x++)
    {
     for (let y = 0; y < msgDist[x].length; y++)
     {
      if (msgDist[x][y] !== 0)
       ctT += 1;
     }
     ct += msgDist[x].length;
     drawn.push(0);
    }
    let sS = Math.floor(sW / (msgDist.length + 2));
    if (sS > Math.floor(sW * cfg.emote.size.ratio.small))
     sS = Math.floor(sW * cfg.emote.size.ratio.small);
    if (sS > Math.floor(sH * cfg.emote.size.ratio.small))
     sS = Math.floor(sH * cfg.emote.size.ratio.small);
    let eT = cfg.emote.time * 1000;
    let tPerB = Math.floor(eT / ctT);
    if (tPerB < 24)
     tPerB = 24;
    eT = tPerB * ctT;
    let vH = Math.floor(Math.random() * (sH - (sS * msgDist[0].length))) + (sS * msgDist[0].length);
    function block(url, oX, x, t)
    {
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     img.setAttribute('src', url);
     img.setAttribute('alt', '');
     let h = oX + sS * x;
     let v = -1 * sS;
     let vD = vH - (sS * (drawn[x] + 1));
     let s = 'top: 0px;';
     s += ' left: 0px;';
     s += ' height: ' + sS + 'px;';
     s += ' width: ' + sS + 'px;';
     s += ' transition: all ' + tPerB + 'ms ease-in;';
     s += ' transform: translate(' + h + 'px, ' + v + 'px);';
     img.setAttribute('style', s);
     document.body.appendChild(img);
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
       img.style.transitionTime = '500ms';
       gcEmote(img, false, true, 500);
      },
      Math.floor(eT + (iTime * 1000) + (t / 10))
     );
     window.setTimeout(
      function()
      {
       img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
      },
      t
     );
    }
    let oX = Math.floor(Math.random() * (sW - (sS * msgDist.length)));
    let t = 0;
    for (let i = 0; i < ct; i++)
    {
     let x;
     do
      x = Math.floor(Math.random() * msgDist.length);
     while(drawn[x] >= msgDist[x].length);
     if (msgDist[x][drawn[x]] !== 0)
     {
      block(kList[Math.floor(Math.random() * kList.length)].url, oX, x, t);
      t += tPerB;
     }
     drawn[x]++;
    }
   }

   function showEmote(url)
   {
    let sW = window.innerWidth;
    let sH = window.innerHeight;
    let sS = cfg.emote.size.max;
    if (sW < sH)
     sS = Math.floor(sW * cfg.emote.size.ratio.normal);
    else
     sS = Math.floor(sH * cfg.emote.size.ratio.normal);
    if (sS > cfg.emote.size.max)
     sS = cfg.emote.size.max;
    if (sS < cfg.emote.size.min)
     sS = cfg.emote.size.min;
    document.documentElement.style.setProperty('--height', sH + 'px');
    document.documentElement.style.setProperty('--width', sW + 'px');
    document.documentElement.style.setProperty('--emote-height', sS + 'px');
    document.documentElement.style.setProperty('--emote-height-s', Math.ceil(sS * 0.5) + 'px');
    document.documentElement.style.setProperty('--emote-height-l', (sS * 2) + 'px');
    let style = cfg.display.styles[(Math.floor(Math.random() * cfg.display.styles.length))];
    if (style === undefined)
     return;
    window['showEmote_' + style](url, sW, sH, sS);
   }

   function showEmotes()
   {
    if (tEmote !== false)
    {
     window.clearTimeout(tEmote);
     tEmote = false;
    }
    if (cfg.emote.max > 0 && eActive >= cfg.emote.max)
    {
     tEmote = window.setTimeout(showEmotes, 500);
     return;
    }
    let e = null;
    while ((e =  toShow.shift()) !== undefined)
    {
     showEmote(e.url);
     if (cfg.emote.max > 0 && eActive > cfg.emote.max)
     {
      if (cfg.emote.queue > 0 && toShow.length > cfg.emote.queue)
       toShow.splice(0, toShow.length - cfg.emote.queue);
      tEmote = window.setTimeout(showEmotes, 500);
      return;
     }
    }
   }

   function showKappas()
   {
    if (tKappa !== false)
    {
     window.clearTimeout(tKappa);
     tKappa = false;
    }
    if (cfg.emote.max > 0 && eActive + cfg.display.kappa.count > cfg.emote.max)
    {
     tKappa = window.setTimeout(showKappas, 500);
     return;
    }
    let e = null;
    while ((e =  toKappa.shift()) !== undefined)
    {
     let a = [];
     a[e.style] = e.prefs;
     showKappa(e.list, a, e.params);
     if (cfg.emote.max > 0 && eActive + cfg.display.kappa.count > cfg.emote.max)
     {
      if (cfg.emote.queue > 0 && toKappa.length > cfg.emote.queue)
       toKappa.splice(0, toKappa.length - cfg.emote.queue);
      tKappa = window.setTimeout(showKappas, 500);
      return;
     }
    }
   }

   async function showKappa(kList, kStyles = false, kParams = false)
   {
    if (typeof kStyles !== 'object')
    {
     if (cfg.display.kappa.styles.length < 1)
      return;
     kStyles = cfg.display.kappa.styles;
    }
    if (!Array.isArray(kList) || kList.length < 1)
     kList = cList;
    if (!Array.isArray(kList) || kList.length < 1)
     kList = bareList;
    let sW = window.innerWidth;
    let sH = window.innerHeight;
    let sS = cfg.emote.size.max;
    let sSm = Math.floor(sS / 2);
    if (sW < sH)
    {
     sS = Math.floor(sW * cfg.emote.size.ratio.normal);
     sSm = Math.floor(sW * cfg.emote.size.ratio.small);
    }
    else
    {
     sS = Math.floor(sH * cfg.emote.size.ratio.normal);
     sSm = Math.floor(sH * cfg.emote.size.ratio.small);
    }
    if (sS > cfg.emote.size.max)
     sS = cfg.emote.size.max;
    if (sS < cfg.emote.size.min)
     sS = cfg.emote.size.min;
    if (sSm > cfg.emote.size.max)
     sSm = cfg.emote.size.max;
    if (sSm < cfg.emote.size.min)
     sSm = cfg.emote.size.min;
    document.documentElement.style.setProperty('--height', sH + 'px');
    document.documentElement.style.setProperty('--width', sW + 'px');
    document.documentElement.style.setProperty('--emote-height', sS + 'px');
    document.documentElement.style.setProperty('--emote-height-s', Math.ceil(sS * 0.5) + 'px');
    document.documentElement.style.setProperty('--emote-height-l', (sS * 2) + 'px');
    let style, prefs;
    if (cfg.display.kappa.conga.contagious && conga.length > 0)
    {
     style = 'Conga';
     prefs = {};
    }
    else
    {
     let keys = Object.keys(kStyles);
     style = keys[(Math.floor(Math.random() * keys.length))];
     prefs = kStyles[style];
    }
    if (style === undefined)
     return;
    let iKC = cfg.display.kappa.count;
    if (cfg.display.kappa.styles.hasOwnProperty(style) && cfg.display.kappa.styles[style].hasOwnProperty('count'))
     iKC = cfg.display.kappa.styles[style].count;
    if (prefs.hasOwnProperty('count'))
    {
     let tKC = prefs.count;
     if (tKC === -1 && kParams !== false)
     {
      let pK = Object.keys(kParams);
      for (let i = 0; i < pK.length; i++)
      {
       if (pK[i] === '%AMOUNT%')
       {
        tKC = kParams[pK[i]];
        break;
       }
      }
     }
     if (tKC !== -1)
      iKC = tKC;
    }
    let waitFor = iKC;
    switch (style)
    {
     case 'Pyramid':
     case 'SmallPyramid':
      waitFor = 0;
      for (let i = 0; i < pyramidDist.length; i++)
       waitFor += pyramidDist[i];
      break;
     case 'Fireworks':
      waitFor = 0;
      let inner = Math.floor(iKC / 8);
      let outer = inner;
      let core = iKC - (inner + outer);
      waitFor = 1 + inner + outer + core;
      break;
    }
    if ((cfg.emote.max > 0) && ((eActive + iKC) > cfg.emote.max))
    {
     toKappa.push({list: kList, style: style, prefs: prefs, params: kParams});
     if (tKappa !== false)
     {
      window.clearTimeout(tKappa);
      tKappa = false;
     }
     tKappa = window.setTimeout(showKappas, 500);
     return;
    }
    eActive += waitFor;
    switch(style)
    {
     case 'Stampede':
      let iStampedeCount = cfg.display.kappa.styles['Text'].message;
      if (prefs.hasOwnProperty('message'))
       sTM = prefs.message[Math.floor(Math.random() * prefs.message.length)];
      await showKappa_Stampede(kList, sW, sH, sS, iKC);
      eActive -= iKC;
      break;
     case 'Fireworks':
      showKappa_Fireworks(kList, sW, sH, sSm, iKC);
      break;
     case 'Spiral':
      showKappa_Spiral(kList, sW, sH, sSm, iKC);
      break;
     case 'Pyramid':
      showKappa_Pyramid(kList, sW, sH);
      break;
     case 'SmallPyramid':
      showKappa_SmallPyramid(kList, sW, sH);
      break;
     case 'Conga':
      eActive -= waitFor;
      showKappa_Conga(kList, sW, sH, sS);
      break;
     case 'Text':
      eActive -= waitFor;
      let sTM = 'HYPE!';
      if (cfg.display.kappa.styles.hasOwnProperty('Text') && cfg.display.kappa.styles['Text'].hasOwnProperty('message'))
       sTM = cfg.display.kappa.styles['Text'].message;
      if (prefs.hasOwnProperty('message'))
       sTM = prefs.message[Math.floor(Math.random() * prefs.message.length)];
      let sTT = cfg.emote.time;
      if (cfg.display.kappa.styles.hasOwnProperty('Text') && cfg.display.kappa.styles['Text'].hasOwnProperty('time'))
       sTT = cfg.display.kappa.styles['Text'].time;
      if (prefs.hasOwnProperty('time'))
       sTT = prefs.time;
      if (kParams !== false)
      {
       let pK = Object.keys(kParams);
       for (let i = 0; i < pK.length; i++)
       {
        sTM = sTM.replace(pK[i], kParams[pK[i]]);
       }
      }
      showKappa_Text(kList, sW, sH, sTM, sTT);
      break;
     case 'TheCube':
      eActive -= waitFor;
      let cS = sW;
      if (sW > sH)
       cS = sH;
      let r = Math.floor(Math.random() * kList.length);
      let sCS = cfg.display.kappa.styles['TheCube'].size;
      if (prefs.hasOwnProperty('size'))
       sCS = prefs.size;
      let sCC = cfg.display.kappa.styles['TheCube'].center;
      if (prefs.hasOwnProperty('center'))
       sCC = prefs.center;
      let sCR = cfg.display.kappa.styles['TheCube'].rotations;
      if (prefs.hasOwnProperty('rotations'))
       sCR = prefs.rotations;
      showKappa_TheCube(kList[r].url, sW, sH, Math.floor(cS * sCS), sCC, sCR);
      break;
     case 'Burst':
      let oH = Math.floor((Math.random() * ((sW - sS) * 0.33)) + (sW - sS) * 0.33);
      let oV = Math.floor((Math.random() * ((sH - sS) * 0.33)) + (sH - sS) * 0.33);
      for (let i = 0; i < iKC; i++)
      {
       let r = Math.floor(Math.random() * kList.length);
       eActive--;
       showEmote_StraightLine(kList[r].url, sW, sH, sS, oH, oV, false);
       await sleep(50);
      }
      break;
     case 'Fountain':
      let fX = Math.floor((Math.random() * ((sW - sS) * 0.33)) + (sW - sS) * 0.33);
      let fY = Math.floor(Math.random() * 25) + 15;
      for (let i = 0; i < iKC; i++)
      {
       let r = Math.floor(Math.random() * kList.length);
       eActive--;
       showEmote_Fountain(kList[r].url, sW, sH, sS, fX, fY, false);
       await sleep(50);
      }
      break;
     case 'Confetti':
      for (let i = 0; i < iKC; i++)
      {
       let r = Math.floor(Math.random() * kList.length);
       eActive--;
       showEmote_Confetti(kList[r].url, sW, sH, sSm, false);
       await sleep(25);
      }
      break;
     default:
      if (typeof window['showEmote_' + style] === 'undefined')
       return false;
      for (let i = 0; i < iKC; i++)
      {
       let r = Math.floor(Math.random() * kList.length);
       eActive--;
       if (style === 'StraightLine')
        showEmote_StraightLine(kList[r].url, sW, sH, sS, false, false, false);
       else
        window['showEmote_' + style](kList[r].url, sW, sH, sS, false);
       await sleep(100);
      }
    }
   }

   async function parseEmoji(cmd, set, dup = null)
   {
    if (cmd.params.length < 2)
     return [];
    let msg = cmd.params[1];
    // https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f
    msg = msg.replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d'); //zwj alternate
    let emSeg = /((?:[\p{EPres}\p{ExtPict}]\ufe0f?\u200d?)+)+/gu;
    let emList = [...msg.matchAll(emSeg)];
    if (emList.length === 0)
     return [];
    if (dup === null)
     dup = cfg.display.duplicates;
    if (set === true)
     set = 'twemoji';
    let ret = [];
    let uri = 'https://cdn.frankerfacez.com/static/emoji/images/' + set + '/';
    let addList = {};
    function showEmoji(c)
    {
     if (c.slice(-5) === '-fe0f' && !c.match(/-200d-264[0|2]-/) && !c.match(/-200d-26a7/) && !c.match(/-200d-2620/))
      c = c.slice(0, -5);
     if (!addList.hasOwnProperty(c))
      addList[c] = 0;
     else
     {
      if (dup === false)
       return false;
      if (dup !== true && addList[c] >= dup)
       return false;
     }
     addList[c]++;
     ret.push({svc: 'e', url: uri + c + '.png', str: c});
     return true;
    }
    for (let i = 0; i < emList.length; i++)
    {
     let cpList = [];
     for (let c of emList[i][0])
     {
      let p = c.codePointAt(0).toString(16);
      if (cpList.length > 0)
      {
       if (p === 'fe0f') //emoji variation
        cpList[cpList.length - 1] += '-' + p;
       else if (p === '200d') //zwj
        cpList[cpList.length - 1] += '-' + p;
       else if (p.match(/1f3f[b-f]/)) //skin tone
        cpList[cpList.length - 1] += '-' + p;
       else if (p.match(/1f9b[0-3]/)) //hair
       {
        if (cpList[cpList.length - 1].slice(-5) === '-200d')
         cpList[cpList.length - 1] += '-' + p;
        else
         cpList[cpList.length - 1] += '-200d-' + p;
       }
       else if (p.match(/264[0|2]/) || p.match(/26a7/)) //gender
       {
        if (cpList[cpList.length - 1].slice(-5) === '-200d')
         cpList[cpList.length - 1] += '-' + p;
        else
         cpList[cpList.length - 1] += '-200d-' + p;
       }
       else if (p.match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[cpList.length - 1].match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[cpList.length - 1].length < 11) //country code (2 chars max)
        cpList[cpList.length - 1] += '-' + p;
       else if (p === '1f308' && cpList[cpList.length - 1] === '1f3f3-fe0f') //rainbow flag
        cpList[cpList.length - 1] += '-200d-' + p;
       else if (p === '2620' && cpList[cpList.length - 1] === '1f3f4') //pirate flag
        cpList[cpList.length - 1] += '-200d-' + p;
       else if (cpList[cpList.length - 1].slice(-5) === '-200d') //post-zwj
        cpList[cpList.length - 1] += '-' + p;
       else
        cpList.push(p);
      }
      else
       cpList.push(p);
     }
     let found = false;
     if (cpList.length === 1)
     {
      let s = cpList[0];
      let tU;
      if (s.slice(-5) === '-fe0f')
      {
       if (s.match(/-200d-264[0|2]-/) || s.match(/-200d-26a7/) || s.match(/-200d-2620/))
        tU = uri + s + '.png';
       else
        tU = uri + s.slice(0, -5) + '.png';
      }
      else
       tU = uri + s + '.png';
      found = await checkURL(tU);
      if (found)
      {
       showEmoji(s);
       continue;
      }
      while (s.includes('-'))
      {
       s = s.slice(0, s.lastIndexOf('-'));
       if (s.slice(-5) === '-fe0f')
        tU = uri + s.slice(0, -5) + '.png';
       else
        tU = uri + s + '.png';
       found = await checkURL(tU);
       if (found)
       {
        showEmoji(s);
        break;
       }
      }
      continue;
     }
     for (let i = 0; i < cpList.length; i++)
      showEmoji(cpList[i]);
    }
    return ret;
   }

   function parseT(cmd, dup = null)
   {
    if (!cmd.hasOwnProperty('tags'))
     return [];
    if (!cmd.tags.hasOwnProperty('emotes'))
     return [];
    if (cmd.tags.emotes === '')
     return [];
    let f = 'default';
    let t = 'dark';
    let r = '3.0';
    if (cmd.params.length < 2)
     return [];
    let m = cmd.params[1];
    let e = cmd.tags.emotes.split('/');
    if (dup === null)
     dup = cfg.display.duplicates;
    let ret = [];
    for (let i = 0; i < e.length; i++)
    {
     let eID = e[i].slice(0, e[i].indexOf(':'));
     let u = 'https://static-cdn.jtvnw.net/emoticons/v2/' + eID + '/' + f + '/' + t + '/' + r;
     let eVals = e[i].slice(e[i].indexOf(':') + 1).split(',');
     let eStart = parseInt(eVals[0].split('-')[0], 10);
     let eEnd = parseInt(eVals[0].split('-')[1], 10);
     let sName = m.slice(eStart, (eEnd + 1));
     let l = eVals.length;
     if (dup === false)
      l = 1;
     else if (dup !== true && l > dup)
      l = dup;
     for (let c = 0; c < l; c++)
      ret.push({svc: 't', url: u, str: sName});
    }
    return ret;
   }

   function parseFFZ(cmd, dup = null)
   {
    if (!eList.hasOwnProperty('ffz'))
     return [];
    if (cmd.params.length < 2)
     return [];
    let m = cmd.params[1].split(' ');
    if (dup === null)
     dup = cfg.display.duplicates;
    let ret = [];
    let addList = {};
    for (let i = 0; i < m.length; i++)
    {
     if (!eList.ffz.hasOwnProperty(m[i]))
      continue;
     if (eList.ffz[m[i]].users !== null)
     {
      let u = parseUser(cmd);
      if (!eList.ffz[m[i]].users.includes(u.host))
       continue;
     }
     if (!addList.hasOwnProperty(m[i]))
      addList[m[i]] = 0;
     else
     {
      if (dup === false)
       continue;
      if (dup !== true && addList[m[i]] >= dup)
       continue;
     }
     addList[m[i]]++;
     ret.push({svc: 'f', url: eList.ffz[m[i]].url, str: m[i], scope: eList.ffz[m[i]].scope});
    }
    return ret;
   }

   function parseBTTV(cmd, dup = null)
   {
    if (!eList.hasOwnProperty('bttv'))
     return [];
    if (cmd.params.length < 2)
     return [];
    let m = cmd.params[1].split(' ');
    if (dup === null)
     dup = cfg.display.duplicates;
    let ret = [];
    let addList = {};
    for (let i = 0; i < m.length; i++)
    {
     if (!eList.bttv.hasOwnProperty(m[i]))
      continue;
     if (!addList.hasOwnProperty(m[i]))
      addList[m[i]] = 0;
     else
     {
      if (dup === false)
       continue;
      if (dup !== true && addList[m[i]] >= dup)
       continue;
     }
     addList[m[i]]++;
     ret.push({svc: 'b', url: eList.bttv[m[i]].url, str: m[i], scope: eList.bttv[m[i]].scope});
    }
    return ret;
   }

   function parseBTTVU(cmd, dup = null)
   {
    if (!eList.hasOwnProperty('bttvU'))
     return [];
    if (cmd.params.length < 2)
     return [];
    let u = parseUser(cmd);
    if (!eList.bttvU.hasOwnProperty(u.host))
     return [];
    let m = cmd.params[1].split(' ');
    if (dup === null)
     dup = cfg.display.duplicates;
    let ret = [];
    let addList = {};
    for (let i = 0; i < m.length; i++)
    {
     if (!eList.bttvU[u.host].hasOwnProperty(m[i]))
      continue;
     if (!addList.hasOwnProperty(m[i]))
      addList[m[i]] = 0;
     else
     {
      if (dup === false)
       continue;
      if (dup !== true && addList[m[i]] >= dup)
       continue;
     }
     addList[m[i]]++;
     ret.push({svc: 'b', url: eList.bttvU[u.host][m[i]].url, str: m[i], scope: eList.bttvU[u.host][m[i]].scope});
    }
    return ret;
   }

   function parse7TV(cmd, dup = null)
   {
    if (!eList.hasOwnProperty('7tv'))
     return [];
    if (cmd.params.length < 2)
     return [];
    let m = cmd.params[1].split(' ');
    if (dup === null)
     dup = cfg.display.duplicates;
    let ret = [];
    let addList = {};
    for (let i = 0; i < m.length; i++)
    {
     if (!eList['7tv'].hasOwnProperty(m[i]))
      continue;
     if (!addList.hasOwnProperty(m[i]))
      addList[m[i]] = 0;
     else
     {
      if (dup === false)
       continue;
      if (dup !== true && addList[m[i]] >= dup)
       continue;
     }
     addList[m[i]]++;
     ret.push({svc: '7', url: eList['7tv'][m[i]].url, str: m[i], scope: eList['7tv'][m[i]].scope});
    }
    return ret;
   }

   function streamlabsWS()
   {
    let p = 0;
    const ws = new WebSocket('wss://sockets.streamlabs.com/socket.io/?token=' + cfg.streamlabs.token + '&transport=websocket');
    ws.onopen = function(event)
    {
     if (p !== 0)
     {
      window.clearInterval(p);
      p = 0;
     }
    };
    ws.onclose = function(event)
    {
     if (p !== 0)
     {
      window.clearInterval(p);
      p = 0;
     }
     if (!dead)
      window.setTimeout(function(){streamlabsWS();}, 5000);
    };
    ws.onmessage = async function(event)
    {
     if (dead)
     {
      ws.close();
      return;
     }
     let d = event.data;
     if (d.length < 1)
      return;
     switch (d.slice(0, 1))
     {
      case '0':
       let t = 20000;
       if (d.length > 1)
       {
        let c = JSON.parse(d.slice(1));
        if (c.hasOwnProperty('pingInterval'))
         t = c.pingInterval;
       }
       if (p !== 0)
       {
        window.clearInterval(p);
        p = 0;
       }
       p = window.setInterval(function(){ws.send('2');}, t);
       break;
      case '4':
       if (d.slice(1, 2) !== '2')
        return;
       if (d.length < 2)
        return;
       let o = JSON.parse(d.slice(2));
       if (o.length < 2)
        return;
       if (o[0] !== 'event')
        return;
       if (!o[1].hasOwnProperty('message'))
        return;
       let r = [];
       for (let i = 0; i < o[1].message.length; i++)
       {
        if (!o[1].message[i].hasOwnProperty('amount'))
         continue;
        if (!o[1].message[i].hasOwnProperty('type') || o[1].message[i].type !== 'donation')
         continue;
        let n = false;
        if (o[1].message[i].hasOwnProperty('name'))
         n = o[1].message[i].name;
        r.push({amt: o[1].message[i].amount, name: n});
       }
       await showStreamlabsTips(r);
       break;
     }
    };
   }

   async function showStreamlabsTips(dRet)
   {
    for (let i = 0; i < dRet.length; i++)
    {
     let n = dRet[i].name;
     let a = dRet[i].amt;
     let v = Math.floor(a * cfg.streamlabs.curMul);
     let r = findInMaybeRange(cfg.event.tip.streamlabs, v);
     if (r === false)
      continue;
     let p = false;
     if (cfg.event.tip.useProfileImage && n !== false)
     {
      let u = false;
      if (!(/[^A-Za-z0-9_]/).test(n))
       u = await getUserInfo(n);
      if (u !== false)
      {
       if (u.hasOwnProperty('profile_image_url'))
        p = [
         {url: u['profile_image_url']}
        ];
      }
     }
     showKappa(p, r, {'%USER%': n, '%AMOUNT%': Number.parseFloat(a).toFixed(2)});
    }
   }

   function streamelementsWS()
   {
    let p = 0;
    const ws = new WebSocket('wss://realtime.streamelements.com/socket.io/?transport=websocket');
    ws.onopen = function(event)
    {
     if (p !== 0)
     {
      window.clearInterval(p);
      p = 0;
     }
    };
    ws.onclose = function(event)
    {
     if (p !== 0)
     {
      window.clearInterval(p);
      p = 0;
     }
     if (!dead)
      window.setTimeout(function(){streamelementsWS();}, 5000);
    };
    ws.onmessage = async function(event)
    {
     if (dead)
     {
      ws.close();
      return;
     }
     let d = event.data;
     if (d.length < 1)
      return;
     switch (d.slice(0, 1))
     {
      case '0':
       let t = 20000;
       if (d.length > 1)
       {
        let c = JSON.parse(d.slice(1));
        if (c.hasOwnProperty('pingInterval'))
         t = c.pingInterval;
       }
       if (p !== 0)
       {
        window.clearInterval(p);
        p = 0;
       }
       p = window.setInterval(function(){ws.send('2');}, t);
       break;
      case '4':
       if (d.slice(1, 2) === '0')
       {
        let a = '';
        if (cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== 'OAUTH_ID')
         a = '["authenticate",{"method":"oauth2","token":"' + cfg.streamelements.oauth + '"}]';
        else if (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== 'JWT_TOKEN')
         a = '["authenticate",{"method":"jwt","token":"' + cfg.streamelements.token + '"}]';
        ws.send('42' + a);
        return;
       }
       if (d.slice(1, 2) !== '2')
        return;
       if (d.length < 2)
        return;
       let o = JSON.parse(d.slice(2));
       if (o.length < 2)
        return;
       if (o[0] !== 'event:update')
        return;
       if (!o[1].hasOwnProperty('name'))
        return;
       if (o[1].name !== 'tip-latest')
        return;
       if (!o[1].hasOwnProperty('data'))
        return;
       if (!o[1].data.hasOwnProperty('amount'))
        return;
       let n = false;
       if (o[1].data.hasOwnProperty('name'))
        n = o[1].data.name;
       await showStreamElementsTip(o[1].data.amount, n);
       break;
     }
    };
   }

   async function showStreamElementsTip(dAmt, dName)
   {
    let v = Math.floor(dAmt * cfg.streamelements.curMul);
    if (v < 1)
     return;
    let r = findInMaybeRange(cfg.event.tip.streamelements, v);
    if (r === false)
     return;
    let p = false;
    if (cfg.event.tip.useProfileImage && dName !== false)
    {
     let u = false;
     if (!(/[^A-Za-z0-9_]/).test(dName))
      u = await getUserInfo(dName);
     if (u !== false)
     {
      if (u.hasOwnProperty('profile_image_url'))
       p = [
        {url: u['profile_image_url']}
       ];
     }
    }
    showKappa(p, r, {'%USER%': dName, '%AMOUNT%': Number.parseFloat(dAmt).toFixed(2)});
   }

   async function detectFollowers(chID)
   {
    if (tFC === false)
     return;
    window.clearTimeout(tFC);
    tFC = false;
    let fRet = await getFollowerChange(chID);
    if (fRet !== false && fRet.length > 0)
    {
     for (let i = 0; i < fRet.length; i++)
      showKappa(false, cfg.event.follow, {'%USER%': fRet[i]});
    }
    tFC = window.setTimeout(detectFollowers, rFC, chID);
   }

   function getFollowerChange(chID)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.twitch.tv/helix/users/follows?to_id=' + chID + '&first=100');
      x.setRequestHeader('Authorization', 'Bearer ' + cfg.login.oauth);
      x.setRequestHeader('Client-Id', cfg.login.client);
      x.onreadystatechange = async function()
      {
       if (x.status !== 200)
       {
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       if (j.total < 1 || !j.hasOwnProperty('data') || j.data.length < 1)
       {
        resolve(false);
        return;
       }
       let findU = uLF;
       uLF = j.data[0].from_id;
       if (findU === false)
       {
        resolve(false);
        return;
       }
       let s = [];
       for (let i = 0; i < j.data.length; i++)
       {
        if (j.data[i].from_id === findU)
        {
         resolve(s);
         return;
        }
        s.push(j.data[i].from_name);
       }
       resolve([]);
      };
      x.send();
     }
    );
    return p;
   }

   function checkFollower(cmd)
   {
    let p = new Promise(
     (resolve, reject) =>
     {
      if (fList.length > 0)
      {
       for (let i = 0; i < fList.length; i++)
       {
        if (fList[i].id === cmd.tags['user-id'])
        {
         let tDif = Math.floor((new Date().getTime() - fList[i].t) / 1000);
         if (tDif > 3600)
         {
          fList.splice(i, 1);
          break;
         }
         resolve(fList[i].value);
         return;
        }
       }
      }
      let uID = cmd.tags['user-id'];
      let chID = cmd.tags['room-id'];
      let x = new XMLHttpRequest();
      x.open('GET', 'https://api.twitch.tv/helix/users/follows?from_id=' + uID + '&to_id=' + chID);
      x.setRequestHeader('Authorization', 'Bearer ' + cfg.login.oauth);
      x.setRequestHeader('Client-Id', cfg.login.client);
      x.onreadystatechange = async function()
      {
       if (x.status !== 200)
       {
        resolve(false);
        return;
       }
       if (x.readyState !== 4)
        return;
       if (x.responseText === '')
        return;
       let j = JSON.parse(x.responseText);
       if (j.total > 0)
       {
        fList.push({id: uID, value: true, t: new Date().getTime()});
        resolve(true);
        return;
       }
       fList.push({id: uID, value: false, t: new Date().getTime()});
       resolve(false);
      };
      x.send();
     }
    );
    return p;
   }

   async function parseLevel(cmd)
   {
    let level = 0x001;
    if (cmd.tags.hasOwnProperty('badges'))
    {
     let badges = cmd.tags.badges.split(',');
     for (let i = 0; i < badges.length; i++)
     {
      let bData = jSplit(badges[i], '/', 2);
      switch (bData[0])
      {
       case 'broadcaster':
        level |= 0x800;
        break;
       case 'moderator':
        level |= 0x400;
        break;
       case 'vip':
        level |= 0x100;
        break;
       case 'artist-badge':
        level |= 0x080;
        break;
       case 'founder':
        level |= 0x200;
        break;
       case 'bits':
        level |= 0x004;
        break;
       case 'subscriber':
        let badge = parseInt(bData[1], 10);
        if (badge < 2000)
         level |= 0x010;
        else if (badge < 3000)
         level |= 0x020;
        else
         level |= 0x040;
        break;
      }
     }
    }
    /* api-heavy, only check if follower access is allowed and there's a chance it matters */
    let needF = false;
    if ((cfg.display.access & 0x002) === 0x002 && (cfg.display.access & 0x001) !== 0x001)
     needF = true;
    else if ((cfg.display.kappa.access & 0x002) === 0x002 && (cfg.display.kappa.access & 0x001) !== 0x001)
     needF = true;
    if (needF)
    {
     let f = await checkFollower(cmd);
     if (f)
      level |= 0x002;
    }
    return level;
   }

   function handleDuplicates(a)
   {
    if (a.length < 1)
     return a;
    let r = [];
    for (let i = 0; i < a.length; i++)
    {
     if (a[i].scope === 'u')
      r.push(a[i]);
    }
    for (let i = 0; i < a.length; i++)
    {
     if (a[i].svc === 't' || a[i].svc === 'c' || a[i].svc === 'e')
      r.push(a[i]);
    }
    for (let i = 0; i < a.length; i++)
    {
     if ((a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7') && (a[i].scope === 'c'))
     {
      let f = false;
      for (let j = 0; j < r.length; j++)
      {
       if (r[j].str === a[i].str)
       {
        f = true;
        if (r[j].svc === a[i].svc)
         r.push(a[i]);
        break;
       }
      }
      if (!f)
       r.push(a[i]);
     }
    }
    for (let i = 0; i < a.length; i++)
    {
     if ((a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7') && (a[i].scope !== 'c'))
     {
      let f = false;
      for (let j = 0; j < r.length; j++)
      {
       if (r[j].str === a[i].str)
       {
        f = true;
        if (r[j].svc === a[i].svc)
         r.push(a[i]);
        break;
       }
      }
      if (!f)
       r.push(a[i]);
     }
    }
    return r;
   }

   async function parseCheer(cmd)
   {
    if (!eList.hasOwnProperty('cheer'))
     return false;
    if (!cmd.hasOwnProperty('tags'))
     return false;
    if (!cmd.tags.hasOwnProperty('bits'))
     return false;
    if (cmd.tags.bits < 1)
     return false;
    let p = [];
    let msg = cmd.params[1].split(' ');
    for (let m = 0; m < msg.length; m++)
    {
     for (const prefix in eList.cheer)
     {
      if (!eList.cheer.hasOwnProperty(prefix))
       continue;
      let firstChars = prefix.length;
      if (msg[m].slice(0, firstChars).toLowerCase() !== prefix.toLowerCase())
       continue;
      let amt = msg[m].slice(firstChars);
      if (isNaN(amt))
       continue;
      for (let i = 0; i < eList.cheer[prefix].length; i++)
      {
       if (parseInt(amt, 10) < eList.cheer[prefix][i].min)
        continue;
       let sName = prefix + eList.cheer[prefix][i].min;
       p.push({svc: 'c', url: eList.cheer[prefix][i].img, str: sName});
       break;
      }
     }
    }
    if (cfg.event.cheer.useMsg)
    {
     p = p.concat(parseT(cmd));
     if (cfg.display.useEmoji)
      p = p.concat(await parseEmoji(cmd, cfg.display.useEmoji));
     if (cfg.display.extended.useFFZ)
      p = p.concat(parseFFZ(cmd));
     if (cfg.display.extended.useBTTV)
     {
      p = p.concat(parseBTTV(cmd));
      p = p.concat(parseBTTVU(cmd));
     }
     if (cfg.display.extended.use7TV)
      p = p.concat(parse7TV(cmd));
    }
    else
     await parseLine(cmd);
    p = handleDuplicates(p);
    if (p.length === 0)
     return false;
    let r = findInMaybeRange(cfg.event.cheer.bits, cmd.tags.bits);
    if (r === false)
    {
     toShow = toShow.concat(p);
     showEmotes();
     return true;
    }
    let u = parseUser(cmd, true);
    let dn = 'Anonymous';
    if (u.hasOwnProperty('display-name'))
     dn = u['display-name'];
    showKappa(p, r, {'%USER%': dn, '%AMOUNT%': cmd.tags.bits});
    return true;
   }

   async function parseLine(cmd)
   {
    let level = -1;
    if (cmd.params.length > 1)
    {
     let m = cmd.params[1].toLowerCase();
     if (cfg.display.kappa.aliases.includes(m))
     {
      if (level === -1)
       level = await parseLevel(cmd);
      if ((level & cfg.display.kappa.access) !== 0)
      {
       showKappa(false);
       return;
      }
     }
     let foundCmd = false;
     for (let i = 0; i < cfg.display.kappa.aliases.length; i++)
     {
      if (m.slice(0, cfg.display.kappa.aliases[i].length + 1) === cfg.display.kappa.aliases[i] + ' ')
      {
       foundCmd = true;
       break;
      }
     }
     if (foundCmd)
     {
      if (level === -1)
       level = await parseLevel(cmd);
      if ((level & cfg.display.kappa.access) !== 0)
      {
       let a = [];
       a = a.concat(parseT(cmd, true));
       if (cfg.display.useEmoji)
        a = a.concat(await parseEmoji(cmd, cfg.display.useEmoji, true));
       if (cfg.display.extended.useFFZ)
        a = a.concat(parseFFZ(cmd, true));
       if (cfg.display.extended.useBTTV)
       {
        a = a.concat(parseBTTV(cmd, true));
        a = a.concat(parseBTTVU(cmd, true));
       }
       if (cfg.display.extended.use7TV)
        a = a.concat(parse7TV(cmd, true));
       a = handleDuplicates(a);
       showKappa(a);
       return;
      }
     }
    }
    let p = [];
    p = p.concat(parseT(cmd));
    if (cfg.display.useEmoji)
     p = p.concat(await parseEmoji(cmd, cfg.display.useEmoji));
    if (cfg.display.extended.useFFZ)
     p = p.concat(parseFFZ(cmd));
    if (cfg.display.extended.useBTTV)
    {
     p = p.concat(parseBTTV(cmd));
     p = p.concat(parseBTTVU(cmd));
    }
    if (cfg.display.extended.use7TV)
     p = p.concat(parse7TV(cmd));
    p = handleDuplicates(p);
    if (p.length === 0)
     return;
    if (level === -1)
     level = await parseLevel(cmd);
    if ((level & cfg.display.access) === 0)
     return;
    toShow = toShow.concat(p);
    showEmotes();
   }

   async function parseRaid(cmd)
   {
    if (!cmd.tags.hasOwnProperty('msg-param-viewerCount'))
     return;
    let c = cmd.tags['msg-param-viewerCount'];
    let r = findInMaybeRange(cfg.event.raid.raiders, c);
    if (r === false)
     return;
    let u = parseUser(cmd, true);
    let dn = 'Anonymous';
    if (u.hasOwnProperty('display-name'))
     dn = u['display-name'];
    if (!cfg.event.raid.originEmotes)
    {
     showKappa(false, r, {'%USER%': dn, '%AMOUNT%': c});
     return;
    }
    let d = cmd.tags['user-id'];
    let e = await findEmote_channel(d);
    showKappa(e, r, {'%USER%': dn, '%AMOUNT%': c});
   }

   async function parseSub(cmd)
   {
    function parsePlan(c)
    {
     if (!c.tags.hasOwnProperty('msg-param-sub-plan'))
      return;
     let p = c.tags['msg-param-sub-plan'];
     switch (p)
     {
      case '1000': return 't1';
      case '2000': return 't2';
      case '3000': return 't3';
      case 'Prime': return 'prime';
      default:
     }
     console.log('Unknown Sub Plan: ', p, c);
     return false;
    }
    if (!cmd.tags.hasOwnProperty('msg-id'))
     return;
    let subPlan = parsePlan(cmd);
    if (subPlan === false)
     return;
    let mpoi = false;
    if (cmd.tags.hasOwnProperty('msg-param-origin-id'))
     mpoi = cmd.tags['msg-param-origin-id'];
    if (mpoi !== false && bList.includes(mpoi))
     return;
    let a = [];
    if (cmd.params.length > 1)
    {
     if (cfg.event.sub.useMsg)
     {
      a = a.concat(parseT(cmd, true));
      if (cfg.display.useEmoji)
       a = a.concat(await parseEmoji(cmd, cfg.display.useEmoji, true));
      if (cfg.display.extended.useFFZ)
       a = a.concat(parseFFZ(cmd, true));
      if (cfg.display.extended.useBTTV)
      {
       a = a.concat(parseBTTV(cmd, true));
       a = a.concat(parseBTTVU(cmd, true));
      }
      if (cfg.display.extended.use7TV)
       a = a.concat(parse7TV(cmd, true));
     }
     else
      await parseLine(cmd);
    }
    let mpm = 1;
    if (cmd.tags.hasOwnProperty('msg-param-months'))
     mpm = parseInt(cmd.tags['msg-param-months'], 10);
    let mpcm = 1;
    if (cmd.tags.hasOwnProperty('msg-param-cumulative-months'))
     mpcm = parseInt(cmd.tags['msg-param-cumulative-months'], 10);
    let mpmgc = 1;
    if (cmd.tags.hasOwnProperty('msg-param-mass-gift-count'))
     mpmgc = parseInt(cmd.tags['msg-param-mass-gift-count'], 10);
    let u = parseUser(cmd, true);
    let dn = 'Anonymous';
    if (u.hasOwnProperty('display-name'))
     dn = u['display-name'];
    let mprdn = 'Anonymous';
    if (cmd.tags.hasOwnProperty('msg-param-recipient-display-name'))
     mprdn = cmd.tags['msg-param-recipient-display-name'];
    switch (cmd.tags['msg-id'])
    {
     case 'sub':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('first'))
       return;
      if (cfg.event.sub[subPlan].first === false)
       return;
      showKappa(a, cfg.event.sub[subPlan].first, {'%USER%': dn});
      break;
     case 'resub':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('resub'))
       return;
      let rs = findInMaybeRange(cfg.event.sub[subPlan].resub, mpcm);
      if (rs === false)
       return;
      showKappa(a, rs, {'%USER%': dn, '%AMOUNT%': mpcm});
      break;
     case 'primepaidupgrade':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('upgrade'))
       return;
      if (!cfg.event.sub[subPlan].upgrade.hasOwnProperty('prime'))
       return;
      showKappa(a, cfg.event.sub[subPlan].upgrade.prime, {'%USER%': dn});
      break;
     case 'giftpaidupgrade':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('upgrade'))
       return;
      if (!cfg.event.sub[subPlan].upgrade.hasOwnProperty('gift'))
       return;
      showKappa(a, cfg.event.sub[subPlan].upgrade.gift, {'%USER%': dn});
      break;
     case 'subgift':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('gift'))
       return;
      if (mpm === 1)
      {
       if (!cfg.event.sub[subPlan].gift.hasOwnProperty('first'))
        return;
       if (cfg.event.sub[subPlan].gift.first === false)
        return;
       showKappa(a, cfg.event.sub[subPlan].gift.first, {'%SENDER%': dn, '%USER%': mprdn});
       return;
      }
      if (!cfg.event.sub[subPlan].gift.hasOwnProperty('resub'))
       return;
      let gpr = findInMaybeRange(cfg.event.sub[subPlan].gift.resub, mpm);
      if (gpr === false)
       return;
      showKappa(a, gpr, {'%SENDER%': dn, '%USER%': mprdn, '%AMOUNT%': mpm});
      break;
     case 'submysterygift':
      if (!cfg.event.sub.hasOwnProperty(subPlan))
       return;
      if (!cfg.event.sub[subPlan].hasOwnProperty('gift'))
       return;
      if (!cfg.event.sub[subPlan].gift.hasOwnProperty('bomb'))
       return;
      if (cfg.event.sub[subPlan].gift.bomb === false)
       return;
      if (mpoi !== false)
       bList.push(mpoi);
      let gpb = findInMaybeRange(cfg.event.sub[subPlan].gift.bomb, mpmgc);
      if (gpb === false)
       return;
      showKappa(a, gpb, {'%SENDER%': dn, '%AMOUNT%': mpmgc});
      break;
     default:
      console.log('Unknown Sub Type: ', cmd);
    }
   }

   function parseBadge(cmd)
   {
    if (!cmd.tags.hasOwnProperty('msg-param-threshold'))
     return;
    let c = cmd.tags['msg-param-threshold'];
    let u = parseUser(cmd, true);
    let dn = 'Anonymous';
    if (u.hasOwnProperty('display-name'))
     dn = u['display-name'];
    if (cfg.event.badge.hasOwnProperty(c) && cfg.event.badge[c] !== false)
    {
     showKappa(false, cfg.event.badge[c], {'%USER%': dn, '%AMOUNT%': c});
     return;
    }
    let closest = null;
    for (const b in cfg.event.badge)
    {
     if (!cfg.event.badge.hasOwnProperty(b))
      continue;
     if (closest === null)
     {
      closest = b;
      continue;
     }
     if (Math.abs(parseInt(closest, 10) - parseInt(c, 10)) > Math.abs(parseInt(b, 10) - parseInt(c, 10)))
      closest = b;
    }
    if (closest === null)
     return;
    if (cfg.event.badge[closest] === false)
     return;
    showKappa(false, cfg.event.badge[closest], {'%USER%': dn, '%AMOUNT%': c});
   }

   function irc()
   {
    let firstRoomstate = true;
    const ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
    ws.onopen = function(event)
    {
     tIRC = setTimeout(
      function()
      {
       dead = true;
       if (tIRC !== false)
       {
        clearTimeout(tIRC);
        tIRC = false;
       }
       ws.close();
       blargIAmDead(5);
      },
      5000);
     ws.send('PASS oauth:' + cfg.login.oauth);
     ws.send('NICK ' + cfg.channel);
     ws.send('CAP REQ :twitch.tv/commands');
     ws.send('CAP REQ :twitch.tv/tags');
     ws.send('JOIN #' + cfg.channel);
    };
    ws.onclose = function()
    {
     if (tIRC !== false)
     {
      clearTimeout(tIRC);
      tIRC = false;
     }
     if (!dead)
      window.setTimeout(irc, 5000);
    };
    ws.onmessage = async function(event)
    {
     let data = event.data.split('\r\n');
     for (let i = 0; i < data.length; i++)
     {
      if (data[i].length === 0)
       continue;
      let cmd = parseMsg(data[i]);
      if (cmd === false)
      {
       console.log('Unparsed IRC Command: ', data[i]);
       continue;
      }
      switch(cmd.command)
      {
       case '001':
       case '002':
       case '003':
       case '004':
       case '353':
       case '366':
       case '372':
       case '375':
       case '376':
       case 'CAP':
       case 'JOIN':
       case 'PART':
       case 'WHISPER':
       case 'CLEARCHAT':
       case 'CLEARMSG':
       case 'USERSTATE':
        break;
       case 'PING':
        ws.send('PONG ' + cmd.params[0]);
        break;
       case 'PRIVMSG':
        if (!await parseCheer(cmd))
         parseLine(cmd);
        break;
       case 'NOTICE':
        if (cmd.params.length > 1 && cmd.params[1] === 'Login authentication failed')
        {
         dead = true;
         blargIAmDead(1);
        }
        else
         console.log('Unhandled IRC NOTICE: ', cmd);
        break;
       case 'ROOMSTATE':
        if (!cmd.hasOwnProperty('tags'))
         continue;
        if (!cmd.tags.hasOwnProperty('room-id'))
         continue;
        channelID = cmd.tags['room-id'];
        if (firstRoomstate)
        {
         if (tIRC !== false)
         {
          clearTimeout(tIRC);
          tIRC = false;
         }
         firstRoomstate = false;
         await loadEmote_channel(channelID);
         loadCheer_channel(channelID);
         if (cfg.display.extended.useFFZ)
          loadFFZ_channel(channelID);
         if (cfg.display.extended.useBTTV)
         {
          loadBTTV_channel(channelID);
          loadBTTV_ws_channel(channelID);
         }
         if (cfg.event.follow !== false)
          tFC = window.setTimeout(detectFollowers, tStart, channelID);
        }
        break;
       case 'USERNOTICE':
        if (!cmd.hasOwnProperty('tags'))
         continue;
        if (!cmd.tags.hasOwnProperty('msg-id'))
         continue;
        switch (cmd.tags['msg-id'])
        {
         case 'raid':
          parseRaid(cmd);
          break;
         case 'sub':
         case 'resub':
         case 'subgift':
         case 'submysterygift':
         case 'giftpaidupgrade':
         case 'primepaidupgrade':
          parseSub(cmd);
          break;
         case 'bitsbadgetier':
          parseBadge(cmd);
          break;
         default:
          if (cmd.params.length > 1)
           parseLine(cmd);
          console.log('Unhandled IRC USERNOTICE: ', cmd.tags['msg-id'], cmd);
        }
        break;
       default:
        console.log('Unhandled IRC Command: ', cmd.command, cmd);
      }
     }
    };
   }

   function redditWS(wsURL)
   {
    const ws = new WebSocket(wsURL);
    ws.onopen = function(event)
    {
    };
    ws.onclose = function()
    {
     window.setTimeout(function(){redditWS(wsURL);}, 5000);
    };
    ws.onmessage = async function(event)
    {
     let d = JSON.parse(event.data);
     if (d.type !== 'new_comment')
     {
      console.log('Unparsed Reddit Message: ', d);
      return;
     }
     console.log('Reddit Comment: ', d.payload.author, d.payload.body);
     let cmd = {params: [d.payload.author, d.payload.body]};
     let p = [];
     p = await parseEmoji(cmd, cfg.display.useEmoji);
     if (p.length === 0)
      return;
     toShow = toShow.concat(p);
     showEmotes();
    };
   }

   function reddit(rID)
   {
    let x = new XMLHttpRequest();
    x.open('GET', 'https://strapi.reddit.com/videos/t3_' + rID);
    x.onreadystatechange = function()
    {
     if (x.status !== 200)
      return;
     if (x.readyState !== 4)
      return;
     if (x.responseText === '')
      return;
     let j = JSON.parse(x.responseText);
     if (!j.hasOwnProperty('data'))
      return;
     if (!j.data.hasOwnProperty('post'))
      return;
     if (!j.data.post.hasOwnProperty('liveCommentsWebsocket'))
      return;
     let ws = j.data.post.liveCommentsWebsocket;
     redditWS(ws);
    };
    x.send();
   }

   function shouldUseLogin()
   {
    useL = false;
    if (cfg.hasOwnProperty('channel') && cfg.channel !== false && cfg.channel !== 'CHANNEL_NAME' && cfg.hasOwnProperty('login') && cfg.login.hasOwnProperty('oauth') && cfg.login.oauth !== false && cfg.login.oauth !== 'OAUTH_ID')
     return false;
    useL = true;
    let lsChannel = window.localStorage.getItem('rrew.channel');
    let lsClient  = window.localStorage.getItem('rrew.client');
    let lsOAuth   = window.localStorage.getItem('rrew.oauth');
    let lsExpires = window.localStorage.getItem('rrew.expires');
    if (lsChannel === null || lsOAuth === null)
    {
     let h = getHashParams();
     if (!h.hasOwnProperty('channel') || !h.hasOwnProperty('client') || !h.hasOwnProperty('oauth') || !h.hasOwnProperty('expires'))
     {
      showLoginButton();
      return true;
     }
     lsChannel = h.channel;
     lsClient = h.client;
     lsOAuth = h.oauth;
     lsExpires = h.expires;
     window.localStorage.setItem('rrew.channel', lsChannel);
     window.localStorage.setItem('rrew.oauth', lsOAuth);
     window.localStorage.setItem('rrew.client', lsClient);
     window.localStorage.setItem('rrew.expires', lsExpires);
    }
    cfg.channel = lsChannel;
    cfg.login.oauth = lsOAuth;
    cfg.login.client = lsClient;
    cfg.login.expires = lsExpires;
    document.title = cfg.channel + ' Emote Wall';
    showLogoutButton();
    return false;
   }

   function getHashParams()
   {
    let d = function(s) {
     let a = /\+/g;
     return decodeURIComponent(s.replace(a, " "));
    };
    let hashParams = {};
    let r = /([^&;=]+)=?([^&;]*)/g;
    let q = window.location.hash.substring(1);
    let e;
    while ((e = r.exec(q)))
    {
     hashParams[d(e[1])] = d(e[2]);
    }
    return hashParams;
   }

   function doLogin()
   {
    let o = encodeURIComponent(btoa(window.location));
    let u = 'https://id.twitch.tv/oauth2/authorize?client_id=' + encodeURIComponent('4umzcpmjkg6ar78b81s7302jlj33t8') + '&redirect_uri=' + encodeURIComponent('https://realityripple.com/Tools/Twitch/EmoteWall/wizard.php') + '&response_type=token&scope=' + encodeURIComponent('chat:read') + '&state=redirto_' + o + '&force_verify=true';
    window.location = u;
   }

   function showLoginButton()
   {
    document.title = 'Log In to Access Emote Wall';
    if (document.getElementById('cmdLogout'))
     document.body.removeChild(document.getElementById('cmdLogout'));
    window.localStorage.removeItem('rrew.channel');
    window.localStorage.removeItem('rrew.oauth');
    window.localStorage.removeItem('rrew.client');
    window.localStorage.removeItem('rrew.expires');
    let cmdLogin = document.createElement('button');
    cmdLogin.setAttribute('id', 'cmdLogin');
    cmdLogin.setAttribute('type', 'button');
    cmdLogin.setAttribute('onclick', 'doLogin();');
    let sStyle = 'z-index: 1000;';
    sStyle += ' position: absolute;';
    sStyle += ' top: 45%;';
    sStyle += ' left: calc(50% - 6.5em);';
    sStyle += ' width: 13em;';
    sStyle += ' font-size: 3vw;';
    sStyle += ' padding: 0.5em;';
    cmdLogin.setAttribute('style', sStyle);
    cmdLogin.innerHTML = 'Authenticate Emote Wall';
    document.body.appendChild(cmdLogin);
   }

   function showLogoutButton(v = false)
   {
    let visTime = 5000;
    if (document.getElementById('cmdLogout'))
     document.body.removeChild(document.getElementById('cmdLogout'));
    let cmdLogout = document.createElement('button');
    if (tL !== false)
    {
     window.clearTimeout(tL);
     tL = false;
    }
    cmdLogout.setAttribute('id', 'cmdLogout');
    cmdLogout.setAttribute('type', 'button');
    let sStyle = 'z-index: 1000;';
    sStyle += ' transition: opacity 0.5s;';
    sStyle += ' position: absolute;';
    sStyle += ' top: 1em;';
    sStyle += ' right: 1em;';
    sStyle += ' width: 5em;';
    sStyle += ' font-size: 1vw;';
    sStyle += ' padding: 0.5em;';
    document.addEventListener(
     'mouseover',
     function()
     {
      cmdLogout.style.opacity = '1';
      if (tL !== false)
      {
       window.clearTimeout(tL);
       tL = false;
      }
      tL = window.setTimeout(
       function()
       {
        if (tL !== false)
        {
         window.clearTimeout(tL);
         tL = false;
        }
        cmdLogout.style.opacity = '0';
       },
       visTime
      );
     }
    );
    if (v)
    {
     cmdLogout.setAttribute('onclick', 'doLogin();');
     cmdLogout.innerHTML = 'Re-Auth';
     sStyle += ' opacity: 1;';
     tL = window.setTimeout(
      function()
      {
       if (tL !== false)
       {
        window.clearTimeout(tL);
        tL = false;
       }
       cmdLogout.style.opacity = '0';
      },
      visTime
     );
    }
    else
    {
     cmdLogout.setAttribute('onclick', 'showLoginButton();');
     cmdLogout.innerHTML = 'Log Out';
     sStyle += ' opacity: 0;';
    }
    cmdLogout.setAttribute('style', sStyle);
    document.body.appendChild(cmdLogout);
   }

   function blargIAmDead(e)
   {
    let showButton = false;
    switch (e)
    {
     case 1:
      if (useL)
      {
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Connect to Twitch<br><br>Please Log In Again</div>';
       showButton = true;
       showLoginButton();
      }
      else
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Connect to Twitch<br><br>Please Update Your OAuth Token</div>';
      break;
     case 2:
      document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Corrupted Configuration<br><br>Please Check Your Browser\'s Error Console</div>';
      break;
     case 3:
      if (useL)
      {
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Emotes<br><br>Please Log In Again</div>';
       showButton = true;
       showLoginButton();
      }
      else
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Emotes<br><br>Please Check Your Client ID and OAuth Token</div>';
      break;
     case 4:
      if (useL)
      {
       showLogoutButton(true);
       return;
      }
      document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Warning:<br><br>Your Credentials Will Expire Soon<br><br>Please Update Your OAuth Token</div>';
      break;
     case 5:
      document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>The connection to the IRC channel was incomplete.<br><br>Please check your Channel</div>';
      break;
    }
    window.setTimeout(function(){document.body.innerHTML = ''; if (showButton) showLoginButton();}, 15000);
   }
  </script>
 </head>
 <body>
  <script>
   async function startup()
   {
    if (typeof cfg === 'undefined')
    {
     blargIAmDead(2);
     return;
    }
    if (shouldUseLogin() === true)
     return;
    if (cfg.login.hasOwnProperty('expires') && cfg.login.expires > 0)
    {
     let expTime = cfg.login.expires - new Date().getTime();
     if (expTime > 0)
     {
      let expDays = Math.floor(expTime / 1000 / 60 / 60 / 24);
      if (expDays < 7)
      {
       blargIAmDead(4);
      }
     }
    }
    if (cfg.hasOwnProperty('streamlabs') && cfg.streamlabs.hasOwnProperty('token') && cfg.streamlabs.token !== false && cfg.streamlabs.token !== 'SOCKET_TOKEN')
     streamlabsWS();
    if (cfg.hasOwnProperty('streamelements') && ((cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== 'OAUTH_ID') || (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== 'JWT_TOKEN')))
     streamelementsWS();
    if (cfg.display.extended.useFFZ)
     await loadFFZ_global();
    if (cfg.display.extended.useBTTV)
     await loadBTTV_global();
    if (cfg.display.extended.use7TV)
    {
     await load7TV_global();
     await load7TV_channel(cfg.channel);
    }
    irc();
    if (cfg.hasOwnProperty('reddit') && cfg.reddit !== false)
     reddit(cfg.reddit);
   }
   startup();
  </script>
 </body>
</html>