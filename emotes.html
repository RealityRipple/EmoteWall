<!doctype html>
<html lang="en">
 <head>
  <meta charset="utf-8" />
  <title>Emote Wall</title>
  <script>
   'use strict';
   /* RealityRipple's Home-Made Emote Wall
    * ====================================
    *
    * v0.7.5 BETA
    *
    *  <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *
    *
    * Help
    * ----
    *
    *  Please contact RealityRipple for assistance, bug reports, or questions.
    *
    *   <https://realityripple.com>
    *   <https://twitch.tv/realityripple>
    *   <https://discord.gg/fcxJ9tq3XS>
    *
    *
    * Configuration Information
    * -------------------------
    *
    * channel     The name of the channel to join. Also used to choose an IRC nickname.
    *             If FALSE, the interactive login process will be enabled.
    *
    * login       Settings related to the login process.
    *
    *             NOTE: OAuth refresh tokens expire automatically (usually after around half a year).
    *                   If you don't use the Emote Wall for around this long, you may have to log in again.
    *                   Regular OAuth tokens expire much sooner (usually after 60 days). If you use the manual oauth
    *                   method, please make sure to update these values on a regular basis.
    *
    *  client     The Client ID value is used to track which third-party project is accessing your account.
    *             This emote wall does not require a constant ID, and will work with whatever tool you use to
    *             get an OAuth ID (see below).
    *
    *  oauth      The OAuth ID value is used in lieu of a password to access the Twitch API.
    *             By default, this value is not required.
    *             If you do not wish to use the oauth_refresh method, which relies on a file on my webserver,
    *             you can generate your own OAuth2 token manually using a third-party Twitch Token Generator, and set
    *             this value to the token you receive. However, it will expire and require updating manually.
    *
    *  oauth_refresh  A refresh token to get a new Twitch OAuth ID when the current one expires.
    *                This value is used instead of the oauth value above, by default. Using a refresh token allows the
    *             emote wall to stay logged in for a much longer period of time. Please note that this feature makes
    *             use of the browser's Local Storage to store new OAuth Tokens and Refresh Tokens as they're generated.
    *             New OAuth Tokens are generated every 60 minutes, and Twitch may or may not send a new Refresh Token
    *             at the same time. If the token expires, the Local Storage values will be erased on the next refesh
    *             attempt automatically.
    *             Please generate an OAuth ID and matching Client ID:
    *             - Visit <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *             - Click the "Authenticate on Twitch" button under "Do-it-Yourself" and log in
    *             - Fill out the captcha prompt, if necessary
    *             - Copy the Client ID value and paste it into "client:"
    *             - Copy the OAuth Refresh value and paste it into "oauth_refresh:"
    *             If you ever stop using this emote wall, please log into Twitch and visit
    *             <https://www.twitch.tv/settings/connections>. Under "Other Connections", click the "Disconnect" button
    *             next to "RealityRipple's Home-Made Emote Wall".
    *
    *             If both oauth and oauth_refresh are FALSE (or missing), the interactive login process will be enabled.
    *
    *  scope      A list of scopes which the OAuth ID provides access to. Please make sure this list reflects
    *             any scope selections you made while creating the token above.
    *
    * streamlabs  Settings related to Streamlabs tips.
    *
    *  token      The Socket Token is used in lieu of a password to access the Streamlabs API.
    *             Please generate a Socket Token:
    *             - Visit <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *             - Click the "Streamlabs Tip Support" button and log in
    *             - Copy the Token value and paste it into "token:"
    *             If you ever stop using this emote wall, please log into Streamlabs and visit
    *             <https://streamlabs.com/dashboard#/settings/api-settings>. Under "Connected Apps", click the
    *             "Revoke Access" button next to "RealityRipple's Home-Made Emote Wall". If you want to use a different
    *             Streamlabs OAuth generator (or do it yourself), feel free.
    *
    *  curMul     This value is the currency multiplier. The ranges of Streamlabs tip entries (see below) will
    *             match against this multiplier. For example, if you use USD and want to set ranges by penny amount,
    *             then set this value to 100. If you want to use dollar amounts, set the value to 1.
    *             Note: Any decimal amount will be rounded down after multiplying, so $3.95 will be handled as "395"
    *                   pennies when multiplied by 100, or "3" dollars when multiplied by 1.
    *
    *  dispMul    This value is the currency multiplier when the currency is being displayed. For kappagen events such
    *             as Text, the Streamlabs tip amount will be multiplied by this number before being displayed.
    *             For example, if you use USD and want to display the value as cents, then set this value to 100. If
    *             you want to show dollar amounts, set this value to 1.
    *
    *  dispDec    This value is the decimal count when the currency is being displayed. After being multiplied by the
    *             dispMul value above, the Streamlabs tip amount will be rounded to this many decimal places.
    *             For example, an amount of $3.95 rounded to "0" decimal places will be "3", to "1" would be "3.9", and
    *             to "2" would be "3.95".
    *
    *  dispPre    This value should be added before any currency amount as a prefix, such as a dollar sign '$'.
    *
    *  dispSuf    This value should be added after any currency amount as a suffix, such as the word " dollars". Usually
    *             only the prefix or the suffix should be used, not both at the same time.
    *
    * streamelements  Settings related to StreamElements tips.
    *
    *  oauth_refresh  A refresh token to get a new StreamElements OAuth ID when the current one expires.
    *                The OAuth ID value is used in lieu of a password to access the StreamElements API.
    *             Please generate an OAuth ID:
    *             - Visit <https://realityripple.com/Tools/Twitch/EmoteWall/>
    *             - Click the "StreamElements Tip Support" button and log in
    *             - Copy the Token value and paste it into "oauth_refresh:"
    *             If you ever stop using this emote wall, please log into StreamElements and visit
    *             <https://streamelements.com/dashboard/account/security>. Click the "Reset my Personal Access Token"
    *             button. If you want to use a different StreamElements OAuth generator (or do it yourself), feel free.
    *             Please only use oauth_refresh or token, not both. Token does not expire, but is also less secure.
    *             OAuth is recommended, if possible.
    *
    *  token      The JWT Token is used in lieu of a password to access the StreamElements API.
    *             Please grab your JWT Token from the StreamElements Dashboard:
    *             - Visit <https://streamelements.com/dashboard/account/channels>
    *             - Click the "Show secrets" button
    *             - Copy the JWT Token value and paste it into "token:"
    *             Please only use refresh or token, not both. Token does not expire, but is also less secure. OAuth is
    *             recommended, if possible.
    *
    *  curMul     This value is the currency multiplier. The ranges of StreamElements tip entries (see below) will
    *             match against this multiplier. For example, if you use USD and want to set ranges by penny amount,
    *             then set this value to 100. If you want to use dollar amounts, set the value to 1.
    *             Note: Any decimal amount will be rounded down after multiplying, so $3.95 will be handled as "395"
    *                   pennies when multiplied by 100, or "3" dollars when multiplied by 1.
    *
    *  dispMul    This value is the currency multiplier when the currency is being displayed. For kappagen events such
    *             as Text, the StreamElements tip amount will be multiplied by this number before being displayed.
    *             For example, if you use USD and want to display the value as cents, then set this value to 100. If
    *             you want to show dollar amounts, set this value to 1.
    *
    *  dispDec    This value is the decimal count when the currency is being displayed. After being multiplied by the
    *             dispMul value above, the StreamElements tip amount will be rounded to this many decimal places.
    *             For example, an amount of $3.95 rounded to "0" decimal places will be "3", to "1" would be "3.9", and
    *             to "2" would be "3.95".
    *
    *  dispPre    This value should be added before any currency amount as a prefix, such as a dollar sign '$'.
    *
    *  dispSuf    This value should be added after any currency amount as a suffix, such as the word " dollars". Usually
    *             only the prefix or the suffix should be used, not both at the same time.
    *
    * display     Settings related to the animation of the emote wall.
    *
    *  styles     An array of animation styles which individual emotes randomly perform. You may turn on and off
    *             elements in this array by "commenting out" a style, by putting two slashes before the name:
    *              // 'Still',        < disabled
    *                 'StraightLine', < allowed
    *
    *  access     A bitwise flag representing which users' messages show up on the emote wall. Account types are
    *             represented by the following values:
    *
    *              0x800 = broadcaster
    *              0x400 = moderator badge
    *              0x200 = founder badge
    *              0x100 = vip badge
    *              0x080 = artist badge
    *              0x040 = tier 3 subscriber badge
    *              0x020 = tier 2 subscriber badge
    *              0x010 = tier 1 subscriber badge
    *              0x004 = cheer badge
    *              0x002 = follower
    *              0x001 = stranger
    *
    *             Just put a vertical pipe " | " in between each of the values representing levels of access:
    *
    *              ACCESS                                 MEANING
    *             0x800 | 0x400                           broadcaster and moderator only
    *             0x800 | 0x400 | 0x100 | 0x040 | 0x020   broadcasters, mods, VIPs, and tier 2 and 3 subscribers
    *             0x800 | 0x010 | 0x002                   boradcaster, tier 1 subscribers, and followers
    *
    *             If you know how bitwise flags work, you can also use them
    *             in more complicated ways:
    *               ACCESS           MEANING
    *             0xFF7             all users from the broadcaster to strangers
    *             0xFF7 ^ 0x003     all users except followers and strangers
    *             0x070             all subscribers
    *
    *  duplicates  A boolean or integer to toggle duplicate emotes per message.
    *             If TRUE, every emote posted in chat will be shown.
    *             If FALSE, only one of each emote per message will be shown.
    *             If greater than 1, sets the maximum number of identical emotes shown from any message.
    *
    *  useEmoji   Toggles display of emojis on the emote wall, and lets you choose an emoji font style.
    *             If TRUE, emojis will be shown using the "twemoji" font.
    *             If FALSE, emojis will not be shown on the emote wall.
    *             If 'twemoji', emojis will be shown using the "twemoji" font.
    *             If 'openmoji', emojis will be shown using the "openmoji" font.
    *             If 'noto', emojis will be shown using the "noto" font.
    *             If 'blob', emojis will be shown using the "blobmoji" font.
    *
    *  extended   Settings related to third-party emotes.
    *
    *   useFFZ    Toggles display of FrankerFaceZ emotes.
    *
    *   useBTTV   Toggles display of BetterTTV emotes.
    *
    *   use7TV    Toggles display of 7TV emotes.
    *
    *   useZWE    Toggles display of Zero-Width (overlapping) emotes. If disabled, this will hide ZWEs entirely.
    *             Note: ZWE display requires more objects on-screen, which can be process-intensive, and precise
    *                   timing is required for accurate overlay.
    *                   CHAOS MAY ENSUE.
    *
    *  kappa      Settings related to emote-splosions and the !kappagen command.
    *
    *   count     The number of emotes to display per kappagen. This value should be less than the "emote max" value
    *             seen below (best would be 1/4th or less), if "emote max" is used, or it will be truncated to match.
    *
    *   styles    Similar to the array of styles for normal emotes, but this one lists emote-splosion types.
    *             Please do not try to add normal styles to the kappa list or vice versa. This is an associative array
    *             which can have custom settings for certain styles (namely The Cube and Text - see below).
    *
    *    [ALL]    Settings related to multiple kappagens. These settings will be the default for all instances of their
    *             respective kappagens. Each setting below may or may not apply to a specific kappagen style.
    *
    *     count   The number of emotes to display for this specific kappagen. This value should be less than the
    *             "emote max" value seen below (best would be 1/4th or less), if "emote max" is used, or it will be
    *             truncated to match. If unset, this will default to the global kappa count preference listed above.
    *             Note: If this preference is in an event below (not in this general kappa context), then an additional
    *                   value is possible: -1, which will refer to the AMOUNT value present in the event. This can be
    *                   the number of raiders, bits cheered, dollars tipped, subs gifted, or months subscribed.
    *
    *    Conga    Settings related to Conga kappagen. These settings will be the default for all instances of
    *             Conga kappagen.
    *
    *     avoidMiddle  If TRUE, conga lines will only show up on the top or bottom three rows to avoid the middle off
    *                 the screen.
    *             If FALSE, conga lines will show up on any row of the screen.
    *
    *    TheCube  Settings related to The Cube kappagen. These settings will be the default for all instances of
    *             TheCube kappagen.
    *
    *     size    A decimal value representing the height of The Cube kappagen, relative to the smallest
    *             screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "8 / 10" (80%).
    *
    *     center  If TRUE, The Cube will show up in the exact center of the screen.
    *             If FALSE, The Cube will show up in a random location.
    *
    *     rotations  The maximum number of rotations a kappa cube might spin while on screen. This effectively controls
    *               the maximum possible speed at which cubes will rotate.
    *
    *    Text     Settings related to Text kappagen. These settings will be the default for all instances of Text
    *             kappagen.
    *
    *     message  An array of alphanumeric strings (letters, numbers, and spaces), one of which will randomly be used.
    *
    *     time    The number of seconds the Text kappagen should show the final result for.
    *             This value should be adjusted depending on the average message length, for readability.
    *
    *   access    Similar to the access flag for normal emotes, but controls which users can use the !kappagen command.
    *
    *   aliases   An array of kappagen command aliases which can be used to force-trigger kappagens.
    *
    *   cooldown  The number of seconds between force-triggered kappagens using an above alias. Any commands sent before
    *             the cooldown will be ignored, unless the another command shares the same alias.
    *
    *   conga     Settings related to Conga kappagen.
    *
    *    contagious  If TRUE, while one Conga kappagen is visible, all additional kappagens will also be Conga.
    *               If FALSE, Conga kappagns will behave like any other kappagen.
    *
    *    time     The number of seconds the Conga kappagen should show up on the screen for.
    *             This value lets you increase or decrease the chances of keeping a "contagious" Conga line going.
    *
    *    avoidMiddle  If TRUE, conga lines will only show up on the top or bottom three rows to avoid the middle off
    *                the screen globally.
    *             If FALSE, the setting will default to any more specific avoidMiddle Conga settings.
    *
    * emote       Settings related to individual emote display.
    *
    *  time       The number of seconds an emote should show up on the screen for.
    *
    *  max        The maximum nuber of emotes to show on the screen at one time. Set this value to 0 for
    *             infinite emotes. This value should be greater than any "kappa count" values seen above or below
    *             (best would be 4x or more), as it will limit any single kappagen events to this maximum.
    *
    *  queue      The maximum number of emotes to save in queue. Set this value to 0 for an infinite queue.
    *             This value will be ignored if the previous value (cfg.emote.max) is infinite (0).
    *
    *  size       Settings related to the size of emotes.
    *
    *   ratio     Emotes show up in multiple sizes due to the kappagen feature. There are a total of four sizes
    *             that an emote can be:
    *              - The Cube kappagen's faces are squares equal to 80% of the smaller screen dimension
    *                (usually height on PC).
    *              - Pyramid kappagen emotes have a height equal to 1/19th of the screen's width.
    *              - Fireworks, Spiral, and Confetti kappagen emotes have a height equal to the small ratio (see below).
    *              - All standard emotes and kappagens not listed above will use the normal ratio (see below).
    *                Most normal emotes will limit by height, except The Cube, which fits in the center of every side.
    *
    *    normal   A decimal value representing the height of each emote, relative to the smallest screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "1 / n" where n is greater than 10.
    *
    *    small    A decimal value representing the height of small emotes, relative to the smallest screen dimension.
    *             If the height of the screen is less than the width, each emote will be equal to the height of
    *             the screen multiplied by this ratio. Suggested "1 / n" where n is greater than 20.
    *
    *   min       The minimum height of an emote, in pixels.
    *
    *   max       The maximum height of an emote, in pixels.
    *
    *   variation  An integer variable that determines how often occasional random large or small emotes show up.
    *             If FALSE, no variations will occur.
    *
    *  cube      Settings related to The Cube emote.
    *
    *   rotations  The maximum number of rotations a cube might spin while on screen. This effectively controls the
    *             maximum possible speed at which cubes will rotate.
    *
    *  in         Settings related to the showing of an emote.
    *             Note: Some kappagen styles do not use these. See the notes next to each kappagen style name.
    *
    *   fade      A boolean to toggle the "fade in" style.
    *
    *   zoom      A boolean to toggle the "zoom in" style.
    *
    *  out        Settings related to the hiding of an emote.
    *             Note: Some kappagen styles do not use these. See the notes next to each kappagen style name.
    *
    *   fade      A boolean to toggle the "fade out" style.
    *
    *   zoom      A boolean to toggle the "zoom out" style.
    *
    * event       Settings related to channel events which trigger emote-splosions (kappagen).
    *
    *  clear      A boolean to toggle clearing the screen when chat is cleared.
    *              If TRUE, the emote wall will be cleared when the /clear command is used.
    *              If FALSE, the emote wall will ignore the /clear command.
    *
    *  raid       Settings related to kappagens when being raided.
    *
    *   raiders   A streamer raids the channel with viewers. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all raids.
    *              If FALSE, no kappagen will occur on raids.
    *              If Integer, the value is the minimum raiders required for a raid to trigger a kappagen.
    *               If 0, no kappagen will occur on raid.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   originEmotes  A boolean to toggle the use of the raiding streamer's channel emotes for raid kappagens.
    *                If TRUE, raid kappagens will use channel emotes from the raider's channel.
    *               If FALSE, raid kappagens will use your channel's emotes.
    *
    *  follow     A user follows the channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  shoutout   Settings related to kappagens on a shoutout event. Requires "moderator:read:shoutouts" scope.
    *             Note: Shoutout event booleans can also be arrays of kappa styles. This will override the default list
    *                   of kappa styles for the particular event in question.
    *
    *   create    Settings related to kappagens when you shout another channel out.
    *
    *    styles   You shout another channel out. This value can be a boolean or array.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   targetEmotes  A boolean to toggle the use of the target channel's emotes for shoutout kappagens.
    *                If TRUE, shoutout kappagens will use channel emotes from the target's channel.
    *               If FALSE, shoutout kappagens will use your channel's emotes.
    *
    *   receive    Settings related to kappagens when another channel shouts you out.
    *
    *    styles   You are shouted out by another channel. This value can be a boolean or array.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   originEmotes  A boolean to toggle the use of the source channel's emotes for shoutout kappagens.
    *                If TRUE, shoutout kappagens will use channel emotes from the source's channel.
    *               If FALSE, shoutout kappagens will use your channel's emotes.
    *
    *  tag        Settings related to kappagens when users tag a channel you've tagged in your stream title.
    *
    *   styles     A user posts a message that starts with '@user'. This value can be a boolean or array.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   access    A bitwise flag representing which users can trigger this kappagen with a command.
    *             This value will fall back to the general kappagen access value if missing or less than 0.
    *
    *   targetEmotes  A boolean to toggle the use of the target channel's emotes for tag kappagens.
    *                If TRUE, tag kappagens will use channel emotes from the target's channel.
    *               If FALSE, tag kappagens will use your channel's emotes.
    *
    *  sub        Settings related to kappagens on a subscribe event.
    *             Note: Sub event booleans can also be arrays of kappa styles. This will override the default list
    *                   of kappa styles for the particular event in question.
    *
    *   useMsg    If TRUE, any emotes in resub messages will be used for the kappagen.
    *             If FALSE, any emotes in resub messages will show up like normal emotes.
    *
    *   t1        Settings related to kappagens on a tier 1 subscribe event.
    *
    *    first    A user subscribes at Tier 1 for the first time.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    resub    A user resubscribes at Tier 1. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Tier 1 resubs.
    *              If FALSE, no kappagen will occur on T1 resubs.
    *              If Integer, the value is the minimum months required for a Tier 1 resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    upgrade  Settings related to "converted" subscriptions.
    *
    *     gift     A user upgrades a gift sub to Tier 1.
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     prime    A user upgrades a Prime sub to Tier 1.
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    gift     Settings related to tier 1 gifts.
    *
    *     first   A user gifts another user their first Tier 1 subscription.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     resub   A user gifts another user a Tier 1 resubscription. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Tier 1 gift resubs.
    *              If FALSE, no kappagen will occur on T1 gift resubs.
    *              If Integer, the value is the minimum months required for a Tier 1 gift resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *     bomb    A user gifts multiple Tier 1 subscriptions. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on any random gift.
    *              If FALSE, no kappagen will occur on giftbombs.
    *              If Integer, the value is the minimum gifts required for a gift bomb to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur on any random gift.
    *               If greater than 1, the number of gifted users in a Tier 1 giftbomb must be greater than or equal to
    *               this number to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   t2        Identical to t1, but for Tier 2 subscriptions.
    *
    *   t3        Identical to t1, but for Tier 3 subscriptions.
    *
    *   prime     Settings related to kappagens on an Amazon Prime subscribe event.
    *
    *    first    A user subscribes with Prime for the first time.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *    resub    A user resubscribes with Prime. This can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all Prime resubs.
    *              If FALSE, no kappagen will occur on Prime resubs.
    *              If Integer, the value is the minimum months required for a Prime resub to trigger a kappagen.
    *               If 0, no kappagen will occur.
    *               If 1, a kappagen will occur every month.
    *               If greater than 1, the number of months subscribed must be greater than or equal to this number
    *               to trigger a kappagen.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-9', or an open-maximum range such as '10+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  cheer      Settings related to kappagens on a cheer event.
    *
    *   useMsg    If TRUE, any emotes in cheer messages will also be included in the kappagen.
    *             If FALSE, any emotes in cheer messages will show up like normal emotes.
    *
    *   bits       Minimum number of bits for a kappagen. This value can be a boolean, integer, or array:
    *              If TRUE, a kappagen will occur on all cheers.
    *              If FALSE, no kappagen will occur on cheers.
    *              If Integer, the value is the minimum bits required for a cheer to trigger a kappagen.
    *               If 0, no kappagen will occur on cheer.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-499' or '2500-4999', or an open-maximum range such as '7500+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  badge      Settings related to users earning bits badges.
    *             This section is more "fluid" than other sections.
    *             Each entry is a number representing a bits badge and a kappa boolean value.
    *             For example:
    *   '1'        If TRUE, a kappagen will occur when a user gets their 1 bit badge.
    *              If FALSE, no kappagen will occur for 1 bit badges.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *             If a user earns a bits badge for a number not listed in the array, the system will find the number
    *             which is closest to the badge, favoring the lower number in case of a tie.
    *             For example:
    *   '100': false
    *   '5000': true
    *              If a user earns their 1000 bits badge, no kappagen will occur because 1000 is closer to 100
    *              than 5000.
    *              If a user earns their 10000 bits badge, a kappagen will occur because 5000 is the closest
    *              listed number.
    *             Note: The numbers must be strings (in 'single quotes') to function properly.
    *
    *  hypetrain  Settings related to hype trains.
    *
    *   begin     A hype train begins in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   success   Minimum level for a kappagen on hype train completion. This value can be a boolean, integer, or
    *              array:
    *              If TRUE, a kappagen will occur on all hype train completions.
    *              If FALSE, no kappagen will occur on hype train completions.
    *              If Integer, the value is the minimum level required for a hype train to trigger a kappagen.
    *               If 0, no kappagen will occur on hype train success.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-5' or '6-10', or an open-maximum range such as '11+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  poll       Settings related to polls.
    *
    *   begin     A poll begins in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   end       A poll ends in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  prediction  Settings related to predictions.
    *
    *   begin     A prediction begins in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   resolved  A prediction ends in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  goal       Settings related to goals.
    *
    *   begin     A goal begins in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *   achieved  A goal ends in your channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  charity    A charity donation is made in the channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  timeout    Minimum time for a kappagen when a user is timed out. This value can be a boolean, integer, or
    *              array:
    *              If TRUE, a kappagen will occur on all timeouts.
    *              If FALSE, no kappagen will occur on timeouts.
    *              If Integer, the value is the minimum seconds required for a timeout to trigger a kappagen.
    *               If 0, no kappagen will occur on timeouts.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '5-30' or '60-180', or an open-maximum range such as '300+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  ban        A user is banned in the channel.
    *              If TRUE, a kappagen will occur.
    *              If FALSE, no kappagen will occur.
    *              If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *
    *  tip        Settings related to third-party tip systems.
    *
    *   useProfileImage  If TRUE, tips will use the tipper's profile image instead of emotes.
    *                   If FALSE, tips will use your standard kappagen emotes.
    *
    *   streamlabs  Settings related to Streamlabs payment events.
    *
    *    donation  Minimum tip amount through Streamlabs for a kappagen. This value can be a boolean, integer,
    *              or array:
    *              If TRUE, a kappagen will occur on all Streamlabs tips.
    *              If FALSE, no kappagen will occur on tips.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on tips through Streamlabs.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamlabs.curMul setting (see above)
    *              based on your default currency in Streamlabs.
    *
    *    pledge   Minimum pledge amount through Streamlabs for a kappagen. This value can be a boolean, integer,
    *             or array:
    *              If TRUE, a kappagen will occur on all Streamlabs pledges.
    *              If FALSE, no kappagen will occur on pledges.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on pledges through Streamlabs.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamlabs.curMul setting (see above)
    *              based on your default currency in Streamlabs.
    *
    *   streamelements  Minimum tip amount through StreamElements for a kappagen. This value can be a boolean,
    *                  integer, or array:
    *              If TRUE, a kappagen will occur on all StreamElements tips.
    *              If FALSE, no kappagen will occur on tips.
    *              If Integer, the value is the minimum amount required for a tip to trigger a kappagen.
    *               If 0, no kappagen will occur on tips through StreamElements.
    *              If Array, each key of the array should be a string containing a range of integers,
    *              such as '1', '2-4' or '5-19', or an open-maximum range such as '20+'.
    *              Each value follows the standard rule:
    *               If TRUE, a kappagen will occur.
    *               If FALSE, no kappagen will occur.
    *               If an array of kappa styles, a kappagen of one of the listed styles will occur.
    *              The values used in these ranges can be controlled with the cfg.streamelements.curMul setting (see above)
    *              based on your default currency in StreamElements.
    *
    * commands    An array of commands which can trigger one or more kappagens, or clear the screen.
    *             Each command is an object with the following properties:
    *
    *  aliases    An array of kappa command aliases which can be used to force-trigger this kappagen.
    *
    *  access     A bitwise flag representing which users can trigger this kappagen with a command.
    *             This value will fall back to the general kappagen access value.
    *
    *  cooldown   The number of seconds between force-triggered kappagens using an above alias. Any commands sent before
    *             the cooldown will be ignored, unless the another command shares the same alias.
    *             This value is optional; no value is the same as a value of 0, which is, no cooldown.
    *
    *  redeem     An array of style-specific channel point reward names which can be used to force-trigger this kappagen.
    *
    *  erase      If this property exists, the command will erase the screen rather than showing a style. Any 'styles'
    *             property will be ignored, regardless of the value of erase.
    *
    *  styles     An array of styles. A kappagen of one of the listed styles will occur upon command.
    *
    * ignore      Ignore Lists
    *
    *  users      Users who should be ignored.
    *              If FALSE, no users will be ignored.
    *              If an array of strings, these user names will not be able to make emotes show up.
    *
    *  emotes     Emotes which should be ignored.
    *              If FALSE, no emotes will be ignored.
    *              If an array of strings, these emotes will not show up.
    *               (You can also use \u{XXXXX} escape'd emojis)
    *
    *
    * Note on Event and Command Kappagen Entries
    * ------------------------------------------
    *
    * Keep in mind that kappagen arrays are also associative, and may have independent settings for kappas such as
    * TheCube and Text. The kappagen style can also contain the following values:
    *
    *  count      The number of emotes to show for this kappagen. This can be an integer or an object.
    *              If this property does not exist, it will fall back to the count setting for the kappagen style.
    *               If the kappagen style has no count property, then the global kappagen count will be used.
    *              If Integer, this is the number of emotes that will be shown in this kappagen.
    *              If Object:
    *
    *   default   The number of emotes to show for this kappagen by default. This must be an integer.
    *              If this property does not exist, it will fall back as the parent count would.
    *              If Integer, this is the number of emotes that will be shown in this kappagen.
    *
    *   dynamic   This is a boolean value to determine if the count can be changed by users.
    *              If this property does not exist, it will fall back to FALSE.
    *              If TRUE, a user may include a number in the command's parameters, and that number will be used.
    *              If FALSE, the default count will be used exclusively.
    *
    *   maximum   The maximum number of emotes to show for this kappagen if dynamic is set to TRUE. This must be
    *             an integer.
    *              If this property does not exist, it will fall back to the maximum number of emotes allowed on screen.
    *              If Integer, this is the maximum number of emotes this kappagen style can display.
    *
    * emotes      A list of emotes that will be used for this kappagen. This can be an array or an object.
    *              If Array, each entry must be a string containing the name or URL of an emote, or an emoji.
    *               Please note that only your channel or global emotes can be named (including 3rd-party).
    *              If object:
    *
    *  list       This must be an array of strings, the same as the Array entry of the parent emotes property above.
    *
    *  dynamic    This is a boolean value to determine if the displayed emotes can be set by the user.
    *              If this property does not exist, it will fall back to TRUE.
    *              If TRUE, a user may include emotes in the command's parameters, and those emotes will be used.
    *              If FALSE, only the emotes in the list property above will be used.
    *
    *
    * Additional Notes and Caveats
    * ============================
    *
    * Update Procedure
    * ----------------
    *
    *  To update this emote wall, simply use the Wizard to import and download it.
    *   1) Visit the official page <https://realityripple.com/Tools/Twitch/EmoteWall/>.
    *   2) Under "Config Wizard", click "Authorize on Twitch".
    *   3) Import this HTML file by clicking Import.
    *   4) Make any changes you need to make on each page.
    *   5) At the end of your configuration, hit "Download".
    *  You will receive a new version of this HTML file with your previous settings.
    *
    *
    * Emojis
    * ------
    *
    *  Twitch filters out the ZWJ (Zero-Width Joiner) character which is used for merging many emojis.
    *  This system makes use of basic character detection to correctly parse many standard ZWJ-style emojis even without
    *  the ZWJ character, however more complicated sets such as the "family units" are not possible to correctly handle.
    *  The alternative character 0xE0002 used by some third-party Twitch chat projects will be correctly parsed as a
    *  ZWJ according to the rules laid out in the RFC:
    *   <https://gist.github.com/Mm2PL/982c76964fe53f80fcf6b6963bba049f>
    *
    *
    * Emote Dimensions
    * ----------------
    *
    *  Emotes that are not square will be shrunk to fit while maintaining the original aspect ratio.
    *
    *
    * Cheers
    * ------
    *
    *  The cheer style will be used for kappagens. If a user cheers 1000 bits in a single 1000 bit emote, then the
    *  kappagen will be made of the 1000-bit cheers. However, if the user cheers 1000 bits using multiple smaller cheer
    *  emotes, those emotes will be used for the kappagen instead.
    *
    *
    * Kappagen
    * --------
    *
    *  Each emote-splosion uses the number of emotes defined in the kappa count preference mentioned above, except
    *  Pyramid, which uses a constant number based on the pyramidDist array (below). If the trigger includes specific
    *  emotes (via kappagen, cheer, or resub message), the ratio of one emote to another will be maintained.
    *  If a user with kappa access posts "!kappagen PunchTrees PunchTrees SSSsss" then two thirds of the emotes in
    *  the emote-splosion will be "PunchTrees", and one third will be "SSSsss".
    *
    *
    * OBS
    * ---
    *
    *  This emote wall may do better if the browser source has a frame rate limit of 30 or 60.
    *  If you use your GPU while streaming, you may wish to disable Browser Source Hardware Acceleration.
    *  It may also work better using a smaller screen resolution (such as 720p on a 1080p screen) and then stretching
    *  the browser source to fit to the screen using the OBS Transform feature.
    *
    *
    * Inefficiencies
    * --------------
    *
    *  This emote wall uses normal <img> objects rather than a HTML Canvas. While this lowers efficiency, it also adds
    *  better GIF file support and allows easier user manipulation.
    *
    *  At present, the "zoom in" and "zoom out" feature uses a resource-heavy design. I had hoped the new CSS directive
    *  "scale: " would have helped, however it's useless without a "scale-origin" directive to accompany it.
    *
    *  The Bounce animation uses specific position-based drawing rather than actually being animated.
    *
    *  The Cube animation uses eight objects on screen for every image, making it a particularly resource-heavy drawing.
    *
    *  If your computer has trouble with this emote wall, please try disabling these options.
    *
    */

   /* jshint esversion: 11, bitwise: false, eqeqeq: true, loopfunc: true, forin: true, freeze: true, futurehostile: true, leanswitch: true, noarg: true, nocomma: true, nonbsp: true, nonew: true, noreturnawait: true, quotmark: single, shadow: outer, singleGroups: false, strict: global, trailingcomma: false, undef: true, unused: true, varstmt: true */

   var cfg = {
    channel: 'CHANNEL_NAME',
    login: {
     client: '4umzcpmjkg6ar78b81s7302jlj33t8',
     oauth_refresh: 'OAUTH_REFRESH',
     scope: [
      'chat:read',                 // required
    //'moderator:read:followers',  // optional. only required if you use follow events or access
    //'channel:read:redemptions',  // optional. only required if you use channel point redeem commands
    //'channel:read:hype_train',   // optional. only required if you use hype train events
    //'channel:read:goals',        // optional. only required if you use goal events
    //'channel:read:polls',        // optional. only required if you use poll events
    //'channel:read:predictions',  // optional. only required if you use prediction events
    //'channel:read:charity',      // optional. only required if you use Twitch charity events
    //'moderator:read:shoutouts'   // optional. only required if you use shoutout events
     ]
    },
    streamlabs: {
     token: 'SOCKET_TOKEN', //Requires socket.token
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    streamelements: {
     oauth_refresh: 'OAUTH_REFRESH', //Requires tips:read
     token: 'JWT_TOKEN',
     curMul: 100,
     dispMul: 1,
     dispDec: 2,
     dispPre: '$',
     dispSuf: false
    },
    display: {
     styles: [
    //'Still',        // No movement
      'StraightLine', // Gentle movement in a random straight line
      'Rise',         // Slowly rise to top while wobbling back and forth
      'Bounce',       // Fall from the top at an angle and bounce along the bottom (Windows Solitaire style)
      'Speed',        // Zoom across the screen
      'Drop',         // Get stuck at the top and tumble down (no fade/zoom in, only out)
      'Crazy',        // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
      'Confetti',     // Fall like confetti                   (no zoom, no fade in, only fade out)
      'Throw',        // Toss at the middle and tumble down   (no fade/zoom in, only out)
      'TheCube'       // Rotate a 3D cube of an emote         (no zoom, only fade)
     ],
     access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x004 | 0x002 | 0x001,
     duplicates: true,
     useEmoji: true,
     extended: {
      useFFZ: true,
      useBTTV: true,
      use7TV: true,
      useZWE: true
     },
     kappa: {
      count: 150,
      styles: {
       'Rise': {},        // Slowly rise to top while wobbling back and forth
       'Speed': {},       // Zoom across the screen
       'Crazy': {},       // Bounce off the walls [Layout Shifts - Requires offset-anchor / offset-position directives]
       'Burst': {},       // Expand from a center point
       'Fireworks': {},   // Burst out from a single emote (no fade/zoom; small emotes)
       'Spiral': {},      // Burst out from a single emote in a spiral (no fade/zoom; small emotes)
       'Pyramid': {},     // Build a pyramid        (no fade/zoom; specific-size emotes)
       'SmallPyramid': {},// Build a small pyramid  (no fade/zoom; small emotes)
       'Fountain': {},    // Spout from a fountain  (no fade/zoom)
       'Stampede': {},    // Stampede of emotes     (no fade/zoom)
       'Confetti': {},    // Fall like confetti     (no zoom, no fade in, only fade out; small emotes)
       'Conga': {},       // Start a conga line     (no fade/zoom)
       'TheCube': {       // Rotate a 3D cube of an emote (no zoom, only fade)
        size: 8/10,
        center: true,
        rotations: 5
       },
       'Text': {          // Show a message         (no fade/zoom; specific-size emotes)
        message: ['HYPE!'],
        time: 3
       }
      },
      access: 0x800 | 0x400 | 0x200 | 0x100 | 0x080 | 0x040 | 0x020 | 0x010 | 0x004 | 0x002,
      aliases: [      // !kappagen command aliases (must be lower-case)
       '!kappagen',
       '-kappagen'
      ],
      cooldown: 0,
      conga: {
       contagious: false,
       time: 5,
       avoidMiddle: false
      }
     }
    },
    emote: {
     time: 5,
     max: 0,
     queue: 0,
     size: {
      ratio: {
       normal: 1/12,
       small: 1/24
      },
      min: 16,
      max: 112,
      variation: false
     },
     cube: {
      rotations: 5
     },
     in: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     },
     out: {
      fade: true,
      zoom: true /* Layout Shifts - Requires independent scale directive */
     }
    },
    event: {
     clear: true,
     raid: {
      raiders: 2,
      originEmotes: true
     },
     follow: true,
     shoutout: {
      create: {
       styles: false,
       targetEmotes: true
      },
      receive: {
       styles: false,
       originEmotes: true
      }
     },
     tag: {
      styles: true,
      access: -1,
      targetEmotes: true
     },
     sub: {
      useMsg: true,
      t1: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      t2: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      t3: {
       first: true,
       resub: true,
       upgrade: {
        gift: false,
        prime: false
       },
       gift: {
        first: true,
        resub: true,
        bomb: 1
       }
      },
      prime: {
       first: true,
       resub: true
      }
     },
     cheer: {
      useMsg: true,
      bits: 50
     },
     badge: {
      '1': false,
      '100': true
     },
     hypetrain: {
      begin: false,
      success: false
     },
     poll: {
      begin: false,
      end: false
     },
     prediction: {
      begin: false,
      resolved: false
     },
     goal: {
      begin: false,
      achieved: false
     },
     charity: false,
     timeout: false,
     ban: false,
     tip: {
      useProfileImage: false,
      streamlabs: {
       donation: false,
       pledge: false
      },
      streamelements: false
     }
    },
    commands: [],
    ignore: {
     users: false,
     emotes: false
    }
   };

   /* potentially alterable arrays */

   // list of default images to use if your channel has no emotes
   const bareList = [
    {url: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAHv0lEQVRIx52Xa6xdRRXHf2vN7L3Puff29ra37yfQaCPGkPIwoCLVhEQEDaCngaAGo8FErZCI1gTweD6QKIiBEkyKhoBSwXtDwEaKhkQKJmKLgIRCebbIoy19nnse9+zHPPzQNBSwIbjm02Stmd9kzays/wjHsQgiEO+84YoVRcyWTHUPLo7en7Hn9d033Lzx73tiRESIfEjT4zkmGw0F6HTanyh7B7dU/emNVsJVs+bOu/eW5mWja9Y0tNlsagT5MED5AF9srv3CaNUfXOyD+eycRfO/MWfuAtPrTl+79qcbrj8a2Gw2FbYorA6tViv8v0AAaTabptVquesuP/2MkdkLtg7NXhBdOXi12L39osolnVQXtdfdsan7DhyFJscDHw8oExMNXbNm0h+dX3vpqptr1v/A1lI/OjZmYrRtlZpIUj8coj5RVINHyqr/t3W3/PVFgEajYSYmJ4Pw7nt+H7DZbOrR023YsCEx+5+6rMx738q7Bz4diq6kSUY2YzyabEQEQQVwJSE6Bnk5IPjNkNz4/Zvu2/re/d4HPOpsNpvp4uzgV9T7q+qZ/WReDBj0exByYvCEqkAkRqInEWJEYlSDijEKDArnPOY2V0+vW3fjpu6xUHkvbP013z7RSnF3lphPeVeSD6ZDWQwioTTiSkIxQDRijCAmJbGGrJYRAkznVQw+hBiCSW2Kk/RpOzr7krU//+NLR/eXd14ZzMkOzDKDzqM18R+f6rS9K3MJZaExBvAFKhCrkqRex0gkhIhNE9IsJQbPdKdHnjti8DFGfH1k1Gpt1i4dqp975S8feLXZbKoAxGZTpdUK6398ye+GEv/1TrdbRV8mrsiJVUHwnsREgnfEqkSzYWr1FOcqVBQ1hhADMrScUJ9HXnm06BP6b7skdq1kM5+gPvOczuhkIRONhlkzOelvW3f5l6Kb2pRPt31wTkNVSAweO3M5YXgJQRLU9Um6O/G93ST1YQieGCMiEbPkcwxGV1J5jw+RsshJ80PY/U+7WjhsQ33mD6++7aFfydFaG+88uw0/WDXdPeQlOCOSYJaeTTW0hLRWx3tP5Rwz6inujX/C1AvYJCV4j5m9gmL8TLpFiarBZgndTg8rih56JWbt5zCm3Lv0rHNWKRAXFS+vTjSsKnpTIVbO4D31E84mH17KvLkZr778DK+99gpWhW4/p5x1CmZ0OWmWktWGiPVllN5TGxqiDCV/uHMD9917B/94/BGKoXniagshxIWHdz5/lgK4qrzQ+AJX5pEqx44s5LCO85cH72Fy8m42P/Qn7r9/I/9+5kmSJGVs3nx05knYbBg1lsGgwBrlwP79PLjpPt54fSeHD+3n8cce5l9PPYEdWxSNSaj6vfMVILr8hKoYQAhI8ITaHJ58eht552127XoTH47Uz7ZtjzHVbVNVJWXMqFwgEul326hJeev1nex88XlUFR8CWVbjhR3b6RVObGKJMZ6hExPNNPq4ILoSE5wokW63x7639+Ax1LIUawVjDVVZ0p1qUwwGFNN9Ovvfoju1j+rQfyA4EqOIRIL3BOfwztHvdfFugOIBRrX/XHtIcKORgEhEgkPKNmoMg8LRy3NAjgwxZFl2pBH295J3DpBP96kO7KDzxvOsWLGS8bExfDiSEmst8+YvoB7auGIKCRQ6zNi0TbSfWINai1dDVh5gzoyMaFJUDd57ut0OH/3IShYvWkwYdHDt7ZAIqGNoCDrPbSarpjjv/Is56cQTmTtvPguXLef0lQuYUe6KagRR7QjA7T+6cJN17Qum2p1QDXLjfUFX5/DkoWH27DtACBXLlp7E6tXnYQn0Xvoz9HagmqAGEEsxqJguhBlLzySPNQ4c3EtNpliYTmHwYWR4ljozdLsA/HbdV9da311/uH3QV4PChBjwxTSuvoCpZCn1WUsZHx+nnNpLvnsr6vZiswwJDrUGxEBUnHPk/QKT1KgN10mtx1cOIY1JUkeTkfME4NfNi+ZxqLMjuulZea8fXai0Kkq8c2AMPiZ4PInkpImgWR2xigaPGIMYS3AeNQbBEqNDjYVoCJXzNZsap7WttfCxs3Wi0TDfbd2/z1X+plqSCqJBRTFqscagGkniNMOppz5Ux6Y1VARrDUYVjWCNYo2gRlAFq4qiiA+RKsYYFbG11nduv72SCPKzZlN4bUs6XgsPJ7H8TK/XcYhYV5SgEQFEFbGgakBBU4uEAD5gspToPRgDGHAeURt8XvnMDiXTpvaLq3/z6E8ajYbRoxKgddejeWHs14pod9VrIxaxTkwSBIOogSgQDTFAqCAWgRjAOwiVJ4RIqAKUPgQnXoLRWjqcDKjfs+zc713TbKKTRyTHuxvw9d/8/MnDkv9ecae6qqIoyigaQqyCSGJEjYD3ICAWYhmipvZIGkLURFNRW6fw+mYgual/wpb1rZbEeKTbx/dIDLTVIjQvOG1odIxLQ2Stip5iTcSVBa7yaGII3kMI2FSJHowx2EQpKsGRbMekGwc6887WXZv3His5jyOijkABmo1zRkbq8YsR/+UY3Mm+KBcgMiwabXAxGkMeQjwUot1rUvNsCMkDI3NPfezKW28tAI722g+UiRFkstHQY4OvuOK0ZFl/zpxAOWqMZD4vRGxou2rJwdbkZO/Y9RONhmlMTIb/9RX4Ly/EQPT2tQstAAAAAElFTkSuQmCC'}
   ];

   // distribution of emotes for Pyramid and SmallPyramid kappagen
   const pyramidDist = [1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1];

   // treat these BTTV emotes as zero-width (overlapping) emotes
   const bttvZWE = [
    'SoSnowy',  'IceCold',   'SantaHat', 'TopHat',
    'ReinDeer', 'CandyCane', 'cvMask',   'cvHazmat'
   ];

   // distribution of emotes for letters in message kappagens
   const alnumDist = {
    'A': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'a': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'B': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    'b': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'C': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0]
    ],
    'c': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'D': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'd': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'E': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'e': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'F': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'f': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    'G': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 1, 0, 0]
    ],
    'g': [
     [1, 0, 0, 1, 1, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'H': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'h': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0]
    ],
    'I': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'i': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'J': [
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'j': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0]
    ],
    'K': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'k': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'L': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'l': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'M': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'm': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'N': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'n': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'O': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'o': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'P': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    'p': [
     [1, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 1, 0, 0, 0, 0]
    ],
    'Q': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [1, 1, 0, 1, 1, 1, 1, 0, 0]
    ],
    'q': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'R': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 1, 0, 0]
    ],
    'r': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'S': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    's': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    'T': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    't': [
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0]
    ],
    'U': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'u': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'V': [
     [0, 0, 0, 0, 1, 1, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 1, 1, 0]
    ],
    'v': [
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0]
    ],
    'W': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'w': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 0, 0, 0]
    ],
    'X': [
     [0, 1, 1, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 0, 1, 1, 0]
    ],
    'x': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'Y': [
     [0, 0, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    'y': [
     [1, 0, 0, 1, 1, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'Z': [
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0]
    ],
    'z': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '1': [
     [0, 1, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '2': [
     [0, 1, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '3': [
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '4': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0]
    ],
    '5': [
     [0, 0, 1, 0, 0, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 0, 1, 0]
    ],
    '6': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0]
    ],
    '7': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    '8': [
     [0, 0, 1, 1, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '9': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 1, 1, 0, 0]
    ],
    '0': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    ':': [
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    '.': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    ',': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '\'': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 1]
    ],
    '-': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '_': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '+': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '=': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0]
    ],
    '!': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    '@': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 1, 1, 0, 0]
    ],
    '#': [
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    '$': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [1, 1, 1, 1, 1, 1, 1, 1, 1],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    '\u00a2': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '\u20ac': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    '\u00a3': [
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '\u00a5': [
     [0, 0, 0, 0, 1, 0, 1, 1, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 1, 0]
    ],
    '%': [
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0]
    ],
    '?': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ]
   };

   //////////////////////////////////////////////////////////////////////////////
   // don't mess with things below this line without knowing what you're doing //
   //////////////////////////////////////////////////////////////////////////////
   if (typeof cfg === 'undefined')
    throw new Error('Corrupted Configuration detected.');
   document.title = cfg.channel + ' Emote Wall';

   let cList = [];
   const wWS = 5;
   const cURLs = {
    ws: {
     twitch: {
      irc: 'wss://irc-ws.chat.twitch.tv',
      eventSub: {
       beta: 'wss://eventsub-beta.wss.twitch.tv/ws',
       release: 'wss://eventsub.wss.twitch.tv/ws'
      }
     },
     streamlabs: 'wss://sockets.streamlabs.com/socket.io/?transport=websocket&token=%TOKEN%',
     streamelements: 'wss://realtime.streamelements.com/socket.io/?transport=websocket',
     bttv: 'wss://sockets.betterttv.net/ws',
     '7tv': 'wss://events.7tv.io/v3'
    },
    api: {
     twitch: {
      users: {
       name: 'https://api.twitch.tv/helix/users?login=%USER%',
       id: 'https://api.twitch.tv/helix/users?id=%USER_ID%',
      },
      bits: {
       cheermotes: 'https://api.twitch.tv/helix/bits/cheermotes?broadcaster_id=%CHANNEL_ID%'
      },
      channels: {
       root: 'https://api.twitch.tv/helix/channels?broadcaster_id=%CHANNEL_ID%',
       followers: 'https://api.twitch.tv/helix/channels/followers?user_id=%USER_ID%&broadcaster_id=%CHANNEL_ID%'
      },
      chat: {
       emotes: {
        root: 'https://api.twitch.tv/helix/chat/emotes?broadcaster_id=%CHANNEL_ID%',
        global: 'https://api.twitch.tv/helix/chat/emotes/global'
       }
      },
      eventSub: {
       get: 'https://api.twitch.tv/helix/eventsub/subscriptions',
       delete: 'https://api.twitch.tv/helix/eventsub/subscriptions?id=%ID%'
      }
     },
     ffz: {
      set: {
       global: 'https://api.frankerfacez.com/v1/set/global'
      },
      room: 'https://api.frankerfacez.com/v1/room/id/%CHANNEL_ID%'
     },
     bttv: {
      emotes: {
       global: 'https://api.betterttv.net/3/cached/emotes/global'
      },
      users: {
       twitch: 'https://api.betterttv.net/3/cached/users/twitch/%CHANNEL_ID%'
      }
     },
     '7tv': {
      emotes: {
       global: 'https://api.7tv.app/v2/emotes/global'
      },
      users: {
       root: 'https://api.7tv.app/v2/users/%CHANNEL_ID%',
       emotes: 'https://api.7tv.app/v2/users/%CHANNEL_ID%/emotes'
      }
     }
    },
    cdn: {
     twitch: {
      emote: 'https://static-cdn.jtvnw.net/emoticons/v2/%EMOTE_ID%/default/dark/3.0'
     },
     ffz: {
      emoji: 'https://cdn.frankerfacez.com/static/emoji/images/%SET_ID%/'
     },
     bttv: {
      emote: 'https://cdn.betterttv.net/emote/%EMOTE_ID%/3x'
     },
     crew: 'https://uploads.realityripple.com/Pictures/crew/%DIRECTION%/%COLOR%.png'
    },
    html: {
     rr: {
      wizard: 'https://realityripple.com/Tools/Twitch/EmoteWall/wizard.php',
      t: 'https://realityripple.com/Tools/Twitch/EmoteWall/oauth2t.php?refresh=%REFRESH_TOKEN%',
      se: 'https://realityripple.com/Tools/Twitch/EmoteWall/oauth2se.php?refresh=%REFRESH_TOKEN%',
      redir: 'https://realityripple.com/Tools/Twitch/tempRedir.php?t=code&c=%CLIENT_ID%&r=%URL%&s=%SCOPE%&u=%ORIGIN%'
     },
     twitch: 'https://id.twitch.tv/oauth2/authorize?client_id=%CLIENT_ID%&redirect_uri=%URL%&response_type=code&scope=%SCOPE%&state=redirto_%ORIGIN%&force_verify=true'
    }
   };

   const display = function()
   {
    let _eActive = 0;
    let _iTitanic = 0;
    const _tStart = 48;
    const _tAnim = {
     fade: {
      in: 8,
      out: 8
     },
     zoom: {
      in: 17,
      out: 8
     }
    };

    const emote = function()
    {
     let _toShow = [];

     let _tEmote = false;

     const list = function()
     {
      function Still(url, zwe, sW, sH, sS, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const h = shared.rnd(sW - sS);
       const v = shared.rnd(sH - sS);
       let s = 'top: ' + v + 'px;';
       s += ' left: ' + h + 'px;';
       s += ' height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
       _addEmoteToDoc(tInit, url, s, false, {space: false});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        _addEmoteToDoc(tInit, zwe[i].url, s, false, {space: false});
       }
      }

      function StraightLine(url, zwe, sW, sH, sS, x = false, y = false, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sSm = Math.ceil(sS / 2);
       let h = x;
       if (h === false)
        h = shared.rnd(sW) - sSm;
       let v = y;
       if (v === false)
        v = shared.rnd(sH) - sSm;
       const r = Math.min(sW, sH) * (shared.rnd() + 1);
       const cRadius = Math.PI * 2;
       let th = shared.rnd() * cRadius;
       let hD = Math.floor(h + r * Math.cos(th));
       let vD = Math.floor(v + r * Math.sin(th));
       if (!x && !y)
       {
        const sR = sW - sS - sSm;
        const sB = sH - sS - sSm;
        while ((h < sSm && hD < sSm) || (v < sSm && vD < sSm) || (h > sR && hD > sR) || (v > sB && vD > sB))
        {
         th = shared.rnd() * cRadius;
         hD = Math.floor(h + r * Math.cos(th));
         vD = Math.floor(v + r * Math.sin(th));
        }
       }
       let s = 'height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       s += ' transition: transform ' + cfg.emote.time + 's linear;';
       s += ' transform: translate(' + h + 'px, ' + v + 'px);';
       s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
       _addEmoteToDoc(tInit, url, s, false, {}, {x: hD, y: vD});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        _addEmoteToDoc(tInit, zwe[i].url, s, false, {}, {x: hD, y: vD});
       }
      }

      function Rise(url, zwe, sW, sH, sS, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sSm = Math.ceil(sS / 2);
       const h = shared.rnd(sW) - sSm;
       const v = Math.floor(shared.rnd(0.3) * sH) + Math.floor(0.8 * sH);
       let s = 'left: ' + h + 'px;';
       s += ' height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       if (cfg.emote.out.fade || cfg.emote.out.zoom)
        s += ' offset-path: path("M 0 ' + v + ' L 0 ' + Math.floor(v * 0.05) + '") ;';
       else
        s += ' offset-path: path("M 0 ' + v + ' L 0 -' + sS + '") ;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       if (shared.rnd(2) === 0)
        aNames.push('wiggleL');
       else
        aNames.push('wiggleR');
       const d = shared.rnd(600);
       aDelays.push(d + 'ms');
       const w = shared.rnd(3) + 2;
       aDurs.push(w + 's');
       aTimings.push('ease-in-out');
       aFills.push('both');
       aIters.push('infinite');
       aNames.push('offsetPath');
       aDelays.push('0s');
       aDurs.push(cfg.emote.time + 's');
       aTimings.push('linear');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
       _addEmoteToDoc(tInit, url, s, false, {space: false});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        _addEmoteToDoc(tInit, zwe[i].url, s, false, {space: false});
       }
      }

      const Bounce = function()
      {
       const _ms = 20;

       function task(url, zwe, sW, sH, sS, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         sS = Math.ceil(sS / 2);
        else if (variationSize === 2)
         sS = sS * 2;
        const sSm = Math.ceil(sS / 2);
        const sWm = Math.ceil(sW / 2);
        const h = Math.floor(shared.rnd(sW) - sSm);
        const v = Math.floor(shared.rnd(0.2) * sH);
        let velH = shared.rnd(6) + 3;
        const velV = shared.rnd(3) + 4;
        if (h + sSm > sWm)
         velH = -1 * velH;
        let s = 'height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        let bX = h;
        let bY = v;
        let velY = velV;
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, url, s, true));
        for (let i = 0, l = zwe.length; i < l; i++)
        {
         iArr.push(_addEmoteToDoc(tInit, zwe[i].url, s, true));
        }
        window.setTimeout(_tLoop, _ms, tInit, iArr, bX, bY, velH, velY, sH, sS);
       }

       function _tLoop(tInit, iArr, bX, bY, velH, velY, sH, sS)
       {
        if (_iTitanic > tInit)
         return;
        if (iArr[0].parentElement === null)
         return;
        bX += velH;
        bY += velY;
        velY += 1;
        const sB = sH - sS;
        if (bY >= sB)
        {
         bY = sB;
         velY *= -0.7;
         velY = Math.floor(velY);
        }
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].style.transform = 'translate(' + bX + 'px, ' + bY + 'px)';
        }
        window.setTimeout(_tLoop, _ms, tInit, iArr, bX, bY, velH, velY, sH, sS);
       }

       return task;
      }();

      function Speed(url, zwe, sW, sH, sS, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sSm = Math.ceil(sS / 2);
       const sWm = Math.ceil(sW / 2);
       const h = shared.rnd(sW) - sSm;
       const v = Math.floor(shared.rnd(0.4) * sH) + Math.floor(0.3 * sH);
       let s = 'top: ' + v + 'px;';
       s += ' left: ' + h + 'px;';
       s += ' height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       if (h + sSm > sWm)
       {
        s += ' transform-origin: center right;';
        aNames.push('speedL');
       }
       else
       {
        s += ' transform-origin: center left;';
        aNames.push('speedR');
       }
       aDelays.push('0.5s');
       aDurs.push(cfg.emote.time + 's');
       aTimings.push('ease-in');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
       _addEmoteToDoc(tInit, url, s);
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        _addEmoteToDoc(tInit, zwe[i].url, s);
       }
      }

      function Drop(url, zwe, sW, sH, sS, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sSm = Math.ceil(sS / 2);
       const h = shared.rnd(sW) - sSm;
       let s = 'left: ' + h + 'px;';
       s += ' height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       if (shared.rnd(2) === 0)
       {
        s += ' transform-origin: top left;';
        aNames.push('dropL');
       }
       else
       {
        s += ' transform-origin: top right;';
        aNames.push('dropR');
       }
       aDelays.push('0s');
       aDurs.push(cfg.emote.time + 's');
       aTimings.push('ease-in');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
       _addEmoteToDoc(tInit, url, s, false, {space: false});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        _addEmoteToDoc(tInit, zwe[i].url, s, false, {space: false});
       }
      }

      const Crazy = function()
      {
       /* LAYOUT SHIFTS
        * =============
        * squashes via scale
        * offset-path requires support for offset-anchor/offset-position
        * due to transform-origin changes during squash
        */
       const _squashT = 100;

       function task(url, zwe, sW, sH, sS, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         sS = Math.ceil(sS / 2);
        else if (variationSize === 2)
         sS = sS * 2;
        const sR = sW - sS;
        const sB = sH - sS;
        const h = shared.rnd(sR - 5) + 10;
        const v = shared.rnd(sB - 5) + 10;
        let s = 'top: ' + v + 'px;';
        s += ' left: ' + h + 'px;';
        s += ' height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        let dests = [];
        let traj = {x: 0, y: 0};
        traj.x = shared.rnd() * 11 - 5;
        traj.y = shared.rnd() * 11 - 5;
        let pos = {x: h, y: v, t: 0};
        let lastT = 0;
        let bCt = 0;
        const eTime = cfg.emote.time * 1000;
        const sqTime = _squashT * 2;
        while(bCt * sqTime + pos.t < eTime)
        {
         pos.x += traj.x;
         pos.y += traj.y;
         pos.t += 5;
         let wall = false;
         if (pos.x < 0)
         {
          pos.x = 0;
          traj.x *= -1;
          wall = 1;
         }
         else if (pos.x > sR)
         {
          pos.x = sR;
          traj.x *= -1;
          wall = 3;
         }
         if (pos.y < 0)
         {
          pos.y = 0;
          traj.y *= -1;
          wall = 2;
         }
         else if (pos.y > sB)
         {
          pos.y = sB;
          traj.y *= -1;
          wall = 4;
         }
         if (wall !== false)
         {
          bCt++;
          dests.push({x: Math.floor(pos.x), y: Math.floor(pos.y), t: pos.t - lastT, w: wall});
          lastT = pos.t;
         }
        }
        dests.push({x: pos.x, y: pos.y, t: pos.t - lastT, w: 0});
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, cfg.emote.in.zoom, cfg.emote.out.fade, cfg.emote.out.zoom, variationSize);
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, url, s, true, {space: false}));
        for (let i = 0, l = zwe.length; i < l; i++)
        {
         iArr.push(_addEmoteToDoc(tInit, zwe[i].url, s, true, {space: false}));
        }
        let d = 0;
        const lA = iArr.length;
        const lD = dests.length;
        window.setTimeout(_tLoop, _tStart, tInit, lA, iArr, lD, dests, d);
       }

       function _tLoop(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        if (d >= lD)
         return;
        for (let i = 0; i < lA; i++)
        {
         iArr[i].style.transformOrigin = 'center center';
         iArr[i].style.transform = 'scale(1, 1)';
         iArr[i].style.top = dests[d].y + 'px';
         iArr[i].style.left = dests[d].x + 'px';
         iArr[i].style.transition = 'all ' + dests[d].t + 'ms linear';
        }
        d++;
        window.setTimeout(_tSquash, dests[d - 1].t, tInit, lA, iArr, lD, dests, d);
       }

       function _tSquash(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0; i < lA; i++)
        {
         iArr[i].style.transition = 'transform ' + _squashT + 'ms linear';
         switch(dests[d - 1].w)
         {
          case 1:
           iArr[i].style.transformOrigin = 'left center';
           iArr[i].style.transform = 'scale(0.7, 2)';
           break;
          case 2:
           iArr[i].style.transformOrigin = 'center top';
           iArr[i].style.transform = 'scale(2, 0.7)';
           break;
          case 3:
           iArr[i].style.transformOrigin = 'right center';
           iArr[i].style.transform = 'scale(0.7, 2)';
           break;
          case 4:
           iArr[i].style.transformOrigin = 'center bottom';
           iArr[i].style.transform = 'scale(2, 0.7)';
           break;
         }
        }
        window.setTimeout(_tUnsquash, _squashT, tInit, lA, iArr, lD, dests, d);
       }

       function _tUnsquash(tInit, lA, iArr, lD, dests, d)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0; i < lA; i++)
        {
         iArr[i].style.transition = 'transform ' + _squashT + 'ms linear';
         iArr[i].style.transform = 'scale(1, 1)';
        }
        window.setTimeout(_tLoop, _squashT, tInit, lA, iArr, lD, dests, d);
       }

       return task;
      }();

      function Confetti(url, zwe, sW, sH, sS, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sSm = Math.ceil(sS / 2);
       const h = shared.rnd(sW) - sSm;
       let s = 'left: ' + h + 'px;';
       s += ' height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       s += ' transform-origin: center center;';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       switch (shared.rnd(3))
       {
        case 0:
         aNames.push('confettiA');
         break;
        case 1:
         aNames.push('confettiB');
         break;
        case 2:
         aNames.push('confettiC');
         break;
       }
       aDelays.push('0s');
       aDurs.push(cfg.emote.time + 's');
       aTimings.push('linear');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, false, false, cfg.emote.out.fade, false, variationSize);
       _addEmoteToDoc(tInit, url, s, false, {space: false});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        _addEmoteToDoc(tInit, zwe[i].url, s, false, {space: false});
       }
      }

      const Throw = function()
      {
       function task(url, zwe, sW, sH, sS, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         sS = Math.ceil(sS / 2);
        else if (variationSize === 2)
         sS = sS * 2;
        const sR = sW - sS;
        const sB = sH - sS;
        const h = shared.rnd(2) === 0 ? sS * -1 : sW;
        const v = shared.rnd(sH + sS) - sS;
        const hD = Math.floor(shared.rnd() * (sR * 0.4) + sR * 0.3);
        const vD = Math.floor(shared.rnd() * (sB * 0.4) + sB * 0.3);
        const dH = shared.rnd() * sS;
        const tMS = cfg.emote.time * 1000;
        const t1 = tMS * 0.14;
        const t2 = tMS * 0.2;
        const t3 = tMS * 0.8;
        let s = 'height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: transform ' + t1 + 'ms cubic-bezier(0.32, 0, 0.67, 0);';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        let s2 = 'height: ' + sS + 'px;';
        s2 += ' width: ' + sS + 'px;';
        s2 += ' transition: transform ' + t3 + 'ms cubic-bezier(0.5, 0, 0.75, 0);';
        let r = '360';
        if (h > 0)
         r = '-360';
        s2 += ' transform: translate(' + hD + 'px, ' + (sH - dH) + 'px) rotate(' + r + 'deg);';
        let aNames = [];
        let aDelays = [];
        let aDurs = [];
        let aTimings = [];
        let aFills = [];
        let aIters = [];
        if (cfg.emote.out.fade)
        {
         const fOut = _tAnim.fade.out / 100;
         const t3F = t3 * fOut;
         aNames.push('fadeOut');
         aDelays.push(Math.floor(t3 - t3F) + 'ms');
         aDurs.push(Math.floor(t3F) + 'ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        else
        {
         aNames.push('noFadeOut');
         aDelays.push(t3 - 50 + 'ms');
         aDurs.push('50ms');
         aTimings.push('ease-out');
         aFills.push('forwards');
         aIters.push('1');
        }
        if (cfg.emote.out.zoom)
        {
         const zOut = _tAnim.zoom.out / 100;
         const t3Z = t3 * zOut;
         if (variationSize === 0)
          aNames.push('zoomOutS');
         else if (variationSize === 2)
          aNames.push('zoomOutL');
         else
          aNames.push('zoomOut');
         aDelays.push(Math.floor(t3 - t3Z) + 'ms');
         aDurs.push(Math.floor(t3Z) + 'ms');
         aTimings.push('linear');
         aFills.push('forwards');
         aIters.push('1');
        }
        s2 += _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, url, s, true, {space: false}));
        for (let i = 0, l = zwe.length; i < l; i++)
        {
         iArr.push(_addEmoteToDoc(tInit, zwe[i].url, s, true, {space: false}));
        }
        window.setTimeout(_tMove, _tStart, tInit, iArr, hD, vD);
        window.setTimeout(_tDrop, t2, tInit, iArr, s2);
       }

       function _tMove(tInit, iArr, hD, vD)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
        }
       }

       function _tDrop(tInit, iArr, s2)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         iArr[i].setAttribute('style', s2);
        }
       }

       return task;
      }();

      const TheCube = function()
      {
       function task(url, zwe, sW, sH, sS, canV = true, tInit = 0)
       {
        if (tInit === 0)
         tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let scene = document.createElement('div');
        scene.setAttribute('class', 'scene');
        let variationSize = 1;
        if (canV && cfg.emote.size.variation !== false)
        {
         variationSize = shared.rnd(cfg.emote.size.variation + 2);
         if (variationSize !== 0 && variationSize !== 2)
          variationSize = 1;
        }
        if (variationSize === 0)
         sS = Math.ceil(sS / 2);
        else if (variationSize === 2)
         sS = sS * 2;
        const sSm = Math.ceil(sS / 2);
        const nSm = sSm * -1;
        scene.setAttribute('width', sS);
        scene.setAttribute('height', sS);
        let cube = document.createElement('div');
        cube.setAttribute('class', 'cube');
        cube.setAttribute('style', 'transform: translateZ(' + nSm + 'px); transition: transform linear ' + cfg.emote.time + 's;');
        let f = 'height: ' + sS + 'px;';
        f += ' width: ' + sS + 'px;';
        const lZ = zwe.length;
        if (lZ === 0)
        {
         let cubeF = document.createElement('img');
         _setImgSrc(cubeF, url);
         cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
         cubeF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px);');
         cube.appendChild(cubeF);
         let cubeB = document.createElement('img');
         _setImgSrc(cubeB, url);
         cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
         cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeB);
         let cubeR = document.createElement('img');
         _setImgSrc(cubeR, url);
         cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
         cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeR);
         let cubeL = document.createElement('img');
         _setImgSrc(cubeL, url);
         cubeL.setAttribute('class', 'cubeFace cubeFaceLeft');
         cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeL);
         let cubeT = document.createElement('img');
         _setImgSrc(cubeT, url);
         cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
         cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeT);
         let cubeU = document.createElement('img');
         _setImgSrc(cubeU, url);
         cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
         cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeU);
        }
        else
        {
         let cubeF = document.createElement('div');
         cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
         cubeF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px);');
         let pctF = document.createElement('img');
         _setImgSrc(pctF, url);
         pctF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeF.appendChild(pctF);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeF.appendChild(pctZ);
         }
         cube.appendChild(cubeF);
         let cubeB = document.createElement('div');
         cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
         cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + sSm + 'px);');
         let pctB = document.createElement('img');
         _setImgSrc(pctB, url);
         pctB.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeB.appendChild(pctB);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeB.appendChild(pctZ);
         }
         cube.appendChild(cubeB);
         let cubeR = document.createElement('div');
         cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
         cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + sSm + 'px);');
         let pctR = document.createElement('img');
         _setImgSrc(pctR, url);
         pctR.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeR.appendChild(pctR);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeR.appendChild(pctZ);
         }
         cube.appendChild(cubeR);
         let cubeL = document.createElement('div');
         cubeL.setAttribute('class', 'cubeFace cubeFaceLight');
         cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + sSm + 'px);');
         let pctL = document.createElement('img');
         _setImgSrc(pctL, url);
         pctL.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeL.appendChild(pctL);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeL.appendChild(pctZ);
         }
         cube.appendChild(cubeL);
         let cubeT = document.createElement('div');
         cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
         cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + sSm + 'px);');
         let pctT = document.createElement('img');
         _setImgSrc(pctT, url);
         pctT.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeT.appendChild(pctT);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeT.appendChild(pctZ);
         }
         cube.appendChild(cubeT);
         let cubeU = document.createElement('div');
         cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
         cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + sSm + 'px);');
         let pctU = document.createElement('img');
         _setImgSrc(pctU, url);
         pctU.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeU.appendChild(pctU);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeU.appendChild(pctZ);
         }
         cube.appendChild(cubeU);
        }
        scene.appendChild(cube);
        const h = shared.rnd(sW) - sSm;
        const v = shared.rnd(sH) - sSm;
        const r = Math.min(sW, sH) * (shared.rnd() + 1);
        const cRadius = Math.PI * 2;
        let th = shared.rnd() * cRadius;
        let hD = Math.floor(h + r * Math.cos(th));
        let vD = Math.floor(v + r * Math.sin(th));
        const sR = sW - sS - sSm;
        const sB = sH - sS - sSm;
        while ((h < sSm && hD < sSm) || (v < sSm && vD < sSm) || (h > sR && hD > sR) || (v > sB && vD > sB))
        {
         th = shared.rnd() * cRadius;
         hD = Math.floor(h + r * Math.cos(th));
         vD = Math.floor(v + r * Math.sin(th));
        }
        let s = 'width: ' + sS + 'px;';
        s += ' height: ' + sS + 'px;';
        s += ' perspective: ' + sS * 3 + 'px;';
        s += ' transition: all ' + cfg.emote.time + 's linear;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false, variationSize);
        scene.setAttribute('style', s);
        _eActive++;
        document.body.appendChild(scene);
        _gc.hook(scene);
        window.setTimeout(_tMove, _tStart, tInit, cube, scene, hD, vD, sS);
       }

       function _tMove(tInit, cube, scene, hD, vD, sS)
       {
        if (_iTitanic > tInit)
         return;
        const nSm = Math.ceil(sS / 2) * -1;
        let rX = 0;
        let rY = 0;
        while (Math.abs(rX) + Math.abs(rY) < 45)
        {
         rX = (360 - shared.rnd() * 720) * cfg.emote.cube.rotations;
         rY = (360 - shared.rnd() * 720) * cfg.emote.cube.rotations;
        }
        cube.style.transform = 'translateZ(' + nSm + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
        scene.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
       }

       return task;
      }();

      function Fountain(url, zwe, sW, sH, sS, fX, fY, canV = true, tInit = 0)
      {
       if (tInit === 0)
        tInit = new Date().getTime();
       if (_iTitanic > tInit)
        return;
       const aT = Math.floor(cfg.emote.time * 1000 / 2);
       let variationSize = 1;
       if (canV && cfg.emote.size.variation !== false)
       {
        variationSize = shared.rnd(cfg.emote.size.variation + 2);
        if (variationSize !== 0 && variationSize !== 2)
         variationSize = 1;
       }
       if (variationSize === 0)
        sS = Math.ceil(sS / 2);
       else if (variationSize === 2)
        sS = sS * 2;
       const sR = sW - sS;
       const sB = sH - sS;
       let h = fX;
       if (h === false)
        h = Math.floor(shared.rnd() * (sR * 0.33) + sR * 0.33);
       let hD;
       if (shared.rnd(2) === 0)
        hD = h - shared.rnd(sR * 0.2);
       else
        hD = h + shared.rnd(sR * 0.2);
       let s = 'height: ' + sS + 'px;';
       s += ' width: ' + sS + 'px;';
       s += ' transition: transform ' + aT + 'ms cubic-bezier(0, 0, 0.58, 1);';
       s += ' transform: translateX(' + h + 'px);';
       s += ' offset-path: path("M 0 ' + sH + ' L 0 ' + Math.floor(fY / 100 * sH + shared.rnd(sB / 2)) + ' L 0 ' + (sH + sS) + '");';
       let aNames = [];
       let aDelays = [];
       let aDurs = [];
       let aTimings = [];
       let aFills = [];
       let aIters = [];
       aNames.push('offsetPath');
       aDelays.push('0s');
       aDurs.push(aT + 'ms');
       aTimings.push('cubic-bezier(0, 0.9, 1, 0.15)');
       aFills.push('forwards');
       aIters.push('1');
       s += _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
       _addEmoteToDoc(tInit, url, s, false, {time: aT}, {x: hD});
       for (let i = 0, l = zwe.length; i < l; i++)
       {
        _addEmoteToDoc(tInit, zwe[i].url, s, false, {time: aT}, {x: hD});
       }
      }

      return {
       Still: Still,
       StraightLine: StraightLine,
       Rise: Rise,
       Bounce: Bounce,
       Speed: Speed,
       Drop: Drop,
       Crazy: Crazy,
       Confetti: Confetti,
       Throw: Throw,
       TheCube: TheCube,
       Fountain: Fountain
      };
     }();

     function _queueEmote(url, zwe)
     {
      const sW = window.innerWidth;
      const sH = window.innerHeight;
      const sS = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
      const ehs = Math.ceil(sS / 2);
      const ehl = sS * 2;
      document.documentElement.style.setProperty('--height', sH + 'px');
      document.documentElement.style.setProperty('--width', sW + 'px');
      document.documentElement.style.setProperty('--emote-height', sS + 'px');
      document.documentElement.style.setProperty('--emote-height-s', ehs + 'px');
      document.documentElement.style.setProperty('--emote-height-l', ehl + 'px');
      let style = cfg.display.styles[shared.rnd(cfg.display.styles.length)];
      if (style === undefined)
       return;
      list[style](url, zwe, sW, sH, sS);
     }

     function showEmotes()
     {
      if (_tEmote !== false)
      {
       window.clearTimeout(_tEmote);
       _tEmote = false;
      }
      if (cfg.emote.max > 0 && _eActive >= cfg.emote.max)
      {
       _tEmote = window.setTimeout(showEmotes, 500);
       return;
      }
      let e = null;
      while ((e = _toShow.shift()) !== undefined)
      {
       _queueEmote(e.url, e.zwe ?? []);
       if (cfg.emote.max > 0 && _eActive > cfg.emote.max)
       {
        if (cfg.emote.queue > 0 && _toShow.length > cfg.emote.queue)
         _toShow.splice(0, _toShow.length - cfg.emote.queue);
        _tEmote = window.setTimeout(showEmotes, 500);
        return;
       }
      }
     }

     function addToShowList(p)
     {
      _toShow = _toShow.concat(p);
     }

     return {
      showEmotes: showEmotes,
      addToShowList: addToShowList,
      list: list
     };
    }();

    const kappa = function()
    {
     let _toKappa = [];
     let _conga = [];
     const _dKappa = 500;

     let _tKappa = false;

     const _list = function()
     {
      const Fireworks = function()
      {
       const _smallBurst = 0.5;
       const _largeBurst = 1.5;

       function task(kList, sW, sH, sS, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const sSm = Math.ceil(sS / 2);
        const sWm = Math.ceil(sW / 2);
        const sendUp = 2;
        const oX = sWm - sSm;
        const oY = sH;
        let cX = oX;
        switch(shared.rnd(3))
        {
         case 0:
          cX = Math.floor(cX * _smallBurst);
          break;
         case 2:
          cX = Math.floor(cX * _largeBurst);
          break;
        }
        const cY = oY * 0.33;
        let s = 'height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: transform ' + sendUp + 's linear;';
        s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
        const oK = kList[shared.rnd(kList.length)];
        let iArr = [];
        iArr.push(_addEmoteToDoc(tInit, oK.url, s, true, false, {x: cX, y: cY}));
        if (oK.hasOwnProperty('zwe'))
        {
         for (let i = 0, l = oK.zwe.length; i < l; i++)
         {
          _eActive++;
          iArr.push(_addEmoteToDoc(tInit, oK.zwe[i].url, s, true, false, {x: cX, y: cY}));
         }
        }
        window.setTimeout(_explode, sendUp * 1000, tInit, kList, iArr, cX, cY, sS, sW, sH, iKC);
       }

       async function _explode(tInit, kList, iArr, cX, cY, sS, sW, sH, iKC)
       {
        if (_iTitanic > tInit)
         return;
        for (let i = 0, l = iArr.length; i < l; i++)
        {
         document.body.removeChild(iArr[i]);
         _eActive--;
        }
        const r = Math.min(sW, sH) * 0.66;
        const inner = Math.floor(iKC / 8);
        const outer = inner;
        const core = iKC - (inner + outer);
        let t = 0;
        const lK = kList.length;
        for (let v = 0; v < inner; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         const sA = shared.rnd();
         _sparkler(tInit, sK.url, cX, cY, sS, r * _smallBurst, t, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, sS, r * _smallBurst, t, sA);
          }
         }
         if (v % Math.floor(outer / 3) === 0)
          await _sleep(1);
        }
        t += 0.5;
        for (let v = 0; v < core; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         const sA = shared.rnd();
         _sparkler(tInit, sK.url, cX, cY, sS, r, t, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, sS, r, t, sA);
          }
         }
         t += 0.005;
         if (v % Math.floor(outer / 9) === 0)
          await _sleep(1);
        }
        t += 0.25;
        for (let v = 0; v < outer; v++)
        {
         if (_iTitanic > tInit)
          return;
         const sK = kList[shared.rnd(lK)];
         const sA = shared.rnd();
         _sparkler(tInit, sK.url, cX, cY, sS, r * _largeBurst, t, sA);
         if (sK.hasOwnProperty('zwe'))
         {
          for (let i = 0, l = sK.zwe.length; i < l; i++)
          {
           _sparkler(tInit, sK.zwe[i].url, cX, cY, sS, r * _largeBurst, t, sA);
          }
         }
         if (v % Math.floor(outer / 3) === 0)
          await _sleep(1);
        }
       }

       function _sparkler(tInit, url, cX, cY, sS, r, d, a)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        _setImgSrc(img, url);
        const cRadius = Math.PI * 2;
        const th = a * cRadius;
        const hD = Math.floor(cX + r * Math.cos(th));
        const vD = Math.floor(cY + r * Math.sin(th));
        let s = 'height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: transform ' + cfg.emote.time + 's ease-out;';
        s += ' transform: translate(' + cX + 'px, ' + cY + 'px);';
        s += ' opacity: 0;';
        const dMS = d * 1000;
        const tMS = cfg.emote.time * 1000;
        const tFI = _tAnim.fade.in / 100;
        const tFO = _tAnim.fade.out / 100;
        let aNames = [];
        let aDelays = [];
        let aDurs = [];
        let aTimings = [];
        let aFills = [];
        let aIters = [];
        aNames.push('fadeIn');
        aDelays.push(dMS + 'ms');
        aDurs.push(Math.floor(tMS * tFI) + 'ms');
        aTimings.push('linear');
        aFills.push('forwards');
        aIters.push('1');
        aNames.push('fadeOut');
        aDelays.push(dMS + Math.floor(tMS - tMS * tFO) + 'ms');
        aDurs.push(Math.floor(tMS * tFO) + 'ms');
        aTimings.push('ease-out');
        aFills.push('forwards');
        aIters.push('1');
        s += _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
        img.setAttribute('style', s);
        document.body.appendChild(img);
        _gc.hook(img, true, true, dMS + tMS);
        window.setTimeout(_tMove, dMS + _tStart, tInit, img, hD, vD);
       }

       function _tMove(tInit, img, hD, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.opacity = 1;
        img.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
       }

       return task;
      }();

      const Spiral = function()
      {
       function task(kList, sW, sH, sS, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const oX = shared.rnd(sW - sS);
        const oY = shared.rnd(sH - sS);
        const r = Math.min(sW, sH);
        window.setTimeout(_init, _tStart, tInit, kList, oX, oY, sS, r, iKC);
       }

       async function _init(tInit, kList, oX, oY, sS, r, iKC)
       {
        if (_iTitanic > tInit)
         return;
        let l = iKC / 25 + 2;
        l = l + (shared.rnd() * 4 - 2);
        l = Math.max(l, 0.1);
        const cRadius = Math.PI * 2;
        const c = Math.PI * l / iKC;
        let th = shared.rnd() * cRadius;
        const o = shared.rnd(2) === 0;
        for (let i = 0; i < iKC; i++)
        {
         if (_iTitanic > tInit)
          return;
         if (o)
         {
          th-= c;
          if (th <= 0)
           th+= cRadius;
         }
         else
         {
          th+= c;
          if (th >= cRadius)
           th-= cRadius;
         }
         const oK = kList[shared.rnd(kList.length)];
         _sparkler(tInit, oK.url, oX, oY, sS, r, th);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, m = oK.zwe.length; j < m; j++)
          {
           _eActive++;
           _sparkler(tInit, oK.zwe[j].url, oX, oY, sS, r, th);
          }
         }
         await _sleep(10);
        }
       }

       function _sparkler(tInit, url, oX, oY, sS, r, th)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        _setImgSrc(img, url);
        const hD = Math.floor(oX + r * Math.cos(th));
        const vD = Math.floor(oY + r * Math.sin(th));
        let s = 'height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: transform ' + cfg.emote.time + 's ease-out;';
        s += ' transform: translate(' + oX + 'px, ' + oY + 'px);';
        s += _styleEmote([], [], [], [], [], [], true, false, true, false);
        img.setAttribute('style', s);
        document.body.appendChild(img);
        _gc.hook(img, true, true);
        window.setTimeout(_tMove, _tStart, tInit, img, hD, vD);
       }

       function _tMove(tInit, img, hD, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + hD + 'px, ' + vD + 'px)';
       }

       return task;
      }();

      const Pyramid = function()
      {
       function task(kList, sW, sH)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const sS = sW / 19;
        let drawn = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        let ct = 0;
        const lP = pyramidDist.length;
        for (let i = 0; i < lP; i++)
         ct += pyramidDist[i];
        const eMS = cfg.emote.time * 1000;
        let eT = eMS * 0.8;
        const tPerB = Math.max(Math.floor(eT / ct), 50);
        eT = tPerB * ct;
        const dT = eMS * 0.2;
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lP);
         while(drawn[x] >= pyramidDist[x]);
         const oK = kList[shared.rnd(kList.length)];
         _block(tInit, oK.url, x, t, sS, sH, drawn[x] + 1, tPerB, eT + dT);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _eActive++;
           _block(tInit, oK.zwe[j].url, x, t, sS, sH, drawn[x] + 1, tPerB, eT + dT);
          }
         }
         drawn[x]++;
         t += tPerB;
        }
       }

       function _block(tInit, url, x, t, sS, sH, dX, tPerB, aT)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        _setImgSrc(img, url);
        const h = sS * x;
        const v = -1 * sS;
        const vD = sH - sS * dX;
        let s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: all ' + tPerB + 'ms ease-in;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tDrop, Math.floor(t / 10 + aT), tInit, img, h, sH);
        window.setTimeout(_tMove, t, tInit, img, h, vD);
       }

       function _tMove(tInit, img, h, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
       }

       function _tDrop(tInit, img, h, sH)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
        img.style.transitionTime = '500ms';
        _gc.hook(img, false, true, 500);
       }

       return task;
      }();

      const SmallPyramid = function()
      {
       function task(kList, sW, sH)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const sS = Math.min(sW / 19, Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small));
        let drawn = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        let ct = 0;
        const lP = pyramidDist.length;
        for (let i = 0; i < lP; i++)
         ct += pyramidDist[i];
        const eMS = cfg.emote.time * 1000;
        let eT = eMS * 0.8;
        const tPerB = Math.max(Math.floor(eT / ct), 75);
        eT = tPerB * ct;
        const dT = eMS * 0.2;
        const oX = shared.rnd(sW - sS * lP);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lP);
         while(drawn[x] >= pyramidDist[x]);
         const oK = kList[shared.rnd(kList.length)];
         _block(tInit, oK.url, oX, x, t, sS, sH, drawn[x] + 1, tPerB, eT + dT);
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _eActive++;
           _block(tInit, oK.zwe[j].url, oX, x, t, sS, sH, drawn[x] + 1, tPerB, eT + dT);
          }
         }
         drawn[x]++;
         t += tPerB;
        }
       }

       function _block(tInit, url, oX, x, t, sS, sH, dX, tPerB, aT)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        _setImgSrc(img, url);
        const h = oX + sS * x;
        const v = -1 * sS;
        const vD = sH - sS * dX;
        let s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: all ' + tPerB + 'ms ease-in;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tDrop, Math.floor(t / 10 + aT), tInit, img, h, sH);
        window.setTimeout(_tMove, t, tInit, img, h, vD);
       }

       function _tMove(tInit, img, h, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
       }

       function _tDrop(tInit, img, h, sH)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
        img.style.transitionTime = '500ms';
        _gc.hook(img, false, true, 500);
       }

       return task;
      }();

      const Stampede = function()
      {
       const _speed = 2000;

       async function task(kList, sW, sH, sS, iKC)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const bandHeight = sS * 3;
        const d = shared.rnd(2) === 0;
        const bandTop = shared.rnd(sH - sS * 2.5);
        const b1 = shared.rnd(4) + 1;
        const b2 = shared.rnd(8 - b1) + b1;
        const b4 = shared.rnd(4);
        const hasB4 = b4 > 0;
        await _stampede(tInit, kList, b1, _speed * 0.8, bandTop, bandHeight, d, sW, sS);
        if (_iTitanic > tInit)
         return;
        await _stampede(tInit, kList, b2, _speed * 0.4, bandTop, bandHeight, d, sW, sS);
        if (_iTitanic > tInit)
         return;
        await _stampede(tInit, kList, iKC, hasB4, bandTop, bandHeight, d, sW, sS);
        if (_iTitanic > tInit)
         return;
        if (hasB4)
         await _stampede(tInit, kList, b4, false, bandTop, bandHeight, d, sW, sS);
       }

       async function _stampede(tInit, kList, ct, pause, bandTop, bandHeight, d, sW, sS)
       {
        if (_iTitanic > tInit)
         return;
        let imgs = [];
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         const oK = kList[shared.rnd(kList.length)];
         const y = bandTop + shared.rnd(bandHeight);
         imgs.push(_run(tInit, oK.url, y, d, sW, sS));
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           _run(tInit, oK.zwe[j].url, y, d, sW, sS);
          }
         }
         await _sleep(shared.rnd(90) + 10);
        }
        if (pause === false)
         return;
        if (pause !== true)
        {
         await _sleep(pause);
         return;
        }
        do
        {
         if (_iTitanic > tInit)
          return;
         await _sleep(100);
         for (let i = imgs.length - 1; i >= 0; i--)
         {
          if (imgs[i] === null || imgs[i].hasAttribute('deleted'))
           imgs.splice(i, 1);
         }
        } while (imgs.length > 0);
       }

       function _run(tInit, url, v, d, sW, sS)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        _setImgSrc(img, url);
        const h = -2 * sS;
        let s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: all ' + _speed + 'ms linear;';
        if (d)
         s += ' transform: translate(' + sW + 'px, ' + v + 'px);';
        else
         s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        window.setTimeout(_tMark, _speed, tInit, img);
        window.setTimeout(_tMove, _tStart, tInit, img, d, h, sW + sS, v);
        return img;
       }

       function _tMove(tInit, img, d, h1, h2, v)
       {
        if (_iTitanic > tInit)
         return;
        let h = h2;
        if (d)
         h = h1;
        img.style.transform = 'translate(' + h + 'px, ' + v + 'px)';
       }

       function _tMark(tInit, img)
       {
        if (_iTitanic > tInit)
         return;
        document.body.removeChild(img);
        img.setAttribute('deleted', true);
       }

       return task;
      }();

      const Conga = function()
      {
       const _longWait = cfg.emote.time * 2;

       async function task(kList, sW, sH, sS, nM)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        let v = 0;
        let unique = false;
        const bS = Math.ceil(sS * (5/3));
        const seg = Math.floor(bS / 2);
        const sht = Math.floor(sH / seg);
        let lns = sht;
        if (nM)
         lns = 6;
        while (_conga.length >= lns)
        {
         if (_iTitanic > tInit)
          return;
         await _sleep(250);
        }
        while (!unique)
        {
         v = shared.rnd(sht) * seg;
         if (nM)
         {
          v = shared.rnd(6);
          if (v > 2)
           v = sht - 1 - (v - 3);
          v *= seg;
         }
         let found = false;
         for (let i = 0, l = _conga.length; i < l; i++)
         {
          if (_conga[i].row === v)
          {
           found = true;
           break;
          }
         }
         if (!found)
          unique = true;
        }
        _conga.push({row: v, done: false});
        let urls = [];
        let zurls = [];
        const ct = Math.floor(sW / bS);
        for (let i = 0; i < ct; i++)
        {
         const oK = kList[shared.rnd(kList.length)];
         urls.push(oK.url);
         let oZ = [];
         if (oK.hasOwnProperty('zwe'))
         {
          for (let j = 0, l = oK.zwe.length; j < l; j++)
          {
           oZ.push(oK.zwe[j].url);
          }
         }
         zurls.push(oZ);
        }
        const d = v / seg % 2 === 0;
        const xtra = Math.floor((sW - ct * bS) / 2);
        let imgs = [];
        let zimgs = [];
        for (let i = 0; i < ct; i++)
        {
         imgs.push(_dance(tInit, urls[i], i, sW, v, sS, bS, ct, d, xtra));
         let oZ = [];
         for (let j = 0, l = zurls[i].length; j < l; j++)
         {
          oZ.push(_dance(tInit, zurls[i][j], i, sW, v, sS, bS, ct, d, xtra));
         }
         zimgs.push(oZ);
        }
        await _sleep(_longWait * 1000);
        let full = false;
        if (_conga.length === sht)
         full = true;
        await _sleep(cfg.display.kappa.conga.time * 1000);
        if (cfg.display.kappa.conga.contagious)
        {
         let ex = false;
         let lC = _conga.length;
         if (lC > 1)
          ex = true;
         for (let i = 0; i < lC; i++)
         {
          if (_conga[i].row !== v)
           continue;
          _conga[i].done = true;
          break;
         }
         let done = false;
         while (!done)
         {
          if (_iTitanic > tInit)
           return;
          lC = _conga.length;
          if (!ex && lC > 1)
           ex = true;
          let notDone = false;
          for (let i = 0; i < lC; i++)
          {
           if (_conga[i].done === false)
           {
            notDone = true;
            break;
           }
          }
          if (notDone === false)
           done = true;
          await _sleep(100);
         }
        }
        for (let i = 0, l = imgs.length; i < l; i++)
        {
         _endDance(tInit, imgs[i], i, sW, v, sS, bS, ct, d, xtra);
         for (let j = 0, m = zimgs[i].length; j < m; j++)
         {
          _endDance(tInit, zimgs[i][j], i, sW, v, sS, bS, ct, d, xtra);
         }
        }
        await _sleep(_longWait * 1000);
        for (let i = 0, l = _conga.length; i < l; i++)
        {
         if (_conga[i].row !== v)
          continue;
         _conga.splice(i, 1);
         break;
        }
       }

       function _dance(tInit, url, col, sW, v, sS, bS, ct, d, xtra)
       {
        if (_iTitanic > tInit)
         return;
        let box = document.createElement('div');
        box.setAttribute('class', 'scene');
        let img = document.createElement('img');
        img.setAttribute('class', 'dancer');
        _setImgSrc(img, url);
        let s = 'width: ' + sS + 'px;';
        s += ' height: ' + sS + 'px;';
        img.setAttribute('style', s);
        let sE = bS * col + xtra;
        let sB = sE - sW;
        if (d)
        {
         sE = bS * (ct - 1 - col) + xtra;
         sB = sE + sW;
        }
        s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' width: ' + bS + 'px;';
        s += ' height: ' + bS + 'px;';
        s += ' z-index: ' + v + ';';
        s += ' transition: all ' + _longWait + 's linear;';
        s += ' transform: translate(' + sB + 'px, ' + v + 'px);';
        box.setAttribute('style', s);
        _eActive++;
        box.appendChild(img);
        document.body.appendChild(box);
        window.setTimeout(_tMove, _tStart, tInit, box, sE, v);
        return box;
       }

       function _endDance(tInit, box, col, sW, v, sS, bS, ct, d, xtra)
       {
        if (_iTitanic > tInit)
         return;
        let sB = bS * col + xtra;
        let sE = sB + sW;
        if (d)
        {
         sB = bS * (ct - 1 - col) + xtra;
         sE = sB - sW;
        }
        let s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' width: ' + bS + 'px;';
        s += ' height: ' + bS + 'px;';
        s += ' z-index: ' + v + ';';
        s += ' transition: all ' + _longWait + 's ease-in;';
        s += ' transform: translate(' + sB + 'px, ' + v + 'px);';
        box.setAttribute('style', s);
        _gc.hook(box, true, true, _longWait * 1000 * 1.25);
        window.setTimeout(_tMove, _tStart, tInit, box, sE, v);
       }

       function _tMove(tInit, box, sE, v)
       {
        if (_iTitanic > tInit)
         return;
        box.style.transform = 'translate(' + sE + 'px, ' + v + 'px)';
       }

       return task;
      }();

      const TheCube = function()
      {
       function task(url, zwe, sW, sH, sS, bC, iR)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const sSm = Math.ceil(sS / 2);
        const nSm = sSm * -1;
        const sWm = Math.ceil(sW / 2);
        const sHm = Math.ceil(sH / 2);
        let scene = document.createElement('div');
        scene.setAttribute('class', 'scene');
        scene.setAttribute('width', sS);
        scene.setAttribute('height', sS);
        let cube = document.createElement('div');
        cube.setAttribute('class', 'cube');
        cube.setAttribute('style', 'transform: translateZ(' + nSm + 'px); transition: transform linear ' + cfg.emote.time + 's;');
        let f = 'height: ' + sS + 'px;';
        f += ' width: ' + sS + 'px;';
        const lZ = zwe.length;
        if (lZ === 0)
        {
         let cubeF = document.createElement('img');
         _setImgSrc(cubeF, url);
         cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
         cubeF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px);');
         cube.appendChild(cubeF);
         let cubeB = document.createElement('img');
         _setImgSrc(cubeB, url);
         cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
         cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeB);
         let cubeR = document.createElement('img');
         _setImgSrc(cubeR, url);
         cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
         cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeR);
         let cubeL = document.createElement('img');
         _setImgSrc(cubeL, url);
         cubeL.setAttribute('class', 'cubeFace cubeFaceLeft');
         cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeL);
         let cubeT = document.createElement('img');
         _setImgSrc(cubeT, url);
         cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
         cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeT);
         let cubeU = document.createElement('img');
         _setImgSrc(cubeU, url);
         cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
         cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + sSm + 'px);');
         cube.appendChild(cubeU);
        }
        else
        {
         let cubeF = document.createElement('div');
         cubeF.setAttribute('class', 'cubeFace cubeFaceFront');
         cubeF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px);');
         let pctF = document.createElement('img');
         _setImgSrc(pctF, url);
         pctF.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeF.appendChild(pctF);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeF.appendChild(pctZ);
         }
         cube.appendChild(cubeF);
         let cubeB = document.createElement('div');
         cubeB.setAttribute('class', 'cubeFace cubeFaceBack');
         cubeB.setAttribute('style', f + ' transform: rotateY(90deg) translateZ(' + sSm + 'px);');
         let pctB = document.createElement('img');
         _setImgSrc(pctB, url);
         pctB.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeB.appendChild(pctB);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeB.appendChild(pctZ);
         }
         cube.appendChild(cubeB);
         let cubeR = document.createElement('div');
         cubeR.setAttribute('class', 'cubeFace cubeFaceRight');
         cubeR.setAttribute('style', f + ' transform: rotateY(180deg) translateZ(' + sSm + 'px);');
         let pctR = document.createElement('img');
         _setImgSrc(pctR, url);
         pctR.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeR.appendChild(pctR);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeR.appendChild(pctZ);
         }
         cube.appendChild(cubeR);
         let cubeL = document.createElement('div');
         cubeL.setAttribute('class', 'cubeFace cubeFaceLight');
         cubeL.setAttribute('style', f + ' transform: rotateY(-90deg) translateZ(' + sSm + 'px);');
         let pctL = document.createElement('img');
         _setImgSrc(pctL, url);
         pctL.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeL.appendChild(pctL);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeL.appendChild(pctZ);
         }
         cube.appendChild(cubeL);
         let cubeT = document.createElement('div');
         cubeT.setAttribute('class', 'cubeFace cubeFaceTop');
         cubeT.setAttribute('style', f + ' transform: rotateX(90deg) translateZ(' + sSm + 'px);');
         let pctT = document.createElement('img');
         _setImgSrc(pctT, url);
         pctT.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeT.appendChild(pctT);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeT.appendChild(pctZ);
         }
         cube.appendChild(cubeT);
         let cubeU = document.createElement('div');
         cubeU.setAttribute('class', 'cubeFace cubeFaceBottom');
         cubeU.setAttribute('style', f + ' transform: rotateX(-90deg) translateZ(' + sSm + 'px);');
         let pctU = document.createElement('img');
         _setImgSrc(pctU, url);
         pctU.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
         cubeU.appendChild(pctU);
         for (let i = 0; i < lZ; i++)
         {
          let pctZ = document.createElement('img');
          _setImgSrc(pctZ, zwe[i].url);
          pctZ.setAttribute('style', f + ' transform: translateZ(' + sSm + 'px); position: absolute;');
          cubeU.appendChild(pctZ);
         }
         cube.appendChild(cubeU);
        }
        scene.appendChild(cube);
        let h = shared.rnd(sW - sS);
        let v = shared.rnd(sH - sS);
        if (bC)
        {
         h = Math.floor(sWm - sSm);
         v = Math.floor(sHm - sSm);
        }
        let s = 'width: ' + sS + 'px;';
        s += ' height: ' + sS + 'px;';
        s += ' perspective: ' + sS * 3 + 'px;';
        s += ' transition: all ' + cfg.emote.time + 's linear;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        s += _styleEmote([], [], [], [], [], [], cfg.emote.in.fade, false, cfg.emote.out.fade, false);
        scene.setAttribute('style', s);
        _eActive++;
        document.body.appendChild(scene);
        _gc.hook(scene, false);
        window.setTimeout(_tMove, _tStart, tInit, cube, iR, sS);
       }

       function _tMove(tInit, cube, iR, sS)
       {
        if (_iTitanic > tInit)
         return;
        const nSm = Math.ceil(sS / 2) * -1;
        let rX = 0;
        let rY = 0;
        while (Math.abs(rX) + Math.abs(rY) < 45)
        {
         rX = (360 - shared.rnd() * 720) * iR;
         rY = (360 - shared.rnd() * 720) * iR;
        }
        cube.style.transform = 'translateZ(' + nSm + 'px) rotateX(' + rX + 'deg) rotateY(' + rY + 'deg)';
       }

       return task;
      }();

      const Text = function()
      {
       let _mL = 0;

       function task(kList, sW, sH, sMsg, iTime)
       {
        const tInit = new Date().getTime();
        if (_iTitanic > tInit)
         return;
        const msgDist = _buildMsgArr(sMsg);
        let ct = 0;
        let ctT = 0;
        let drawn = [];
        const lM = msgDist.length;
        for (let x = 0; x < lM; x++)
        {
         const lX = msgDist[x].length;
         for (let y = 0; y < lX; y++)
         {
          if (msgDist[x][y] !== 0)
           ctT += 1;
         }
         ct += lX;
         drawn.push(0);
        }
        const sS = Math.min(Math.floor(sW / (lM + 2)), Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small));
        let eT = cfg.emote.time * 1000;
        const tPerB = Math.max(Math.floor(eT / ctT), 24);
        eT = tPerB * ctT;
        const lF = msgDist[0].length;
        const lFS = sS * lF;
        const vH = shared.rnd(sH - lFS) + lFS;
        const oX = shared.rnd(sW - sS * lM);
        let t = 0;
        for (let i = 0; i < ct; i++)
        {
         if (_iTitanic > tInit)
          return;
         let x;
         do
          x = shared.rnd(lM);
         while(drawn[x] >= msgDist[x].length);
         if (msgDist[x][drawn[x]] !== 0)
         {
          const oK = kList[shared.rnd(kList.length)];
          _block(tInit, oK.url, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, sS);
          if (oK.hasOwnProperty('zwe'))
          {
           for (let j = 0, l = oK.zwe.length; j < l; j++)
           {
            _eActive++;
            _block(tInit, oK.zwe[j].url, vH, oX, drawn[x] + 1, tPerB, eT, iTime, x, t, sH, sS);
           }
          }
          t += tPerB;
         }
         drawn[x]++;
        }
       }

       function _buildMsgArr(s)
       {
        let o = [];
        let spc = [];
        if (_mL === 0)
        {
         for (let i = 0, k = Object.keys(alnumDist), l = k.length; i < l; i++)
         {
          _mL = Math.max(_mL, alnumDist[k[i]][0].length);
         }
        }
        for (let y = 0; y < _mL; y++)
        {
         spc.push(0);
        }
        for (let i = 0, l = s.length; i < l; i++)
        {
         if (i > 0)
          o.push(spc);
         if (s[i] === ' ')
         {
          o.push(spc);
          o.push(spc);
          continue;
         }
         const v = s[i];
         if (!alnumDist.hasOwnProperty(v))
          continue;
         const c = alnumDist[v];
         for (let x = 0, m = c.length; x < m; x++)
         {
          o.push(c[x]);
         }
        }
        return o;
       }

       function _block(tInit, url, vH, oX, dX, tPerB, eT, iTime, x, t, sH, sS)
       {
        if (_iTitanic > tInit)
         return;
        let img = document.createElement('img');
        img.setAttribute('class', 'emote');
        _setImgSrc(img, url);
        const h = oX + sS * x;
        const v = -1 * sS;
        const vD = vH - sS * dX;
        let s = 'top: 0px;';
        s += ' left: 0px;';
        s += ' height: ' + sS + 'px;';
        s += ' width: ' + sS + 'px;';
        s += ' transition: all ' + tPerB + 'ms ease-in;';
        s += ' transform: translate(' + h + 'px, ' + v + 'px);';
        img.setAttribute('style', s);
        document.body.appendChild(img);
        const tMS = iTime * 1000;
        window.setTimeout(_tDrop, Math.floor(eT + tMS + t / 10), tInit, img, h, sH);
        window.setTimeout(_tMove, t, tInit, img, h, vD);
       }

       function _tMove(tInit, img, h, vD)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + vD + 'px)';
       }

       function _tDrop(tInit, img, h, sH)
       {
        if (_iTitanic > tInit)
         return;
        img.style.transform = 'translate(' + h + 'px, ' + sH + 'px)';
        img.style.transitionTime = '500ms';
        _gc.hook(img, false, true, 500);
       }

       return task;
      }();

      return {
       Fireworks: Fireworks,
       Spiral: Spiral,
       Pyramid: Pyramid,
       SmallPyramid: SmallPyramid,
       Stampede: Stampede,
       Conga: Conga,
       TheCube: TheCube,
       Text: Text
      };
     }();

     function _canShowKappa(k)
     {
      if (cfg.emote.max < 1)
       return true;
      if (_eActive < 1)
       return true;
      let tC = cfg.display.kappa.count;
      if (k !== false)
       tC = _getKappaCountEstimate(k);
      let cM = Math.max(cfg.emote.max, tC);
      return _eActive + tC < cM;
     }

     function _showKappas()
     {
      if (_tKappa !== false)
      {
       window.clearTimeout(_tKappa);
       _tKappa = false;
      }
      if (_toKappa.length < 1)
       return;
      let nK = _getNextKappa(_toKappa[0]);
      if (nK === false)
       return;
      if (!_canShowKappa(nK))
      {
       _tKappa = window.setTimeout(_showKappas, _dKappa);
       return;
      }
      let e = null;
      while ((e = _toKappa.shift()) !== undefined)
      {
       nK = false;
       let a = {};
       a[e.style] = e.prefs;
       showKappa(e.list, a, e.params);
       if (_toKappa.length < 1)
        return;
       nK = _getNextKappa(_toKappa[0]);
       if (nK === false)
        return;
       if (!_canShowKappa(nK))
       {
        if (cfg.emote.queue > 0 && _toKappa.length > cfg.emote.queue)
         _toKappa.splice(0, _toKappa.length - cfg.emote.queue);
        _tKappa = window.setTimeout(_showKappas, _dKappa);
        return;
       }
      }
     }

     function _getNextKappa(k)
     {
      let a = [];
      a[k.style] = k.prefs;
      return _getNextKappaEx(a, k.params);
     }

     function _getKappaCountParam(p)
     {
      const a = p.split(' ');
      for (let i = 0, l = a.length; i < l; i++)
      {
       if (!isNaN(a[i]))
        return parseInt(a[i], 10);
      }
      return false;
     }

     function _getNextKappaEx(kS = false, kP = false)
     {
      if (typeof kS !== 'object')
      {
       if (cfg.display.kappa.styles.length < 1)
        return false;
       kS = cfg.display.kappa.styles;
      }
      let s, p;
      const keys = Object.keys(kS);
      if (cfg.display.kappa.conga.contagious && _conga.length > 0)
      {
       s = 'Conga';
       p = {};
       if (keys.includes(s))
        p = kS[s];
      }
      else
      {
       s = keys[shared.rnd(keys.length)];
       p = kS[s];
      }
      if (s === undefined)
       return false;
      let iKC = cfg.display.kappa.count;
      if (cfg.display.kappa.styles.hasOwnProperty(s) && cfg.display.kappa.styles[s].hasOwnProperty('count') && cfg.display.kappa.styles[s].count > 0)
       iKC = cfg.display.kappa.styles[s].count;
      if (p === undefined)
       p = {};
      let pMax = cfg.emote.max;
      if (p.hasOwnProperty('count'))
      {
       let tKC = 0;
       if (Number.isInteger(p.count))
        tKC = p.count;
       else
       {
        if (p.count.hasOwnProperty('maximum'))
         pMax = p.count.max;
        if (p.count.hasOwnProperty('default'))
         tKC = p.count.default;
        if (p.count.hasOwnProperty('dynamic') && p.count.dynamic !== false)
        {
         if (p.hasOwnProperty('params') && p.params !== null)
         {
          const pC = _getKappaCountParam(p.params);
          if (pC !== false)
           tKC = pC;
         }
        }
       }
       if (tKC === -1 && kP !== false && kP.hasOwnProperty('%AMOUNT%') && Math.ceil(kP['%AMOUNT%']) > 0)
        tKC = Math.ceil(kP['%AMOUNT%']);
       if (tKC > 0)
        iKC = tKC;
      }
      if (pMax > 0 && iKC > pMax)
       iKC = pMax;
      return {style: s, prefs: p, count: iKC};
     }

     function _getKappaCountEstimate(k)
     {
      switch (k.style)
      {
       case 'Pyramid':
       case 'SmallPyramid':
        let c = 0;
        for (let i = 0, l = pyramidDist.length; i < l; i++)
         c += pyramidDist[i];
        return c;
       case 'Fireworks':
        const inner = Math.floor(k.count / 8);
        const outer = inner;
        const core = k.count - (inner + outer);
        return 1 + inner + core + outer;
       case 'Conga':
        const sW = window.innerWidth;
        const sH = window.innerHeight;
        const sS = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
        const bS = Math.ceil(sS * (5/3));
        return Math.floor(sW / bS);
      }
      return k.count;
     }

     async function _StringArrayToEmoteArray(s)
     {
      let r = [];
      let idx = 0;
      for (let i = 0, l = s.length; i < l; i++)
      {
       let v = {};
       v.str = s[i];
       v.pos = idx;
       idx+= s[i].length + 1;
       if (s[i].includes('//'))
       {
        v.svc = 'u';
        v.scope = 'g';
        v.url = s[i];
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('twitch') && thirdparty.emotes.twitch.hasOwnProperty(s[i]))
       {
        v.svc = 't';
        v.url = thirdparty.emotes.twitch[s[i]].url;
        v.scope = thirdparty.emotes.twitch[s[i]].scope;
        r.push(v);
        continue;
       }
       if (cfg.display.useEmoji !== false)
       {
        const cmd = {params: [null, s[i]]};
        const eMoji = await twitch.parse.content.emoji(cmd, cfg.display.useEmoji, true);
        if (eMoji.length > 0)
        {
         v.svc = 'e';
         v.scope = 'g';
         const vStart = v.pos;
         for (let j = 0, m = eMoji.length; j < m; j++)
         {
          v.url = eMoji[j].url;
          v.str = eMoji[j].str;
          v.pos = vStart + eMoji[j].pos;
          r.push(v);
         }
         continue;
        }
       }
       if (thirdparty.emotes.hasOwnProperty('ffz') && thirdparty.emotes.ffz.hasOwnProperty(s[i]) && thirdparty.emotes.ffz[s[i]].scope === 'c')
       {
        v.svc = 'f';
        v.url = thirdparty.emotes.ffz[s[i]].url;
        v.scope = thirdparty.emotes.ffz[s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('bttv') && thirdparty.emotes.bttv.hasOwnProperty(s[i]) && thirdparty.emotes.bttv[s[i]].scope === 'c')
       {
        v.svc = 'b';
        v.url = thirdparty.emotes.bttv[s[i]].url;
        v.scope = thirdparty.emotes.bttv[s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('7tv') && thirdparty.emotes['7tv'].hasOwnProperty(s[i]) && thirdparty.emotes['7tv'][s[i]].scope === 'c')
       {
        v.svc = '7';
        v.url = thirdparty.emotes['7tv'][s[i]].url;
        v.scope = thirdparty.emotes['7tv'][s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('ffz') && thirdparty.emotes.ffz.hasOwnProperty(s[i]) && thirdparty.emotes.ffz[s[i]].scope !== 'c')
       {
        v.svc = 'f';
        v.url = thirdparty.emotes.ffz[s[i]].url;
        v.scope = thirdparty.emotes.ffz[s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('bttv') && thirdparty.emotes.bttv.hasOwnProperty(s[i]) && thirdparty.emotes.bttv[s[i]].scope !== 'c')
       {
        v.svc = 'b';
        v.url = thirdparty.emotes.bttv[s[i]].url;
        v.scope = thirdparty.emotes.bttv[s[i]].scope;
        r.push(v);
        continue;
       }
       if (thirdparty.emotes.hasOwnProperty('7tv') && thirdparty.emotes['7tv'].hasOwnProperty(s[i]) && thirdparty.emotes['7tv'][s[i]].scope !== 'c')
       {
        v.svc = '7';
        v.url = thirdparty.emotes['7tv'][s[i]].url;
        v.scope = thirdparty.emotes['7tv'][s[i]].scope;
        r.push(v);
        continue;
       }
      }
      return r;
     }

     async function showKappa(kList, kStyles = false, kParams = false)
     {
      const kStyle = _getNextKappaEx(kStyles, kParams);
      if (kStyle === false)
       return;
      if (kStyle.style === undefined)
       return;
      if (kStyle.prefs.hasOwnProperty('emotes'))
      {
       let kForce = [];
       let bForce = false;
       if (Array.isArray(kStyle.prefs.emotes))
        kForce = kStyle.prefs.emotes;
       else
       {
        if (kStyle.prefs.emotes.hasOwnProperty('list'))
         kForce = kStyle.prefs.emotes.list;
        if (kStyle.prefs.emotes.hasOwnProperty('dynamic') && kStyle.prefs.emotes.dynamic === false)
         bForce = true;
       }
       if (!Array.isArray(kList) || kList.length < 1)
        bForce = true;
       if (bForce)
       {
        const fList = await _StringArrayToEmoteArray(kForce);
        if (fList.length > 0)
         kList = fList;
       }
      }
      if (!Array.isArray(kList) || kList.length < 1)
       kList = cList;
      if (!Array.isArray(kList) || kList.length < 1)
       kList = bareList;
      const sW = window.innerWidth;
      const sH = window.innerHeight;
      const sS = Math.max(cfg.emote.size.min, Math.min(cfg.emote.size.max, Math.floor(sW * cfg.emote.size.ratio.normal), Math.floor(sH * cfg.emote.size.ratio.normal)));
      const sSm = Math.max(cfg.emote.size.min, Math.min(Math.floor(cfg.emote.size.max / 2), Math.floor(sW * cfg.emote.size.ratio.small), Math.floor(sH * cfg.emote.size.ratio.small)));
      const sR = sW - sS;
      const sB = sH - sS;
      const ehs = Math.ceil(sS / 2);
      const ehl = sS * 2;
      const fR = sR * 0.33;
      document.documentElement.style.setProperty('--height', sH + 'px');
      document.documentElement.style.setProperty('--width', sW + 'px');
      document.documentElement.style.setProperty('--emote-height', sS + 'px');
      document.documentElement.style.setProperty('--emote-height-s', ehs + 'px');
      document.documentElement.style.setProperty('--emote-height-l', ehl + 'px');
      const waitFor = _getKappaCountEstimate(kStyle);
      if (!_canShowKappa(kStyle))
      {
       _toKappa.push({list: kList, style: kStyle.style, prefs: kStyle.prefs, params: kParams});
       if (_tKappa !== false)
       {
        window.clearTimeout(_tKappa);
        _tKappa = false;
       }
       _tKappa = window.setTimeout(_showKappas, _dKappa);
       return;
      }
      _eActive += waitFor;
      const lK = kList.length;
      const tInit = new Date().getTime();
      switch(kStyle.style)
      {
       case 'Stampede':
        await _list.Stampede(kList, sW, sH, sS, kStyle.count);
        _eActive -= kStyle.count;
        break;
       case 'Fireworks':
        _list.Fireworks(kList, sW, sH, sSm, kStyle.count);
        break;
       case 'Spiral':
        _list.Spiral(kList, sW, sH, sSm, kStyle.count);
        break;
       case 'Pyramid':
        _list.Pyramid(kList, sW, sH);
        break;
       case 'SmallPyramid':
        _list.SmallPyramid(kList, sW, sH);
        break;
       case 'Conga':
        _eActive -= waitFor;
        let avoidMiddle = false;
        if (cfg.display.kappa.conga.hasOwnProperty('avoidMiddle') && cfg.display.kappa.conga.avoidMiddle === true)
         avoidMiddle = true;
        if (kStyle.prefs.hasOwnProperty('avoidMiddle') && kStyle.prefs.avoidMiddle === true)
         avoidMiddle = true;
        _list.Conga(kList, sW, sH, sS, avoidMiddle);
        break;
       case 'Text':
        _eActive -= waitFor;
        let sTM = 'HYPE!';
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('message'))
         sTM = cfg.display.kappa.styles[kStyle.style].message[shared.rnd(cfg.display.kappa.styles[kStyle.style].message.length)];
        if (kStyle.prefs.hasOwnProperty('message') && Array.isArray(kStyle.prefs.message) && kStyle.prefs.message.length > 0)
         sTM = kStyle.prefs.message[shared.rnd(kStyle.prefs.message.length)];
        let sTT = cfg.emote.time;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('time'))
         sTT = cfg.display.kappa.styles[kStyle.style].time;
        if (kStyle.prefs.hasOwnProperty('time') && kStyle.prefs.time > 0)
         sTT = kStyle.prefs.time;
        if (kParams !== false)
        {
         const pK = Object.keys(kParams);
         for (let i = 0, l = pK.length; i < l; i++)
         {
          sTM = sTM.replaceAll(pK[i], kParams[pK[i]]);
         }
        }
        _list.Text(kList, sW, sH, sTM, sTT);
        break;
       case 'TheCube':
        _eActive -= waitFor;
        const cS = Math.min(sW, sH);
        const rC = shared.rnd(lK);
        let sCS = 8 / 10;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('size'))
         sCS = cfg.display.kappa.styles[kStyle.style].size;
        if (kStyle.prefs.hasOwnProperty('size'))
         sCS = kStyle.prefs.size;
        let sCC = true;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('center'))
         sCC = cfg.display.kappa.styles[kStyle.style].center;
        if (kStyle.prefs.hasOwnProperty('center'))
         sCC = kStyle.prefs.center;
        let sCR = 5;
        if (cfg.display.kappa.styles.hasOwnProperty(kStyle.style) && cfg.display.kappa.styles[kStyle.style].hasOwnProperty('rotations'))
         sCR = cfg.display.kappa.styles[kStyle.style].rotations;
        if (kStyle.prefs.hasOwnProperty('rotations'))
         sCR = kStyle.prefs.rotations;
        _list.TheCube(kList[rC].url, kList[rC].zwe ?? [], sW, sH, Math.floor(cS * sCS), sCC, sCR);
        break;
       case 'Burst':
        const fB = sB * 0.33;
        const oH = Math.floor(shared.rnd() * fR + fR);
        const oV = Math.floor(shared.rnd() * fB + fB);
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rB = shared.rnd(lK);
         _eActive--;
         display.emote.list.StraightLine(kList[rB].url, kList[rB].zwe ?? [], sW, sH, sS, oH, oV, false, tInit);
         await _sleep(50);
        }
        break;
       case 'Fountain':
        const fX = Math.floor(shared.rnd() * fR + fR);
        const fY = shared.rnd(25) + 15;
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rF = shared.rnd(lK);
         _eActive--;
         display.emote.list.Fountain(kList[rF].url, kList[rF].zwe ?? [], sW, sH, sS, fX, fY, false, tInit);
         await _sleep(50);
        }
        break;
       case 'Confetti':
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const rN = shared.rnd(lK);
         _eActive--;
         display.emote.list.Confetti(kList[rN].url, kList[rN].zwe ?? [], sW, sH, sSm, false, tInit);
         await _sleep(25);
        }
        break;
       default:
        if (typeof display.emote.list[kStyle.style] === 'undefined')
         return;
        for (let i = 0; i < kStyle.count; i++)
        {
         if (_iTitanic > tInit)
          return;
         const r = shared.rnd(lK);
         _eActive--;
         if (kStyle.style === 'StraightLine')
          display.emote.list.StraightLine(kList[r].url, kList[r].zwe ?? [], sW, sH, sS, false, false, false, tInit);
         else
          display.emote.list[kStyle.style](kList[r].url, kList[r].zwe ?? [], sW, sH, sS, false, tInit);
         await _sleep(100);
        }
      }
     }

     function hideKappa()
     {
      if (_tKappa !== false)
      {
       window.clearTimeout(_tKappa);
       _tKappa = false;
      }
      _toKappa.length = 0;
      _conga.length = 0;
     }

     return {
      show: showKappa,
      hide: hideKappa
     };
    }();

    const _gc = function()
    {
     let _toGC = {};

     let _tGC = false;

     function _doGC()
     {
      if (_tGC === false)
       return;
      window.clearTimeout(_tGC);
      _tGC = false;
      let done = true;
      const tNow = new Date().getTime();
      for (const idx in _toGC)
      {
       if (!_toGC.hasOwnProperty(idx))
        continue;
       done = false;
       const i = _toGC[idx].img;
       const t = _toGC[idx].end;
       const d = _toGC[idx].dec;
       if (_toGC[idx].space)
       {
        const r = i.getBoundingClientRect();
        if (t > tNow && r.bottom > 0 && r.right > 0 && r.top < window.innerHeight && r.left < window.innerWidth)
         continue;
       }
       else
       {
        if (t > tNow)
         continue;
       }
       delete _toGC[idx];
       if (i.parentNode !== null)
        document.body.removeChild(i);
       if (d)
        _eActive--;
      }
      if (!done)
       _tGC = window.setTimeout(_doGC, 500);
     }

     function gcEmote(img, space = true, decActive = true, t = false)
     {
      if (t === false)
       t = cfg.emote.time * 1000;
      let x = 0;
      do
      {
       x++;
      } while(_toGC.hasOwnProperty(x));
      _toGC[x] = {img: img, space: space, dec: decActive, end: new Date().getTime() + t};
      if (_tGC === false)
       _tGC = window.setTimeout(_doGC, 500);
     }

     return {
      hook: gcEmote
     };
    }();

    function _sleep(ms)
    {
     return new Promise(function(resolve){setTimeout(resolve, ms);});
    }

    function _addEmoteToDoc(tInit, uri, s, r = false, oGC = {}, oT = false)
    {
     if (_iTitanic > tInit)
      return;
     let img = document.createElement('img');
     img.setAttribute('class', 'emote');
     _setImgSrc(img, uri);
     img.setAttribute('style', s);
     _eActive++;
     document.body.appendChild(img);
     let space = true;
     let decActive = true;
     let t = false;
     if (oGC !== false)
     {
      if (oGC.hasOwnProperty('space'))
       space = oGC.space;
      if (oGC.hasOwnProperty('decrement'))
       decActive = oGC.decrement;
      if (oGC.hasOwnProperty('time'))
       t = oGC.time;
      _gc.hook(img, space, decActive, t);
     }
     if (oT !== false)
     {
      let sTF = null;
      if (oT.hasOwnProperty('x') && oT.hasOwnProperty('y'))
       sTF = 'translate(' + oT.x + 'px, ' + oT.y + 'px)';
      else if (oT.hasOwnProperty('x'))
       sTF = 'translateX(' + oT.x + 'px)';
      else if (oT.hasOwnProperty('y'))
       sTF = 'translateX(' + oT.y + 'px)';
      if (sTF !== null)
       window.setTimeout(_tMoveOnDock, _tStart, tInit, img, sTF);
     }
     if (r)
      return img;
    }

    function _tMoveOnDock(tInit, img, sTF)
    {
     if (_iTitanic > tInit)
      return;
     img.style.transform = sTF;
    }

    function _setImgSrc(img, url)
    {
     img.alt = '';
     img.onload = function()
     {
      img.onerror = null;
      img.onload = null;
     };
     img.onerror = function()
     {
      img.onerror = null;
      img.onload = null;
      img.src = bareList[shared.rnd(bareList.length)].url;
     };
     img.src = url;
    }

    function _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters)
    {
     let s = '';
     if (aNames.length > 0)
     {
      s += ' animation-name: ' + aNames.join() + ';';
      s += ' animation-delay: ' + aDelays.join() + ';';
      s += ' animation-duration: ' + aDurs.join() + ';';
      s += ' animation-timing-function: ' + aTimings.join() + ';';
      s += ' animation-fill-mode: ' + aFills.join() + ';';
      s += ' animation-iteration-count: ' + aIters.join() + ';';
     }
     return s;
    }

    function _styleEmote(aNames, aDelays, aDurs, aTimings, aFills, aIters, fadeIn = true, zoomIn = true, fadeOut = true, zoomOut = true, variationSize = 1)
    {
     const tMS = cfg.emote.time * 1000;
     const tFI = _tAnim.fade.in / 100;
     const tFO = _tAnim.fade.out / 100;
     const tZI = _tAnim.zoom.in / 100;
     const tZO = _tAnim.zoom.out / 100;
     if (fadeIn)
     {
      aNames.push('fadeIn');
      aDelays.push('0s');
      aDurs.push(Math.floor(tMS * tFI) + 'ms');
      aTimings.push('ease-in');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (zoomIn)
     {
      if (variationSize === 0)
       aNames.push('zoomInS');
      else if (variationSize === 2)
       aNames.push('zoomInL');
      else
       aNames.push('zoomIn');
      aDelays.push('0s');
      aDurs.push(Math.floor(tMS * tZI) + 'ms');
      aTimings.push('linear');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (fadeOut)
     {
      aNames.push('fadeOut');
      aDelays.push(Math.floor(tMS - tMS * tFO) + 'ms');
      aDurs.push(Math.floor(tMS * tFO) + 'ms');
      aTimings.push('ease-out');
      aFills.push('forwards');
      aIters.push('1');
     }
     else
     {
      aNames.push('noFadeOut');
      aDelays.push(tMS - 50 + 'ms');
      aDurs.push('50ms');
      aTimings.push('ease-out');
      aFills.push('forwards');
      aIters.push('1');
     }
     if (zoomOut)
     {
      if (variationSize === 0)
       aNames.push('zoomOutS');
      else if (variationSize === 2)
       aNames.push('zoomOutL');
      else
       aNames.push('zoomOut');
      aDelays.push(Math.floor(tMS - tMS * tZO) + 'ms');
      aDurs.push(Math.floor(tMS * tZO) + 'ms');
      aTimings.push('linear');
      aFills.push('forwards');
      aIters.push('1');
     }
     return _styleEmoteString(aNames, aDelays, aDurs, aTimings, aFills, aIters);
    }

    function eraseAll()
    {
     _iTitanic = new Date().getTime();
     display.kappa.hide();
     let cubes = document.getElementsByClassName('scene');
     while (cubes.length)
      cubes[0].parentElement.removeChild(cubes[0]);
     let imgs = document.getElementsByTagName('img');
     while (imgs.length)
      imgs[0].parentElement.removeChild(imgs[0]);
     twitch.parse.clearCooldowns();
    }

    return {
     emote: emote,
     kappa: kappa,
     eraseAll: eraseAll
    };
   }();

   const twitch = function()
   {
    let _rList = {};
    let _aTagged = {};

    const net = function()
    {
     async function _loadCheer_channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('cheer'))
       thirdparty.emotes.cheer = {};
      const url = cURLs.api.twitch.bits.cheermotes.replaceAll('%CHANNEL_ID%', chID);
      const h = {
       'Authorization': 'Bearer ' + cfg.login.oauth,
       'Client-Id': cfg.login.client
      };
      const r = await shared.httpRequest(url, h);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('data'))
       return false;
      for (let c = 0, l = j.data.length; c < l; c++)
      {
       const set = j.data[c];
       if (!set.hasOwnProperty('prefix'))
        continue;
       if (!set.hasOwnProperty('tiers'))
        continue;
       const prefix = set.prefix;
       let tierList = [];
       for (let i = set.tiers.length - 1; i >= 0; i--)
       {
        if (!set.tiers[i].hasOwnProperty('min_bits'))
         continue;
        if (!set.tiers[i].hasOwnProperty('images'))
         continue;
        const amt = set.tiers[i].min_bits;
        let img = null;
        if (set.tiers[i].images.hasOwnProperty('dark'))
        {
         if (set.tiers[i].images.dark.hasOwnProperty('animated'))
         {
          if (set.tiers[i].images.dark.animated.hasOwnProperty('4'))
           img = set.tiers[i].images.dark.animated['4'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('3'))
           img = set.tiers[i].images.dark.animated['3'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('2'))
           img = set.tiers[i].images.dark.animated['2'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('1.5'))
           img = set.tiers[i].images.dark.animated['1.5'];
          else if (set.tiers[i].images.dark.animated.hasOwnProperty('1'))
           img = set.tiers[i].images.dark.animated['1'];
         }
         else if (set.tiers[i].images.dark.hasOwnProperty('static'))
         {
          if (set.tiers[i].images.dark.static.hasOwnProperty('4'))
           img = set.tiers[i].images.dark.static['4'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('3'))
           img = set.tiers[i].images.dark.static['3'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('2'))
           img = set.tiers[i].images.dark.static['2'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('1.5'))
           img = set.tiers[i].images.dark.static['1.5'];
          else if (set.tiers[i].images.dark.static.hasOwnProperty('1'))
           img = set.tiers[i].images.dark.static['1'];
         }
        }
        else if (set.tiers[i].images.hasOwnProperty('light'))
        {
         if (set.tiers[i].images.light.hasOwnProperty('animated'))
         {
          if (set.tiers[i].images.light.animated.hasOwnProperty('4'))
           img = set.tiers[i].images.light.animated['4'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('3'))
           img = set.tiers[i].images.light.animated['3'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('2'))
           img = set.tiers[i].images.light.animated['2'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('1.5'))
           img = set.tiers[i].images.light.animated['1.5'];
          else if (set.tiers[i].images.light.animated.hasOwnProperty('1'))
           img = set.tiers[i].images.light.animated['1'];
         }
         else if (set.tiers[i].images.light.hasOwnProperty('static'))
         {
          if (set.tiers[i].images.light.static.hasOwnProperty('4'))
           img = set.tiers[i].images.light.static['4'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('3'))
           img = set.tiers[i].images.light.static['3'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('2'))
           img = set.tiers[i].images.light.static['2'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('1.5'))
           img = set.tiers[i].images.light.static['1.5'];
          else if (set.tiers[i].images.light.static.hasOwnProperty('1'))
           img = set.tiers[i].images.light.static['1'];
         }
        }
        if (img === null)
         continue;
        tierList.push({min: amt, img: img});
       }
       thirdparty.emotes.cheer[prefix] = tierList;
      }
      return true;
     }

     const eventSub = function()
     {
      let _wsURL = cURLs.ws.twitch.eventSub.release;
      let _wsRetry = null;
      let _ws = null;
      let _oldWS = null;
      let _ch = 0;
      let _sess = null;
      let _lTimeout = 5000;
      let _tTimeout = false;

      function task(chID = null)
      {
       if (chID !== null)
        _ch = chID;
       _ws = new WebSocket(_wsURL);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       _ws.onopen = null;
       _tTimeout = setTimeout(_wsTimeout, _lTimeout);
      }

      function _wsClose()
      {
       if (_tTimeout !== false)
       {
        clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       if (twitch.net.dead)
        return;
       if (_wsURL === cURLs.ws.twitch.eventSub.release)
       {
        _wsURL = cURLs.ws.twitch.eventSub.beta;
        window.setTimeout(task, 100);
        return;
       }
       if (_wsURL.length > cURLs.ws.twitch.eventSub.release.length && _wsURL.slice(0, cURLs.ws.twitch.eventSub.release.length) === cURLs.ws.twitch.eventSub.release)
        _wsURL = cURLs.ws.twitch.eventSub.release;
       else if (_wsURL.length > cURLs.ws.twitch.eventSub.beta.length && _wsURL.slice(0, cURLs.ws.twitch.eventSub.beta.length) === cURLs.ws.twitch.eventSub.beta)
        _wsURL = cURLs.ws.twitch.eventSub.beta;
       else
        _wsURL = cURLs.ws.twitch.eventSub.release;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(task, wsWait);
      }

      async function _wsMessage(ev)
      {
       if (_tTimeout !== false)
       {
        clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (twitch.net.dead)
       {
        _ws.close();
        return;
       }
       _tTimeout = setTimeout(_wsTimeout, _lTimeout);
       const r = JSON.parse(ev.data);
       if (!r.hasOwnProperty('metadata'))
        return;
       if (!r.hasOwnProperty('payload'))
        return;
       switch (r.metadata.message_type)
       {
        case 'session_welcome':
         if (_oldWS !== null)
         {
          _oldWS.close();
          _oldWS = null;
         }
         if (!r.payload.hasOwnProperty('session'))
          return;
         if (r.payload.session.hasOwnProperty('id'))
          _sess = r.payload.session.id;
         if (r.payload.session.hasOwnProperty('keepalive_timeout_seconds'))
         {
          _lTimeout = parseInt(r.payload.session.keepalive_timeout_seconds, 10) * 2 * 1000;
          if (_tTimeout !== false)
          {
           clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _tTimeout = setTimeout(_wsTimeout, _lTimeout);
         }
         const haveSubs = await _handleSubs();
         if (!haveSubs)
         {
          if (_tTimeout !== false)
          {
           clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _ws.onopen = null;
          _ws.onmessage = null;
          _ws.onclose = null;
          _ws.close();
          _ws = null;
          return;
         }
         break;
        case 'session_keepalive':
         _wsRetry = 0;
         break;
        case 'notification':
         if (!r.metadata.hasOwnProperty('subscription_type'))
          return;
         switch (r.metadata.subscription_type)
         {
          case 'channel.follow':
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('user_id'))
            return;
           if (cfg.ignore.users !== false && r.payload.event.hasOwnProperty('user_login') && cfg.ignore.users.includes(r.payload.event.user_login))
            return;
           if (!r.payload.event.hasOwnProperty('user_name'))
            return;
           twitch.net.fList[r.payload.event.user_id] = {value: true, t: new Date().getTime()};
           if (document.visibilityState !== 'hidden')
            display.kappa.show(false, cfg.event.follow, {'%USER%': r.payload.event.user_name});
           break;
          case 'channel.channel_points_custom_reward_redemption.add':
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('reward'))
            return;
           if (!r.payload.event.reward.hasOwnProperty('title'))
            return;
           if (cfg.ignore.users !== false && r.payload.event.hasOwnProperty('user_login') && cfg.ignore.users.includes(r.payload.event.user_login))
            return;
           const n = r.payload.event.reward.title;
           if (!r.payload.event.hasOwnProperty('user_input') || r.payload.event.user_input === '')
           {
            await twitch.parse.event.redeem(n, false);
            return;
           }
           if (!r.payload.event.reward.hasOwnProperty('id'))
            return;
           const lnID = r.payload.event.reward.id;
           if (!_rList.hasOwnProperty(lnID))
           {
            _rList[lnID] = {name: n, cmds: []};
            return;
           }
           if (_rList[lnID].name === false)
            _rList[lnID].name = n;
           while (_rList[lnID].cmds.length > 0)
           {
            await twitch.parse.event.redeem(n, _rList[lnID].cmds.shift());
           }
           break;
          case 'channel.shoutout.create':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('to_broadcaster_user_id'))
            return;
           if (!r.payload.event.hasOwnProperty('to_broadcaster_user_name'))
            return;
           await twitch.parse.event.shoutoutCreate(r.payload.event.to_broadcaster_user_id, r.payload.event.to_broadcaster_user_name);
           break;
          case 'channel.shoutout.receive':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('from_broadcaster_user_id'))
            return;
           if (cfg.ignore.users !== false && r.payload.event.hasOwnProperty('from_broadcaster_user_login') && cfg.ignore.users.includes(r.payload.event.from_broadcaster_user_login))
            return;
           if (!r.payload.event.hasOwnProperty('from_broadcaster_user_name'))
            return;
           await twitch.parse.event.shoutoutReceive(r.payload.event.from_broadcaster_user_id, r.payload.event.from_broadcaster_user_name);
           break;
          case 'channel.hype_train.begin':
           if (document.visibilityState === 'hidden')
            return;
           display.kappa.show(false, cfg.event.hypetrain.begin);
           break;
          case 'channel.hype_train.end':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('level'))
            return;
           const rs = shared.findInMaybeRange(cfg.event.hypetrain.success, r.payload.event.level);
           if (rs === false)
            return;
           display.kappa.show(false, rs);
           break;
          case 'channel.poll.begin':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           if (cfg.event.poll !== false && cfg.event.poll.hasOwnProperty('begin'))
            display.kappa.show(false, cfg.event.poll.begin, {'%TITLE%': r.payload.event.title});
           break;
          case 'channel.poll.end':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           if (!r.payload.event.hasOwnProperty('status') || r.payload.event.status !== 'completed')
            return;
           if (!r.payload.event.hasOwnProperty('choices'))
            return;
           twitch.parse.event.pollEnd(r.payload.event);
           break;
          case 'channel.prediction.begin':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           if (cfg.event.prediction !== false && cfg.event.prediction.hasOwnProperty('begin'))
            display.kappa.show(false, cfg.event.prediction.begin, {'%TITLE%': r.payload.event.title});
           break;
          case 'channel.prediction.end':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           if (!r.payload.event.hasOwnProperty('status') || r.payload.event.status !== 'resolved')
            return;
           if (!r.payload.event.hasOwnProperty('winning_outcome_id'))
            return;
           if (!r.payload.event.hasOwnProperty('outcomes'))
            return;
           twitch.parse.event.predictionEnd(r.payload.event);
           break;
          case 'channel.charity_campaign.donate':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('user_name'))
            return;
           const dName = r.payload.event.user_name;
           if (!r.payload.event.hasOwnProperty('amount'))
            return;
           if (!r.payload.event.amount.hasOwnProperty('value'))
            return;
           if (!r.payload.event.amount.hasOwnProperty('decimal_places'))
            return;
           if (!r.payload.event.amount.hasOwnProperty('currency'))
            return;
           const dAmt = r.payload.event.amount.value / Math.pow(10, r.payload.event.decimal_places) + ' ' + r.payload.event.amount.currency;
           const rd = shared.findInMaybeRange(cfg.event.charity, r.payload.event.amount.value);
           if (rd === false)
            return;
           display.kappa.show(false, rd, {'%USER%': dName, '%AMOUNT%': dAmt});
           break;
          case 'channel.goal.begin':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('type'))
            return;
           if (!r.payload.event.hasOwnProperty('description'))
            return;
           if (!r.payload.event.hasOwnProperty('target_amount'))
            return;
           if (cfg.event.goal !== false && cfg.event.goal.hasOwnProperty('begin'))
            display.kappa.show(false, cfg.event.goal.begin, {'%TITLE%': r.payload.event.description, '%TYPE%': r.payload.event.type, '%AMOUNT%': r.payload.event.target_amount});
           break;
          case 'channel.goal.end':
           if (document.visibilityState === 'hidden')
            return;
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('type'))
            return;
           if (!r.payload.event.hasOwnProperty('description'))
            return;
           if (!r.payload.event.hasOwnProperty('current_amount'))
            return;
           if (!r.payload.event.hasOwnProperty('is_achieved') || r.payload.event.is_achieved !== true)
            return;
           if (cfg.event.goal !== false && cfg.event.goal.hasOwnProperty('achieved'))
            display.kappa.show(false, cfg.event.goal.achieved, {'%TITLE%': r.payload.event.description, '%TYPE%': r.payload.event.type, '%AMOUNT%': r.payload.event.current_amount});
           break;
          case 'channel.update':
           if (!r.payload.hasOwnProperty('event'))
            return;
           if (!r.payload.event.hasOwnProperty('title'))
            return;
           await _addToChannelTitleTags(r.payload.event.title);
           break;
         }
         break;
        case 'session_reconnect':
         if (!r.payload.hasOwnProperty('session'))
          return;
         if (_tTimeout !== false)
         {
          clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         if (r.payload.session.hasOwnProperty('id'))
          _sess = r.payload.session.id;
         if (r.payload.session.hasOwnProperty('keepalive_timeout_seconds') && r.payload.session.keepalive_timeout_seconds !== null)
          _lTimeout = parseInt(r.payload.session.keepalive_timeout_seconds, 10) * 2 * 1000;
         if (r.payload.session.hasOwnProperty('reconnect_url'))
          _wsURL = r.payload.session.reconnect_url;
         _oldWS = _ws;
         _oldWS.onclose = null;
         _oldWS.onmessage = null;
         _ws = null;
         const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
         if (_wsRetry < 2)
          _wsRetry += 0.2;
         window.setTimeout(task, wsWait);
         break;
        case 'revocation':
         if (!r.metadata.hasOwnProperty('subscription_type'))
          return;
         const subType = r.metadata.subscription_type;
         let subVer = '1';
         if (r.metadata.hasOwnProperty('subscription_version'))
          subVer = r.metadata.subscription_version;
         await _subscribe(subType, subVer);
         break;
       }
      }

      function _wsTimeout()
      {
       _lTimeout = 5000;
       if (twitch.net.dead === true)
        return;
       if (_tTimeout !== false)
       {
        clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws !== null)
       {
        _ws.onopen = null;
        _ws.onmessage = null;
        _ws.onclose = null;
        _ws.close();
       }
       if (_wsURL.length > cURLs.ws.twitch.eventSub.release.length && _wsURL.slice(0, cURLs.ws.twitch.eventSub.release.length) === cURLs.ws.twitch.eventSub.release)
        _wsURL = cURLs.ws.twitch.eventSub.release;
       else if (_wsURL.length > cURLs.ws.twitch.eventSub.beta.length && _wsURL.slice(0, cURLs.ws.twitch.eventSub.beta.length) === cURLs.ws.twitch.eventSub.beta)
        _wsURL = cURLs.ws.twitch.eventSub.beta;
       else
        _wsURL = cURLs.ws.twitch.eventSub.release;
       task();
      }

      async function _handleSubs()
      {
       const aSubs = [
        {id: 'channel.follow', v: '2', scope: ['moderator:read:followers'], cfg: ['event.follow']},
        {id: 'channel.channel_points_custom_reward_redemption.add', scope: ['channel:read:redemptions'], cfg: false},
        {id: 'channel.shoutout.create', scope: ['moderator:read:shoutouts'], cfg: ['event.shoutout.create.styles']},
        {id: 'channel.shoutout.receive', scope: ['moderator:read:shoutouts'], cfg: ['event.shoutout.receive.styles']},
        {id: 'channel.hype_train.begin', scope: ['channel:read:hype_train'], cfg: ['event.hypetrain.begin']},
        {id: 'channel.hype_train.end', scope: ['channel:read:hype_train'], cfg: ['event.hypetrain.success']},
        {id: 'channel.poll.begin', scope: ['channel:read:polls'], cfg: ['event.poll.begin']},
        {id: 'channel.poll.end', scope: ['channel:read:polls'], cfg: ['event.poll.end']},
        {id: 'channel.prediction.begin', scope: ['channel:read:predictions'], cfg: ['event.prediction.begin']},
        {id: 'channel.prediction.end', scope: ['channel:read:predictions'], cfg: ['event.prediction.resolved']},
        {id: 'channel.goal.begin', scope: ['channel:read:goals'], cfg: ['event.goal.begin']},
        {id: 'channel.goal.end', scope: ['channel:read:goals'], cfg: ['event.goal.achieved']},
        {id: 'channel.charity_campaign.donate', scope: ['channel:read:charity'], cfg: ['event.charity']},
        {id: 'channel.update', scope: false, cfg: ['event.tag.styles']}
       ];
       const aActive = await _unsubscribe();
       let didSomething = aActive.length > 0;
       for (let i = 0, l = aSubs.length; i < l; i++)
       {
        if (await _handleSub(aSubs[i], aActive) !== false)
         didSomething = true;
       }
       return didSomething;
      }

      async function _handleSub(sub, aActive)
      {
       if (sub.hasOwnProperty('cfg') && sub.cfg !== false)
       {
        let found = true;
        for (let i = 0, l = sub.cfg.length; i < l; i++)
        {
         let aPref = sub.cfg[i].split('.');
         let cPref = cfg;
         found = true;
         for (let j = 0, m = aPref.length; j < m; j++)
         {
          if (!cPref.hasOwnProperty(aPref[j]))
          {
           found = false;
           break;
          }
          if (cPref[aPref[j]] === false)
          {
           found = false;
           break;
          }
          cPref = cPref[aPref[j]];
         }
         if (found !== false)
          break;
        }
        if (found === false)
         return false;
       }
       else if (sub.id === 'channel.channel_points_custom_reward_redemption.add')
       {
        let found = false;
        for (const k of cfg.commands)
        {
         if (!k.hasOwnProperty('redeem') || !Array.isArray(k.redeem) || k.redeem.length < 1)
          continue;
         found = true;
         break;
        }
        if (found === false)
         return false;
       }
       if (sub.hasOwnProperty('scope') && sub.scope !== false)
       {
        for (let i = 0, l = sub.scope.length; i < l; i++)
        {
         if (!cfg.login.scope.includes(sub.scope[i]))
          return false;
        }
       }
       if (aActive.includes(sub.id))
        return false;
       if (!sub.hasOwnProperty('v'))
        return _subscribe(sub.id);
       return _subscribe(sub.id, sub.v);
      }

      async function _unsubscribe()
      {
       const h = {
        'Authorization': 'Bearer ' + cfg.login.oauth,
        'Client-Id': cfg.login.client
       };
       const r = await shared.httpRequest(cURLs.api.twitch.eventSub.get, h);
       const j = JSON.parse(r);
       if (!j.hasOwnProperty('data'))
        return [];
       if (!j.hasOwnProperty('total'))
        return [];
       if (j.total < 1)
        return [];
       let rList = [];
       for (let i = 0; i < j.total; i++)
       {
        if (!j.data[i].hasOwnProperty('id'))
         continue;
        if (!j.data[i].hasOwnProperty('status'))
         continue;
        switch (j.data[i].status)
        {
         case 'enabled':
          if (!j.data[i].hasOwnProperty('type'))
           continue;
          if (!j.data[i].hasOwnProperty('transport'))
           continue;
          if (!j.data[i].transport.hasOwnProperty('method'))
           continue;
          if (j.data[i].transport.method !== 'websocket')
           continue;
          if (!j.data[i].transport.hasOwnProperty('session_id'))
           continue;
          if (j.data[i].transport.session_id !== _sess)
           continue;
          rList.push(j.data[i].type);
          break;
         case 'authorization_revoked':
         case 'moderator_removed':
         case 'user_removed':
         case 'version_removed':
         case 'websocket_disconnected':
         case 'websocket_failed_ping_pong':
         case 'websocket_received_inbound_traffic':
         case 'websocket_connection_unused':
         case 'websocket_internal_error':
         case 'websocket_network_timeout':
         case 'websocket_network_error':
          shared.httpSend('DELETE', cURLs.api.twitch.eventSub.delete.replaceAll('%ID%', j.data[i].id), null, h);
          break;
        }
       }
       return rList;
      }

      async function _subscribe(type, version = '1')
      {
       let d = {
        'type': type,
        'version': version,
        'condition': {'broadcaster_user_id': _ch},
        'transport': {'method': 'websocket', 'session_id': _sess}
       };
       switch (type)
       {
        case 'channel.follow':
        case 'channel.shoutout.create':
        case 'channel.shoutout.receive':
         d.condition.moderator_user_id = _ch;
         break;
       }
       const h = {
        'Authorization': 'Bearer ' + cfg.login.oauth,
        'Client-Id': cfg.login.client,
        'Content-Type': 'application/json'
       };
       const r = await shared.httpSend('POST', cURLs.api.twitch.eventSub.get, JSON.stringify(d), h);
       return r !== false;
      }

      return task;
     }();

     const irc = function()
     {
      let _wsRetry = 0;
      let _firstRS = true;
      let _ws = null;
      let _tTimeout = false;

      function task()
      {
       _firstRS = true;
       _ws = new WebSocket(cURLs.ws.twitch.irc);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       _ws.onopen = null;
       _tTimeout = setTimeout(_wsTimeout, 5000);
       _ws.send('CAP REQ :twitch.tv/commands twitch.tv/tags');
       _ws.send('PASS oauth:' + cfg.login.oauth);
       _ws.send('NICK ' + cfg.channel);
       _ws.send('JOIN #' + cfg.channel);
      }

      function _wsClose()
      {
       if (_tTimeout !== false)
       {
        clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(task, wsWait);
      }

      async function _wsMessage(ev)
      {
       if (_ws === null)
        return;
       if (twitch.net.dead)
       {
        _ws.close();
        _ws = null;
        return;
       }
       _wsRetry = 0;
       const data = ev.data.split('\r\n');
       for (let i = 0, l = data.length; i < l; i++)
       {
        if (data[i].length === 0)
         continue;
        let cmd = twitch.parse.message(data[i]);
        if (cmd === false)
        {
         console.log('Unparsed IRC Command: ', data[i]);
         continue;
        }
        switch(cmd.command)
        {
         case 'PING':
          _ws.send('PONG ' + cmd.params[0]);
          if (cfg.login.hasOwnProperty('oauth_refresh') && cfg.login.oauth_refresh !== false && cfg.login.oauth_refresh !== 'OAUTH_REFRESH')
           await twitch.net.updateOAuth();
          break;
         case 'PRIVMSG':
          if (document.visibilityState === 'hidden')
           continue;
          if (cmd.params.length > 1)
           cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d');
          if (!await twitch.parse.event.cheer(cmd))
           twitch.parse.line(cmd);
          break;
         case 'NOTICE':
          if (cmd.params.length > 1 && cmd.params[1] === 'Login authentication failed')
          {
           twitch.net.dead = true;
           shared.blargIAmDead(1);
          }
          break;
         case 'ROOMSTATE':
          if (!cmd.hasOwnProperty('tags'))
           continue;
          if (!cmd.tags.hasOwnProperty('room-id'))
           continue;
          twitch.net.channelID = cmd.tags['room-id'];
          if (_firstRS)
          {
           if (_tTimeout !== false)
           {
            clearTimeout(_tTimeout);
            _tTimeout = false;
           }
           _firstRS = false;
           await _loadEmote_channel(twitch.net.channelID);
           await _loadCheer_channel(twitch.net.channelID);
           if (cfg.event.tag.hasOwnProperty('styles') && cfg.event.tag.styles !== false)
            await _getChannelTitleTags(twitch.net.channelID);
           if (cfg.display.extended.useFFZ)
            thirdparty.ffz.channel(twitch.net.channelID);
           if (cfg.display.extended.useBTTV)
           {
            thirdparty.bttv.channel(twitch.net.channelID);
            thirdparty.bttv.socket(twitch.net.channelID);
           }
           if (cfg.display.extended.use7TV)
           {
            thirdparty['7tv'].channel(twitch.net.channelID);
            thirdparty['7tv'].socket(twitch.net.channelID);
           }
           if (cfg.display.extended.useFFZ | cfg.display.extended.use7TV)
            thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval, twitch.net.channelID);
           if (cfg.display.extended.useBTTV)
            thirdparty.bttv.timer = window.setTimeout(thirdparty.bttv.reload, thirdparty.interval, twitch.net.channelID);
           eventSub(twitch.net.channelID);
          }
          break;
         case 'USERNOTICE':
          if (document.visibilityState === 'hidden')
           continue;
          if (!cmd.hasOwnProperty('tags'))
           continue;
          if (!cmd.tags.hasOwnProperty('msg-id'))
           continue;
          if (cmd.params.length > 1)
           cmd.params[1] = cmd.params[1].replace(/(?<!\u{e0002})\u{e0002}(?!\u{e0002})/gu, '\u200d');
          switch (cmd.tags['msg-id'])
          {
           case 'raid':
            twitch.parse.event.raid(cmd);
            break;
           case 'sub':
           case 'resub':
           case 'subgift':
           case 'submysterygift':
           case 'giftpaidupgrade':
           case 'primepaidupgrade':
            twitch.parse.event.sub(cmd);
            break;
           case 'bitsbadgetier':
            twitch.parse.event.badge(cmd);
            break;
           default:
            if (cmd.params.length > 1)
             twitch.parse.line(cmd);
            break;
          }
          break;
         case 'CLEARCHAT':
          switch (cmd.params.length)
          {
           case 1:
            if (cfg.event.clear)
             display.eraseAll();
            break;
           case 2:
            if (document.visibilityState === 'hidden')
             continue;
            if (cmd.tags.hasOwnProperty('ban-duration'))
            {
             if (cfg.event.timeout !== false)
             await twitch.parse.event.timeout(cmd);
            }
            else
            {
             if (cfg.event.ban !== false)
              await twitch.parse.event.ban(cmd);
            }
            break;
          }
          break;
        }
       }
      }

      function _wsTimeout()
      {
       if (_ws === null)
        return;
       if (twitch.net.dead === true)
        return;
       twitch.net.dead = true;
       if (_tTimeout !== false)
       {
        clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       _ws.close();
       _ws = null;
       shared.blargIAmDead(4);
      }

      return task;
     }();

     async function _loadEmote_channel(chID)
     {
      cList = [];
      if (!thirdparty.emotes.hasOwnProperty('twitch'))
       thirdparty.emotes.twitch = {};
      const r = await _findEmote_channel(chID, thirdparty.emotes.twitch);
      if (r === false)
       return false;
      cList = r;
      return true;
     }

     async function getUserInfo(u, isID = false)
     {
      let url = cURLs.api.twitch.users.name.replaceAll('%USER%', u);
      if (isID)
       url = cURLs.api.twitch.users.id.replaceAll('%USER_ID%', u);
      const h = {
       'Authorization': 'Bearer ' + cfg.login.oauth,
       'Client-Id': cfg.login.client
      };
      const r = await shared.httpRequest(url, h);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('data'))
       return false;
      if (j.data.length !== 1)
       return false;
      return j.data[0];
     }

     async function _getChannelTitleTags(chID)
     {
      const url = cURLs.api.twitch.channels.root.replaceAll('%CHANNEL_ID%', chID);
      const h = {
       'Authorization': 'Bearer ' + cfg.login.oauth,
       'Client-Id': cfg.login.client
      };
      const r = await shared.httpRequest(url, h);
      if (r === false)
       return;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('data'))
       return;
      if (j.data.length !== 1)
       return;
      if (!j.data[0].hasOwnProperty('title'))
       return;
      await _addToChannelTitleTags(j.data[0].title);
     }

     async function _addToChannelTitleTags(title)
     {
      const tReg = /(?:^| )(?:@([A-Za-z0-9_]+))/g;
      let tList = [];
      let match = '';
      while ((match = tReg.exec(title)) !== null)
      {
       tList.push(match);
      }
      if (tList.length < 1)
       return;
      _aTagged = {};
      for (let i = 0, l = tList.length; i < l; i++)
      {
       if (tList[i][1].length < 1)
        continue;
       let u = await twitch.net.userInfo(tList[i][1]);
       if (u === false)
        continue;
       if (!u.hasOwnProperty('id'))
        continue;
       if (!u.hasOwnProperty('login'))
        continue;
       _aTagged[u.login] = u.id;
      }
     }

     async function _getOAuthToken(t)
     {
      const url = cURLs.html.rr.t.replaceAll('%REFRESH_TOKEN%', t);
      const r = await shared.httpRequest(url, {}, true, false);
      if (r === false)
       return false;
      if (r === null)
      {
       shared.blargIAmDead(1);
       window.localStorage.removeItem(login.path() + '.oauth');
       window.localStorage.removeItem(login.path() + '.refresh');
       window.localStorage.removeItem(login.path() + '.refreshed');
       return false;
      }
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('access_token'))
       return false;
      if (!j.hasOwnProperty('refresh_token'))
       return false;
      return j;
     }

     async function updateOAuth()
     {
      const lsOAuth = window.localStorage.getItem(login.path() + '.oauth');
      const lsRefresh = window.localStorage.getItem(login.path() + '.refresh');
      const lsRefreshed = window.localStorage.getItem(login.path() + '.refreshed');
      if (lsOAuth !== null)
       cfg.login.oauth = lsOAuth;
      if (lsRefresh !== null)
       cfg.login.oauth_refresh = lsRefresh;
      if (lsRefreshed !== null)
       cfg.login.oauth_refreshed = lsRefreshed;
      if (cfg.login.hasOwnProperty('oauth_refreshed') && cfg.login.oauth_refreshed > 0)
      {
       const tokAge = Math.floor(new Date().getTime() / 1000) - cfg.login.oauth_refreshed;
       if (tokAge < 60 * 60)
        return;
      }
      const ret = await _getOAuthToken(cfg.login.oauth_refresh);
      if (ret === false)
       return;
      cfg.login.oauth = ret.access_token;
      cfg.login.oauth_refresh = ret.refresh_token;
      cfg.login.oauth_refreshed = Math.floor(new Date().getTime() / 1000);
      window.localStorage.setItem(login.path() + '.oauth', cfg.login.oauth);
      window.localStorage.setItem(login.path() + '.refresh', cfg.login.oauth_refresh);
      window.localStorage.setItem(login.path() + '.refreshed', cfg.login.oauth_refreshed);
     }

     return {
      channelID: 0,
      fList: [],
      dead: false,
      irc: irc,
      userInfo: getUserInfo,
      updateOAuth: updateOAuth
     };
    }();

    const parse = function()
    {
     let _aLast = {};

     function _parseUser(cmd, latinOnly = false)
     {
      let data = cmd.prefix;
      let ret = {};
      if (cmd.hasOwnProperty('tags') && cmd.tags.hasOwnProperty('display-name'))
       ret['display-name'] = cmd.tags['display-name'];
      const gReg = new RegExp(twitch.parse.uReg, 'g');
      if (data.includes('!'))
      {
       ret.nick = data.slice(0, data.indexOf('!'));
       data = data.slice(data.indexOf('!') + 1);
       if (!ret.hasOwnProperty('display-name') || (latinOnly && ret['display-name'] !== ret['display-name'].replaceAll(gReg, '')))
        ret['display-name'] = ret.nick;
      }
      if (data.includes('@'))
      {
       ret.host = data.slice(0, data.indexOf('@'));
       data = data.slice(data.indexOf('@') + 1);
       if (!ret.hasOwnProperty('display-name') || (latinOnly && ret['display-name'] !== ret['display-name'].replaceAll(gReg, '')))
        ret['display-name'] = ret.host;
      }
      ret.user = data;
      return ret;
     }

     function parseMsg(line)
     {
      let cmd = {};
      if (line.slice(0, 1) === '@')
      {
       line = line.slice(1);
       if (!line.includes(' '))
        return false;
       cmd.tags = {};
       const t = line.slice(0, line.indexOf(' '));
       line = line.slice(line.indexOf(' ') + 1);
       const a = t.split(';');
       for (let i = 0, l = a.length; i < l; i++)
       {
        const k = a[i].slice(0, a[i].indexOf('='));
        let v = a[i].slice(a[i].indexOf('=') + 1);
        v = v.replace(/\\s/g, ' ');
        cmd.tags[k] = v;
       }
      }
      if (line.slice(0, 1) === ':')
      {
       line = line.slice(1);
       if (!line.includes(' '))
        return false;
       cmd.prefix = line.slice(0, line.indexOf(' '));
       line = line.slice(line.indexOf(' ') + 1);
      }
      if (!line.includes(' '))
      {
       cmd.command = line;
       return cmd;
      }
      cmd.command = line.slice(0, line.indexOf(' '));
      line = line.slice(line.indexOf(' ') + 1);
      cmd.params = [];
      if (!line.includes(' '))
      {
       cmd.params.push(line);
       return cmd;
      }
      while (line.includes(' '))
      {
       if (line.slice(0, 1) === ':')
       {
        cmd.params.push(line.slice(1));
        return cmd;
       }
       cmd.params.push(line.slice(0, line.indexOf(' ')));
       line = line.slice(line.indexOf(' ') + 1);
      }
      if (line.slice(0, 1) === ':')
       line = line.slice(1);
      cmd.params.push(line);
      return cmd;
     }

     const content = function()
     {
      const emoji = function()
      {
       let _uList = {};

       async function task(cmd, set, dup = null)
       {
        if (cmd.params.length < 2)
         return [];
        const msg = cmd.params[1];
        const emSeg = /((?:[\p{EPres}\p{ExtPict}]\ufe0f?\u200d?)+)+/gu;
        let emList = [];
        let match = '';
        while ((match = emSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        const kcSeg = /((?:[0-9#\*]\ufe0f\u20e3)+)+/gu;
        match = '';
        while ((match = kcSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        const acSeg = /(\u0d9e)/gu;
        match = '';
        while ((match = acSeg.exec(msg)) !== null)
        {
         emList.push(match);
        }
        if (emList.length === 0)
         return [];
        if (dup === null)
         dup = cfg.display.duplicates;
        if (set === true)
         set = 'twemoji';
        let ret = [];
        const uri = cURLs.cdn.ffz.emoji.replaceAll('%SET_ID%', set);
        let addList = {};
        function showEmoji(c, p)
        {
         if (c.slice(-5) === '-fe0f' && !c.match(/-200d-264[0|2]-/) && !c.match(/-200d-26a7/) && !c.match(/-200d-2620/))
          c = c.slice(0, -5);
         if (!addList.hasOwnProperty(c))
          addList[c] = 0;
         else
         {
          if (dup === false)
           return false;
          if (dup !== true && addList[c] >= dup)
           return false;
         }
         addList[c]++;
         ret.push({svc: 'e', url: uri + c + '.png', str: c, pos: p});
         return true;
        }
        function showCrew(p)
        {
         if (!addList.hasOwnProperty('0d9e'))
          addList['0d9e'] = 0;
         else
         {
          if (dup === false)
           return false;
          if (dup !== true && addList['0d9e'] >= dup)
           return false;
         }
         addList['0d9e']++;
         const crew = cURLs.cdn.crew.replaceAll('%DIRECTION%', shared.rnd(2)).replaceAll('%COLOR%', shared.rnd(18));
         ret.push({svc: 'e', url: crew, str: '0d9e', pos: p});
         return true;
        }
        for (let i = 0, l = emList.length; i < l; i++)
        {
         let cpList = [];
         for (const c of emList[i][0])
         {
          const p = c.codePointAt(0).toString(16).padStart(4, '0');
          if (cpList.length === 0)
          {
           cpList.push(p);
           continue;
          }
          const lL = cpList.length - 1;
          if (p === 'fe0f')
           cpList[lL] += '-' + p;
          else if (p === '200d')
           cpList[lL] += '-' + p;
          else if (p === '20e3')
           cpList[lL] += '-' + p;
          else if (p.match(/1f3f[b-f]/))
           cpList[lL] += '-' + p;
          else if (p.match(/1f9b[0-3]/))
          {
           if (cpList[lL].slice(-5) === '-200d')
            cpList[lL] += '-' + p;
           else
            cpList[lL] += '-200d-' + p;
          }
          else if (p.match(/264[0|2]/) || p.match(/26a7/))
          {
           if (cpList[lL].slice(-5) === '-200d')
            cpList[lL] += '-' + p;
           else
            cpList[lL] += '-200d-' + p;
          }
          else if (p.match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].match(/1f1((e[6-9a-f])|(f[0-9a-f]))/) && cpList[lL].length < 11)
           cpList[lL] += '-' + p;
          else if (p === '1f308' && cpList[lL] === '1f3f3-fe0f')
           cpList[lL] += '-200d-' + p;
          else if (p === '2620' && cpList[lL] === '1f3f4')
           cpList[lL] += '-200d-' + p;
          else if (cpList[lL].slice(-5) === '-200d')
           cpList[lL] += '-' + p;
          else
           cpList.push(p);
         }
         let found = false;
         const lP = cpList.length;
         if (lP === 1)
         {
          let s = cpList[0];
          if (s === '0d9e')
          {
           showCrew(emList[i].index);
           continue;
          }
          let tU;
          if (s.slice(-5) === '-fe0f')
          {
           if (s.match(/-200d-264[0|2]-/) || s.match(/-200d-26a7/) || s.match(/-200d-2620/))
            tU = uri + s + '.png';
           else
            tU = uri + s.slice(0, -5) + '.png';
          }
          else
           tU = uri + s + '.png';
          found = await _checkURL(tU);
          if (found)
          {
           showEmoji(s, emList[i].index);
           continue;
          }
          while (s.includes('-'))
          {
           s = s.slice(0, s.lastIndexOf('-'));
           if (s.slice(-5) === '-fe0f')
            tU = uri + s.slice(0, -5) + '.png';
           else
            tU = uri + s + '.png';
           found = await _checkURL(tU);
           if (found)
           {
            showEmoji(s, emList[i].index);
            break;
           }
          }
          continue;
         }
         let p = emList[i].index;
         for (let j = 0; j < lP; j++)
         {
          p += cpList[j].replaceAll(/[^\-]/g, '').length + 1;
          found = await _checkURL(uri + cpList[j] + '.png');
          if (found)
           showEmoji(cpList[j], p);
         }
        }
        return ret;
       }

       function _checkURL(url)
       {
        const p = new Promise(
         function(resolve)
         {
          if (_uList.hasOwnProperty(url))
          {
           resolve(_uList[url]);
           return;
          }
          const x = new XMLHttpRequest();
          x.open('HEAD', url);
          x.onreadystatechange = function()
          {
           if (x.readyState < 2)
            return;
           x.onreadystatechange = null;
           const r = x.status === 200;
           _uList[url] = r;
           resolve(r);
          };
          x.send();
         }
        );
        return p;
       }

       return task;
      }();

      function parseT(cmd, dup = null)
      {
       if (!cmd.hasOwnProperty('tags'))
        return [];
       if (!cmd.tags.hasOwnProperty('emotes'))
        return [];
       if (cmd.tags.emotes === '')
        return [];
       if (cmd.params.length < 2)
        return [];
       const m = cmd.params[1];
       const e = cmd.tags.emotes.split('/');
       if (dup === null)
        dup = cfg.display.duplicates;
       let ret = [];
       for (let i = 0, n = e.length; i < n; i++)
       {
        const eID = e[i].slice(0, e[i].indexOf(':'));
        const u = cURLs.cdn.twitch.emote.replaceAll('%EMOTE_ID%', eID);
        const eVals = e[i].slice(e[i].indexOf(':') + 1).split(',');
        const eStart = parseInt(eVals[0].split('-')[0], 10);
        const eEnd = parseInt(eVals[0].split('-')[1], 10);
        const sName = m.slice(eStart, eEnd + 1);
        let l = eVals.length;
        if (dup === false)
         l = 1;
        else if (dup !== true)
         l = Math.min(l, dup);
        for (let c = 0; c < l; c++)
        {
         const p = parseInt(eVals[c].split('-')[0], 10);
         ret.push({svc: 't', url: u, str: sName, pos: p});
        }
       }
       return ret;
      }

      const $3rdparty = function()
      {
       function parseFFZ(cmd, dup = null)
       {
        if (!thirdparty.emotes.hasOwnProperty('ffz'))
         return [];
        if (cmd.params.length < 2)
         return [];
        const m = cmd.params[1].split(' ');
        if (dup === null)
         dup = cfg.display.duplicates;
        let ret = [];
        let addList = {};
        for (let i = 0, l = m.length; i < l; i++)
        {
         if (!thirdparty.emotes.ffz.hasOwnProperty(m[i]))
          continue;
         if (thirdparty.emotes.ffz[m[i]].users !== null)
         {
          const u = _parseUser(cmd);
          if (!thirdparty.emotes.ffz[m[i]].users.includes(u.host))
           continue;
         }
         if (!addList.hasOwnProperty(m[i]))
          addList[m[i]] = 0;
         else
         {
          if (dup === false)
           continue;
          if (dup !== true && addList[m[i]] >= dup)
           continue;
         }
         addList[m[i]]++;
         let p = 0;
         for (let j = 0; j < i; j++)
         {
          p+= m[j].length + 1;
         }
         ret.push({svc: 'f', url: thirdparty.emotes.ffz[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.ffz[m[i]].scope});
        }
        return ret;
       }

       const bttv = function()
       {
        function parseBTTV(cmd, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('bttv'))
          return [];
         if (cmd.params.length < 2)
          return [];
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes.bttv.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          ret.push({svc: 'b', url: thirdparty.emotes.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.bttv[m[i]].scope});
         }
         return ret;
        }

        function parseBTTVZWE(l, cmd, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!thirdparty.emotes.hasOwnProperty('zwe'))
          return;
         if (!thirdparty.emotes.zwe.hasOwnProperty('bttv'))
          return;
         if (cmd.params.length < 2)
          return;
         l.sort(_posSort);
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!thirdparty.emotes.zwe.bttv.hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope});
          }
          else
          {
           let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(thirdparty.emotes.zwe.bttv);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('7tv'))
           {
            z = Object.keys(thirdparty.emotes.zwe['7tv']);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: 'b', url: thirdparty.emotes.zwe.bttv[m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe.bttv[m[i]].scope});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== 'b')
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        function parseBTTVU(cmd, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('bttvU'))
          return [];
         if (cmd.params.length < 2)
          return [];
         const u = _parseUser(cmd);
         if (!thirdparty.emotes.bttvU.hasOwnProperty(u.host))
          return [];
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes.bttvU[u.host].hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          ret.push({svc: 'b', url: thirdparty.emotes.bttvU[u.host][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.bttvU[u.host][m[i]].scope});
         }
         return ret;
        }

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: parseBTTV,
         zwe: parseBTTVZWE,
         user: parseBTTVU
        };
       }();

       const $7tv = function()
       {
        function parse7TV(cmd, dup = null)
        {
         if (!thirdparty.emotes.hasOwnProperty('7tv'))
          return [];
         if (cmd.params.length < 2)
          return [];
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let ret = [];
         let addList = {};
         for (let i = 0, l = m.length; i < l; i++)
         {
          if (!thirdparty.emotes['7tv'].hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          ret.push({svc: '7', url: thirdparty.emotes['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes['7tv'][m[i]].scope});
         }
         return ret;
        }

        function parse7TVZWE(l, cmd, pass, dup = null)
        {
         if (!cfg.display.extended.useZWE)
          return;
         if (!thirdparty.emotes.hasOwnProperty('zwe'))
          return;
         if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
          return;
         if (cmd.params.length < 2)
          return;
         l.sort(_posSort);
         const m = cmd.params[1].split(' ');
         if (dup === null)
          dup = cfg.display.duplicates;
         let addList = {};
         for (let i = 0, n = m.length; i < n; i++)
         {
          if (!thirdparty.emotes.zwe['7tv'].hasOwnProperty(m[i]))
           continue;
          if (!addList.hasOwnProperty(m[i]))
           addList[m[i]] = 0;
          else
          {
           if (dup === false)
            continue;
           if (dup !== true && addList[m[i]] >= dup)
            continue;
          }
          addList[m[i]]++;
          let p = 0;
          for (let j = 0; j < i; j++)
          {
           p+= m[j].length + 1;
          }
          let f = -1;
          let h = -1;
          for (let j = 0, o = l.length; j < o; j++)
          {
           if (l[j].pos > h)
            h = l[j].pos;
           else
            continue;
           if (l[j].pos < p)
            f = j;
          }
          if (f === -1)
          {
           if (pass === 1)
            l.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope});
          }
          else
          {
           let t = cmd.params[1].slice(l[f].pos + l[f].str.length, p);
           let z = Object.keys(thirdparty.emotes.zwe['7tv']);
           for (let j = 0, o = z.length; j < o; j++)
           {
            t = t.replaceAll(z[j], '');
           }
           if (thirdparty.emotes.zwe.hasOwnProperty('bttv'))
           {
            z = Object.keys(thirdparty.emotes.zwe.bttv);
            for (let j = 0, o = z.length; j < o; j++)
            {
             t = t.replaceAll(z[j], '');
            }
           }
           t = t.trim();
           if (t.length > 0)
           {
            if (pass === 1)
             l.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope});
           }
           else if (pass === 2)
           {
            if (!l[f].hasOwnProperty('zwe'))
             l[f].zwe = [];
            l[f].zwe.push({svc: '7', url: thirdparty.emotes.zwe['7tv'][m[i]].url, str: m[i], pos: p, scope: thirdparty.emotes.zwe['7tv'][m[i]].scope});
            l[f].zwe.sort(_posSort);
            for (let j = 0, o = l.length; j < o; j++)
            {
             if (l[j].svc !== '7')
              continue;
             if (l[j].pos !== p)
              continue;
             l.splice(j, 1);
             break;
            }
           }
          }
         }
        }

        function _posSort(a, b)
        {
         return a.pos - b.pos;
        }

        return {
         general: parse7TV,
         zwe: parse7TVZWE
        };
       }();

       return {
        ffz: parseFFZ,
        bttv: bttv,
        '7tv': $7tv
       };
      }();

      return {
       emoji: emoji,
       twitch: parseT,
       '3rdparty': $3rdparty
      };
     }();

     const parseLine = function()
     {
      async function task(cmd)
      {
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       if (await _parseCustomReward(cmd))
        return;
       if (cmd.params.length < 2)
        return;
       const lv = await _level.get(cmd);
       if (await _parseTaggedChannel(cmd, lv))
        return;
       if (await _parseCommand(cmd, lv))
        return;
       if ((lv & cfg.display.access) === 0)
        return;
       const p = _handleDuplicates(await _eListFromCmd(cmd));
       if (p.length === 0)
        return;
       display.emote.addToShowList(p);
       display.emote.showEmotes();
      }

      async function _parseCustomReward(cmd)
      {
       if (!cmd.hasOwnProperty('tags'))
        return false;
       if (!cmd.tags.hasOwnProperty('custom-reward-id'))
        return false;
       const lnID = cmd.tags['custom-reward-id'];
       if (!_rList.hasOwnProperty(lnID))
       {
        _rList[lnID] = {name: false, cmds: [cmd]};
        return true;
       }
       _rList[lnID].cmds.push(cmd);
       if (_rList[lnID].name === false)
        return true;
       while (_rList[lnID].cmds.length > 0)
       {
        await event.redeem(_rList[lnID].name, _rList[lnID].cmds.shift());
       }
       return true;
      }

      async function _parseTaggedChannel(cmd, lv)
      {
       if (Object.keys(_aTagged).length < 1)
        return false;
       if (!cfg.event.tag.hasOwnProperty('styles'))
        return false;
       if (cfg.event.tag.styles === false)
        return false;
       const m = cmd.params[1];
       if (m.slice(0, 1) !== '@')
        return false;
       let uTagged = m.slice(1);
       if (uTagged.indexOf(' ') > -1)
        uTagged = uTagged.slice(0, uTagged.indexOf(' '));
       uTagged = uTagged.toLowerCase();
       if (!_aTagged.hasOwnProperty(uTagged))
        return false;
       const uID = _aTagged[uTagged];
       let rq = cfg.display.kappa.access;
       if (cfg.event.tag.hasOwnProperty('access') && cfg.event.tag.access >= 0)
        rq = cfg.event.tag.access;
       if ((lv & rq) === 0)
        return false;
       if (!cfg.event.tag.targetEmotes)
       {
        display.kappa.show(false, cfg.event.tag.styles, {'%USER%': uTagged});
        return true;
       }
       const e = await _findEmote_channel(uID);
       if (cfg.display.extended.useFFZ)
       {
        const rFFZ = await thirdparty.ffz.channelEx(uID);
        if (rFFZ !== false)
        {
         for (let i = 0, l = rFFZ.length; i < l; i++)
         {
          e.push({url: rFFZ[i].url});
         }
        }
       }
       if (cfg.display.extended.useBTTV)
       {
        const rBTTV = await thirdparty.bttv.channelEx(uID);
        if (rBTTV !== false)
        {
         for (let i = 0, l = rBTTV.length; i < l; i++)
         {
          e.push({url: rBTTV[i].url});
         }
        }
       }
       if (cfg.display.extended.use7TV)
       {
        const r7TV = await thirdparty['7tv'].channelEx(uID);
        if (r7TV !== false)
        {
         for (let i = 0, l = r7TV.length; i < l; i++)
         {
          if ((r7TV[i].vis & 0x80) === 0x80)
           continue;
          e.push({url: r7TV[i].url});
         }
        }
       }
       display.kappa.show(e, cfg.event.tag.styles, {'%USER%': uTagged});
       return true;
      }

      async function _parseCommand(cmd, lv)
      {
       const kNow = new Date().getTime();
       const m = cmd.params[1].toLowerCase();
       let foundAdvCmd = false;
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('styles') && !k.hasOwnProperty('erase'))
         continue;
        if (!k.hasOwnProperty('aliases'))
         continue;
        let foundKCmd = false;
        if (k.aliases.includes(m))
         foundKCmd = m;
        if (foundKCmd === false)
        {
         for (let i = 0, l = k.aliases.length; i < l; i++)
         {
          if (m.slice(0, k.aliases[i].length + 1) === k.aliases[i] + ' ')
          {
           foundKCmd = k.aliases[i];
           break;
          }
         }
        }
        if (foundKCmd === false)
         continue;
        let kAccess = cfg.display.kappa.access;
        if (k.hasOwnProperty('access'))
         kAccess = k.access;
        if ((lv & kAccess) === 0)
         continue;
        foundAdvCmd = true;
        if (k.hasOwnProperty('cooldown'))
        {
         let hK = _hashCode(k);
         if (!_aLast.hasOwnProperty(hK))
          _aLast[hK] = 0;
         if (k.cooldown !== 0 && kNow - _aLast[hK] < k.cooldown * 1000)
          continue;
        }
        if (k.hasOwnProperty('erase'))
        {
         display.eraseAll();
         return true;
        }
        let kC = {};
        for (let kS in k.styles)
        {
         if (!k.styles.hasOwnProperty(kS))
          continue;
         kC[kS] = JSON.parse(JSON.stringify(k.styles[kS]));
         kC[kS].command = foundKCmd;
         if (foundKCmd.length === m.length)
          kC[kS].params = null;
         else
          kC[kS].params = m.slice(foundKCmd.length + 1);
        }
        let eA = false;
        if (foundKCmd.length < m.length)
         eA = _handleDuplicates(await _eListFromCmd(cmd, true));
        _aLast[_hashCode(k)] = kNow;
        display.kappa.show(eA, kC);
        return true;
       }
       let foundCmd = false;
       if (cfg.display.kappa.aliases.includes(m))
        foundCmd = m;
       if (foundCmd === false)
       {
        for (let i = 0, l = cfg.display.kappa.aliases.length; i < l; i++)
        {
         if (m.slice(0, cfg.display.kappa.aliases[i].length + 1) === cfg.display.kappa.aliases[i] + ' ')
         {
          foundCmd = cfg.display.kappa.aliases[i];
          break;
         }
        }
       }
       if (foundCmd === false)
        return foundAdvCmd;
       if ((lv & cfg.display.kappa.access) === 0)
        return foundAdvCmd;
       let h = _hashCode(null);
       if (!_aLast.hasOwnProperty(h))
        _aLast[h] = 0;
       if (cfg.display.kappa.cooldown > 0 && kNow - _aLast[h] < cfg.display.kappa.cooldown * 1000)
        return true;
       let a = false;
       if (foundCmd.length < m.length)
        a = _handleDuplicates(await _eListFromCmd(cmd, true));
       _aLast[h] = kNow;
       display.kappa.show(a);
       return true;
      }

      function _hashCode(o)
      {
       const s = JSON.stringify(o);
       let h = 0;
       for (let i = 0, l = s.length; i < l; i++)
        h = Math.imul(31, h) + s.charCodeAt(i) | 0;
       return h;
      }

      return task;
     }();

     const event = function()
     {
      let bList = [];

      async function parseCheer(cmd)
      {
       if (!thirdparty.emotes.hasOwnProperty('cheer'))
        return false;
       if (!cmd.hasOwnProperty('tags'))
        return false;
       if (!cmd.tags.hasOwnProperty('bits'))
        return false;
       if (cmd.tags.bits < 1)
        return false;
       let p = [];
       const msg = cmd.params[1].split(' ');
       for (let m = 0, l = msg.length; m < l; m++)
       {
        for (const prefix in thirdparty.emotes.cheer)
        {
         if (!thirdparty.emotes.cheer.hasOwnProperty(prefix))
          continue;
         const firstChars = prefix.length;
         if (msg[m].slice(0, firstChars).toLowerCase() !== prefix.toLowerCase())
          continue;
         const amt = msg[m].slice(firstChars);
         if (isNaN(amt))
          continue;
         for (let i = 0, n = thirdparty.emotes.cheer[prefix].length; i < n; i++)
         {
          if (parseInt(amt, 10) < thirdparty.emotes.cheer[prefix][i].min)
           continue;
          const sName = prefix + thirdparty.emotes.cheer[prefix][i].min;
          p.push({svc: 'c', url: thirdparty.emotes.cheer[prefix][i].img, str: sName});
          break;
         }
        }
       }
       if (cfg.event.cheer.useMsg)
       {
        const a = await _eListFromCmd(cmd);
        p = p.concat(a);
       }
       else
        await parseLine(cmd);
       p = _handleDuplicates(p);
       if (p.length === 0)
        return false;
       const r = shared.findInMaybeRange(cfg.event.cheer.bits, cmd.tags.bits);
       if (r === false)
       {
        display.emote.addToShowList(p);
        display.emote.showEmotes();
        return true;
       }
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       display.kappa.show(p, r, {'%USER%': dn, '%AMOUNT%': cmd.tags.bits});
       return true;
      }

      async function parseRaid(cmd)
      {
       if (!cmd.tags.hasOwnProperty('msg-param-viewerCount'))
        return;
       const c = cmd.tags['msg-param-viewerCount'];
       const r = shared.findInMaybeRange(cfg.event.raid.raiders, c);
       if (r === false)
        return;
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       if (!cfg.event.raid.originEmotes)
       {
        display.kappa.show(false, r, {'%USER%': dn, '%AMOUNT%': c});
        return;
       }
       const d = cmd.tags['user-id'];
       const e = await _findEmote_channel(d);
       if (cfg.display.extended.useFFZ)
       {
        const rFFZ = await thirdparty.ffz.channelEx(d);
        if (rFFZ !== false)
        {
         for (let i = 0, l = rFFZ.length; i < l; i++)
         {
          e.push({url: rFFZ[i].url});
         }
        }
       }
       if (cfg.display.extended.useBTTV)
       {
        const rBTTV = await thirdparty.bttv.channelEx(d);
        if (rBTTV !== false)
        {
         for (let i = 0, l = rBTTV.length; i < l; i++)
         {
          e.push({url: rBTTV[i].url});
         }
        }
       }
       if (cfg.display.extended.use7TV)
       {
        const r7TV = await thirdparty['7tv'].channelEx(d);
        if (r7TV !== false)
        {
         for (let i = 0, l = r7TV.length; i < l; i++)
         {
          if ((r7TV[i].vis & 0x80) === 0x80)
           continue;
          e.push({url: r7TV[i].url});
         }
        }
       }
       display.kappa.show(e, r, {'%USER%': dn, '%AMOUNT%': c});
      }

      function _parseSubPlan(c)
      {
       if (!c.tags.hasOwnProperty('msg-param-sub-plan'))
        return false;
       const p = c.tags['msg-param-sub-plan'];
       switch (p)
       {
        case '1000': return 't1';
        case '2000': return 't2';
        case '3000': return 't3';
        case 'Prime': return 'prime';
       }
       return false;
      }

      async function parseSub(cmd)
      {
       if (!cmd.tags.hasOwnProperty('msg-id'))
        return;
       const subPlan = _parseSubPlan(cmd);
       if (subPlan === false)
        return;
       let mpoi = false;
       if (cmd.tags.hasOwnProperty('msg-param-origin-id'))
        mpoi = cmd.tags['msg-param-origin-id'];
       if (mpoi !== false && bList.includes(mpoi))
        return;
       let a = [];
       if (cmd.params.length > 1)
       {
        if (cfg.event.sub.useMsg)
         a = await _eListFromCmd(cmd, true);
        else
         await parseLine(cmd);
       }
       let mpm = 1;
       if (cmd.tags.hasOwnProperty('msg-param-months'))
        mpm = parseInt(cmd.tags['msg-param-months'], 10);
       let mpcm = 1;
       if (cmd.tags.hasOwnProperty('msg-param-cumulative-months'))
        mpcm = parseInt(cmd.tags['msg-param-cumulative-months'], 10);
       let mpmgc = 1;
       if (cmd.tags.hasOwnProperty('msg-param-mass-gift-count'))
        mpmgc = parseInt(cmd.tags['msg-param-mass-gift-count'], 10);
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       let mprdn = 'Anonymous';
       if (cmd.tags.hasOwnProperty('msg-param-recipient-display-name'))
        mprdn = cmd.tags['msg-param-recipient-display-name'];
       switch (cmd.tags['msg-id'])
       {
        case 'sub':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('first'))
          return;
         if (cfg.event.sub[subPlan].first === false)
          return;
         display.kappa.show(a, cfg.event.sub[subPlan].first, {'%USER%': dn});
         break;
        case 'resub':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('resub'))
          return;
         const rs = shared.findInMaybeRange(cfg.event.sub[subPlan].resub, mpcm);
         if (rs === false)
          return;
         display.kappa.show(a, rs, {'%USER%': dn, '%AMOUNT%': mpcm});
         break;
        case 'primepaidupgrade':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('upgrade'))
          return;
         if (!cfg.event.sub[subPlan].upgrade.hasOwnProperty('prime'))
          return;
         display.kappa.show(a, cfg.event.sub[subPlan].upgrade.prime, {'%USER%': dn});
         break;
        case 'giftpaidupgrade':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('upgrade'))
          return;
         if (!cfg.event.sub[subPlan].upgrade.hasOwnProperty('gift'))
          return;
         display.kappa.show(a, cfg.event.sub[subPlan].upgrade.gift, {'%USER%': dn});
         break;
        case 'subgift':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('gift'))
          return;
         if (mpm === 1)
         {
          if (!cfg.event.sub[subPlan].gift.hasOwnProperty('first'))
           return;
          if (cfg.event.sub[subPlan].gift.first === false)
           return;
          display.kappa.show(a, cfg.event.sub[subPlan].gift.first, {'%SENDER%': dn, '%USER%': mprdn});
          return;
         }
         if (!cfg.event.sub[subPlan].gift.hasOwnProperty('resub'))
          return;
         const gpr = shared.findInMaybeRange(cfg.event.sub[subPlan].gift.resub, mpm);
         if (gpr === false)
          return;
         display.kappa.show(a, gpr, {'%SENDER%': dn, '%USER%': mprdn, '%AMOUNT%': mpm});
         break;
        case 'submysterygift':
         if (!cfg.event.sub.hasOwnProperty(subPlan))
          return;
         if (!cfg.event.sub[subPlan].hasOwnProperty('gift'))
          return;
         if (!cfg.event.sub[subPlan].gift.hasOwnProperty('bomb'))
          return;
         if (cfg.event.sub[subPlan].gift.bomb === false)
          return;
         if (mpoi !== false)
          bList.push(mpoi);
         const gpb = shared.findInMaybeRange(cfg.event.sub[subPlan].gift.bomb, mpmgc);
         if (gpb === false)
          return;
         display.kappa.show(a, gpb, {'%SENDER%': dn, '%AMOUNT%': mpmgc});
         break;
       }
      }

      function parseBadge(cmd)
      {
       if (!cmd.tags.hasOwnProperty('msg-param-threshold'))
        return;
       const c = cmd.tags['msg-param-threshold'];
       const u = _parseUser(cmd, true);
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
        return;
       let dn = 'Anonymous';
       if (u.hasOwnProperty('display-name'))
        dn = u['display-name'];
       if (cfg.event.badge.hasOwnProperty(c) && cfg.event.badge[c] !== false)
       {
        display.kappa.show(false, cfg.event.badge[c], {'%USER%': dn, '%AMOUNT%': c});
        return;
       }
       let closest = null;
       for (const b in cfg.event.badge)
       {
        if (!cfg.event.badge.hasOwnProperty(b))
         continue;
        if (closest === null)
        {
         closest = b;
         continue;
        }
        if (Math.abs(parseInt(closest, 10) - parseInt(c, 10)) > Math.abs(parseInt(b, 10) - parseInt(c, 10)))
         closest = b;
       }
       if (closest === null)
        return;
       if (cfg.event.badge[closest] === false)
        return;
       display.kappa.show(false, cfg.event.badge[closest], {'%USER%': dn, '%AMOUNT%': c});
      }

      async function parseRedeem(title, cmd)
      {
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('redeem'))
         continue;
        if (!k.redeem.includes(title))
         continue;
        let kC = k.styles;
        if (cmd === false)
        {
         display.kappa.show(false, kC);
         return;
        }
        const a = _handleDuplicates(await _eListFromCmd(cmd, true));
        display.kappa.show(a, kC);
        return;
       }
      }

      async function parseBan(cmd)
      {
       let dn = cmd.params[1];
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(dn))
        return;
       if (cmd.tags.hasOwnProperty('target-user-id'))
       {
        const r = await twitch.net.userInfo(cmd.tags['target-user-id'], true);
        if (r.hasOwnProperty('display_name'))
         dn = r.display_name;
       }
       display.kappa.show(false, cfg.event.ban, {'%USER%': dn});
      }

      async function parseTimeout(cmd)
      {
       let dn = cmd.params[1];
       if (cfg.ignore.users !== false && cfg.ignore.users.includes(dn))
        return;
       if (cmd.tags.hasOwnProperty('target-user-id'))
       {
        const r = await twitch.net.userInfo(cmd.tags['target-user-id'], true);
        if (r.hasOwnProperty('display_name'))
         dn = r.display_name;
       }
       const dDur = cmd.tags['ban-duration'];
       const r = shared.findInMaybeRange(cfg.event.timeout, dDur);
       if (r === false)
        return;
       display.kappa.show(false, r, {'%USER%': dn, '%AMOUNT%': dDur});
      }

      async function parseShoutoutCreate(uID, uName)
      {
       if (!cfg.event.shoutout.create.targetEmotes)
       {
        display.kappa.show(false, cfg.event.shoutout.create.styles, {'%USER%': uName});
        return;
       }
       const e = await _findEmote_channel(uID);
       if (cfg.display.extended.useFFZ)
       {
        const rFFZ = await thirdparty.ffz.channelEx(uID);
        if (rFFZ !== false)
        {
         for (let i = 0, l = rFFZ.length; i < l; i++)
         {
          e.push({url: rFFZ[i].url});
         }
        }
       }
       if (cfg.display.extended.useBTTV)
       {
        const rBTTV = await thirdparty.bttv.channelEx(uID);
        if (rBTTV !== false)
        {
         for (let i = 0, l = rBTTV.length; i < l; i++)
         {
          e.push({url: rBTTV[i].url});
         }
        }
       }
       if (cfg.display.extended.use7TV)
       {
        const r7TV = await thirdparty['7tv'].channelEx(uID);
        if (r7TV !== false)
        {
         for (let i = 0, l = r7TV.length; i < l; i++)
         {
          if ((r7TV[i].vis & 0x80) === 0x80)
           continue;
          e.push({url: r7TV[i].url});
         }
        }
       }
       display.kappa.show(e, cfg.event.shoutout.create.styles, {'%USER%': uName});
      }

      async function parseShoutoutReceive(uID, uName)
      {
       if (!cfg.event.shoutout.receive.originEmotes)
       {
        display.kappa.show(false, cfg.event.shoutout.receive.styles, {'%USER%': uName});
        return;
       }
       const e = await _findEmote_channel(uID);
       if (cfg.display.extended.useFFZ)
       {
        const rFFZ = await thirdparty.ffz.channelEx(uID);
        if (rFFZ !== false)
        {
         for (let i = 0, l = rFFZ.length; i < l; i++)
         {
          e.push({url: rFFZ[i].url});
         }
        }
       }
       if (cfg.display.extended.useBTTV)
       {
        const rBTTV = await thirdparty.bttv.channelEx(uID);
        if (rBTTV !== false)
        {
         for (let i = 0, l = rBTTV.length; i < l; i++)
         {
          e.push({url: rBTTV[i].url});
         }
        }
       }
       if (cfg.display.extended.use7TV)
       {
        const r7TV = await thirdparty['7tv'].channelEx(uID);
        if (r7TV !== false)
        {
         for (let i = 0, l = r7TV.length; i < l; i++)
         {
          if ((r7TV[i].vis & 0x80) === 0x80)
           continue;
          e.push({url: r7TV[i].url});
         }
        }
       }
       display.kappa.show(e, cfg.event.shoutout.receive.styles, {'%USER%': uName});
      }

      function parsePollEnd(e)
      {
       let vPoll = 0;
       for (let i = 0, l = e.choices.length; i < l; i++)
       {
        if (!e.choices[i].hasOwnProperty('title'))
         continue;
        if (!e.choices[i].hasOwnProperty('votes'))
         continue;
        vPoll = Math.max(vPoll, e.choices[i].votes);
       }
       let rPoll = [];
       for (let i = 0, l = e.choices.length; i < l; i++)
       {
        if (!e.choices[i].hasOwnProperty('title'))
         continue;
        if (!e.choices[i].hasOwnProperty('votes'))
         continue;
        if (e.choices[i].votes === vPoll)
         rPoll.push(e.choices[i].title);
       }
       let sPoll = 'None';
       if (rPoll.length > 0)
        sPoll = rPoll.join(' + ');
       if (cfg.event.poll !== false && cfg.event.poll.hasOwnProperty('end'))
        display.kappa.show(false, cfg.event.poll.end, {'%TITLE%': e.title, '%RESULT%': sPoll});
      }

      function parsePredictionEnd(e)
      {
       let sPrediction = 'None';
       for (let i = 0, l = e.outcomes.length; i < l; i++)
       {
        if (!e.outcomes[i].hasOwnProperty('id'))
         continue;
        if (e.outcomes[i].id !== e.winning_outcome_id)
         continue;
        if (!e.outcomes[i].hasOwnProperty('title'))
         continue;
        sPrediction = e.outcomes[i].title;
        break;
       }
       if (cfg.event.prediction !== false && cfg.event.prediction.hasOwnProperty('resolved'))
        display.kappa.show(false, cfg.event.prediction.resolved, {'%TITLE%': e.title, '%RESULT%': sPrediction});
      }

      return {
       cheer: parseCheer,
       raid: parseRaid,
       sub: parseSub,
       badge: parseBadge,
       redeem: parseRedeem,
       ban: parseBan,
       timeout: parseTimeout,
       shoutoutCreate: parseShoutoutCreate,
       shoutoutReceive: parseShoutoutReceive,
       pollEnd: parsePollEnd,
       predictionEnd: parsePredictionEnd
      };
     }();

     const _level = function()
     {
      const _rFH = 3600000;

      function _jSplit(s, sep, limit)
      {
       let arr = [];
       let v = '';
       for (let i = 0, l = s.length; i < l; i++)
       {
        if (arr.length < limit - 1)
        {
         if (s[i] === sep)
         {
          arr.push(v);
          v = '';
          continue;
         }
        }
        v += s[i];
       }
       if (v.length > 0)
        arr.push(v);
       return arr;
      }

      async function _checkFollower(cmd)
      {
       const uID = cmd.tags['user-id'];
       if (twitch.net.fList.hasOwnProperty(uID))
       {
        const tDif = new Date().getTime() - twitch.net.fList[uID].t;
        if (tDif < _rFH)
         return twitch.net.fList[uID].value;
       }
       const url = cURLs.api.twitch.channels.followers.replaceAll('%USER_ID%', uID).replaceAll('%CHANNEL_ID%', cmd.tags['room-id']);
       const h = {
        'Authorization': 'Bearer ' + cfg.login.oauth,
        'Client-Id': cfg.login.client
       };
       const r = await shared.httpRequest(url, h);
       if (r === false)
        return false;
       const j = JSON.parse(r);
       if (j.hasOwnProperty('data') && j.data.length > 0)
       {
        twitch.net.fList[uID] = {value: true, t: new Date().getTime()};
        return true;
       }
       twitch.net.fList[uID] = {value: false, t: new Date().getTime()};
       return false;
      }

      async function parseLevel(cmd)
      {
       let r = 0x001;
       if (cmd.tags.hasOwnProperty('mod') && cmd.tags.mod === '1')
        r |= 0x400;
       if (cmd.tags.hasOwnProperty('vip') && cmd.tags.vip === '1')
        r |= 0x100;
       if (cmd.tags.hasOwnProperty('badges'))
       {
        const badges = cmd.tags.badges.split(',');
        for (let i = 0, l = badges.length; i < l; i++)
        {
         const bData = _jSplit(badges[i], '/', 2);
         switch (bData[0])
         {
          case 'broadcaster':
           r |= 0x800;
           break;
          case 'moderator':
           r |= 0x400;
           break;
          case 'vip':
           r |= 0x100;
           break;
          case 'artist-badge':
           r |= 0x080;
           break;
          case 'founder':
           r |= 0x200;
           break;
          case 'bits':
           r |= 0x004;
           break;
          case 'subscriber':
           const badge = parseInt(bData[1], 10);
           if (badge < 2000)
            r |= 0x010;
           else if (badge < 3000)
            r |= 0x020;
           else
            r |= 0x040;
           break;
         }
        }
       }
       /* api-heavy, only check if follower access is allowed and there's a chance it matters */
       let needF = false;
       if ((cfg.display.access & 0x002) === 0x002 && (cfg.display.access & 0x001) !== 0x001)
        needF = true;
       else if ((cfg.display.kappa.access & 0x002) === 0x002 && (cfg.display.kappa.access & 0x001) !== 0x001)
        needF = true;
       else
       {
        for (const k of cfg.commands)
        {
         if (!k.hasOwnProperty('styles'))
          continue;
         if (!k.hasOwnProperty('access'))
          continue;
         if ((k.access & 0x002) === 0x002 && (k.access & 0x001) !== 0x001)
         {
          needF = true;
          break;
         }
        }
       }
       if (needF)
       {
        const f = await _checkFollower(cmd);
        if (f)
         r |= 0x002;
       }
       if ((r & 0x800) === 0x800 && (r & 0x070) !== 0)
        return r & ~0x070;
       return r;
      }

      return {
       get: parseLevel
      };
     }();

     function _handleDuplicates(a)
     {
      const lA = a.length;
      if (lA < 1)
       return a;
      let r = [];
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'u')
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].svc === 't' || a[i].svc === 'c' || a[i].svc === 'e')
        r.push(a[i]);
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope === 'c' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        let f = false;
        for (let j = 0, l = r.length; j < l; j++)
        {
         if (r[j].str === a[i].str)
         {
          f = true;
          if (r[j].svc === a[i].svc)
           r.push(a[i]);
          break;
         }
        }
        if (!f)
         r.push(a[i]);
       }
      }
      for (let i = 0; i < lA; i++)
      {
       if (a[i].scope !== 'c' && (a[i].svc === 'b' || a[i].svc === 'f' || a[i].svc === '7'))
       {
        let f = false;
        for (let j = 0, l = r.length; j < l; j++)
        {
         if (r[j].str === a[i].str)
         {
          f = true;
          if (r[j].svc === a[i].svc)
           r.push(a[i]);
          break;
         }
        }
        if (!f)
         r.push(a[i]);
       }
      }
      return r;
     }

     async function _eListFromCmd(cmd, dup = null)
     {
      let r = [];
      const u = _parseUser(cmd, true);
      if (cfg.ignore.users !== false && cfg.ignore.users.includes(u.host))
       return r;
      r = r.concat(twitch.parse.content.twitch(cmd, dup));
      if (cfg.display.useEmoji)
       r = r.concat(await twitch.parse.content.emoji(cmd, cfg.display.useEmoji, dup));
      if (cfg.display.extended.useFFZ)
       r = r.concat(twitch.parse.content['3rdparty'].ffz(cmd, dup));
      if (cfg.display.extended.useBTTV)
      {
       r = r.concat(twitch.parse.content['3rdparty'].bttv.general(cmd, dup));
       r = r.concat(twitch.parse.content['3rdparty'].bttv.user(cmd, dup));
      }
      if (cfg.display.extended.use7TV)
       r = r.concat(twitch.parse.content['3rdparty']['7tv'].general(cmd, dup));
      if (cfg.display.extended.useBTTV)
       twitch.parse.content['3rdparty'].bttv.zwe(r, cmd, 1, dup);
      if (cfg.display.extended.use7TV)
       twitch.parse.content['3rdparty']['7tv'].zwe(r, cmd, 1, dup);
      if (cfg.display.extended.useBTTV)
       twitch.parse.content['3rdparty'].bttv.zwe(r, cmd, 2, dup);
      if (cfg.display.extended.use7TV)
       twitch.parse.content['3rdparty']['7tv'].zwe(r, cmd, 2, dup);
      if (cfg.ignore.emotes !== false && cfg.ignore.emotes.length > 0)
      {
       for (let i = r.length - 1; i >= 0; i--)
       {
        let m = r[i].str;
        if (r[i].svc === 'e')
         m = String.fromCharCode(parseInt(m, 16));
        if (cfg.ignore.emotes.includes(m))
         r.splice(i, 1);
       }
      }
      return r;
     }

     function clearCooldowns()
     {
      _aLast = {};
     }

     return {
      message: parseMsg,
      content: content,
      line: parseLine,
      event: event,
      clearCooldowns: clearCooldowns,
      uReg: /[^A-Za-z0-9_]/
     };
    }();

    const _findEmote_channel = function()
    {
     const _rCH = 300000;
     let _chList = {};

     async function task(chID, n = false)
     {
      if (n === false && _chList.hasOwnProperty(chID))
      {
       const tDif = new Date().getTime() - _chList[chID].t;
       if (tDif < _rCH)
        return _chList[chID].value;
      }
      const url = cURLs.api.twitch.chat.emotes.root.replaceAll('%CHANNEL_ID%', chID);
      const h = {
       'Authorization': 'Bearer ' + cfg.login.oauth,
       'Client-Id': cfg.login.client
      };
      const r = await shared.httpRequest(url, h, true);
      if (r === false)
       return false;
      if (r === null)
      {
       shared.blargIAmDead(3);
       return false;
      }
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('data'))
       return false;
      if (!Array.isArray(j.data))
       return false;
      let ret = [];
      for (let i = 0, l = j.data.length; i < l; i++)
      {
       if (!j.data[i].hasOwnProperty('id'))
        continue;
       if (cfg.ignore.emotes !== false && j.data[i].hasOwnProperty('name') && cfg.ignore.emotes.includes(j.data[i].name))
        continue;
       const eURL = cURLs.cdn.twitch.emote.replaceAll('%EMOTE_ID%', j.data[i].id);
       if (n !== false && j.data[i].hasOwnProperty('name'))
       {
        n[j.data[i].name] = {
         scope: 'c',
         url: eURL,
         id: j.data[i].id,
         users: null
        };
       }
       ret.push({url: eURL});
      }
      _chList[chID] = {t: new Date().getTime(), value: ret};
      return ret;
     }

     return task;
    }();

    async function findEmote_global()
    {
     if (!thirdparty.emotes.hasOwnProperty('twitch'))
      thirdparty.emotes.twitch = {};
     const url = cURLs.api.twitch.chat.emotes.global;
     const h = {
      'Authorization': 'Bearer ' + cfg.login.oauth,
      'Client-Id': cfg.login.client
     };
     const r = await shared.httpRequest(url, h, true);
     if (r === false)
      return false;
     if (r === null)
     {
      shared.blargIAmDead(3);
      return false;
     }
     const j = JSON.parse(r);
     if (!j.hasOwnProperty('data'))
      return false;
     if (!Array.isArray(j.data))
      return false;
     for (let i = 0, l = j.data.length; i < l; i++)
     {
      if (!j.data[i].hasOwnProperty('id'))
       continue;
      if (!j.data[i].hasOwnProperty('name'))
       continue;
      thirdparty.emotes.twitch[j.data[i].name] = {
       scope: 'g',
       url: cURLs.cdn.twitch.emote.replaceAll('%EMOTE_ID%', j.data[i].id),
       id: j.data[i].id,
       users: null
      };
     }
     return true;
    }

    return {
     net: net,
     parse: parse,
     global: findEmote_global
    };
   }();

   const streamlabs = function()
   {
    async function _showStreamlabsDonations(dRet)
    {
     for (let i = 0, l = dRet.length; i < l; i++)
     {
      const n = dRet[i].name;
      const a = dRet[i].amt;
      const v = Math.floor(a * cfg.streamlabs.curMul);
      const r = shared.findInMaybeRange(cfg.event.tip.streamlabs.donation, v);
      if (r === false)
       continue;
      let p = false;
      if (cfg.event.tip.useProfileImage && n !== false)
      {
       let u = false;
       if (!twitch.parse.uReg.test(n))
        u = await twitch.net.userInfo(n);
       if (u !== false)
       {
        if (u.hasOwnProperty('profile_image_url'))
         p = [
          {url: u.profile_image_url}
         ];
       }
      }
      let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
      if (cfg.streamlabs.dispDec > 0)
       s = s.toFixed(cfg.streamlabs.dispDec);
      else
       s = Math.floor(s);
      if (cfg.streamlabs.dispPre !== false)
       s = cfg.streamlabs.dispPre + s;
      if (cfg.streamlabs.dispSuf !== false)
       s += cfg.streamlabs.dispSuf;
      display.kappa.show(p, r, {'%USER%': n, '%AMOUNT%': s});
     }
    }

    async function _showStreamlabsPledges(pRet)
    {
     for (let i = 0, l = pRet.length; i < l; i++)
     {
      const n = pRet[i].name;
      const a = pRet[i].amt;
      const v = Math.floor(a * cfg.streamlabs.curMul);
      const r = shared.findInMaybeRange(cfg.event.tip.streamlabs.pledge, v);
      if (r === false)
       continue;
      let p = false;
      if (cfg.event.tip.useProfileImage && n !== false)
      {
       let u = false;
       if (!twitch.parse.uReg.test(n))
        u = await twitch.net.userInfo(n);
       if (u !== false)
       {
        if (u.hasOwnProperty('profile_image_url'))
         p = [
          {url: u.profile_image_url}
         ];
       }
      }
      let s = Number.parseFloat(a * cfg.streamlabs.dispMul);
      if (cfg.streamlabs.dispDec > 0)
       s = s.toFixed(cfg.streamlabs.dispDec);
      else
       s = Math.floor(s);
      if (cfg.streamlabs.dispPre !== false)
       s = cfg.streamlabs.dispPre + s;
      if (cfg.streamlabs.dispSuf !== false)
       s += cfg.streamlabs.dispSuf;
      display.kappa.show(p, r, {'%USER%': n, '%AMOUNT%': s});
     }
    }

    const streamlabsWS = function()
    {
     let _wsRetry = 0;
     let _tPing = false;
     let _ws = null;

     function task()
     {
      _tPing = 0;
      _ws = new WebSocket(cURLs.ws.streamlabs.replaceAll('%TOKEN%', cfg.streamlabs.token));
      _ws.onclose = _wsClose;
      _ws.onmessage = _wsMessage;
     }

     function _wsClose()
     {
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws = null;
      if (twitch.net.dead)
       return;
      const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
      if (_wsRetry < 2)
       _wsRetry += 0.2;
      window.setTimeout(task, wsWait);
     }

     async function _wsMessage(ev)
     {
      if (_ws === null)
       return;
      if (twitch.net.dead)
      {
       _ws.close();
       _ws = null;
       return;
      }
      _wsRetry = 0;
      const d = ev.data;
      if (d.length < 1)
       return;
      switch (d.slice(0, 1))
      {
       case '0':
        let t = 20000;
        if (d.length > 1)
        {
         const c = JSON.parse(d.slice(1));
         if (c.hasOwnProperty('pingInterval'))
          t = c.pingInterval;
        }
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, t);
        break;
       case '4':
        if (document.visibilityState === 'hidden')
         return;
        if (d.slice(1, 2) !== '2')
         return;
        if (d.length < 2)
         return;
        const o = JSON.parse(d.slice(2));
        if (o.length < 2)
         return;
        if (o[0] !== 'event')
         return;
        if (!o[1].hasOwnProperty('message'))
         return;
        let rD = [];
        let rP = [];
        for (let i = 0, l = o[1].message.length; i < l; i++)
        {
         if (!o[1].message[i].hasOwnProperty('amount'))
          continue;
         if (!o[1].message[i].hasOwnProperty('type'))
          continue;
         if (o[1].message[i].type === 'donation')
         {
          let n = false;
          if (o[1].message[i].hasOwnProperty('name'))
           n = o[1].message[i].name;
          rD.push({amt: o[1].message[i].amount, name: n});
         }
         if (o[1].message[i].type === 'pledge')
         {
          let n = false;
          if (o[1].message[i].hasOwnProperty('name'))
           n = o[1].message[i].name;
          rP.push({amt: o[1].message[i].amount, name: n});
         }
        }
        if (rD.length > 0)
         await _showStreamlabsDonations(rD);
        if (rP.length > 0)
         await _showStreamlabsPledges(rP);
        break;
      }
     }

     function _wsPing()
     {
      if (_ws === null)
       return;
      _ws.send('2');
     }

     return task;
    }();

    return {
     socket: streamlabsWS
    };
   }();

   const streamelements = function()
   {
    async function _showStreamElementsTip(dAmt, dName)
    {
     const v = Math.floor(dAmt * cfg.streamelements.curMul);
     if (v < 1)
      return;
     const r = shared.findInMaybeRange(cfg.event.tip.streamelements, v);
     if (r === false)
      return;
     let p = false;
     if (cfg.event.tip.useProfileImage && dName !== false)
     {
      let u = false;
      if (!twitch.parse.uReg.test(dName))
       u = await twitch.net.userInfo(dName);
      if (u !== false)
      {
       if (u.hasOwnProperty('profile_image_url'))
        p = [
         {url: u.profile_image_url}
        ];
      }
     }
     let s = Number.parseFloat(dAmt * cfg.streamelements.dispMul);
     if (cfg.streamelements.dispDec > 0)
      s = s.toFixed(cfg.streamelements.dispDec);
     else
      s = Math.floor(s);
     if (cfg.streamelements.dispPre !== false)
      s = cfg.streamelements.dispPre + s;
     if (cfg.streamelements.dispSuf !== false)
      s += cfg.streamelements.dispSuf;
     display.kappa.show(p, r, {'%USER%': dName, '%AMOUNT%': s});
    }

    const streamelementsWS = function()
    {
     let _wsRetry = 0;
     let _tPing = 0;
     let _ws = null;

     function task()
     {
      _tPing = 0;
      _ws = new WebSocket(cURLs.ws.streamelements);
      _ws.onclose = _wsClose;
      _ws.onmessage = _wsMessage;
     }

     function _wsClose()
     {
      if (_tPing !== 0)
      {
       window.clearInterval(_tPing);
       _tPing = 0;
      }
      if (_ws === null)
       return;
      _ws.onmessage = null;
      _ws.onclose = null;
      _ws = null;
      if (twitch.net.dead)
       return;
      const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
      if (_wsRetry < 2)
       _wsRetry += 0.2;
      window.setTimeout(task, wsWait);
     }

     async function _wsMessage(ev)
     {
      if (_ws === null)
       return;
      if (twitch.net.dead)
      {
       _ws.close();
       _ws = null;
       return;
      }
      _wsRetry = 0;
      const d = ev.data;
      if (d.length < 1)
       return;
      switch (d.slice(0, 1))
      {
       case '0':
        let t = 20000;
        if (d.length > 1)
        {
         const c = JSON.parse(d.slice(1));
         if (c.hasOwnProperty('pingInterval'))
          t = c.pingInterval;
        }
        if (_tPing !== 0)
        {
         window.clearInterval(_tPing);
         _tPing = 0;
        }
        _tPing = window.setInterval(_wsPing, t);
        break;
       case '4':
        if (d.slice(1, 2) === '0')
        {
         let a = '';
         if (cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== 'OAUTH_ID')
          a = JSON.stringify(['authenticate', {'method': 'oauth2', 'token': cfg.streamelements.oauth}]);
         else if (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== 'JWT_TOKEN')
          a = JSON.stringify(['authenticate', {'method': 'jwt', 'token': cfg.streamelements.token}]);
         _ws.send('42' + a);
         return;
        }
        if (document.visibilityState === 'hidden')
         return;
        if (d.slice(1, 2) !== '2')
         return;
        if (d.length < 2)
         return;
        const o = JSON.parse(d.slice(2));
        if (o.length < 2)
         return;
        if (o[0] !== 'event:update')
         return;
        if (!o[1].hasOwnProperty('name'))
         return;
        if (o[1].name !== 'tip-latest')
         return;
        if (!o[1].hasOwnProperty('data'))
         return;
        if (!o[1].data.hasOwnProperty('amount'))
         return;
        let n = false;
        if (o[1].data.hasOwnProperty('name'))
         n = o[1].data.name;
        await _showStreamElementsTip(o[1].data.amount, n);
        break;
      }
     }

     function _wsPing()
     {
      if (_ws === null)
       return;
      _ws.send('2');
     }

     return task;
    }();

    async function _getOAuthToken(t)
    {
     const url = cURLs.html.rr.se.replaceAll('%REFRESH_TOKEN%', t);
     const r = await shared.httpRequest(url, {}, false, false);
     if (r === false)
      return false;
     const j = JSON.parse(r);
     if (!j.hasOwnProperty('access_token'))
      return false;
     if (!j.hasOwnProperty('refresh_token'))
      return false;
     if (!j.hasOwnProperty('expires_in'))
      return false;
     return j;
    }

    async function updateOAuth()
    {
     const lsOAuth = window.localStorage.getItem('streamelements.tips:read.oauth');
     const lsRefresh = window.localStorage.getItem('streamelements.tips:read.refresh');
     const lsExpires = window.localStorage.getItem('streamelements.tips:read.expires');
     const lsRefreshed = window.localStorage.getItem('streamelements.tips:read.refreshed');
     if (lsOAuth !== null)
      cfg.streamelements.oauth = lsOAuth;
     if (lsRefresh !== null)
      cfg.streamelements.oauth_refresh = lsRefresh;
     if (lsExpires !== null)
      cfg.streamelements.oauth_expires = lsExpires;
     if (lsRefreshed !== null)
      cfg.streamelements.oauth_refreshed = lsRefreshed;
     if (cfg.streamelements.hasOwnProperty('oauth_expires') && cfg.streamelements.oauth_expires > 0)
     {
      const expTime = cfg.streamelements.oauth_expires - Math.floor(new Date().getTime() / 1000);
      if (expTime < 0)
      {
       window.localStorage.removeItem('streamelements.tips:read.oauth');
       window.localStorage.removeItem('streamelements.tips:read.refresh');
       window.localStorage.removeItem('streamelements.tips:read.expires');
       window.localStorage.removeItem('streamelements.tips:read.refreshed');
       shared.blargIAmDead(5);
       return;
      }
     }
     if (cfg.streamelements.hasOwnProperty('oauth_refreshed') && cfg.streamelements.oauth_refreshed > 0)
     {
      const tokAge = Math.floor(new Date().getTime() / 1000) - cfg.streamelements.oauth_refreshed;
      if (tokAge < 24 * 60 * 60)
       return;
     }
     const ret = await _getOAuthToken(cfg.streamelements.oauth_refresh);
     if (ret === false)
      return;
     cfg.streamelements.oauth = ret.access_token;
     cfg.streamelements.oauth_refresh = ret.refresh_token;
     cfg.streamelements.oauth_expires = Math.floor(new Date().getTime() / 1000) + ret.expires_in;
     cfg.streamelements.oauth_refreshed = Math.floor(new Date().getTime() / 1000);
     window.localStorage.setItem('streamelements.tips:read.oauth', cfg.streamelements.oauth);
     window.localStorage.setItem('streamelements.tips:read.refresh', cfg.streamelements.oauth_refresh);
     window.localStorage.setItem('streamelements.tips:read.expires', cfg.streamelements.oauth_expires);
     window.localStorage.setItem('streamelements.tips:read.refreshed', cfg.streamelements.oauth_refreshed);
    }

    return {
     socket: streamelementsWS,
     updateOAuth: updateOAuth
    };
   }();

   const thirdparty = function()
   {
    function _addEmote(list, scope, code, id, url, users = null, zwe = false)
    {
     if (cfg.ignore.emotes !== false && cfg.ignore.emotes.includes(code))
      return;
     list[code] = {scope: scope, url: url, id: id, users: users};
     if (scope === 'c' && !zwe)
      cList.push({url: url});
    }

    function _removeEmote(list, scope, code)
    {
     if (!list.hasOwnProperty(code))
      return;
     if (list[code].scope !== scope)
      return;
     if (scope === 'c')
     {
      for (let c = cList.length - 1; c >= 0; c--)
      {
       if (cList[c].url !== list[code].url)
        continue;
       cList.splice(c, 1);
       break;
      }
     }
     delete list[code];
    }

    function _removeEmoteByID(list, scope, id)
    {
     for (let i = Object.keys(list).length - 1; i >= 0; i--)
     {
      const k = Object.keys(list)[i];
      if (list[k].scope !== scope)
       continue;
      if (list[k].id !== id)
       continue;
      _removeEmote(list, scope, k);
      break;
     }
    }

    function _removeEmoteByScope(list, scope)
    {
     for (let i = Object.keys(list).length - 1; i >= 0; i--)
     {
      const k = Object.keys(list)[i];
      if (list[k].scope !== scope)
       continue;
      _removeEmote(list, scope, k);
     }
    }

    const ffz = function()
    {
     function _readFFZ_URL(entry)
     {
      if (!entry.hasOwnProperty('urls'))
       return false;
      if (entry.urls.hasOwnProperty('4'))
      {
       let u4 = entry.urls[4];
       if (u4.slice(0, 2) === '//')
        u4 = 'https:' + u4;
       return u4;
      }
      if (entry.urls.hasOwnProperty('2'))
      {
       let u2 = entry.urls[2];
       if (u2.slice(0, 2) === '//')
        u2 = 'https:' + u2;
       let u24 = u2;
       if (u24.slice(-2) === '/2')
        u24 = u24.slice(0, -1) + '4';
       return u24;
      }
      if (entry.urls.hasOwnProperty('1'))
      {
       let u1 = entry.urls[1];
       if (u1.slice(0, 2) === '//')
        u1 = 'https:' + u1;
       let u14 = u1;
       if (u14.slice(-2) === '/1')
        u14 = u14.slice(0, -1) + '4';
       return u14;
      }
      return false;
     }

     async function loadFFZ_global()
     {
      if (!thirdparty.emotes.hasOwnProperty('ffz'))
       thirdparty.emotes.ffz = {};
      const url = cURLs.api.ffz.set.global;
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('sets'))
       return false;
      let usedSets = [];
      if (j.hasOwnProperty('default_sets'))
      {
       for (let i = 0, l = j.default_sets.length; i < l; i++)
        usedSets.push(j.default_sets[i]);
      }
      for (const set in j.sets)
      {
       if (!j.sets.hasOwnProperty(set))
        continue;
       if (!usedSets.includes(j.sets[set].id))
        continue;
       if (!j.sets[set].hasOwnProperty('emoticons'))
        continue;
       for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
       {
        if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
         continue;
        const u = _readFFZ_URL(j.sets[set].emoticons[i]);
        if (u === false)
         continue;
        _addEmote(thirdparty.emotes.ffz, 'g', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u);
       }
      }
      if (!j.hasOwnProperty('users'))
       return true;
      for (const setID in j.users)
      {
       if (!j.users.hasOwnProperty(setID))
        continue;
       const aList = j.users[setID];
       if (!Array.isArray(aList))
        continue;
       for (const set in j.sets)
       {
        if (!j.sets.hasOwnProperty(set))
         continue;
        if (setID !== set)
         continue;
        if (!j.sets[set].hasOwnProperty('emoticons'))
         continue;
        for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
        {
         if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
          continue;
         const u = _readFFZ_URL(j.sets[set].emoticons[i]);
         if (u === false)
          continue;
         _addEmote(thirdparty.emotes.ffz, 'g', j.sets[set].emoticons[i].name, j.sets[set].emoticons[i].id, u, aList);
        }
       }
      }
      return true;
     }

     async function readFFZ_channel(chID)
     {
      const url = cURLs.api.ffz.room.replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('sets'))
       return false;
      let ret = [];
      for (const set in j.sets)
      {
       if (!j.sets[set].hasOwnProperty('emoticons'))
        continue;
       for (let i = 0, l = j.sets[set].emoticons.length; i < l; i++)
       {
        if (!j.sets[set].emoticons[i].hasOwnProperty('name'))
         continue;
        const u = _readFFZ_URL(j.sets[set].emoticons[i]);
        if (u === false)
         continue;
        ret.push({name: j.sets[set].emoticons[i].name, id: j.sets[set].emoticons[i].id, url: u});
       }
      }
      return ret;
     }

     async function loadFFZ_channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('ffz'))
       thirdparty.emotes.ffz = {};
      const r = await readFFZ_channel(chID);
      if (r === false)
       return false;
      _removeEmoteByScope(thirdparty.emotes.ffz, 'c');
      for (let i = 0, l = r.length; i < l; i++)
      {
       _addEmote(thirdparty.emotes.ffz, 'c', r[i].name, r[i].id, r[i].url);
      }
      return true;
     }

     return {
      global: loadFFZ_global,
      channel: loadFFZ_channel,
      channelEx: readFFZ_channel
     };
    }();

    const bttv = function()
    {
     const _rBE = 600000;

     function reloadBTTV(chID)
     {
      if (thirdparty.bttv.timer === false)
       return;
      window.clearTimeout(thirdparty.bttv.timer);
      thirdparty.bttv.timer = false;
      if (cfg.display.extended.useBTTV)
       loadBTTV_channel(twitch.net.channelID);
      thirdparty.bttv.timer = window.setTimeout(reloadBTTV, thirdparty.interval, chID);
     }

     async function loadBTTV_global()
     {
      if (!thirdparty.emotes.hasOwnProperty('bttv'))
       thirdparty.emotes.bttv = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('bttv'))
       thirdparty.emotes.zwe.bttv = {};
      const url = cURLs.api.bttv.emotes.global;
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!Array.isArray(j))
       return false;
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('code'))
        continue;
       if (!j[i].hasOwnProperty('id'))
        continue;
       const eURL = cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', j[i].id);
       if (bttvZWE.includes(j[i].code))
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe.bttv, 'g', j[i].code, j[i].id, eURL, null, true);
        continue;
       }
       _addEmote(thirdparty.emotes.bttv, 'g', j[i].code, j[i].id, eURL);
      }
      return true;
     }

     async function readBTTV_channel(chID)
     {
      const url = cURLs.api.bttv.users.twitch.replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      let ret = [];
      if (j.hasOwnProperty('channelEmotes'))
      {
       for (let i = 0, l = j.channelEmotes.length; i < l; i++)
       {
        if (!j.channelEmotes[i].hasOwnProperty('code'))
         continue;
        if (!j.channelEmotes[i].hasOwnProperty('id'))
         continue;
        ret.push({name: j.channelEmotes[i].code, id: j.channelEmotes[i].id, url: cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', j.channelEmotes[i].id)});
       }
      }
      if (j.hasOwnProperty('sharedEmotes'))
      {
       for (let i = 0, l = j.sharedEmotes.length; i < l; i++)
       {
        if (!j.sharedEmotes[i].hasOwnProperty('code'))
         continue;
        if (!j.sharedEmotes[i].hasOwnProperty('id'))
         continue;
        ret.push({name: j.sharedEmotes[i].code, id: j.sharedEmotes[i].id, url: cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', j.sharedEmotes[i].id)});
       }
      }
      return ret;
     }

     async function loadBTTV_channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('bttv'))
       thirdparty.emotes.bttv = {};
      const r = await readBTTV_channel(chID);
      if (r === false)
       return false;
      _removeEmoteByScope(thirdparty.emotes.bttv, 'c');
      for (let i = 0, l = r.length; i < l; i++)
      {
       _addEmote(thirdparty.emotes.bttv, 'c', r[i].name, r[i].id, r[i].url);
      }
      return true;
     }

     const loadBTTV_ws_channel = function()
     {
      let _wsRetry = 0;
      let _ch = 0;
      let _ws = null;

      function task(chID = false)
      {
       if (chID !== false)
        _ch = chID;
       _ws = new WebSocket(cURLs.ws.bttv);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.send(JSON.stringify({'name': 'join_channel', 'data': {'name': 'twitch:' + _ch}}));
       _ws.send(JSON.stringify({'name': 'broadcast_me', 'data': {'name': cfg.channel, 'channel': 'twitch:' + _ch}}));
      }

      function _wsClose()
      {
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(task, wsWait);
      }

      function _wsMessage(ev)
      {
       if (_ws === null)
        return;
       if (twitch.net.dead)
       {
        _ws.close();
        _ws = null;
        return;
       }
       _wsRetry = 0;
       const d = JSON.parse(ev.data);
       if (!d.hasOwnProperty('name'))
        return;
       if (!d.hasOwnProperty('data'))
        return;
       switch (d.name)
       {
        case 'lookup_user':
         if (!d.data.hasOwnProperty('name'))
          return;
         if (!d.data.hasOwnProperty('emotes') || !Array.isArray(d.data.emotes) || d.data.emotes.length < 1)
          return;
         if (!thirdparty.emotes.hasOwnProperty('bttvU'))
          thirdparty.emotes.bttvU = {};
         thirdparty.emotes.bttvU[d.data.name] = {};
         for (let i = 0, l = d.data.emotes.length; i < l; i++)
         {
          if (!d.data.emotes[i].hasOwnProperty('code'))
           continue;
          if (!d.data.emotes[i].hasOwnProperty('id'))
           continue;
          _addEmote(thirdparty.emotes.bttvU[d.data.name], 'u', d.data.emotes[i].code, d.data.emotes[i].id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emotes[i].id));
         }
         break;
        case 'emote_create':
         if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + _ch)
          return;
         if (!d.data.hasOwnProperty('emote'))
          return;
         if (!d.data.emote.hasOwnProperty('id'))
          return;
         if (!d.data.emote.hasOwnProperty('code'))
          return;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _addEmote(thirdparty.emotes.bttv, 'c', d.data.emote.code, d.data.emote.id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emote.id));
         thirdparty.bttv.timer = window.setTimeout(reloadBTTV, _rBE, _ch);
         break;
        case 'emote_delete':
         if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + _ch)
          return;
         if (!d.data.hasOwnProperty('emoteId'))
          return;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _removeEmoteByID(thirdparty.emotes.bttv, 'c', d.data.emoteId);
         thirdparty.bttv.timer = window.setTimeout(reloadBTTV, _rBE, _ch);
         break;
        case 'emote_update':
         if (!d.data.hasOwnProperty('channel') || d.data.channel !== 'twitch:' + _ch)
          return;
         if (!d.data.hasOwnProperty('emote'))
          return;
         if (!d.data.emote.hasOwnProperty('id'))
          return;
         if (!d.data.emote.hasOwnProperty('code'))
          return;
         if (thirdparty.bttv.timer !== false)
          window.clearTimeout(thirdparty.bttv.timer);
         _removeEmoteByID(thirdparty.emotes.bttv, 'c', d.data.emote.id);
         _addEmote(thirdparty.emotes.bttv, 'c', d.data.emote.code, d.data.emote.id, cURLs.cdn.bttv.emote.replaceAll('%EMOTE_ID%', d.data.emote.id));
         thirdparty.bttv.timer = window.setTimeout(reloadBTTV, _rBE, _ch);
         break;
       }
      }

      return task;
     }();

     return {
      timer: false,
      global: loadBTTV_global,
      channel: loadBTTV_channel,
      channelEx: readBTTV_channel,
      socket: loadBTTV_ws_channel,
      reload: reloadBTTV
     };
    }();

    const $7tv = function()
    {
     async function load7TV_global()
     {
      if (!thirdparty.emotes.hasOwnProperty('7tv'))
       thirdparty.emotes['7tv'] = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
       thirdparty.emotes.zwe['7tv'] = {};
      const url = cURLs.api['7tv'].emotes.global;
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!Array.isArray(j))
       return false;
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('name'))
        continue;
       if (!j[i].hasOwnProperty('urls'))
        continue;
       let t4 = null;
       for (let u = 0, m = j[i].urls.length; u < m; u++)
       {
        const tN = j[i].urls[u][0];
        const uN = j[i].urls[u][1];
        if (tN === '4')
        {
         t4 = uN;
         break;
        }
        if (t4 !== null)
         continue;
        if (uN.includes('/' + tN + 'x'))
         t4 = uN.replaceAll('/' + tN + 'x', '/4x');
       }
       if (j[i].hasOwnProperty('visibility') && (j[i].visibility & 0x80) === 0x80)
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe['7tv'], 'g', j[i].name, j[i].id, t4, null, true);
        continue;
       }
       _addEmote(thirdparty.emotes['7tv'], 'g', j[i].name, j[i].id, t4);
      }
      return true;
     }

     async function read7TV_channel(chID)
     {
      const url = cURLs.api['7tv'].users.emotes.replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!Array.isArray(j))
       return false;
      let ret = [];
      for (let i = 0, l = j.length; i < l; i++)
      {
       if (!j[i].hasOwnProperty('name'))
        continue;
       if (!j[i].hasOwnProperty('urls'))
        continue;
       let t4 = null;
       for (let u = 0, m = j[i].urls.length; u < m; u++)
       {
        const tN = j[i].urls[u][0];
        const uN = j[i].urls[u][1];
        if (tN === '4')
        {
         t4 = uN;
         break;
        }
        if (t4 !== null)
         continue;
        if (uN.includes('/' + tN + 'x'))
         t4 = uN.replaceAll('/' + tN + 'x', '/4x');
       }
       let vis = 0;
       if ((j[i].hasOwnProperty('visibility')))
        vis = j[i].visibility;
       ret.push({name: j[i].name, id: j[i].id, url: t4, vis: vis});
      }
      return ret;
     }

     async function load7TV_channel(chID)
     {
      if (!thirdparty.emotes.hasOwnProperty('7tv'))
       thirdparty.emotes['7tv'] = {};
      if (!thirdparty.emotes.hasOwnProperty('zwe'))
       thirdparty.emotes.zwe = {};
      if (!thirdparty.emotes.zwe.hasOwnProperty('7tv'))
       thirdparty.emotes.zwe['7tv'] = {};
      const r = await read7TV_channel(chID);
      if (r === false)
       return false;
      if (cfg.display.extended.useZWE)
       _removeEmoteByScope(thirdparty.emotes.zwe['7tv'], 'c');
      _removeEmoteByScope(thirdparty.emotes['7tv'], 'c');
      for (let i = 0, l = r.length; i < l; i++)
      {
       if ((r[i].vis & 0x80) === 0x80)
       {
        if (cfg.display.extended.useZWE)
         _addEmote(thirdparty.emotes.zwe['7tv'], 'c', r[i].name, r[i].id, r[i].url, null, true);
        continue;
       }
       _addEmote(thirdparty.emotes['7tv'], 'c', r[i].name, r[i].id, r[i].url);
      }
      return true;
     }

     async function _load7TV_channelID(chID)
     {
      const url = cURLs.api['7tv'].users.root.replaceAll('%CHANNEL_ID%', chID);
      const r = await shared.httpRequest(url);
      if (r === false)
       return false;
      const j = JSON.parse(r);
      if (!j.hasOwnProperty('id'))
       return false;
      return j.id;
     }

     const load7TV_ws_channel = function()
     {
      const _lDelay = 500;
      let _wsRetry = 0;
      let _wsR_RL = 0;
      let _wsR_M = 0;
      let _ch = 0;
      let _accID = false;
      let _ws = null;
      let _sess = null;
      let _lTimeout = 5000;
      let _tTimeout = false;
      let _okCt = 0;

      async function task(chID = false)
      {
       if (chID !== false)
        _ch = chID;
       _accID = await _load7TV_channelID(_ch);
       if (_accID === false)
        return;
       _ws = new WebSocket(cURLs.ws['7tv']);
       _ws.onopen = _wsOpen;
       _ws.onclose = _wsClose;
       _ws.onmessage = _wsMessage;
      }

      function _wsOpen()
      {
       if (_ws === null)
        return;
       _ws.onopen = null;
       _tTimeout = setTimeout(_wsTimeout, _lTimeout);
      }

      function _wsClose()
      {
       if (_tTimeout !== false)
       {
        clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       _ws.onopen = null;
       _ws.onmessage = null;
       _ws.onclose = null;
       _ws = null;
       if (twitch.net.dead)
        return;
       const wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
       if (_wsRetry < 2)
        _wsRetry += 0.2;
       window.setTimeout(task, wsWait);
      }

      function _wsMessage(ev)
      {
       if (_tTimeout !== false)
       {
        clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       if (_ws === null)
        return;
       if (twitch.net.dead)
       {
        _ws.close();
        _ws = null;
        return;
       }
       _tTimeout = setTimeout(_wsTimeout, _lTimeout);
       const d = JSON.parse(ev.data);
       if (!d.hasOwnProperty('op'))
        return;
       if (!d.hasOwnProperty('d'))
        return;
       switch(d.op)
       {
        case 0:
         if (thirdparty.timer !== false)
          window.clearTimeout(thirdparty.timer);
         thirdparty.timer = window.setTimeout(thirdparty.reload, _lDelay, _ch);
         break;
        case 1:
         _okCt = 0;
         if (_sess !== null)
          _ws.send(JSON.stringify({'op': 34, 'd': {'session_id': _sess}}));
         else
          _wsSub();
         if (d.d.hasOwnProperty('session_id'))
          _sess = d.d.session_id;
         if (d.d.hasOwnProperty('heartbeat_interval'))
         {
          _lTimeout = parseInt(d.d.heartbeat_interval, 10) * 3;
          if (_tTimeout !== false)
          {
           clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _tTimeout = setTimeout(_wsTimeout, _lTimeout);
         }
         break;
        case 2:
         if (_okCt !== 3)
         {
          if (_tTimeout !== false)
          {
           clearTimeout(_tTimeout);
           _tTimeout = false;
          }
          _ws.onopen = null;
          _ws.onmessage = null;
          _ws.onclose = null;
          _ws.close();
          _ws = null;
          const wsRedo = Math.floor(wWS ** (1 + _wsRetry) * 1000);
          if (_wsRetry < 2)
           _wsRetry += 0.2;
          window.setTimeout(task, wsRedo);
          return;
         }
         _wsRetry = 0;
         _wsR_RL = 0;
         _wsR_M = 0;
         break;
        case 5:
         if (!d.d.hasOwnProperty('command'))
          return;
         switch(d.d.command)
         {
          case 'RESUME':
           if (!d.d.hasOwnProperty('data'))
            return;
           if (!d.d.data.hasOwnProperty('success'))
            return;
           if (d.d.data.success === false)
            _wsSub();
           else
           {
            if (!d.d.data.hasOwnProperty('subscriptions_restored'))
             return;
            if (d.d.data.subscriptions_restored !== 3)
            {
             if (d.d.data.subscriptions_restored > 0)
              _wsUnsub();
             _wsSub();
            }
            else
             _okCt = d.d.data.subscriptions_restored;
           }
           break;
          case 'SUBSCRIBE':
           _okCt++;
           break;
         }
         break;
        case 7:
         if (_tTimeout !== false)
         {
          clearTimeout(_tTimeout);
          _tTimeout = false;
         }
         _ws.onopen = null;
         _ws.onmessage = null;
         _ws.onclose = null;
         _ws.close();
         _ws = null;
         let wsWait = _lDelay;
         if (d.d.hasOwnProperty('code'))
         {
          switch (d.d.code)
          {
           case 4001:
           case 4002:
           case 4003:
           case 4004:
           case 4009:
           case 4010:
           case 4011:
            _sess = null;
            return;
           case 4005:
            wsWait = Math.floor((5 ** (1 + _wsR_RL) / 5) * 60 * 1000);
            if (_wsR_RL < 2.6)
             _wsR_RL += 0.2;
            break;
           case 4006:
            wsWait = Math.max(wsWait, 5 * 60 * 1000);
            break;
           case 4007:
            wsWait = 5 * 60 * 1000 + Math.floor(wWS ** (1 + _wsR_M) * 1000) - 5000;
            if (_wsR_M < 2)
             _wsR_M += 0.2;
            break;
           case 4000:
           case 4008:
            wsWait = Math.floor(wWS ** (1 + _wsRetry) * 1000);
            if (_wsRetry < 2)
             _wsRetry += 0.2;
            break;
          }
         }
         window.setTimeout(task, wsWait);
         break;
       }
      }

      function _wsUnsub()
      {
       if (_ws === null)
        return;
       _ws.send(JSON.stringify({'op': 36, 'd': {'type':'user.*', 'condition': {'object_id': _accID}}}));
       _ws.send(JSON.stringify({'op': 36, 'd': {'type':'emote.*', 'condition': {'object_id': _accID}}}));
       _ws.send(JSON.stringify({'op': 36, 'd': {'type':'emote_set.*', 'condition': {'object_id': _accID}}}));
      }

      function _wsSub()
      {
       if (_ws === null)
        return;
       _ws.send(JSON.stringify({'op': 35, 'd': {'type':'user.*', 'condition': {'object_id': _accID}}}));
       _ws.send(JSON.stringify({'op': 35, 'd': {'type':'emote.*', 'condition': {'object_id': _accID}}}));
       _ws.send(JSON.stringify({'op': 35, 'd': {'type':'emote_set.*', 'condition': {'object_id': _accID}}}));
      }

      function _wsTimeout()
      {
       if (_ws === null)
        return;
       _lTimeout = 5000;
       if (twitch.net.dead === true)
        return;
       if (_tTimeout !== false)
       {
        clearTimeout(_tTimeout);
        _tTimeout = false;
       }
       _ws.close();
       _ws = null;
       task();
      }

      return task;
     }();

     return {
      global: load7TV_global,
      channel: load7TV_channel,
      channelEx: read7TV_channel,
      socket: load7TV_ws_channel
     };
    }();

    function reload3rdParty(chID)
    {
     if (thirdparty.timer === false)
      return;
     window.clearTimeout(thirdparty.timer);
     thirdparty.timer = false;
     if (cfg.display.extended.useFFZ)
      thirdparty.ffz.channel(twitch.net.channelID);
     if (cfg.display.extended.use7TV)
      thirdparty['7tv'].channel(twitch.net.channelID);
     thirdparty.timer = window.setTimeout(thirdparty.reload, thirdparty.interval, chID);
    }

    return {
     emotes: {},
     timer: false,
     interval: 60000,
     ffz: ffz,
     bttv: bttv,
     '7tv': $7tv,
     reload: reload3rdParty
    };
   }();

   const shared = function()
   {
    function rnd(m)
    {
     let r = new Uint32Array(1);
     window.crypto.getRandomValues(r);
     const f = r[0] / 4294967295;
     if (m === undefined)
      return f;
     if (m < 1)
      return f * m;
     return Math.floor(f * m);
    }

    function _httpRequest_RSC(x)
    {
     if (x.readyState < 2)
      return null;
     if (Math.floor(x.status / 100) !== 2)
     {
      x.onreadystatechange = null;
      return false;
     }
     if (x.readyState !== 4)
      return null;
     if (x.responseText === '')
      return null;
     x.onreadystatechange = null;
     if (x.responseText === null)
      return false;
     return x.responseText;
    }

    function httpRequest(url, hdrs = {}, nullOn401 = false, nocache = true)
    {
     const p = new Promise(
      function(resolve)
      {
       const x = new XMLHttpRequest();
       if (nocache)
       {
        if (url.includes('?'))
         url+= '&';
        else
         url+= '?';
        url+= 'nocache=' + shared.rnd(0xFFFFFFFF);
       }
       x.open('GET', url);
       for (const hK in hdrs)
       {
        if (!hdrs.hasOwnProperty(hK))
         continue;
        x.setRequestHeader(hK, hdrs[hK]);
       }
       x.onreadystatechange = function()
       {
        const r = _httpRequest_RSC(x);
        if (r === null)
         return;
        if (r === false && nullOn401 && x.status === 401)
        {
         resolve(null);
         return;
        }
        resolve(r);
       };
       x.send();
      }
     );
     return p;
    }

    function httpSend(type, url, body = null, hdrs = {})
    {
     const p = new Promise(
      function(resolve)
      {
       const x = new XMLHttpRequest();
       x.open(type, url);
       for (const hK in hdrs)
       {
        if (!hdrs.hasOwnProperty(hK))
         continue;
        x.setRequestHeader(hK, hdrs[hK]);
       }
       x.onreadystatechange = function()
       {
        const r = _httpRequest_RSC(x);
        if (r === null)
        {
         if (type === 'DELETE')
          resolve(true);
         return;
        }
        resolve(r);
       };
       if (body === null)
        x.send();
       else
        x.send(body);
      }
     );
     return p;
    }

    function findInMaybeRange(r, v)
    {
     const t = typeof r;
     switch (t)
     {
      case 'undefined':
       return false;
      case 'boolean':
       return r === true;
      case 'number':
       if (r > 0 && v >= r)
        return true;
       return false;
      case 'object':
       if (r === null)
        return false;
       for (const k in r)
       {
        if (!r.hasOwnProperty(k))
         continue;
        let lower = 0;
        let upper = 0;
        if (k.slice(-1) === '+')
        {
         lower = parseInt(k.slice(0, -1), 10);
         upper = Number.MAX_SAFE_INTEGER;
        }
        else if (k.indexOf('-') !== -1)
        {
         lower = parseInt(k.slice(0, k.indexOf('-')), 10);
         upper = parseInt(k.slice(k.indexOf('-') + 1), 10);
        }
        else
        {
         lower = parseInt(k, 10);
         upper = parseInt(k, 10);
        }
        if (v >= lower && v <= upper)
         return r[k];
       }
     }
     return false;
    }

    function blargIAmDead(e)
    {
     let showButton = false;
     switch (e)
     {
      case 1:
       if (login.inUse)
       {
        document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Connect to Twitch<br><br>Please Log In Again</div>';
        showButton = true;
        login.showOut(true);
       }
       else
        document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Connect to Twitch<br><br>Please Update Your OAuth Refresh Token</div>';
       break;
      case 2:
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Corrupted Configuration<br><br>Please Check Your Browser\'s Error Console</div>';
       break;
      case 3:
       if (login.inUse)
       {
        document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Emotes<br><br>Please Log In Again</div>';
        showButton = true;
        login.showIn();
       }
       else
        document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>Unable to Access Channel Emotes<br><br>Please Check Your Client ID and OAuth Refresh Token</div>';
       break;
      case 4:
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Error:<br><br>The Connection to the IRC Channel was Incomplete<br><br>Please Check your Channel</div>';
       break;
      case 5:
       document.body.innerHTML = '<div style="position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(255, 0, 0, 0.75); color: #FFFF00; text-shadow: 2px 2px 4px #000000; font-size: 300%; font-weight: bold; font-family: sans-serif; text-align: center; padding-top: 3em;">Emote Wall Warning:<br><br>Your StreamElements OAuth Token is Expired<br><br>Please Update your StreamElements OAuth Token</div>';
       break;
     }
     window.setTimeout(function(){document.body.innerHTML = ''; if (showButton) login.showIn();}, 15000);
    }

    return {
     rnd: rnd,
     httpRequest: httpRequest,
     httpSend: httpSend,
     findInMaybeRange: findInMaybeRange,
     blargIAmDead: blargIAmDead
    };
   }();

   const login = function()
   {
    let _tL = false;
    const _visTime = 5000;

    function _activeScope()
    {
     let r = [];
     r.push('chat:read');
     for (const k of cfg.commands)
     {
      if (!k.hasOwnProperty('redeem') || !Array.isArray(k.redeem) || k.redeem.length < 1)
       continue;
      r.push('channel:read:redemptions');
      break;
     }
     let needF = false;
     if (cfg.event.follow !== false)
      needF = true;
     else
     {
      if ((cfg.display.access & 0x002) === 0x002 && (cfg.display.access & 0x001) !== 0x001)
       needF = true;
      else if ((cfg.display.kappa.access & 0x002) === 0x002 && (cfg.display.kappa.access & 0x001) !== 0x001)
       needF = true;
      else
      {
       for (const k of cfg.commands)
       {
        if (!k.hasOwnProperty('styles'))
         continue;
        if (!k.hasOwnProperty('access'))
         continue;
        if ((k.access & 0x002) === 0x002 && (k.access & 0x001) !== 0x001)
        {
         needF = true;
         break;
        }
       }
      }
     }
     if (needF)
      r.push('moderator:read:followers');
     if (cfg.event.hypetrain !== false && ((cfg.event.hypetrain.hasOwnProperty('begin') && cfg.event.hypetrain.begin !== false) || (cfg.event.hypetrain.hasOwnProperty('success') && cfg.event.hypetrain.success !== false)))
      r.push('channel:read:hype_train');
     if (cfg.event.goal !== false && ((cfg.event.goal.hasOwnProperty('begin') && cfg.event.goal.begin !== false) || (cfg.event.goal.hasOwnProperty('achieved') && cfg.event.goal.achieved !== false)))
      r.push('channel:read:goals');
     if (cfg.event.poll !== false && ((cfg.event.poll.hasOwnProperty('begin') && cfg.event.poll.begin !== false) || (cfg.event.poll.hasOwnProperty('end') && cfg.event.poll.end !== false)))
      r.push('channel:read:polls');
     if (cfg.event.prediction !== false && ((cfg.event.prediction.hasOwnProperty('begin') && cfg.event.prediction.begin !== false) || (cfg.event.prediction.hasOwnProperty('resolved') && cfg.event.prediction.resolved !== false)))
      r.push('channel:read:predictions');
     if (cfg.event.charity !== false)
      r.push('channel:read:charity');
     if (cfg.event.shoutout !== false && ((cfg.event.shoutout.hasOwnProperty('create') && cfg.event.shoutout.create !== false && cfg.event.shoutout.create.hasOwnProperty('styles') && cfg.event.shoutout.create.styles !== false) || (cfg.event.shoutout.hasOwnProperty('receive') && cfg.event.shoutout.receive !== false && cfg.event.shoutout.receive.hasOwnProperty('styles') && cfg.event.shoutout.receive.styles !== false)))
      r.push('moderator:read:shoutouts');
     return r;
    }

    function _uScope()
    {
     return encodeURIComponent(_activeScope().join(' '));
    }

    function lsPath()
    {
     return 'twitch.' + _activeScope().join('+');
    }

    function shouldUseLogin()
    {
     login.inUse = false;
     if (cfg.hasOwnProperty('channel') && cfg.channel !== false && cfg.channel !== 'CHANNEL_NAME' && cfg.hasOwnProperty('login') && ((cfg.login.hasOwnProperty('oauth') && cfg.login.oauth !== false && cfg.login.oauth !== 'OAUTH_ID') || (cfg.login.hasOwnProperty('oauth_refresh') && cfg.login.oauth_refresh !== false && cfg.login.oauth_refresh !== 'OAUTH_REFRESH')))
      return false;
     login.inUse = true;
     let lsChannel = window.localStorage.getItem(login.path() + '.channel');
     let lsClient  = window.localStorage.getItem(login.path() + '.client');
     let lsOAuth   = window.localStorage.getItem(login.path() + '.oauth');
     let lsRefresh = window.localStorage.getItem(login.path() + '.refresh');
     let lsScope   = window.localStorage.getItem(login.path() + '.scope');
     if (lsChannel === null || lsRefresh === null)
     {
      const h = _getHashParams();
      if (!h.hasOwnProperty('channel') || !h.hasOwnProperty('client') || !h.hasOwnProperty('oauth') || !h.hasOwnProperty('oauth_refresh') || !h.hasOwnProperty('scope'))
      {
       login.showIn();
       return true;
      }
      lsChannel = h.channel;
      lsClient = h.client;
      lsOAuth = h.oauth;
      lsRefresh = h.oauth_refresh;
      lsScope = decodeURIComponent(h.scope);
      window.localStorage.setItem(login.path() + '.channel', lsChannel);
      window.localStorage.setItem(login.path() + '.oauth', lsOAuth);
      window.localStorage.setItem(login.path() + '.refresh', lsRefresh);
      window.localStorage.setItem(login.path() + '.client', lsClient);
      window.localStorage.setItem(login.path() + '.scope', lsScope);
     }
     cfg.channel = lsChannel;
     cfg.login.oauth = lsOAuth;
     cfg.login.oauth_refresh = lsRefresh;
     cfg.login.client = lsClient;
     cfg.login.scope = decodeURIComponent(lsScope).split(' ');
     document.title = cfg.channel + ' Emote Wall';
     login.showOut();
     return false;
    }

    function _getHashParams()
    {
     const d = function(s) {
      const a = /\+/g;
      return decodeURIComponent(s.replace(a, ' '));
     };
     let hashParams = {};
     const r = /([^&;=]+)=?([^&;]*)/g;
     const q = window.location.hash.substring(1);
     let e;
     while ((e = r.exec(q)) !== null)
     {
      hashParams[d(e[1])] = d(e[2]);
     }
     return hashParams;
    }

    function doLogin()
    {
     window.localStorage.removeItem(login.path() + '.channel');
     window.localStorage.removeItem(login.path() + '.oauth');
     window.localStorage.removeItem(login.path() + '.refresh');
     window.localStorage.removeItem(login.path() + '.client');
     window.localStorage.removeItem(login.path() + '.scope');
     const o = encodeURIComponent(btoa(window.location));
     const c = encodeURIComponent('4umzcpmjkg6ar78b81s7302jlj33t8');
     const r = encodeURIComponent(cURLs.html.rr.wizard);
     let u = cURLs.html.twitch.replaceAll('%CLIENT_ID%', c).replaceAll('%URL%', r).replaceAll('%SCOPE%', _uScope()).replaceAll('%ORIGIN%', o);
     if (u.length > 1500)
      u = cURLs.html.rr.redir.replaceAll('%CLIENT_ID%', c).replaceAll('%URL%', r).replaceAll('%SCOPE%', _uScope()).replaceAll('%ORIGIN%', encodeURIComponent(window.location));
     window.location = u;
    }

    function showLoginButton()
    {
     document.title = 'Log In to Access Emote Wall';
     if (document.getElementById('cmdLogout'))
      document.body.removeChild(document.getElementById('cmdLogout'));
     window.localStorage.removeItem(login.path() + '.channel');
     window.localStorage.removeItem(login.path() + '.oauth');
     window.localStorage.removeItem(login.path() + '.refresh');
     window.localStorage.removeItem(login.path() + '.client');
     window.localStorage.removeItem(login.path() + '.scope');
     let cmdLogin = document.createElement('button');
     cmdLogin.setAttribute('id', 'cmdLogin');
     cmdLogin.setAttribute('type', 'button');
     cmdLogin.setAttribute('onclick', 'login.begin();');
     let sStyle = 'z-index: 1000;';
     sStyle += ' position: absolute;';
     sStyle += ' top: 45%;';
     sStyle += ' left: calc(50% - 6.5em);';
     sStyle += ' width: 13em;';
     sStyle += ' font-size: 3vw;';
     sStyle += ' padding: 0.5em;';
     cmdLogin.setAttribute('style', sStyle);
     cmdLogin.innerHTML = 'Authenticate Emote Wall';
     document.body.appendChild(cmdLogin);
    }

    function showLogoutButton(v = false)
    {
     if (document.getElementById('cmdLogout'))
      document.body.removeChild(document.getElementById('cmdLogout'));
     let cmdLogout = document.createElement('button');
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     cmdLogout.setAttribute('id', 'cmdLogout');
     cmdLogout.setAttribute('type', 'button');
     let sStyle = 'z-index: 1000;';
     sStyle += ' transition: opacity 0.5s;';
     sStyle += ' position: absolute;';
     sStyle += ' top: 1em;';
     sStyle += ' right: 1em;';
     sStyle += ' width: 5em;';
     sStyle += ' font-size: 1vw;';
     sStyle += ' padding: 0.5em;';
     document.addEventListener('mouseover', _fadeInLogout);
     if (v)
     {
      cmdLogout.setAttribute('onclick', 'login.begin();');
      cmdLogout.innerHTML = 'Re-Auth';
      sStyle += ' opacity: 1;';
      _tL = window.setTimeout(_fadeOutLogout, _visTime);
     }
     else
     {
      cmdLogout.setAttribute('onclick', 'login.showIn();');
      cmdLogout.innerHTML = 'Log Out';
      sStyle += ' opacity: 0;';
     }
     cmdLogout.setAttribute('style', sStyle);
     document.body.appendChild(cmdLogout);
    }

    function _fadeInLogout()
    {
     if (document.getElementById('cmdLogout'))
      document.getElementById('cmdLogout').style.opacity = '1';
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     _tL = window.setTimeout(_fadeOutLogout, _visTime);
    }

    function _fadeOutLogout()
    {
     if (_tL !== false)
     {
      window.clearTimeout(_tL);
      _tL = false;
     }
     if (document.getElementById('cmdLogout'))
      document.getElementById('cmdLogout').style.opacity = '0';
    }

    return {
     inUse: false,
     use: shouldUseLogin,
     begin: doLogin,
     showIn: showLoginButton,
     showOut: showLogoutButton,
     path: lsPath
    };
   }();

   async function startup()
   {
    if (typeof cfg === 'undefined')
    {
     shared.blargIAmDead(2);
     return;
    }
    if (login.use() === true)
     return;
    if (cfg.hasOwnProperty('streamlabs') && cfg.streamlabs.hasOwnProperty('token') && cfg.streamlabs.token !== false && cfg.streamlabs.token !== 'SOCKET_TOKEN')
     streamlabs.socket();
    if (cfg.hasOwnProperty('streamelements'))
    {
     if (cfg.streamelements.hasOwnProperty('oauth_refresh') && cfg.streamelements.oauth_refresh !== false && cfg.streamelements.oauth_refresh !== 'OAUTH_REFRESH')
      await streamelements.updateOAuth();
     if ((cfg.streamelements.hasOwnProperty('oauth') && cfg.streamelements.oauth !== false && cfg.streamelements.oauth !== 'OAUTH_ID') || (cfg.streamelements.hasOwnProperty('token') && cfg.streamelements.token !== false && cfg.streamelements.token !== 'JWT_TOKEN'))
      streamelements.socket();
    }
    if (cfg.login.hasOwnProperty('oauth_refresh') && cfg.login.oauth_refresh !== false && cfg.login.oauth_refresh !== 'OAUTH_REFRESH')
     await twitch.net.updateOAuth();
    await twitch.global();
    if (cfg.display.extended.useFFZ)
     await thirdparty.ffz.global();
    if (cfg.display.extended.useBTTV)
     await thirdparty.bttv.global();
    if (cfg.display.extended.use7TV)
     await thirdparty['7tv'].global();
    twitch.net.irc();
   }

   window.addEventListener('load', startup);
  </script>
  <style>
   :root
   {
    --height: 0px;
    --width: 0px;
    --emote-height: 0px;
    --emote-height-s: 0px;
    --emote-height-l: 0px;
   }
   body
   {
    margin: 0;
    overflow: hidden;
   }
   img
   {
    object-fit: contain;
    object-position: 50% 50%;
   }
   img.emote
   {
    position: fixed;
    height: 100%;
    border: 0;
    margin: 0;
    padding: 0;
    offset-rotate: 0deg;
   }

   div.scene
   {
    position: fixed;
    border: 0;
    margin: 0;
    padding: 0;
   }
   div.scene div.cube
   {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
   }
   div.scene div.cube .cubeFace
   {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.2);
   }

   div.scene img.dancer
   {
    text-align: center;
    position: relative;
    animation: dance 4s linear infinite;
   }

   @keyframes dance
   {
    0%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    6%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    13%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    19%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    25%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    31%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    38%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    44%
    {
     transform: translate(20%, 10%) rotate(-30deg);
    }
    50%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    56%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    63%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    69%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    75%
    {
     transform: translate(20%, 40%) rotate(-30deg);
    }
    81%
    {
     transform: translate(50%, 10%) rotate(0deg);
    }
    88%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
    94%
    {
     transform: translate(80%, 10%) rotate(30deg);
    }
    100%
    {
     transform: translate(80%, 40%) rotate(30deg);
    }
   }

   @keyframes wiggleL
   {
    33%
    {
     transform: translateX(-50%);
    }
    66%
    {
     transform: translateX(50%);
    }
   }
   @keyframes wiggleR
   {
    33%
    {
     transform: translateX(50%);
    }
    66%
    {
     transform: translateX(-50%);
    }
   }

   @keyframes speedL
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(-1 * var(--width) * 4), 0);
    }
   }
   @keyframes speedR
   {
    0%
    {
     transform: scale(1, 1);
    }
    10%
    {
     transform: scale(0.6, 1);
    }
    15%
    {
     transform: scale(0.6, 1);
    }
    20%
    {
     transform: scale(1, 0.4);
    }
    100%
    {
     transform: scale(1, 0.4) translate(calc(var(--width) * 4), 0);
    }
   }

   @keyframes dropL
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(350deg);
    }
   }
   @keyframes dropR
   {
    0%
    {
     transform: translateY(-100%);
    }
    10%
    {
     transform: translateY(0%);
    }
    20%
    {
     transform: translateY(0%);
    }
    25%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    27%
    {
     transform: translateY(0%) rotate(-35deg);
    }
    30%
    {
     transform: translateY(0%) rotate(-45deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate(-350deg);
    }
   }

   @keyframes confettiA
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0.5, 0, -4500deg);
    }
   }

   @keyframes confettiB
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, 0, 0, -4500deg);
    }
   }

   @keyframes confettiC
   {
    0%
    {
     transform: translateY(-100%) rotate3d(0.25, 0.5, 0, 0deg);
    }
    100%
    {
     transform: translateY(var(--height)) rotate3d(0.25, -0.5, 0, -4500deg);
    }
   }

   @keyframes offsetPath
   {
    0%
    {
     offset-distance: 0%;
    }
    100%
    {
     offset-distance: 100%;
    }
   }

   @keyframes fadeIn
   {
    0%
    {
     opacity: 0;
    }
    100% /* 8% */
    {
     opacity: 1;
    }
   }

   @keyframes fadeOut
   {
    0% /* 95% */
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes noFadeOut
   {
    99%
    {
     opacity: 1;
    }
    100%
    {
     opacity: 0;
    }
   }

   @keyframes zoomIn
   {
    0%
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.1)) / 2);
     max-height: calc(var(--emote-height) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 1.2)) / 2);
     max-height: calc(var(--emote-height) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.8)) / 2);
     max-height: calc(var(--emote-height) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.95)) / 2);
     max-height: calc(var(--emote-height) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
   }

   @keyframes zoomOut
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height);
    }
    100%
    {
     margin: calc((var(--emote-height) - (var(--emote-height) * 0.1)) / 2);
     max-height: calc(var(--emote-height) * 0.1);
    }
   }

   @keyframes zoomInS
   {
    0%
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.1)) / 2);
     max-height: calc(var(--emote-height-s) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 1.2)) / 2);
     max-height: calc(var(--emote-height-s) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.8)) / 2);
     max-height: calc(var(--emote-height-s) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.95)) / 2);
     max-height: calc(var(--emote-height-s) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
   }

   @keyframes zoomOutS
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height-s);
    }
    100%
    {
     margin: calc((var(--emote-height-s) - (var(--emote-height-s) * 0.1)) / 2);
     max-height: calc(var(--emote-height-s) * 0.1);
    }
   }

   @keyframes zoomInL
   {
    0%
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.1)) / 2);
     max-height: calc(var(--emote-height-l) * 0.1);
    }
    24% /* 4% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 1.2)) / 2);
     max-height: calc(var(--emote-height-l) * 1.2);
    }
    35% /* 6% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    47% /* 8% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.8)) / 2);
     max-height: calc(var(--emote-height-l) * 0.8);
    }
    71% /* 12% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    88% /* 15% */
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.95)) / 2);
     max-height: calc(var(--emote-height-l) * 0.95);
    }
    100% /* 17% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
   }

   @keyframes zoomOutL
   {
    0% /* 95% */
    {
     margin: 0;
     max-height: var(--emote-height-l);
    }
    100%
    {
     margin: calc((var(--emote-height-l) - (var(--emote-height-l) * 0.1)) / 2);
     max-height: calc(var(--emote-height-l) * 0.1);
    }
   }

   button
   {
    background-color: #7D5BBE;
    transition: background 0.12s ease-in, color 0.12s ease-in;
    white-space: nowrap;
    cursor: pointer;
    color: #FFFFFF;
    border-radius: 4px;
    border: none;
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
   }
   button:focus, button:hover
   {
    background-color: #772CE8;
   }
   button:focus
   {
    outline: none;
   }
   button:active
   {
    background-color: #5C16C5;
   }
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
 </head>
</html>